\chapter{Discussion}
\label{chap:discussion}

\section{Data Model of Objects and Events}
\begin{itemize}
	\item Focus on three viewpoints: Pull requests, users and files/methods
	\item Other auxiliary objects without useful viewpoint: Label and commit
	\item Relationships between objects and objects and events and objects
	\item Attributes of objects and events including initialization timestamp (1970-01-01 vs.\ actual date of creation)
	\item Attributes modeled as relationship to objects
	\item Distinguishing between events and objects: Example of the commit object and event and their differences
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{figures/Object_Types.pdf}
	\caption{Object types, their attributes and relationships, with the qualifier and cardinality  written on the end of a line relating two object types}
\end{figure}

\paragraph{Selection of object types and attributes.} To model the data from both the local git repository and the information on pull requests from GitHub, the object types can be divided into three categories:

\begin{enumerate}
	\item Object types whose data origin is the local git repository
	\item Object types whose data origin is the remote GitHub repository
	\item Object types that have a mixed data origin
\end{enumerate}

Although other object types are possible to include, the author chooses to limit the complexity by focusing on the most relevant object types. For analysis of the code quality the source code has to be analyzed. Therefore, local operations are vital to ensure a sufficiently fast runtime of the tool. 

The \emph{method} object type is the smallest entity for later analysis of code quality. The attributes include the Halstead's complexity merics, the cyclomatic complexity and the pylint score, as well as line related metrics. Together these raw metrics enable the calculation of the proposed overall code quality. The method object was included because in initial analysis it was found that large parts of the file are not modified, whereas modifications often affect related methods across several files. Additionally, the cyclomatic complexity has to be evaluated per method in order to calculate the \emph{weighted method count} for file level code quality metrics.

The \emph{file} object type includes all the same attributes as the \emph{method} object type, but the cyclomatic complexity is replaced with the \emph{method\_count} attribute to calculate the \emph{weighted method count} during analysis. A file includes any number of methods and a commit aggregates one or more files.

The \emph{commit} object type only includes the higher level attributes, that are not completely dependent of the code changes. Every commit has a commit message, however the more detailed description for commits is optional, marked by a question mark. The \emph{to} attribute stores to which branch in which repository the commit has been made to. This is especially relevant for repositories that use the fork and merge contribution process as explained in the works of Liu et al. \autocite{DBLP:conf/icse/Liu0MKYXGG24}.

The \emph{pull request} object type has a remote origin. Similar to the \emph{commit} object type it has a mandatory name, namely the title and an optional description. The \emph{state} attribute describes the overarching history of the pull request and can be either, opened, closed or merged. Pull requests can have labels, and every label that exists in the event log is used by at least one pull request. This ensures that unused labels do not unnecessarily complicate the event log. Labels often are a heavily used feature for managing pull requests and therefore, have been included in the analysis. The goal is to analyze if pull requests labeled similarly also exhibit closely related contribution processes or user groups. 

Lastly, the \emph{user} object type both has local and remote data origins. To identify a user, the full name was chosen as it is both prevalent in the local and remote data. Furthermore, the username is stored as well, as this is the primary identifier for users in the remote data. The rank describes the association of the user to the repository that is analyzed in the event log and can be either \emph{COLLABORATOR}, \emph{CONTRIBUTOR}, \emph{FIRST\_TIMER}, \emph{FIRST\_TIME\_CONTRIBUTOR}, \emph{MANNEQUIN}, \emph{MEMBER}, \emph{NONE} or \emph{OWNER}. These terms are also used within the \emph{GitHub REST API} documentation \footnote{https://docs.github.com/en/graphql/reference/enums\#commentauthorassociation}. The user type describes, whether the user is a bot, or a human user. The type of the \emph{type} attribute, is chosen as string to allow extension in the future and because the \emph{GitHub REST API} also uses a string type.

\paragraph{Relationships of objects and events.} According to the  \ac{ocel} 2.0 specification connections can be grouped into event-to-object and object-to-object relations \cite{DBLP:journals/corr/abs-2403-01975}. Based on their cardinaltiy, connections are distributed further into the following three groups.

\begin{enumerate}
	\item One-to-one relationships (1:1)
	\item One-to-many relationships (1:n)
	\item Many-to-many relationships (m:n)
\end{enumerate}

Generally, the cardinalities were chosen not according to how they are related in the source data, but how objects and events are related in the \ac{ocel} i.e., users on GitHub exist without having executed any activity, but in the \ac{ocel} every user is related to at least one event.

The only \emph{one-to-one} relation between objects describes, that each pull request can be merged with one commit (\emph{is-merged-with}) and each commit can merge at most one pull request

\emph{One-to-many} relations are used predominantly to keep track of the original author and last editor of the file and method objects described by the qualifiers \emph{last-edited-by} and \emph{created-by}. These relations are useful to assign reviewers that already have understanding of the method or file that is being modified in an open pull request.
Furthermore, \emph{method} objects are only stored in one file. As Python allows method overwriting, the last defined method in the respective \emph{file} object is part of the relation, mimicking the behavior of Python code, where the function name uniquely identifies its definition \footnote{https://docs.python.org/3/reference/compound\_stmts.html\#function-definitions}.

All other relations between objects fall into the \emph{many-to-many} group. The relations can be further grouped into relations between the same object types and different object types. 
\emph{Commit} objects are related through a parent-child relation i.e., merge commits have multiple children and commits before a new branch was created have one parent per created branch. One method can be called by multiple other methods and one method can call multiple methods. Because methods do not have to call other methods and not every defined method has to be called, the relation both directions have $0..*$ as cardinality. Similarly, the initial and latest commits both do not have children and parents respectively and therefore also $0..*$ as cardinality in both directions.
All other relations are between different object types. There exist multiple relations between \emph{user} and \emph{pull request} objects. They capture the different events how a user can interact with pull requests on GitHub. Every pull request is authored by at least one user and therefore automatically has at least one participant. However, pull requests may not have been reviewed yet and therefore, this relation has $0..*$ as cardinality compared to $1..*$ for the \emph{is-authored-by} and \emph{has-participant} relation. All users that are stored in the \ac{ocel} have either authored a commit in a pull request or reviewed a pull request, and therefore participated in at least one pull request. Consequently, users might not have committed to a repository e.g., because they only reviewed pull requests, but every commit has one or more authors. Because the process of contributions through pull requests is analyzed, every commit is part of one or multiple pull request. This is possible e.g., if a second branch is created based on the default branch of the repository, then commit $i$ is added to the created branch and a third branch is created based on the just created branch, then pull requests from the second and third branch to the default branch include commit $i$. Naturally, one pull request can include multiple commits.
