{
    ".gitignore": [],
    "boards.txt": [],
    "Arduino.h": [],
    "Client.h": [],
    "Esp.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 223,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223
                        ],
                        "comments": [
                            " *   uint32_t = test = 10_MHz; // --> 10000000",
                            "    // read first 4 byte (magic byte + flash config)",
                            "    // read first 4 byte (magic byte + flash config)",
                            "    // read first 4 byte (magic byte + flash config)",
                            "    case 0x0: // 4 Mbit (512KB)",
                            "    case 0x1: // 2 MBit (256KB)",
                            "    case 0x2: // 8 MBit (1MB)",
                            "    case 0x3: // 16 MBit (2MB)",
                            "    case 0x4: // 32 MBit (4MB)",
                            "    case 0x5: // 64 MBit (8MB)",
                            "    case 0x6: // 128 MBit (16MB)",
                            "    case 0x7: // 256 MBit (32MB)",
                            "    default: // fail?",
                            "    case 0x0: // 40 MHz",
                            "    case 0x1: // 26 MHz",
                            "    case 0x2: // 20 MHz",
                            "    case 0xf: // 80 MHz",
                            "    default: // fail?"
                        ],
                        "lines": [
                            " */",
                            "",
                            "unsigned long long operator\"\" _kHz(unsigned long long x)",
                            "{",
                            "    return x * 1000;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _MHz(unsigned long long x)",
                            "{",
                            "    return x * 1000 * 1000;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _GHz(unsigned long long x)",
                            "{",
                            "    return x * 1000 * 1000 * 1000;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _kBit(unsigned long long x)",
                            "{",
                            "    return x * 1024;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _MBit(unsigned long long x)",
                            "{",
                            "    return x * 1024 * 1024;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _GBit(unsigned long long x)",
                            "{",
                            "    return x * 1024 * 1024 * 1024;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _kB(unsigned long long x)",
                            "{",
                            "    return x * 1024;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _MB(unsigned long long x)",
                            "{",
                            "    return x * 1024 * 1024;",
                            "}",
                            "",
                            "unsigned long long operator\"\" _GB(unsigned long long x)",
                            "{",
                            "    return x * 1024 * 1024 * 1024;",
                            "}",
                            "",
                            "",
                            "EspClass ESP;",
                            "",
                            "uint32_t EspClass::getCycleCount()",
                            "{",
                            "    uint32_t ccount;",
                            "    __asm__ __volatile__(\"esync; rsr %0,ccount\":\"=a\" (ccount));",
                            "    return ccount;",
                            "}",
                            "",
                            "void EspClass::restart(void)",
                            "{",
                            "    system_restart();",
                            "}",
                            "",
                            "uint32_t EspClass::getFreeHeap(void)",
                            "{",
                            "    return system_get_free_heap_size();",
                            "}",
                            "",
                            "const char * EspClass::getSdkVersion(void)",
                            "{",
                            "    return system_get_sdk_version();",
                            "}",
                            "",
                            "uint32_t EspClass::getFlashChipSize(void)",
                            "{",
                            "    uint32_t data;",
                            "    uint8_t * bytes = (uint8_t *) &data;",
                            "    if(SPIRead(0x0000, &data, 4) == SPI_FLASH_RESULT_OK) {",
                            "        return magicFlashChipSize((bytes[3] & 0xf0) >> 4);",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "uint32_t EspClass::getFlashChipSpeed(void)",
                            "{",
                            "    uint32_t data;",
                            "    uint8_t * bytes = (uint8_t *) &data;",
                            "    if(SPIRead(0x0000, &data, 4) == SPI_FLASH_RESULT_OK) {",
                            "        return magicFlashChipSpeed(bytes[3] & 0x0F);",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "FlashMode_t EspClass::getFlashChipMode(void)",
                            "{",
                            "    FlashMode_t mode = FM_UNKNOWN;",
                            "    uint32_t data;",
                            "    uint8_t * bytes = (uint8_t *) &data;",
                            "    if(SPIRead(0x0000, &data, 4) == SPI_FLASH_RESULT_OK) {",
                            "        mode = magicFlashChipMode(bytes[2]);",
                            "    }",
                            "    return mode;",
                            "}",
                            "",
                            "uint32_t EspClass::magicFlashChipSize(uint8_t byte)",
                            "{",
                            "    switch(byte & 0x0F) {",
                            "        return (512_kB);",
                            "        return (256_kB);",
                            "        return (1_MB);",
                            "        return (2_MB);",
                            "        return (4_MB);",
                            "        return (8_MB);",
                            "        return (16_MB);",
                            "        return (32_MB);",
                            "        return 0;",
                            "    }",
                            "}",
                            "",
                            "uint32_t EspClass::magicFlashChipSpeed(uint8_t byte)",
                            "{",
                            "    switch(byte & 0x0F) {",
                            "        return (40_MHz);",
                            "        return (26_MHz);",
                            "        return (20_MHz);",
                            "        return (80_MHz);",
                            "        return 0;",
                            "    }",
                            "}",
                            "",
                            "FlashMode_t EspClass::magicFlashChipMode(uint8_t byte)",
                            "{",
                            "    FlashMode_t mode = (FlashMode_t) byte;",
                            "    if(mode > FM_DOUT) {",
                            "        mode = FM_UNKNOWN;",
                            "    }",
                            "    return mode;",
                            "}",
                            "",
                            "bool EspClass::eraseConfig(void)",
                            "{",
                            "    bool ret = true;",
                            "    size_t cfgAddr = (getFlashChipSize() - 0x4000);",
                            "    size_t cfgSize = (8*1024);",
                            "",
                            "    while(cfgSize) {",
                            "",
                            "        if(SPIEraseSector((cfgAddr / 4096)) != SPI_FLASH_RESULT_OK) {",
                            "            ret = false;",
                            "        }",
                            "",
                            "        cfgSize -= 4096;",
                            "        cfgAddr += 4096;",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "bool EspClass::flashEraseSector(uint32_t sector)",
                            "{",
                            "    int rc = SPIEraseSector(sector);",
                            "    return rc == 0;",
                            "}",
                            "",
                            "bool EspClass::flashWrite(uint32_t offset, uint32_t *data, size_t size)",
                            "{",
                            "    int rc = SPIWrite(offset, (uint32_t*) data, size);",
                            "    return rc == 0;",
                            "}",
                            "",
                            "bool EspClass::flashRead(uint32_t offset, uint32_t *data, size_t size)",
                            "{",
                            "    int rc = SPIRead(offset, (uint32_t*) data, size);",
                            "    return rc == 0;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "32": " *   uint32_t = test = 10_MHz; // --> 10000000",
                "109": "    // read first 4 byte (magic byte + flash config)",
                "120": "    // read first 4 byte (magic byte + flash config)",
                "132": "    // read first 4 byte (magic byte + flash config)",
                "142": "    case 0x0: // 4 Mbit (512KB)",
                "144": "    case 0x1: // 2 MBit (256KB)",
                "146": "    case 0x2: // 8 MBit (1MB)",
                "148": "    case 0x3: // 16 MBit (2MB)",
                "150": "    case 0x4: // 32 MBit (4MB)",
                "152": "    case 0x5: // 64 MBit (8MB)",
                "154": "    case 0x6: // 128 MBit (16MB)",
                "156": "    case 0x7: // 256 MBit (32MB)",
                "158": "    default: // fail?",
                "166": "    case 0x0: // 40 MHz",
                "168": "    case 0x1: // 26 MHz",
                "170": "    case 0x2: // 20 MHz",
                "172": "    case 0xf: // 80 MHz",
                "174": "    default: // fail?"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "00c1a6561267dc148d674d1cd9a1b4870d0d7377",
            "timestamp": "2017-02-23T02:23:27+02:00",
            "author": "Martin Sloup",
            "commit_message": "Improvements in EspClass (#222)\n\n* Improvements in EspClass\r\n\r\n- fixed not working functions for flash chip size, speed and mode\r\n- added function to retrieve chip revision from eFuse\r\n- flashRead / flashWrite supports encrypted flash\r\n\r\n* Rename getCpuRevision function to getChipRevision\r\n\r\n* Revert: flashRead / flashWrite supports encrypted flash\r\n\r\nReading and writing to encrypted flash has to be aligned to 16-bytes. Also NAND way of writing (i.e. flipping 1s to 0s) will not work with spi_flash_write_encrypted. Note: spi_flash_read_encrypted will always try to decrypt data, even if it wasn't encrypted in the first place.",
            "additions": 40,
            "deletions": 34,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            160
                        ],
                        "comments": [
                            "    case 0x0: // 8 MBit (1MB)"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            194
                        ],
                        "comments": [],
                        "lines": [
                            "    if(mode > FM_SLOW_READ) {"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            116,
                            117,
                            118
                        ],
                        "comments": [
                            "    // read first 4 byte (magic byte + flash config)"
                        ],
                        "lines": [
                            "    if(flashRead(0x0000, &data, 4) == ESP_OK) {",
                            "        return magicFlashChipSize((bytes[3] & 0xf0) >> 4);"
                        ]
                    },
                    {
                        "line_numbers": [
                            120
                        ],
                        "comments": [],
                        "lines": [
                            "    return 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            125,
                            126,
                            127,
                            128,
                            129
                        ],
                        "comments": [
                            "    // read first 4 byte (magic byte + flash config)"
                        ],
                        "lines": [
                            "    uint32_t data;",
                            "    uint8_t * bytes = (uint8_t *) &data;",
                            "    if(flashRead(0x0000, &data, 4) == ESP_OK) {",
                            "        return magicFlashChipSpeed(bytes[3] & 0x0F);"
                        ]
                    },
                    {
                        "line_numbers": [
                            131
                        ],
                        "comments": [],
                        "lines": [
                            "    return 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            136,
                            137,
                            138,
                            139,
                            140,
                            141
                        ],
                        "comments": [
                            "    // read first 4 byte (magic byte + flash config)"
                        ],
                        "lines": [
                            "    FlashMode_t mode = FM_UNKNOWN;",
                            "    uint32_t data;",
                            "    uint8_t * bytes = (uint8_t *) &data;",
                            "    if(flashRead(0x0000, &data, 4) == ESP_OK) {",
                            "        mode = magicFlashChipMode(bytes[2]);"
                        ]
                    },
                    {
                        "line_numbers": [
                            143
                        ],
                        "comments": [],
                        "lines": [
                            "    return mode;"
                        ]
                    },
                    {
                        "line_numbers": [
                            150,
                            151,
                            152,
                            153
                        ],
                        "comments": [
                            "    case 0x1: // 2 MBit (256KB)",
                            "    case 0x2: // 8 MBit (1MB)"
                        ],
                        "lines": [
                            "        return (512_kB);",
                            "        return (256_kB);"
                        ]
                    },
                    {
                        "line_numbers": [
                            164
                        ],
                        "comments": [],
                        "lines": [
                            "        return (32_MB);"
                        ]
                    },
                    {
                        "line_numbers": [
                            189
                        ],
                        "comments": [],
                        "lines": [
                            "    if(mode > FM_DOUT) {"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "160": "    case 0x0: // 8 MBit (1MB)",
                "162": "    case 0x1: // 16 MBit (2MB)",
                "164": "    case 0x2: // 32 MBit (4MB)",
                "166": "    case 0x3: // 64 MBit (8MB)",
                "168": "    case 0x4: // 128 MBit (16MB)",
                "205": "// Warning: These functions do not work with encrypted flash"
            },
            "comment_deleted_diff": {
                "116": "    // read first 4 byte (magic byte + flash config)",
                "127": "    // read first 4 byte (magic byte + flash config)",
                "139": "    // read first 4 byte (magic byte + flash config)",
                "149": "    case 0x0: // 4 Mbit (512KB)",
                "151": "    case 0x1: // 2 MBit (256KB)",
                "153": "    case 0x2: // 8 MBit (1MB)",
                "155": "    case 0x3: // 16 MBit (2MB)",
                "157": "    case 0x4: // 32 MBit (4MB)",
                "159": "    case 0x5: // 64 MBit (8MB)",
                "161": "    case 0x6: // 128 MBit (16MB)",
                "163": "    case 0x7: // 256 MBit (32MB)"
            },
            "comment_modified_diff": {}
        }
    ],
    "Esp.h": [],
    "HardwareSerial.cpp": [
        {
            "commit": "233d31bed22211e8c85f82bcf2492977604bbc78",
            "timestamp": "2018-11-19T16:51:55+01:00",
            "author": "Jeroen88",
            "commit_message": "Added baudrate detection to esp32-hal-uart and HardwareSerial (#1961)\n\n* Added baudrate detection to esp32-hal-uart and HardwareSerial\r\n\r\n* Solved compiler warning for uartResizeRxBuffer()\r\n\r\n* Add unit to header variable name (timeout_ms)\r\n\r\n* Reverting accidentally changed files to master\r\n\r\n* Add small delay after baudrate detection",
            "additions": 21,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73
                        ],
                        "comments": [
                            "            delay(100); // Give some time..."
                        ],
                        "lines": [
                            "            _uart = uartBegin(_uart_nr, detectedBaudRate, config, rxPin, txPin, 256, invert);",
                            "        } else {",
                            "            log_e(\"Could not detect baudrate. Serial data at the port must be present within the timeout for detection to be possible\");",
                            "            _uart = NULL;",
                            "        }",
                            "    }"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "67": "            delay(100); // Give some time..."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "0607d36734d52d67be1b88764bf446fac7eb62f3",
            "timestamp": "2020-01-20T15:54:50+02:00",
            "author": "Dirk O. Kaar",
            "commit_message": "HardwareSerial::write(const char*, ...) API compatibility to AVR, ESP8266, et al (#3585)\n\n* API compatibility to AVR, ESP8266, et al\r\n\r\n* Add non-blocking HardwareSerial::read(buffer, size) extension (ESP8266 portability)\r\n\r\n* Refactor for fewer indirect calls.",
            "additions": 18,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151
                        ],
                        "comments": [
                            "// read characters into buffer",
                            "// terminates if size characters have been read, or no further are pending",
                            "// returns the number of characters placed in the buffer",
                            "// the buffer is NOT null terminated."
                        ],
                        "lines": [
                            "size_t HardwareSerial::read(uint8_t *buffer, size_t size)",
                            "{",
                            "    size_t avail = available();",
                            "    if (size < avail) {",
                            "        avail = size;",
                            "    }",
                            "    size_t count = 0;",
                            "    while(count < avail) {",
                            "        *buffer++ = uartRead(_uart);",
                            "        count++;",
                            "    }",
                            "    return count;",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "134": "// read characters into buffer",
                "135": "// terminates if size characters have been read, or no further are pending",
                "136": "// returns the number of characters placed in the buffer",
                "137": "// the buffer is NOT null terminated."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "HardwareSerial.h": [],
    "IPAddress.cpp": [
        {
            "commit": "d8b229031342ab3f27dcf9be7e37ac5088c9624e",
            "timestamp": "2016-11-24T09:46:11+02:00",
            "author": "Drake Youngkun Min",
            "commit_message": "Add 'fromString(const char*)', 'fromString(const String)' to IPAddress class (#68)",
            "additions": 41,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122
                        ],
                        "comments": [
                            "    // TODO: add support for \"a\", \"a.b\", \"a.b.c\" formats",
                            "    uint16_t acc = 0; // Accumulator",
                            "                // Value out of [0..255] range",
                            "                // Too much dots (there must be 3 dots)",
                            "            // Invalid char",
                            "        // Too few dots (there must be 3 dots)"
                        ],
                        "lines": [
                            "",
                            "    uint8_t dots = 0;",
                            "",
                            "    while (*address)",
                            "    {",
                            "        char c = *address++;",
                            "        if (c >= '0' && c <= '9')",
                            "        {",
                            "            acc = acc * 10 + (c - '0');",
                            "            if (acc > 255) {",
                            "                return false;",
                            "            }",
                            "        }",
                            "        else if (c == '.')",
                            "        {",
                            "            if (dots == 3) {",
                            "                return false;",
                            "            }",
                            "            _address.bytes[dots++] = acc;",
                            "            acc = 0;",
                            "        }",
                            "        else",
                            "        {",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    if (dots != 3) {",
                            "        return false;",
                            "    }",
                            "    _address.bytes[3] = acc;",
                            "    return true;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "84": "    // TODO: add support for \"a\", \"a.b\", \"a.b.c\" formats",
                "86": "    uint16_t acc = 0; // Accumulator",
                "96": "                // Value out of [0..255] range",
                "103": "                // Too much dots (there must be 3 dots)",
                "111": "            // Invalid char",
                "117": "        // Too few dots (there must be 3 dots)"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "IPAddress.h": [],
    "MD5Builder.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 117,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117
                        ],
                        "comments": [
                            "        // determine number of bytes to read",
                            "            readBytes = maxLengthLeft ;    // read only until max_len",
                            "            readBytes = buf_size;    // not read more the buffer can handle",
                            "        // read data and check if we got something",
                            "        // Update MD5 with buffer payload",
                            "        // update available number of bytes"
                        ],
                        "lines": [
                            "        int readBytes = bytesAvailable;",
                            "        if(readBytes > maxLengthLeft) {",
                            "        }",
                            "        if(readBytes > buf_size) {",
                            "        }",
                            "",
                            "        int numBytesRead = stream.readBytes(buf, readBytes);",
                            "        if(numBytesRead< 1) {",
                            "            return false;",
                            "        }",
                            "",
                            "        MD5Update(&_ctx, buf, numBytesRead);",
                            "",
                            "        maxLengthLeft -= numBytesRead;",
                            "        bytesAvailable = stream.available();",
                            "    }",
                            "    free(buf);",
                            "    return true;",
                            "}",
                            "",
                            "void MD5Builder::calculate(void)",
                            "{",
                            "    MD5Final(_buf, &_ctx);",
                            "}",
                            "",
                            "void MD5Builder::getBytes(uint8_t * output)",
                            "{",
                            "    memcpy(output, _buf, 16);",
                            "}",
                            "",
                            "void MD5Builder::getChars(char * output)",
                            "{",
                            "    for(uint8_t i = 0; i < 16; i++) {",
                            "        sprintf(output + (i * 2), \"%02x\", _buf[i]);",
                            "    }",
                            "}",
                            "",
                            "String MD5Builder::toString(void)",
                            "{",
                            "    char out[33];",
                            "    getChars(out);",
                            "    return String(out);",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "69": "        // determine number of bytes to read",
                "72": "            readBytes = maxLengthLeft ;    // read only until max_len",
                "75": "            readBytes = buf_size;    // not read more the buffer can handle",
                "78": "        // read data and check if we got something",
                "84": "        // Update MD5 with buffer payload",
                "87": "        // update available number of bytes"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "MD5Builder.h": [],
    "Print.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 293,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293
                        ],
                        "comments": [
                            "// Public Methods //////////////////////////////////////////////////////////////",
                            "// Private Methods /////////////////////////////////////////////////////////////",
                            "    char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.",
                            "    // prevent crash if called with base == 1",
                            "        return print(\"ovf\");    // constant determined empirically",
                            "        return print(\"ovf\");    // constant determined empirically",
                            "    // Handle negative numbers",
                            "    // Round correctly so that print(1.999, 2) prints as \"2.00\"",
                            "    // Extract the integer part of the number and print it",
                            "    // Print the decimal point, but only if there are digits beyond",
                            "    // Extract digits from the remainder one at a time"
                        ],
                        "lines": [
                            "",
                            "/* default implementation: may be overridden */",
                            "size_t Print::write(const uint8_t *buffer, size_t size)",
                            "{",
                            "    size_t n = 0;",
                            "    while(size--) {",
                            "        n += write(*buffer++);",
                            "    }",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::printf(const char *format, ...)",
                            "{",
                            "    va_list arg;",
                            "    va_start(arg, format);",
                            "    size_t len = vsnprintf(NULL, 0, format, arg);",
                            "    char temp[len+1];",
                            "    uint8_t * stemp = (uint8_t*)temp;",
                            "    len = vsnprintf(temp, len+1, format, arg);",
                            "    write(stemp, len);",
                            "    va_end(arg);",
                            "    return len;",
                            "}",
                            "/*",
                            "size_t Print::print(const __FlashStringHelper *ifsh) {",
                            "    PGM_P p = reinterpret_cast<PGM_P>(ifsh);",
                            "",
                            "    size_t n = 0;",
                            "    while (1) {",
                            "        uint8_t c = pgm_read_byte(p++);",
                            "        if (c == 0) break;",
                            "        n += write(c);",
                            "    }",
                            "    return n;",
                            "}",
                            "*/",
                            "size_t Print::print(const String &s)",
                            "{",
                            "    return write(s.c_str(), s.length());",
                            "}",
                            "",
                            "size_t Print::print(const char str[])",
                            "{",
                            "    return write(str);",
                            "}",
                            "",
                            "size_t Print::print(char c)",
                            "{",
                            "    return write(c);",
                            "}",
                            "",
                            "size_t Print::print(unsigned char b, int base)",
                            "{",
                            "    return print((unsigned long) b, base);",
                            "}",
                            "",
                            "size_t Print::print(int n, int base)",
                            "{",
                            "    return print((long) n, base);",
                            "}",
                            "",
                            "size_t Print::print(unsigned int n, int base)",
                            "{",
                            "    return print((unsigned long) n, base);",
                            "}",
                            "",
                            "size_t Print::print(long n, int base)",
                            "{",
                            "    if(base == 0) {",
                            "        return write(n);",
                            "    } else if(base == 10) {",
                            "        if(n < 0) {",
                            "            int t = print('-');",
                            "            n = -n;",
                            "            return printNumber(n, 10) + t;",
                            "        }",
                            "        return printNumber(n, 10);",
                            "    } else {",
                            "        return printNumber(n, base);",
                            "    }",
                            "}",
                            "",
                            "size_t Print::print(unsigned long n, int base)",
                            "{",
                            "    if(base == 0) {",
                            "        return write(n);",
                            "    } else {",
                            "        return printNumber(n, base);",
                            "    }",
                            "}",
                            "",
                            "size_t Print::print(double n, int digits)",
                            "{",
                            "    return printFloat(n, digits);",
                            "}",
                            "",
                            "size_t Print::println(const __FlashStringHelper *ifsh)",
                            "{",
                            "    size_t n = print(ifsh);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::print(const Printable& x)",
                            "{",
                            "    return x.printTo(*this);",
                            "}",
                            "",
                            "size_t Print::println(void)",
                            "{",
                            "    return print(\"\\r\\n\");",
                            "}",
                            "",
                            "size_t Print::println(const String &s)",
                            "{",
                            "    size_t n = print(s);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(const char c[])",
                            "{",
                            "    size_t n = print(c);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(char c)",
                            "{",
                            "    size_t n = print(c);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(unsigned char b, int base)",
                            "{",
                            "    size_t n = print(b, base);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(int num, int base)",
                            "{",
                            "    size_t n = print(num, base);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(unsigned int num, int base)",
                            "{",
                            "    size_t n = print(num, base);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(long num, int base)",
                            "{",
                            "    size_t n = print(num, base);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(unsigned long num, int base)",
                            "{",
                            "    size_t n = print(num, base);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(double num, int digits)",
                            "{",
                            "    size_t n = print(num, digits);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "size_t Print::println(const Printable& x)",
                            "{",
                            "    size_t n = print(x);",
                            "    n += println();",
                            "    return n;",
                            "}",
                            "",
                            "",
                            "size_t Print::printNumber(unsigned long n, uint8_t base)",
                            "{",
                            "    char *str = &buf[sizeof(buf) - 1];",
                            "",
                            "    *str = '\\0';",
                            "",
                            "    if(base < 2) {",
                            "        base = 10;",
                            "    }",
                            "",
                            "    do {",
                            "        unsigned long m = n;",
                            "        n /= base;",
                            "        char c = m - base * n;",
                            "        *--str = c < 10 ? c + '0' : c + 'A' - 10;",
                            "    } while(n);",
                            "",
                            "    return write(str);",
                            "}",
                            "",
                            "size_t Print::printFloat(double number, uint8_t digits)",
                            "{",
                            "    size_t n = 0;",
                            "",
                            "    if(isnan(number)) {",
                            "        return print(\"nan\");",
                            "    }",
                            "    if(isinf(number)) {",
                            "        return print(\"inf\");",
                            "    }",
                            "    if(number > 4294967040.0) {",
                            "    }",
                            "    if(number < -4294967040.0) {",
                            "    }",
                            "",
                            "    if(number < 0.0) {",
                            "        n += print('-');",
                            "        number = -number;",
                            "    }",
                            "",
                            "    double rounding = 0.5;",
                            "    for(uint8_t i = 0; i < digits; ++i) {",
                            "        rounding /= 10.0;",
                            "    }",
                            "",
                            "    number += rounding;",
                            "",
                            "    unsigned long int_part = (unsigned long) number;",
                            "    double remainder = number - (double) int_part;",
                            "    n += print(int_part);",
                            "",
                            "    if(digits > 0) {",
                            "        n += print(\".\");",
                            "    }",
                            "",
                            "    while(digits-- > 0) {",
                            "        remainder *= 10.0;",
                            "        int toPrint = int(remainder);",
                            "        n += print(toPrint);",
                            "        remainder -= toPrint;",
                            "    }",
                            "",
                            "    return n;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "35": "// Public Methods //////////////////////////////////////////////////////////////",
                "219": "// Private Methods /////////////////////////////////////////////////////////////",
                "223": "    char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.",
                "228": "    // prevent crash if called with base == 1",
                "254": "        return print(\"ovf\");    // constant determined empirically",
                "257": "        return print(\"ovf\");    // constant determined empirically",
                "260": "    // Handle negative numbers",
                "266": "    // Round correctly so that print(1.999, 2) prints as \"2.00\"",
                "274": "    // Extract the integer part of the number and print it",
                "279": "    // Print the decimal point, but only if there are digits beyond",
                "284": "    // Extract digits from the remainder one at a time"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "4204869ec9fde1e5a9ba3080f82b4e358269dca2",
            "timestamp": "2020-09-30T14:31:36+03:00",
            "author": "Dirk O. Kaar",
            "commit_message": "Extend Print class for 64bit integers. (#3688)\n\n* Extend Print class for 64bit integers.\r\n\r\nmodulo 32bit and 64bit tuned for code size.\r\n\r\n* Fix 32bit long used in long long printNumber.",
            "additions": 62,
            "deletions": 12,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            281
                        ],
                        "comments": [
                            "    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte."
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314
                        ],
                        "comments": [
                            "    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.",
                            "    // prevent crash if called with base == 1"
                        ],
                        "lines": [
                            "        char c = n % base;",
                            "        n /= base;",
                            "",
                            "        *--str = c < 10 ? c + '0' : c + 'A' - 10;",
                            "    } while (n);",
                            "",
                            "    return write(str);",
                            "}",
                            "",
                            "size_t Print::printNumber(unsigned long long n, uint8_t base)",
                            "{",
                            "    char* str = &buf[sizeof(buf) - 1];",
                            "",
                            "    *str = '\\0';",
                            "",
                            "    if (base < 2) {",
                            "        base = 10;",
                            "    }",
                            "",
                            "    do {",
                            "        auto m = n;"
                        ]
                    },
                    {
                        "line_numbers": [
                            317
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            319
                        ],
                        "comments": [],
                        "lines": [
                            "    } while (n);"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            254
                        ],
                        "comments": [
                            "    char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte."
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            265
                        ],
                        "comments": [],
                        "lines": [
                            "        unsigned long m = n;"
                        ]
                    },
                    {
                        "line_numbers": [
                            269
                        ],
                        "comments": [],
                        "lines": [
                            "    } while(n);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "281": "    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.",
                "303": "    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.",
                "308": "    // prevent crash if called with base == 1"
            },
            "comment_deleted_diff": {
                "254": "    char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte."
            },
            "comment_modified_diff": {}
        }
    ],
    "Print.h": [],
    "Printable.h": [],
    "Server.h": [],
    "Stream.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 291,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291
                        ],
                        "comments": [
                            "#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait",
                            "#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field",
                            "// private method to read stream with timeout",
                            "    return -1;     // -1 indicates timeout",
                            "// private method to peek stream with timeout",
                            "    return -1;     // -1 indicates timeout",
                            "// returns peek of the next digit in the stream or -1 if timeout",
                            "// discards non-numeric characters",
                            "            return c;    // timeout",
                            "        read();  // discard non-numeric",
                            "// Public Methods",
                            "void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait",
                            "// find returns true if the target string is found",
                            "// reads data from the stream until the target string of given length is found",
                            "// returns true if target string is found, false if timed out",
                            "// as find but search ends if the terminator string is found",
                            "// reads data from the stream until the target string of the given length is found",
                            "// search terminated if the terminator string is found",
                            "// returns true if target string is found, false if terminated or timed out",
                            "    size_t index = 0;  // maximum target string length is 64k bytes!",
                            "        return true;    // return true if target is a null string",
                            "            index = 0;    // reset index if any char does not match",
                            "            if(++index >= targetLen) { // return true if all chars in the target match",
                            "                return false;    // return false if terminate string found before target string",
                            "// returns the first valid (long) integer value from the current position.",
                            "// initial characters that are not digits (or the minus sign) are skipped",
                            "// function is terminated by the first character that is not a digit.",
                            "    return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)",
                            "// as above but a given skipChar is ignored",
                            "// this allows format characters (typically commas) in values to be ignored",
                            "    // ignore non numeric leading characters",
                            "        return 0;    // zero returned if timeout",
                            "        } // ignore this charactor",
                            "        } else if(c >= '0' && c <= '9') {    // is c a digit?",
                            "        read();  // consume the character we got with peek",
                            "// as parseInt but returns a floating point value",
                            "// as above but the given skipChar is ignored",
                            "// this allows format characters (typically commas) in values to be ignored",
                            "    // ignore non numeric leading characters",
                            "        return 0;    // zero returned if timeout",
                            "        } // ignore",
                            "        } else if(c >= '0' && c <= '9') {    // is c a digit?",
                            "        read();  // consume the character we got with peek",
                            "// read characters from stream into buffer",
                            "// terminates if length characters have been read, or timeout (see setTimeout)",
                            "// returns the number of characters placed in the buffer",
                            "// the buffer is NOT null terminated.",
                            "// as readBytes with terminator character",
                            "// terminates if length characters have been read, timeout, or if the terminator character  detected",
                            "// returns the number of characters placed in the buffer (0 means no valid data found)",
                            "    return index; // return number of characters, not including null terminator"
                        ],
                        "lines": [
                            "",
                            "int Stream::timedRead()",
                            "{",
                            "    int c;",
                            "    _startMillis = millis();",
                            "    do {",
                            "        c = read();",
                            "        if(c >= 0) {",
                            "            return c;",
                            "        }",
                            "    } while(millis() - _startMillis < _timeout);",
                            "}",
                            "",
                            "int Stream::timedPeek()",
                            "{",
                            "    int c;",
                            "    _startMillis = millis();",
                            "    do {",
                            "        c = peek();",
                            "        if(c >= 0) {",
                            "            return c;",
                            "        }",
                            "    } while(millis() - _startMillis < _timeout);",
                            "}",
                            "",
                            "int Stream::peekNextDigit()",
                            "{",
                            "    int c;",
                            "    while(1) {",
                            "        c = timedPeek();",
                            "        if(c < 0) {",
                            "        }",
                            "        if(c == '-') {",
                            "            return c;",
                            "        }",
                            "        if(c >= '0' && c <= '9') {",
                            "            return c;",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "//////////////////////////////////////////////////////////////",
                            "",
                            "{",
                            "    _timeout = timeout;",
                            "}",
                            "",
                            "bool Stream::find(const char *target)",
                            "{",
                            "    return findUntil(target, (char*) \"\");",
                            "}",
                            "",
                            "bool Stream::find(const char *target, size_t length)",
                            "{",
                            "    return findUntil(target, length, NULL, 0);",
                            "}",
                            "",
                            "bool Stream::findUntil(const char *target, const char *terminator)",
                            "{",
                            "    return findUntil(target, strlen(target), terminator, strlen(terminator));",
                            "}",
                            "",
                            "bool Stream::findUntil(const char *target, size_t targetLen, const char *terminator, size_t termLen)",
                            "{",
                            "    size_t termIndex = 0;",
                            "    int c;",
                            "",
                            "    if(*target == 0) {",
                            "    }",
                            "    while((c = timedRead()) > 0) {",
                            "",
                            "        if(c != target[index]) {",
                            "        }",
                            "",
                            "        if(c == target[index]) {",
                            "            //////Serial.print(\"found \"); Serial.write(c); Serial.print(\"index now\"); Serial.println(index+1);",
                            "                return true;",
                            "            }",
                            "        }",
                            "",
                            "        if(termLen > 0 && c == terminator[termIndex]) {",
                            "            if(++termIndex >= termLen) {",
                            "            }",
                            "        } else {",
                            "            termIndex = 0;",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "long Stream::parseInt()",
                            "{",
                            "}",
                            "",
                            "long Stream::parseInt(char skipChar)",
                            "{",
                            "    boolean isNegative = false;",
                            "    long value = 0;",
                            "    int c;",
                            "",
                            "    c = peekNextDigit();",
                            "    if(c < 0) {",
                            "    }",
                            "",
                            "    do {",
                            "        if(c == skipChar) {",
                            "        else if(c == '-') {",
                            "            isNegative = true;",
                            "            value = value * 10 + c - '0';",
                            "        }",
                            "        c = timedPeek();",
                            "    } while((c >= '0' && c <= '9') || c == skipChar);",
                            "",
                            "    if(isNegative) {",
                            "        value = -value;",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "float Stream::parseFloat()",
                            "{",
                            "    return parseFloat(NO_SKIP_CHAR);",
                            "}",
                            "",
                            "float Stream::parseFloat(char skipChar)",
                            "{",
                            "    boolean isNegative = false;",
                            "    boolean isFraction = false;",
                            "    long value = 0;",
                            "    int c;",
                            "    float fraction = 1.0;",
                            "",
                            "    c = peekNextDigit();",
                            "    if(c < 0) {",
                            "    }",
                            "",
                            "    do {",
                            "        if(c == skipChar) {",
                            "        else if(c == '-') {",
                            "            isNegative = true;",
                            "        } else if(c == '.') {",
                            "            isFraction = true;",
                            "            value = value * 10 + c - '0';",
                            "            if(isFraction) {",
                            "                fraction *= 0.1;",
                            "            }",
                            "        }",
                            "        c = timedPeek();",
                            "    } while((c >= '0' && c <= '9') || c == '.' || c == skipChar);",
                            "",
                            "    if(isNegative) {",
                            "        value = -value;",
                            "    }",
                            "    if(isFraction) {",
                            "        return value * fraction;",
                            "    } else {",
                            "        return value;",
                            "    }",
                            "}",
                            "",
                            "//",
                            "size_t Stream::readBytes(char *buffer, size_t length)",
                            "{",
                            "    size_t count = 0;",
                            "    while(count < length) {",
                            "        int c = timedRead();",
                            "        if(c < 0) {",
                            "            break;",
                            "        }",
                            "        *buffer++ = (char) c;",
                            "        count++;",
                            "    }",
                            "    return count;",
                            "}",
                            "",
                            "",
                            "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)",
                            "{",
                            "    if(length < 1) {",
                            "        return 0;",
                            "    }",
                            "    size_t index = 0;",
                            "    while(index < length) {",
                            "        int c = timedRead();",
                            "        if(c < 0 || c == terminator) {",
                            "            break;",
                            "        }",
                            "        *buffer++ = (char) c;",
                            "        index++;",
                            "    }",
                            "}",
                            "",
                            "String Stream::readString()",
                            "{",
                            "    String ret;",
                            "    int c = timedRead();",
                            "    while(c >= 0) {",
                            "        ret += (char) c;",
                            "        c = timedRead();",
                            "    }",
                            "    return ret;",
                            "}",
                            "",
                            "String Stream::readStringUntil(char terminator)",
                            "{",
                            "    String ret;",
                            "    int c = timedRead();",
                            "    while(c >= 0 && c != terminator) {",
                            "        ret += (char) c;",
                            "        c = timedRead();",
                            "    }",
                            "    return ret;",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "27": "#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait",
                "28": "#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field",
                "30": "// private method to read stream with timeout",
                "41": "    return -1;     // -1 indicates timeout",
                "44": "// private method to peek stream with timeout",
                "55": "    return -1;     // -1 indicates timeout",
                "58": "// returns peek of the next digit in the stream or -1 if timeout",
                "59": "// discards non-numeric characters",
                "66": "            return c;    // timeout",
                "74": "        read();  // discard non-numeric",
                "78": "// Public Methods",
                "81": "void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait",
                "86": "// find returns true if the target string is found",
                "92": "// reads data from the stream until the target string of given length is found",
                "93": "// returns true if target string is found, false if timed out",
                "99": "// as find but search ends if the terminator string is found",
                "105": "// reads data from the stream until the target string of the given length is found",
                "106": "// search terminated if the terminator string is found",
                "107": "// returns true if target string is found, false if terminated or timed out",
                "110": "    size_t index = 0;  // maximum target string length is 64k bytes!",
                "115": "        return true;    // return true if target is a null string",
                "120": "            index = 0;    // reset index if any char does not match",
                "125": "            if(++index >= targetLen) { // return true if all chars in the target match",
                "132": "                return false;    // return false if terminate string found before target string",
                "141": "// returns the first valid (long) integer value from the current position.",
                "142": "// initial characters that are not digits (or the minus sign) are skipped",
                "143": "// function is terminated by the first character that is not a digit.",
                "146": "    return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)",
                "149": "// as above but a given skipChar is ignored",
                "150": "// this allows format characters (typically commas) in values to be ignored",
                "158": "    // ignore non numeric leading characters",
                "160": "        return 0;    // zero returned if timeout",
                "165": "        } // ignore this charactor",
                "168": "        } else if(c >= '0' && c <= '9') {    // is c a digit?",
                "171": "        read();  // consume the character we got with peek",
                "181": "// as parseInt but returns a floating point value",
                "187": "// as above but the given skipChar is ignored",
                "188": "// this allows format characters (typically commas) in values to be ignored",
                "198": "    // ignore non numeric leading characters",
                "200": "        return 0;    // zero returned if timeout",
                "205": "        } // ignore",
                "210": "        } else if(c >= '0' && c <= '9') {    // is c a digit?",
                "216": "        read();  // consume the character we got with peek",
                "230": "// read characters from stream into buffer",
                "231": "// terminates if length characters have been read, or timeout (see setTimeout)",
                "232": "// returns the number of characters placed in the buffer",
                "233": "// the buffer is NOT null terminated.",
                "249": "// as readBytes with terminator character",
                "250": "// terminates if length characters have been read, timeout, or if the terminator character  detected",
                "251": "// returns the number of characters placed in the buffer (0 means no valid data found)",
                "267": "    return index; // return number of characters, not including null terminator"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "Stream.h": [],
    "StreamString.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 71,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71
                        ],
                        "comments": [
                            "            *(buffer + len) = 0x00; // add null for string end"
                        ],
                        "lines": [
                            "            return size;",
                            "        }",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "size_t StreamString::write(uint8_t data)",
                            "{",
                            "    return concat((char) data);",
                            "}",
                            "",
                            "int StreamString::available()",
                            "{",
                            "    return length();",
                            "}",
                            "",
                            "int StreamString::read()",
                            "{",
                            "    if(length()) {",
                            "        char c = charAt(0);",
                            "        remove(0, 1);",
                            "        return c;",
                            "",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "int StreamString::peek()",
                            "{",
                            "    if(length()) {",
                            "        char c = charAt(0);",
                            "        return c;",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "void StreamString::flush()",
                            "{",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "31": "            *(buffer + len) = 0x00; // add null for string end"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "c92b61739743e6df0768bbcba1e0b53755ec91d8",
            "timestamp": "2018-04-16T16:34:39+02:00",
            "author": "Craig Leres",
            "commit_message": "Convert the few remaining cr/lf files to use lf for eol. (#1316)\n\nIf you develop on windows and need cr/lf files, see this:\r\n\r\n    https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_formatting_and_whitespace\r\n\r\n    Git can handle this by auto-converting CRLF line endings into LF\r\n    when you add a file to the index, and vice versa when it checks out\r\n    code onto your filesystem. You can turn on this functionality with\r\n    the core.autocrlf setting. If you're on a Windows machine, set it\r\n    to true - this converts LF endings into CRLF when you check out code:\r\n\r\n    $ git config --global core.autocrlf true",
            "additions": 71,
            "deletions": 71,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71
                        ],
                        "comments": [
                            "            *(buffer + len) = 0x00; // add null for string end"
                        ],
                        "lines": [
                            "            return size;",
                            "        }",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "size_t StreamString::write(uint8_t data)",
                            "{",
                            "    return concat((char) data);",
                            "}",
                            "",
                            "int StreamString::available()",
                            "{",
                            "    return length();",
                            "}",
                            "",
                            "int StreamString::read()",
                            "{",
                            "    if(length()) {",
                            "        char c = charAt(0);",
                            "        remove(0, 1);",
                            "        return c;",
                            "",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "int StreamString::peek()",
                            "{",
                            "    if(length()) {",
                            "        char c = charAt(0);",
                            "        return c;",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "void StreamString::flush()",
                            "{",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71
                        ],
                        "comments": [
                            "            *(buffer + len) = 0x00; // add null for string end"
                        ],
                        "lines": [
                            "            return size;",
                            "        }",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "size_t StreamString::write(uint8_t data)",
                            "{",
                            "    return concat((char) data);",
                            "}",
                            "",
                            "int StreamString::available()",
                            "{",
                            "    return length();",
                            "}",
                            "",
                            "int StreamString::read()",
                            "{",
                            "    if(length()) {",
                            "        char c = charAt(0);",
                            "        remove(0, 1);",
                            "        return c;",
                            "",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "int StreamString::peek()",
                            "{",
                            "    if(length()) {",
                            "        char c = charAt(0);",
                            "        return c;",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "void StreamString::flush()",
                            "{",
                            "}",
                            ""
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "31": "            *(buffer + len) = 0x00; // add null for string end"
            },
            "comment_deleted_diff": {
                "31": "            *(buffer + len) = 0x00; // add null for string end"
            },
            "comment_modified_diff": {
                "31": "            *(buffer + len) = 0x00; // add null for string end"
            }
        },
        {
            "commit": "ab309e40d5f7a593f36f456976973ed7589a1f04",
            "timestamp": "2019-04-26T19:41:42+03:00",
            "author": "Earle F. Philhower, III",
            "commit_message": "Copy ESP8266 String w/SSO to ESP32 repo (#2715)\n\nI redid the ESP8266 WString library to enable small string optimization\r\n(SSO) a while back, and think it would be helpful even on the ESP32 with\r\nits higher memory complement.\r\n\r\nSSO avoids lots of tiny mallocs() on the heap which cause fragmentation\r\nby using the memory in the class object itself to store the actual\r\nstring and only mallocing() for buffers that are larger than what can\r\nfit in thie class object.  Modern C++ std::string implementations have\r\nthis optimization as well, but since we're using Arduino strings we had\r\nto roll our own.",
            "additions": 10,
            "deletions": 15,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            31
                        ],
                        "comments": [
                            "            *(wbuffer() + len()) = 0x00; // add null for string end"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            38
                        ],
                        "comments": [],
                        "lines": [
                            "size_t StreamString::write(uint8_t data) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            42
                        ],
                        "comments": [],
                        "lines": [
                            "int StreamString::available() {"
                        ]
                    },
                    {
                        "line_numbers": [
                            46
                        ],
                        "comments": [],
                        "lines": [
                            "int StreamString::read() {"
                        ]
                    },
                    {
                        "line_numbers": [
                            56
                        ],
                        "comments": [],
                        "lines": [
                            "int StreamString::peek() {"
                        ]
                    },
                    {
                        "line_numbers": [
                            64
                        ],
                        "comments": [],
                        "lines": [
                            "void StreamString::flush() {"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            31
                        ],
                        "comments": [
                            "            *(buffer + len) = 0x00; // add null for string end"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            38,
                            39
                        ],
                        "comments": [],
                        "lines": [
                            "size_t StreamString::write(uint8_t data)",
                            "{"
                        ]
                    },
                    {
                        "line_numbers": [
                            43,
                            44
                        ],
                        "comments": [],
                        "lines": [
                            "int StreamString::available()",
                            "{"
                        ]
                    },
                    {
                        "line_numbers": [
                            48,
                            49
                        ],
                        "comments": [],
                        "lines": [
                            "int StreamString::read()",
                            "{"
                        ]
                    },
                    {
                        "line_numbers": [
                            59,
                            60
                        ],
                        "comments": [],
                        "lines": [
                            "int StreamString::peek()",
                            "{"
                        ]
                    },
                    {
                        "line_numbers": [
                            68,
                            69
                        ],
                        "comments": [],
                        "lines": [
                            "void StreamString::flush()",
                            "{"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "31": "            *(wbuffer() + len()) = 0x00; // add null for string end"
            },
            "comment_deleted_diff": {
                "31": "            *(buffer + len) = 0x00; // add null for string end"
            },
            "comment_modified_diff": {
                "31": "            *(buffer + len) = 0x00; // add null for string end"
            }
        },
        {
            "commit": "bd57ff4ab4011fa88be9b191d9217c363927cc45",
            "timestamp": "2019-05-11T11:16:05+03:00",
            "author": "Earle F. Philhower, III",
            "commit_message": "StreamString SSO fix (#2736)\n\nAs found by @mongozmaki in https://github.com/esp8266/Arduino/pull/6035\r\n\r\nWith SSO implementation in String, StreamString::write generates wrong\r\nstrings under some circumstances.  Reason is that String::len() returns\r\nstrlen(sso_buf) if SSO=true but with newly written data\r\n(in StreamString::write) the null-termination missing at the time len()\r\nis called.\r\n\r\nFurthermore, len() is called twice which is inefficient if SSO=true.",
            "additions": 4,
            "deletions": 3,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            32
                        ],
                        "comments": [
                            "            *(wbuffer() + newlen) = 0x00; // add null for string end"
                        ],
                        "lines": []
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            31
                        ],
                        "comments": [
                            "            *(wbuffer() + len()) = 0x00; // add null for string end"
                        ],
                        "lines": []
                    }
                ]
            },
            "comment_added_diff": {
                "32": "            *(wbuffer() + newlen) = 0x00; // add null for string end"
            },
            "comment_deleted_diff": {
                "31": "            *(wbuffer() + len()) = 0x00; // add null for string end"
            },
            "comment_modified_diff": {}
        }
    ],
    "StreamString.h": [],
    "Udp.h": [],
    "WCharacter.h": [],
    "WMath.cpp": [],
    "WString.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 894,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645,
                            646,
                            647,
                            648,
                            649,
                            650,
                            651,
                            652,
                            653,
                            654,
                            655,
                            656,
                            657,
                            658,
                            659,
                            660,
                            661,
                            662,
                            663,
                            664,
                            665,
                            666,
                            667,
                            668,
                            669,
                            670,
                            671,
                            672,
                            673,
                            674,
                            675,
                            676,
                            677,
                            678,
                            679,
                            680,
                            681,
                            682,
                            683,
                            684,
                            685,
                            686,
                            687,
                            688,
                            689,
                            690,
                            691,
                            692,
                            693,
                            694,
                            695,
                            696,
                            697,
                            698,
                            699,
                            700,
                            701,
                            702,
                            703,
                            704,
                            705,
                            706,
                            707,
                            708,
                            709,
                            710,
                            711,
                            712,
                            713,
                            714,
                            715,
                            716,
                            717,
                            718,
                            719,
                            720,
                            721,
                            722,
                            723,
                            724,
                            725,
                            726,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732,
                            733,
                            734,
                            735,
                            736,
                            737,
                            738,
                            739,
                            740,
                            741,
                            742,
                            743,
                            744,
                            745,
                            746,
                            747,
                            748,
                            749,
                            750,
                            751,
                            752,
                            753,
                            754,
                            755,
                            756,
                            757,
                            758,
                            759,
                            760,
                            761,
                            762,
                            763,
                            764,
                            765,
                            766,
                            767,
                            768,
                            769,
                            770,
                            771,
                            772,
                            773,
                            774,
                            775,
                            776,
                            777,
                            778,
                            779,
                            780,
                            781,
                            782,
                            783,
                            784,
                            785,
                            786,
                            787,
                            788,
                            789,
                            790,
                            791,
                            792,
                            793,
                            794,
                            795,
                            796,
                            797,
                            798,
                            799,
                            800,
                            801,
                            802,
                            803,
                            804,
                            805,
                            806,
                            807,
                            808,
                            809,
                            810,
                            811,
                            812,
                            813,
                            814,
                            815,
                            816,
                            817,
                            818,
                            819,
                            820,
                            821,
                            822,
                            823,
                            824,
                            825,
                            826,
                            827,
                            828,
                            829,
                            830,
                            831,
                            832,
                            833,
                            834,
                            835,
                            836,
                            837,
                            838,
                            839,
                            840,
                            841,
                            842,
                            843,
                            844,
                            845,
                            846,
                            847,
                            848,
                            849,
                            850,
                            851,
                            852,
                            853,
                            854,
                            855,
                            856,
                            857,
                            858,
                            859,
                            860,
                            861,
                            862,
                            863,
                            864,
                            865,
                            866,
                            867,
                            868,
                            869,
                            870,
                            871,
                            872,
                            873,
                            874,
                            875,
                            876,
                            877,
                            878,
                            879,
                            880,
                            881,
                            882,
                            883,
                            884,
                            885,
                            886,
                            887,
                            888,
                            889,
                            890,
                            891,
                            892,
                            893,
                            894
                        ],
                        "comments": [
                            "    *this = pstr; // see operator =",
                            "// /*********************************************/",
                            "// /*  Memory Management                        */",
                            "// /*********************************************/",
                            "// /*********************************************/",
                            "// /*  Copy and Move                            */",
                            "// /*********************************************/",
                            "// /*********************************************/",
                            "// /*  concat                                   */",
                            "// /*********************************************/",
                            "// /*********************************************/",
                            "// /*  Comparison                               */",
                            "// /*********************************************/",
                            "// /*********************************************/",
                            "// /*  Character Access                         */",
                            "// /*********************************************/",
                            "// /*********************************************/",
                            "// /*  Search                                   */",
                            "// /*********************************************/",
                            "    char temp = buffer[right];  // save the replaced character",
                            "    out = buffer + left;  // pointer arithmetic",
                            "// /*********************************************/",
                            "// /*  Modification                             */",
                            "// /*********************************************/",
                            "        unsigned int size = len; // compute size needed for result",
                            "            return;    // XXX: tell user!",
                            "    // Pass the biggest integer as the count. The remove method",
                            "    // below will take care of truncating it at the end of the",
                            "    // string.",
                            "// /*********************************************/",
                            "// /*  Parsing / Conversion                     */",
                            "// /*********************************************/"
                        ],
                        "lines": [
                            "}",
                            "*/",
                            "#ifdef __GXX_EXPERIMENTAL_CXX0X__",
                            "String::String(String &&rval)",
                            "{",
                            "    init();",
                            "    move(rval);",
                            "}",
                            "",
                            "String::String(StringSumHelper &&rval)",
                            "{",
                            "    init();",
                            "    move(rval);",
                            "}",
                            "#endif",
                            "",
                            "String::String(char c)",
                            "{",
                            "    init();",
                            "    char buf[2];",
                            "    buf[0] = c;",
                            "    buf[1] = 0;",
                            "    *this = buf;",
                            "}",
                            "",
                            "String::String(unsigned char value, unsigned char base)",
                            "{",
                            "    init();",
                            "    char buf[1 + 8 * sizeof(unsigned char)];",
                            "    utoa(value, buf, base);",
                            "    *this = buf;",
                            "}",
                            "",
                            "String::String(int value, unsigned char base)",
                            "{",
                            "    init();",
                            "    char buf[2 + 8 * sizeof(int)];",
                            "    itoa(value, buf, base);",
                            "    *this = buf;",
                            "}",
                            "",
                            "String::String(unsigned int value, unsigned char base)",
                            "{",
                            "    init();",
                            "    char buf[1 + 8 * sizeof(unsigned int)];",
                            "    utoa(value, buf, base);",
                            "    *this = buf;",
                            "}",
                            "",
                            "String::String(long value, unsigned char base)",
                            "{",
                            "    init();",
                            "    char buf[2 + 8 * sizeof(long)];",
                            "    ltoa(value, buf, base);",
                            "    *this = buf;",
                            "}",
                            "",
                            "String::String(unsigned long value, unsigned char base)",
                            "{",
                            "    init();",
                            "    char buf[1 + 8 * sizeof(unsigned long)];",
                            "    ultoa(value, buf, base);",
                            "    *this = buf;",
                            "}",
                            "",
                            "String::String(float value, unsigned char decimalPlaces)",
                            "{",
                            "    init();",
                            "    char buf[33];",
                            "    *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);",
                            "}",
                            "",
                            "String::String(double value, unsigned char decimalPlaces)",
                            "{",
                            "    init();",
                            "    char buf[33];",
                            "    *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);",
                            "}",
                            "",
                            "String::~String()",
                            "{",
                            "    if(buffer) {",
                            "        free(buffer);",
                            "    }",
                            "    init();",
                            "}",
                            "",
                            "",
                            "inline void String::init(void)",
                            "{",
                            "    buffer = NULL;",
                            "    capacity = 0;",
                            "    len = 0;",
                            "}",
                            "",
                            "void String::invalidate(void)",
                            "{",
                            "    if(buffer) {",
                            "        free(buffer);",
                            "    }",
                            "    init();",
                            "}",
                            "",
                            "unsigned char String::reserve(unsigned int size)",
                            "{",
                            "    if(buffer && capacity >= size) {",
                            "        return 1;",
                            "    }",
                            "    if(changeBuffer(size)) {",
                            "        if(len == 0) {",
                            "            buffer[0] = 0;",
                            "        }",
                            "        return 1;",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "unsigned char String::changeBuffer(unsigned int maxStrLen)",
                            "{",
                            "    size_t newSize = (maxStrLen + 16) & (~0xf);",
                            "    char *newbuffer = (char *) malloc(newSize);",
                            "    if(newbuffer) {",
                            "        memset(newbuffer, 0, newSize);",
                            "        memcpy(newbuffer, buffer, len);",
                            "        if (buffer) {",
                            "            free(buffer);",
                            "        }",
                            "        capacity = newSize - 1;",
                            "        buffer = newbuffer;",
                            "        return 1;",
                            "    }",
                            "    buffer = newbuffer;",
                            "    return 0;",
                            "}",
                            "",
                            "",
                            "String & String::copy(const char *cstr, unsigned int length)",
                            "{",
                            "    if(!reserve(length)) {",
                            "        invalidate();",
                            "        return *this;",
                            "    }",
                            "    len = length;",
                            "    strcpy(buffer, cstr);",
                            "    return *this;",
                            "}",
                            "/*",
                            "String & String::copy(const __FlashStringHelper *pstr, unsigned int length) {",
                            "    if (!reserve(length)) {",
                            "        invalidate();",
                            "        return *this;",
                            "    }",
                            "    len = length;",
                            "    strcpy_P(buffer, (PGM_P)pstr);",
                            "    return *this;",
                            "}",
                            "*/",
                            "#ifdef __GXX_EXPERIMENTAL_CXX0X__",
                            "void String::move(String &rhs)",
                            "{",
                            "    if(buffer) {",
                            "        if(capacity >= rhs.len) {",
                            "            strcpy(buffer, rhs.buffer);",
                            "            len = rhs.len;",
                            "            rhs.len = 0;",
                            "            return;",
                            "        } else {",
                            "            free(buffer);",
                            "        }",
                            "    }",
                            "    buffer = rhs.buffer;",
                            "    capacity = rhs.capacity;",
                            "    len = rhs.len;",
                            "    rhs.buffer = NULL;",
                            "    rhs.capacity = 0;",
                            "    rhs.len = 0;",
                            "}",
                            "#endif",
                            "",
                            "String & String::operator =(const String &rhs)",
                            "{",
                            "    if(this == &rhs) {",
                            "        return *this;",
                            "    }",
                            "",
                            "    if(rhs.buffer) {",
                            "        copy(rhs.buffer, rhs.len);",
                            "    } else {",
                            "        invalidate();",
                            "    }",
                            "",
                            "    return *this;",
                            "}",
                            "",
                            "#ifdef __GXX_EXPERIMENTAL_CXX0X__",
                            "String & String::operator =(String &&rval)",
                            "{",
                            "    if(this != &rval) {",
                            "        move(rval);",
                            "    }",
                            "    return *this;",
                            "}",
                            "",
                            "String & String::operator =(StringSumHelper &&rval)",
                            "{",
                            "    if(this != &rval) {",
                            "        move(rval);",
                            "    }",
                            "    return *this;",
                            "}",
                            "#endif",
                            "",
                            "String & String::operator =(const char *cstr)",
                            "{",
                            "    if(cstr) {",
                            "        copy(cstr, strlen(cstr));",
                            "    } else {",
                            "        invalidate();",
                            "    }",
                            "",
                            "    return *this;",
                            "}",
                            "/*",
                            "String & String::operator = (const __FlashStringHelper *pstr)",
                            "{",
                            "    if (pstr) copy(pstr, strlen_P((PGM_P)pstr));",
                            "    else invalidate();",
                            "",
                            "    return *this;",
                            "}",
                            "*/",
                            "",
                            "unsigned char String::concat(const String &s)",
                            "{",
                            "    return concat(s.buffer, s.len);",
                            "}",
                            "",
                            "unsigned char String::concat(const char *cstr, unsigned int length)",
                            "{",
                            "    unsigned int newlen = len + length;",
                            "    if(!cstr) {",
                            "        return 0;",
                            "    }",
                            "    if(length == 0) {",
                            "        return 1;",
                            "    }",
                            "    if(!reserve(newlen)) {",
                            "        return 0;",
                            "    }",
                            "    strcpy(buffer + len, cstr);",
                            "    len = newlen;",
                            "    return 1;",
                            "}",
                            "",
                            "unsigned char String::concat(const char *cstr)",
                            "{",
                            "    if(!cstr) {",
                            "        return 0;",
                            "    }",
                            "    return concat(cstr, strlen(cstr));",
                            "}",
                            "",
                            "unsigned char String::concat(char c)",
                            "{",
                            "    char buf[2];",
                            "    buf[0] = c;",
                            "    buf[1] = 0;",
                            "    return concat(buf, 1);",
                            "}",
                            "",
                            "unsigned char String::concat(unsigned char num)",
                            "{",
                            "    char buf[1 + 3 * sizeof(unsigned char)];",
                            "    itoa(num, buf, 10);",
                            "    return concat(buf, strlen(buf));",
                            "}",
                            "",
                            "unsigned char String::concat(int num)",
                            "{",
                            "    char buf[2 + 3 * sizeof(int)];",
                            "    itoa(num, buf, 10);",
                            "    return concat(buf, strlen(buf));",
                            "}",
                            "",
                            "unsigned char String::concat(unsigned int num)",
                            "{",
                            "    char buf[1 + 3 * sizeof(unsigned int)];",
                            "    utoa(num, buf, 10);",
                            "    return concat(buf, strlen(buf));",
                            "}",
                            "",
                            "unsigned char String::concat(long num)",
                            "{",
                            "    char buf[2 + 3 * sizeof(long)];",
                            "    ltoa(num, buf, 10);",
                            "    return concat(buf, strlen(buf));",
                            "}",
                            "",
                            "unsigned char String::concat(unsigned long num)",
                            "{",
                            "    char buf[1 + 3 * sizeof(unsigned long)];",
                            "    ultoa(num, buf, 10);",
                            "    return concat(buf, strlen(buf));",
                            "}",
                            "",
                            "unsigned char String::concat(float num)",
                            "{",
                            "    char buf[20];",
                            "    char* string = dtostrf(num, 4, 2, buf);",
                            "    return concat(string, strlen(string));",
                            "}",
                            "",
                            "unsigned char String::concat(double num)",
                            "{",
                            "    char buf[20];",
                            "    char* string = dtostrf(num, 4, 2, buf);",
                            "    return concat(string, strlen(string));",
                            "}",
                            "/*",
                            "unsigned char String::concat(const __FlashStringHelper * str) {",
                            "    if (!str) return 0;",
                            "    int length = strlen_P((PGM_P)str);",
                            "    if (length == 0) return 1;",
                            "    unsigned int newlen = len + length;",
                            "    if (!reserve(newlen)) return 0;",
                            "    strcpy_P(buffer + len, (PGM_P)str);",
                            "    len = newlen;",
                            "    return 1;",
                            "}",
                            "*/",
                            "/*********************************************/",
                            "/*  Concatenate                              */",
                            "/*********************************************/",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(rhs.buffer, rhs.len)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!cstr || !a.concat(cstr, strlen(cstr))) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, char c)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(c)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(num)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, int num)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(num)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(num)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, long num)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(num)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(num)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, float num)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(num)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "",
                            "StringSumHelper & operator +(const StringSumHelper &lhs, double num)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if(!a.concat(num)) {",
                            "        a.invalidate();",
                            "    }",
                            "    return a;",
                            "}",
                            "/*",
                            "StringSumHelper & operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)",
                            "{",
                            "    StringSumHelper &a = const_cast<StringSumHelper&>(lhs);",
                            "    if (!a.concat(rhs))\ta.invalidate();",
                            "    return a;",
                            "}",
                            "*/",
                            "",
                            "int String::compareTo(const String &s) const",
                            "{",
                            "    if(!buffer || !s.buffer) {",
                            "        if(s.buffer && s.len > 0) {",
                            "            return 0 - *(unsigned char *) s.buffer;",
                            "        }",
                            "        if(buffer && len > 0) {",
                            "            return *(unsigned char *) buffer;",
                            "        }",
                            "        return 0;",
                            "    }",
                            "    return strcmp(buffer, s.buffer);",
                            "}",
                            "",
                            "unsigned char String::equals(const String &s2) const",
                            "{",
                            "    return (len == s2.len && compareTo(s2) == 0);",
                            "}",
                            "",
                            "unsigned char String::equals(const char *cstr) const",
                            "{",
                            "    if(len == 0) {",
                            "        return (cstr == NULL || *cstr == 0);",
                            "    }",
                            "    if(cstr == NULL) {",
                            "        return buffer[0] == 0;",
                            "    }",
                            "    return strcmp(buffer, cstr) == 0;",
                            "}",
                            "",
                            "unsigned char String::operator<(const String &rhs) const",
                            "{",
                            "    return compareTo(rhs) < 0;",
                            "}",
                            "",
                            "unsigned char String::operator>(const String &rhs) const",
                            "{",
                            "    return compareTo(rhs) > 0;",
                            "}",
                            "",
                            "unsigned char String::operator<=(const String &rhs) const",
                            "{",
                            "    return compareTo(rhs) <= 0;",
                            "}",
                            "",
                            "unsigned char String::operator>=(const String &rhs) const",
                            "{",
                            "    return compareTo(rhs) >= 0;",
                            "}",
                            "",
                            "unsigned char String::equalsIgnoreCase(const String &s2) const",
                            "{",
                            "    if(this == &s2) {",
                            "        return 1;",
                            "    }",
                            "    if(len != s2.len) {",
                            "        return 0;",
                            "    }",
                            "    if(len == 0) {",
                            "        return 1;",
                            "    }",
                            "    const char *p1 = buffer;",
                            "    const char *p2 = s2.buffer;",
                            "    while(*p1) {",
                            "        if(tolower(*p1++) != tolower(*p2++)) {",
                            "            return 0;",
                            "        }",
                            "    }",
                            "    return 1;",
                            "}",
                            "",
                            "unsigned char String::startsWith(const String &s2) const",
                            "{",
                            "    if(len < s2.len) {",
                            "        return 0;",
                            "    }",
                            "    return startsWith(s2, 0);",
                            "}",
                            "",
                            "unsigned char String::startsWith(const String &s2, unsigned int offset) const",
                            "{",
                            "    if(offset > len - s2.len || !buffer || !s2.buffer) {",
                            "        return 0;",
                            "    }",
                            "    return strncmp(&buffer[offset], s2.buffer, s2.len) == 0;",
                            "}",
                            "",
                            "unsigned char String::endsWith(const String &s2) const",
                            "{",
                            "    if(len < s2.len || !buffer || !s2.buffer) {",
                            "        return 0;",
                            "    }",
                            "    return strcmp(&buffer[len - s2.len], s2.buffer) == 0;",
                            "}",
                            "",
                            "",
                            "char String::charAt(unsigned int loc) const",
                            "{",
                            "    return operator[](loc);",
                            "}",
                            "",
                            "void String::setCharAt(unsigned int loc, char c)",
                            "{",
                            "    if(loc < len) {",
                            "        buffer[loc] = c;",
                            "    }",
                            "}",
                            "",
                            "char & String::operator[](unsigned int index)",
                            "{",
                            "    static char dummy_writable_char;",
                            "    if(index >= len || !buffer) {",
                            "        dummy_writable_char = 0;",
                            "        return dummy_writable_char;",
                            "    }",
                            "    return buffer[index];",
                            "}",
                            "",
                            "char String::operator[](unsigned int index) const",
                            "{",
                            "    if(index >= len || !buffer) {",
                            "        return 0;",
                            "    }",
                            "    return buffer[index];",
                            "}",
                            "",
                            "void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const",
                            "{",
                            "    if(!bufsize || !buf) {",
                            "        return;",
                            "    }",
                            "    if(index >= len) {",
                            "        buf[0] = 0;",
                            "        return;",
                            "    }",
                            "    unsigned int n = bufsize - 1;",
                            "    if(n > len - index) {",
                            "        n = len - index;",
                            "    }",
                            "    strncpy((char *) buf, buffer + index, n);",
                            "    buf[n] = 0;",
                            "}",
                            "",
                            "",
                            "int String::indexOf(char c) const",
                            "{",
                            "    return indexOf(c, 0);",
                            "}",
                            "",
                            "int String::indexOf(char ch, unsigned int fromIndex) const",
                            "{",
                            "    if(fromIndex >= len) {",
                            "        return -1;",
                            "    }",
                            "    const char* temp = strchr(buffer + fromIndex, ch);",
                            "    if(temp == NULL) {",
                            "        return -1;",
                            "    }",
                            "    return temp - buffer;",
                            "}",
                            "",
                            "int String::indexOf(const String &s2) const",
                            "{",
                            "    return indexOf(s2, 0);",
                            "}",
                            "",
                            "int String::indexOf(const String &s2, unsigned int fromIndex) const",
                            "{",
                            "    if(fromIndex >= len) {",
                            "        return -1;",
                            "    }",
                            "    const char *found = strstr(buffer + fromIndex, s2.buffer);",
                            "    if(found == NULL) {",
                            "        return -1;",
                            "    }",
                            "    return found - buffer;",
                            "}",
                            "",
                            "int String::lastIndexOf(char theChar) const",
                            "{",
                            "    return lastIndexOf(theChar, len - 1);",
                            "}",
                            "",
                            "int String::lastIndexOf(char ch, unsigned int fromIndex) const",
                            "{",
                            "    if(fromIndex >= len) {",
                            "        return -1;",
                            "    }",
                            "    char tempchar = buffer[fromIndex + 1];",
                            "    buffer[fromIndex + 1] = '\\0';",
                            "    char* temp = strrchr(buffer, ch);",
                            "    buffer[fromIndex + 1] = tempchar;",
                            "    if(temp == NULL) {",
                            "        return -1;",
                            "    }",
                            "    return temp - buffer;",
                            "}",
                            "",
                            "int String::lastIndexOf(const String &s2) const",
                            "{",
                            "    return lastIndexOf(s2, len - s2.len);",
                            "}",
                            "",
                            "int String::lastIndexOf(const String &s2, unsigned int fromIndex) const",
                            "{",
                            "    if(s2.len == 0 || len == 0 || s2.len > len) {",
                            "        return -1;",
                            "    }",
                            "    if(fromIndex >= len) {",
                            "        fromIndex = len - 1;",
                            "    }",
                            "    int found = -1;",
                            "    for(char *p = buffer; p <= buffer + fromIndex; p++) {",
                            "        p = strstr(p, s2.buffer);",
                            "        if(!p) {",
                            "            break;",
                            "        }",
                            "        if((unsigned int) (p - buffer) <= fromIndex) {",
                            "            found = p - buffer;",
                            "        }",
                            "    }",
                            "    return found;",
                            "}",
                            "",
                            "String String::substring(unsigned int left, unsigned int right) const",
                            "{",
                            "    if(left > right) {",
                            "        unsigned int temp = right;",
                            "        right = left;",
                            "        left = temp;",
                            "    }",
                            "    String out;",
                            "    if(left >= len) {",
                            "        return out;",
                            "    }",
                            "    if(right > len) {",
                            "        right = len;",
                            "    }",
                            "    buffer[right] = '\\0';",
                            "    buffer[right] = temp;  //restore character",
                            "    return out;",
                            "}",
                            "",
                            "",
                            "void String::replace(char find, char replace)",
                            "{",
                            "    if(!buffer) {",
                            "        return;",
                            "    }",
                            "    for(char *p = buffer; *p; p++) {",
                            "        if(*p == find) {",
                            "            *p = replace;",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "void String::replace(const String& find, const String& replace)",
                            "{",
                            "    if(len == 0 || find.len == 0) {",
                            "        return;",
                            "    }",
                            "    int diff = replace.len - find.len;",
                            "    char *readFrom = buffer;",
                            "    char *foundAt;",
                            "    if(diff == 0) {",
                            "        while((foundAt = strstr(readFrom, find.buffer)) != NULL) {",
                            "            memcpy(foundAt, replace.buffer, replace.len);",
                            "            readFrom = foundAt + replace.len;",
                            "        }",
                            "    } else if(diff < 0) {",
                            "        char *writeTo = buffer;",
                            "        while((foundAt = strstr(readFrom, find.buffer)) != NULL) {",
                            "            unsigned int n = foundAt - readFrom;",
                            "            memcpy(writeTo, readFrom, n);",
                            "            writeTo += n;",
                            "            memcpy(writeTo, replace.buffer, replace.len);",
                            "            writeTo += replace.len;",
                            "            readFrom = foundAt + find.len;",
                            "            len += diff;",
                            "        }",
                            "        strcpy(writeTo, readFrom);",
                            "    } else {",
                            "        while((foundAt = strstr(readFrom, find.buffer)) != NULL) {",
                            "            readFrom = foundAt + find.len;",
                            "            size += diff;",
                            "        }",
                            "        if(size == len) {",
                            "            return;",
                            "        }",
                            "        if(size > capacity && !changeBuffer(size)) {",
                            "        }",
                            "        int index = len - 1;",
                            "        while(index >= 0 && (index = lastIndexOf(find, index)) >= 0) {",
                            "            readFrom = buffer + index + find.len;",
                            "            memmove(readFrom + diff, readFrom, len - (readFrom - buffer));",
                            "            len += diff;",
                            "            buffer[len] = 0;",
                            "            memcpy(buffer + index, replace.buffer, replace.len);",
                            "            index--;",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "void String::remove(unsigned int index)",
                            "{",
                            "    remove(index, (unsigned int) -1);",
                            "}",
                            "",
                            "void String::remove(unsigned int index, unsigned int count)",
                            "{",
                            "    if(index >= len) {",
                            "        return;",
                            "    }",
                            "    if(count <= 0) {",
                            "        return;",
                            "    }",
                            "    if(count > len - index) {",
                            "        count = len - index;",
                            "    }",
                            "    char *writeTo = buffer + index;",
                            "    len = len - count;",
                            "    strncpy(writeTo, buffer + index + count, len - index);",
                            "    buffer[len] = 0;",
                            "}",
                            "",
                            "void String::toLowerCase(void)",
                            "{",
                            "    if(!buffer) {",
                            "        return;",
                            "    }",
                            "    for(char *p = buffer; *p; p++) {",
                            "        *p = tolower(*p);",
                            "    }",
                            "}",
                            "",
                            "void String::toUpperCase(void)",
                            "{",
                            "    if(!buffer) {",
                            "        return;",
                            "    }",
                            "    for(char *p = buffer; *p; p++) {",
                            "        *p = toupper(*p);",
                            "    }",
                            "}",
                            "",
                            "void String::trim(void)",
                            "{",
                            "    if(!buffer || len == 0) {",
                            "        return;",
                            "    }",
                            "    char *begin = buffer;",
                            "    while(isspace(*begin)) {",
                            "        begin++;",
                            "    }",
                            "    char *end = buffer + len - 1;",
                            "    while(isspace(*end) && end >= begin) {",
                            "        end--;",
                            "    }",
                            "    len = end + 1 - begin;",
                            "    if(begin > buffer) {",
                            "        memcpy(buffer, begin, len);",
                            "    }",
                            "    buffer[len] = 0;",
                            "}",
                            "",
                            "",
                            "long String::toInt(void) const",
                            "{",
                            "    if(buffer) {",
                            "        return atol(buffer);",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "float String::toFloat(void) const",
                            "{",
                            "    if(buffer) {",
                            "        return atof(buffer);",
                            "    }",
                            "    return 0;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "50": "    *this = pstr; // see operator =",
                "138": "// /*********************************************/",
                "139": "// /*  Memory Management                        */",
                "140": "// /*********************************************/",
                "189": "// /*********************************************/",
                "190": "// /*  Copy and Move                            */",
                "191": "// /*********************************************/",
                "288": "// /*********************************************/",
                "289": "// /*  concat                                   */",
                "290": "// /*********************************************/",
                "491": "// /*********************************************/",
                "492": "// /*  Comparison                               */",
                "493": "// /*********************************************/",
                "590": "// /*********************************************/",
                "591": "// /*  Character Access                         */",
                "592": "// /*********************************************/",
                "641": "// /*********************************************/",
                "642": "// /*  Search                                   */",
                "643": "// /*********************************************/",
                "739": "    char temp = buffer[right];  // save the replaced character",
                "741": "    out = buffer + left;  // pointer arithmetic",
                "746": "// /*********************************************/",
                "747": "// /*  Modification                             */",
                "748": "// /*********************************************/",
                "788": "        unsigned int size = len; // compute size needed for result",
                "797": "            return;    // XXX: tell user!",
                "813": "    // Pass the biggest integer as the count. The remove method",
                "814": "    // below will take care of truncating it at the end of the",
                "815": "    // string.",
                "876": "// /*********************************************/",
                "877": "// /*  Parsing / Conversion                     */",
                "878": "// /*********************************************/"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "67128fcb2c01205da697cff04d45ba7566393183",
            "timestamp": "2017-02-08T19:57:26+02:00",
            "author": "Martin Sloup",
            "commit_message": "Fixes implementation of __FlashStringHelper (#183)\n\nPrevious __FlashStringHelper implementation was defines as a char which brought problem in case the method with char* parameter used overloading with __FlashStringHelper* parameter (they was identical). Now __FlashStringHelper is defined as a class and all casts between char* and __FlashStringHelper* are made with reinterpret_cast sugar.",
            "additions": 15,
            "deletions": 31,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            50,
                            51,
                            52
                        ],
                        "comments": [
                            "    *this = pstr; // see operator ="
                        ],
                        "lines": [
                            "}",
                            "*/"
                        ]
                    },
                    {
                        "line_numbers": [
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211
                        ],
                        "comments": [],
                        "lines": [
                            "/*",
                            "String & String::copy(const __FlashStringHelper *pstr, unsigned int length) {",
                            "    if (!reserve(length)) {",
                            "        invalidate();",
                            "        return *this;",
                            "    }",
                            "    len = length;",
                            "    strcpy_P(buffer, (PGM_P)pstr);",
                            "    return *this;"
                        ]
                    },
                    {
                        "line_numbers": [
                            213
                        ],
                        "comments": [],
                        "lines": [
                            "*/"
                        ]
                    },
                    {
                        "line_numbers": [
                            279
                        ],
                        "comments": [],
                        "lines": [
                            "/*"
                        ]
                    },
                    {
                        "line_numbers": [
                            287
                        ],
                        "comments": [],
                        "lines": [
                            "*/"
                        ]
                    },
                    {
                        "line_numbers": [
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387
                        ],
                        "comments": [],
                        "lines": [
                            "/*",
                            "unsigned char String::concat(const __FlashStringHelper * str) {",
                            "    if (!str) return 0;",
                            "    int length = strlen_P((PGM_P)str);",
                            "    if (length == 0) return 1;",
                            "    unsigned int newlen = len + length;",
                            "    if (!reserve(newlen)) return 0;",
                            "    strcpy_P(buffer + len, (PGM_P)str);",
                            "    len = newlen;",
                            "    return 1;"
                        ]
                    },
                    {
                        "line_numbers": [
                            389
                        ],
                        "comments": [],
                        "lines": [
                            "*/"
                        ]
                    },
                    {
                        "line_numbers": [
                            483
                        ],
                        "comments": [],
                        "lines": [
                            "/*"
                        ]
                    },
                    {
                        "line_numbers": [
                            490
                        ],
                        "comments": [],
                        "lines": [
                            "*/"
                        ]
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "50": "    *this = pstr; // see operator ="
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 28,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            887,
                            888,
                            889,
                            890,
                            891,
                            892,
                            893,
                            894,
                            895,
                            896,
                            897,
                            898,
                            899,
                            900,
                            901,
                            902,
                            903,
                            904,
                            905,
                            906,
                            907,
                            908,
                            909,
                            910,
                            911
                        ],
                        "comments": [
                            "    // To avoid possible time-based attacks present function",
                            "    // compares given strings in a constant time."
                        ],
                        "lines": [
                            "    if(len != s2.len)",
                            "        return 0;",
                            "    //at this point lengths are the same",
                            "    if(len == 0)",
                            "        return 1;",
                            "    //at this point lenghts are the same and non-zero",
                            "    const char *p1 = buffer;",
                            "    const char *p2 = s2.buffer;",
                            "    unsigned int equalchars = 0;",
                            "    unsigned int diffchars = 0;",
                            "    while(*p1) {",
                            "        if(*p1 == *p2)",
                            "            ++equalchars;",
                            "        else",
                            "            ++diffchars;",
                            "        ++p1;",
                            "        ++p2;",
                            "    }",
                            "    //the following should force a constant time eval of the condition without a compiler \"logical shortcut\"",
                            "    unsigned char equalcond = (equalchars == len);",
                            "    unsigned char diffcond = (diffchars == 0);",
                            "    return (equalcond & diffcond); //bitwise AND",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "887": "    // To avoid possible time-based attacks present function",
                "888": "    // compares given strings in a constant time."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "ab309e40d5f7a593f36f456976973ed7589a1f04",
            "timestamp": "2019-04-26T19:41:42+03:00",
            "author": "Earle F. Philhower, III",
            "commit_message": "Copy ESP8266 String w/SSO to ESP32 repo (#2715)\n\nI redid the ESP8266 WString library to enable small string optimization\r\n(SSO) a while back, and think it would be helpful even on the ESP32 with\r\nits higher memory complement.\r\n\r\nSSO avoids lots of tiny mallocs() on the heap which cause fragmentation\r\nby using the memory in the class object itself to store the actual\r\nstring and only mallocing() for buffers that are larger than what can\r\nfit in thie class object.  Modern C++ std::string implementations have\r\nthis optimization as well, but since we're using Arduino strings we had\r\nto roll our own.",
            "additions": 386,
            "deletions": 451,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            45,
                            46,
                            47
                        ],
                        "comments": [
                            "    *this = pstr; // see operator ="
                        ],
                        "lines": [
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            49
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(String &&rval) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            54
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(StringSumHelper &&rval) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            60
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(char c) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            68
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(unsigned char value, unsigned char base) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            75
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(int value, unsigned char base) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            78,
                            79,
                            80,
                            81,
                            82
                        ],
                        "comments": [],
                        "lines": [
                            "    if (base == 10) {",
                            "        sprintf(buf, \"%d\", value);",
                            "    } else {",
                            "        itoa(value, buf, base);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            86
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(unsigned int value, unsigned char base) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            93
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(long value, unsigned char base) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            96,
                            97,
                            98,
                            99,
                            100
                        ],
                        "comments": [],
                        "lines": [
                            "    if (base==10) {",
                            "        sprintf(buf, \"%ld\", value);",
                            "    } else {",
                            "        ltoa(value, buf, base);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            104
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(unsigned long value, unsigned char base) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            111
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(float value, unsigned char decimalPlaces) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            117
                        ],
                        "comments": [],
                        "lines": [
                            "String::String(double value, unsigned char decimalPlaces) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            123,
                            124
                        ],
                        "comments": [],
                        "lines": [
                            "String::~String() {",
                            "    invalidate();"
                        ]
                    },
                    {
                        "line_numbers": [
                            131,
                            132,
                            133,
                            134,
                            135
                        ],
                        "comments": [],
                        "lines": [
                            "inline void String::init(void) {",
                            "    setSSO(false);",
                            "    setCapacity(0);",
                            "    setLen(0);",
                            "    setBuffer(nullptr);"
                        ]
                    },
                    {
                        "line_numbers": [
                            138,
                            139,
                            140
                        ],
                        "comments": [],
                        "lines": [
                            "void String::invalidate(void) {",
                            "    if(!sso() && wbuffer())",
                            "        free(wbuffer());"
                        ]
                    },
                    {
                        "line_numbers": [
                            144,
                            145
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::reserve(unsigned int size) {",
                            "    if(buffer() && capacity() >= size)"
                        ]
                    },
                    {
                        "line_numbers": [
                            148,
                            149
                        ],
                        "comments": [],
                        "lines": [
                            "        if(len() == 0)",
                            "            wbuffer()[0] = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179
                        ],
                        "comments": [
                            "    // Can we use SSO here to avoid allocation?",
                            "            // Already using SSO, nothing to do",
                            "        } else { // if bufptr && !sso()",
                            "            // Using bufptr, need to shrink into sso_buff",
                            "    // Fallthrough to normal allocator",
                            "    // Make sure we can fit newsize in the buffer"
                        ],
                        "lines": [
                            "unsigned char String::changeBuffer(unsigned int maxStrLen) {",
                            "    if (maxStrLen < sizeof(sso_buf)) {",
                            "        if (sso() || !buffer()) {",
                            "            setSSO(true);",
                            "            return 1;",
                            "            char temp[sizeof(sso_buf)];",
                            "            memcpy(temp, buffer(), maxStrLen);",
                            "            free(wbuffer());",
                            "            setSSO(true);",
                            "            memcpy(wbuffer(), temp, maxStrLen);",
                            "            return 1;",
                            "        }",
                            "    }",
                            "    size_t newSize = (maxStrLen + 16) & (~0xf);",
                            "    if (newSize > CAPACITY_MAX) {",
                            "        return false;",
                            "    }",
                            "    uint16_t oldLen = len();",
                            "    char *newbuffer = (char *) realloc(sso() ? nullptr : wbuffer(), newSize);"
                        ]
                    },
                    {
                        "line_numbers": [
                            182,
                            183,
                            184
                        ],
                        "comments": [
                            "            // Copy the SSO buffer into allocated space"
                        ],
                        "lines": [
                            "        if (sso()) {",
                            "            memcpy(newbuffer, sso_buf, sizeof(sso_buf));"
                        ]
                    },
                    {
                        "line_numbers": [
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193
                        ],
                        "comments": [
                            "        setLen(oldLen); // Needed in case of SSO where len() never existed"
                        ],
                        "lines": [
                            "        if (newSize > oldSize)",
                            "        {",
                            "            memset(newbuffer + oldSize, 0, newSize - oldSize);",
                            "        }",
                            "        setSSO(false);",
                            "        setCapacity(newSize - 1);",
                            "        setBuffer(newbuffer);"
                        ]
                    },
                    {
                        "line_numbers": [
                            203
                        ],
                        "comments": [],
                        "lines": [
                            "String & String::copy(const char *cstr, unsigned int length) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            208,
                            209
                        ],
                        "comments": [],
                        "lines": [
                            "    setLen(length);",
                            "    strcpy(wbuffer(), cstr);"
                        ]
                    },
                    {
                        "line_numbers": [
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220
                        ],
                        "comments": [],
                        "lines": [
                            "String & String::copy(const __FlashStringHelper *pstr, unsigned int length) {",
                            "    if (!reserve(length)) {",
                            "        invalidate();",
                            "        return *this;",
                            "    }",
                            "    setLen(length);",
                            "    strcpy_P(wbuffer(), (PGM_P)pstr);",
                            "    return *this;"
                        ]
                    },
                    {
                        "line_numbers": [
                            224,
                            225,
                            226,
                            227,
                            228,
                            229
                        ],
                        "comments": [],
                        "lines": [
                            "void String::move(String &rhs) {",
                            "    if(buffer()) {",
                            "        if(capacity() >= rhs.len()) {",
                            "            strcpy(wbuffer(), rhs.buffer());",
                            "            setLen(rhs.len());",
                            "\t    rhs.invalidate();"
                        ]
                    },
                    {
                        "line_numbers": [
                            232,
                            233,
                            234,
                            235
                        ],
                        "comments": [],
                        "lines": [
                            "            if (!sso()) {",
                            "                free(wbuffer());",
                            "                setBuffer(nullptr);",
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250
                        ],
                        "comments": [],
                        "lines": [
                            "    if (rhs.sso()) {",
                            "        setSSO(true);",
                            "        memmove(sso_buf, rhs.sso_buf, sizeof(sso_buf));",
                            "    } else {",
                            "        setSSO(false);",
                            "        setBuffer(rhs.wbuffer());",
                            "    }",
                            "    setCapacity(rhs.capacity());",
                            "    setLen(rhs.len());",
                            "    rhs.setSSO(false);",
                            "    rhs.setCapacity(0);",
                            "    rhs.setLen(0);",
                            "    rhs.setBuffer(nullptr);"
                        ]
                    },
                    {
                        "line_numbers": [
                            254,
                            255
                        ],
                        "comments": [],
                        "lines": [
                            "String & String::operator =(const String &rhs) {",
                            "    if(this == &rhs)"
                        ]
                    },
                    {
                        "line_numbers": [
                            258,
                            259,
                            260
                        ],
                        "comments": [],
                        "lines": [
                            "    if(rhs.buffer())",
                            "        copy(rhs.buffer(), rhs.len());",
                            "    else"
                        ]
                    },
                    {
                        "line_numbers": [
                            267,
                            268
                        ],
                        "comments": [],
                        "lines": [
                            "String & String::operator =(String &&rval) {",
                            "    if(this != &rval)"
                        ]
                    },
                    {
                        "line_numbers": [
                            273,
                            274
                        ],
                        "comments": [],
                        "lines": [
                            "String & String::operator =(StringSumHelper &&rval) {",
                            "    if(this != &rval)"
                        ]
                    },
                    {
                        "line_numbers": [
                            280,
                            281
                        ],
                        "comments": [],
                        "lines": [
                            "String & String::operator =(const char *cstr) {",
                            "    if(cstr)"
                        ]
                    },
                    {
                        "line_numbers": [
                            283
                        ],
                        "comments": [],
                        "lines": [
                            "    else"
                        ]
                    },
                    {
                        "line_numbers": [
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318
                        ],
                        "comments": [
                            "    // Special case if we're concatting ourself (s += s;) since we may end up",
                            "    // realloc'ing the buffer and moving s.buffer in the method called"
                        ],
                        "lines": [
                            "unsigned char String::concat(const String &s) {",
                            "    if (&s == this) {",
                            "        unsigned int newlen = 2 * len();",
                            "        if (!s.buffer())",
                            "            return 0;",
                            "        if (s.len() == 0)",
                            "            return 1;",
                            "        if (!reserve(newlen))",
                            "            return 0;",
                            "        memcpy(wbuffer() + len(), buffer(), len());",
                            "        setLen(newlen);",
                            "        wbuffer()[len()] = 0;",
                            "        return 1;",
                            "    } else {",
                            "        return concat(s.buffer(), s.len());",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            321,
                            322,
                            323
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(const char *cstr, unsigned int length) {",
                            "    unsigned int newlen = len() + length;",
                            "    if(!cstr)"
                        ]
                    },
                    {
                        "line_numbers": [
                            325
                        ],
                        "comments": [],
                        "lines": [
                            "    if(length == 0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            327
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!reserve(newlen))"
                        ]
                    },
                    {
                        "line_numbers": [
                            329,
                            330
                        ],
                        "comments": [],
                        "lines": [
                            "    strcpy(wbuffer() + len(), cstr);",
                            "    setLen(newlen);"
                        ]
                    },
                    {
                        "line_numbers": [
                            334,
                            335
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(const char *cstr) {",
                            "    if(!cstr)"
                        ]
                    },
                    {
                        "line_numbers": [
                            340
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(char c) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            347
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(unsigned char num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            349
                        ],
                        "comments": [],
                        "lines": [
                            "    sprintf(buf, \"%d\", num);"
                        ]
                    },
                    {
                        "line_numbers": [
                            353
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(int num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            355
                        ],
                        "comments": [],
                        "lines": [
                            "    sprintf(buf, \"%d\", num);"
                        ]
                    },
                    {
                        "line_numbers": [
                            359
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(unsigned int num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            365
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(long num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            367
                        ],
                        "comments": [],
                        "lines": [
                            "    sprintf(buf, \"%ld\", num);"
                        ]
                    },
                    {
                        "line_numbers": [
                            371
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(unsigned long num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            377
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(float num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            383
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(double num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::concat(const __FlashStringHelper * str) {",
                            "    if (!str) return 0;",
                            "    int length = strlen_P((PGM_P)str);",
                            "    if (length == 0) return 1;",
                            "    unsigned int newlen = len() + length;",
                            "    if (!reserve(newlen)) return 0;",
                            "    strcpy_P(wbuffer() + len(), (PGM_P)str);",
                            "    setLen(newlen);",
                            "    return 1;"
                        ]
                    },
                    {
                        "line_numbers": [
                            404
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            406
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(rhs.buffer(), rhs.len()))"
                        ]
                    },
                    {
                        "line_numbers": [
                            411
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            413
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!cstr || !a.concat(cstr, strlen(cstr)))"
                        ]
                    },
                    {
                        "line_numbers": [
                            418
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, char c) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            420
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(c))"
                        ]
                    },
                    {
                        "line_numbers": [
                            425
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            427
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(num))"
                        ]
                    },
                    {
                        "line_numbers": [
                            432
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, int num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            434
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(num))"
                        ]
                    },
                    {
                        "line_numbers": [
                            439
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            441
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(num))"
                        ]
                    },
                    {
                        "line_numbers": [
                            446
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, long num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            448
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(num))"
                        ]
                    },
                    {
                        "line_numbers": [
                            453
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            455
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(num))"
                        ]
                    },
                    {
                        "line_numbers": [
                            460
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, float num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            462
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(num))"
                        ]
                    },
                    {
                        "line_numbers": [
                            467
                        ],
                        "comments": [],
                        "lines": [
                            "StringSumHelper & operator +(const StringSumHelper &lhs, double num) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            469
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!a.concat(num))"
                        ]
                    },
                    {
                        "line_numbers": [
                            477,
                            478
                        ],
                        "comments": [],
                        "lines": [
                            "    if (!a.concat(rhs))",
                            "        a.invalidate();"
                        ]
                    },
                    {
                        "line_numbers": [
                            486,
                            487,
                            488,
                            489,
                            490,
                            491
                        ],
                        "comments": [],
                        "lines": [
                            "int String::compareTo(const String &s) const {",
                            "    if(!buffer() || !s.buffer()) {",
                            "        if(s.buffer() && s.len() > 0)",
                            "            return 0 - *(unsigned char *) s.buffer();",
                            "        if(buffer() && len() > 0)",
                            "            return *(unsigned char *) buffer();"
                        ]
                    },
                    {
                        "line_numbers": [
                            494
                        ],
                        "comments": [],
                        "lines": [
                            "    return strcmp(buffer(), s.buffer());"
                        ]
                    },
                    {
                        "line_numbers": [
                            497,
                            498
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::equals(const String &s2) const {",
                            "    return (len() == s2.len() && compareTo(s2) == 0);"
                        ]
                    },
                    {
                        "line_numbers": [
                            501,
                            502
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::equals(const char *cstr) const {",
                            "    if(len() == 0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            504,
                            505,
                            506
                        ],
                        "comments": [],
                        "lines": [
                            "    if(cstr == NULL)",
                            "        return buffer()[0] == 0;",
                            "    return strcmp(buffer(), cstr) == 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            509
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::operator<(const String &rhs) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            513
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::operator>(const String &rhs) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            517
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::operator<=(const String &rhs) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            521
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::operator>=(const String &rhs) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            525,
                            526
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::equalsIgnoreCase(const String &s2) const {",
                            "    if(this == &s2)"
                        ]
                    },
                    {
                        "line_numbers": [
                            528
                        ],
                        "comments": [],
                        "lines": [
                            "    if(len() != s2.len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            530
                        ],
                        "comments": [],
                        "lines": [
                            "    if(len() == 0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            532,
                            533
                        ],
                        "comments": [],
                        "lines": [
                            "    const char *p1 = buffer();",
                            "    const char *p2 = s2.buffer();"
                        ]
                    },
                    {
                        "line_numbers": [
                            535
                        ],
                        "comments": [],
                        "lines": [
                            "        if(tolower(*p1++) != tolower(*p2++))"
                        ]
                    },
                    {
                        "line_numbers": [
                            541,
                            542,
                            543,
                            544
                        ],
                        "comments": [
                            "    // To avoid possible time-based attacks present function",
                            "    // compares given strings in a constant time."
                        ],
                        "lines": [
                            "unsigned char String::equalsConstantTime(const String &s2) const {",
                            "    if(len() != s2.len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560
                        ],
                        "comments": [],
                        "lines": [
                            "    //at this point lengths are the same",
                            "    if(len() == 0)",
                            "        return 1;",
                            "    //at this point lenghts are the same and non-zero",
                            "    const char *p1 = buffer();",
                            "    const char *p2 = s2.buffer();",
                            "    unsigned int equalchars = 0;",
                            "    unsigned int diffchars = 0;",
                            "    while(*p1) {",
                            "        if(*p1 == *p2)",
                            "            ++equalchars;",
                            "        else",
                            "            ++diffchars;",
                            "        ++p1;",
                            "        ++p2;"
                        ]
                    },
                    {
                        "line_numbers": [
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570
                        ],
                        "comments": [],
                        "lines": [
                            "    //the following should force a constant time eval of the condition without a compiler \"logical shortcut\"",
                            "    unsigned char equalcond = (equalchars == len());",
                            "    unsigned char diffcond = (diffchars == 0);",
                            "    return (equalcond & diffcond); //bitwise AND",
                            "}",
                            "",
                            "unsigned char String::startsWith(const String &s2) const {",
                            "    if(len() < s2.len())",
                            "        return 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            574,
                            575
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::startsWith(const String &s2, unsigned int offset) const {",
                            "    if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())"
                        ]
                    },
                    {
                        "line_numbers": [
                            577
                        ],
                        "comments": [],
                        "lines": [
                            "    return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            580,
                            581
                        ],
                        "comments": [],
                        "lines": [
                            "unsigned char String::endsWith(const String &s2) const {",
                            "    if(len() < s2.len() || !buffer() || !s2.buffer())"
                        ]
                    },
                    {
                        "line_numbers": [
                            583
                        ],
                        "comments": [],
                        "lines": [
                            "    return strcmp(&buffer()[len() - s2.len()], s2.buffer()) == 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            590
                        ],
                        "comments": [],
                        "lines": [
                            "char String::charAt(unsigned int loc) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            594,
                            595,
                            596
                        ],
                        "comments": [],
                        "lines": [
                            "void String::setCharAt(unsigned int loc, char c) {",
                            "    if(loc < len())",
                            "        wbuffer()[loc] = c;"
                        ]
                    },
                    {
                        "line_numbers": [
                            599
                        ],
                        "comments": [],
                        "lines": [
                            "char & String::operator[](unsigned int index) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            601
                        ],
                        "comments": [],
                        "lines": [
                            "    if(index >= len() || !buffer()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            605
                        ],
                        "comments": [],
                        "lines": [
                            "    return wbuffer()[index];"
                        ]
                    },
                    {
                        "line_numbers": [
                            608,
                            609
                        ],
                        "comments": [],
                        "lines": [
                            "char String::operator[](unsigned int index) const {",
                            "    if(index >= len() || !buffer())"
                        ]
                    },
                    {
                        "line_numbers": [
                            611
                        ],
                        "comments": [],
                        "lines": [
                            "    return buffer()[index];"
                        ]
                    },
                    {
                        "line_numbers": [
                            614,
                            615
                        ],
                        "comments": [],
                        "lines": [
                            "void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {",
                            "    if(!bufsize || !buf)"
                        ]
                    },
                    {
                        "line_numbers": [
                            617
                        ],
                        "comments": [],
                        "lines": [
                            "    if(index >= len()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            622,
                            623,
                            624
                        ],
                        "comments": [],
                        "lines": [
                            "    if(n > len() - index)",
                            "        n = len() - index;",
                            "    strncpy((char *) buf, buffer() + index, n);"
                        ]
                    },
                    {
                        "line_numbers": [
                            632
                        ],
                        "comments": [],
                        "lines": [
                            "int String::indexOf(char c) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            636,
                            637
                        ],
                        "comments": [],
                        "lines": [
                            "int String::indexOf(char ch, unsigned int fromIndex) const {",
                            "    if(fromIndex >= len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            639,
                            640
                        ],
                        "comments": [],
                        "lines": [
                            "    const char* temp = strchr(buffer() + fromIndex, ch);",
                            "    if(temp == NULL)"
                        ]
                    },
                    {
                        "line_numbers": [
                            642
                        ],
                        "comments": [],
                        "lines": [
                            "    return temp - buffer();"
                        ]
                    },
                    {
                        "line_numbers": [
                            645
                        ],
                        "comments": [],
                        "lines": [
                            "int String::indexOf(const String &s2) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            649,
                            650
                        ],
                        "comments": [],
                        "lines": [
                            "int String::indexOf(const String &s2, unsigned int fromIndex) const {",
                            "    if(fromIndex >= len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            652,
                            653
                        ],
                        "comments": [],
                        "lines": [
                            "    const char *found = strstr(buffer() + fromIndex, s2.buffer());",
                            "    if(found == NULL)"
                        ]
                    },
                    {
                        "line_numbers": [
                            655
                        ],
                        "comments": [],
                        "lines": [
                            "    return found - buffer();"
                        ]
                    },
                    {
                        "line_numbers": [
                            658,
                            659
                        ],
                        "comments": [],
                        "lines": [
                            "int String::lastIndexOf(char theChar) const {",
                            "    return lastIndexOf(theChar, len() - 1);"
                        ]
                    },
                    {
                        "line_numbers": [
                            662,
                            663
                        ],
                        "comments": [],
                        "lines": [
                            "int String::lastIndexOf(char ch, unsigned int fromIndex) const {",
                            "    if(fromIndex >= len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            665,
                            666,
                            667,
                            668,
                            669
                        ],
                        "comments": [],
                        "lines": [
                            "    char tempchar = buffer()[fromIndex + 1];",
                            "    wbuffer()[fromIndex + 1] = '\\0';",
                            "    char* temp = strrchr(wbuffer(), ch);",
                            "    wbuffer()[fromIndex + 1] = tempchar;",
                            "    if(temp == NULL)"
                        ]
                    },
                    {
                        "line_numbers": [
                            671
                        ],
                        "comments": [],
                        "lines": [
                            "    return temp - buffer();"
                        ]
                    },
                    {
                        "line_numbers": [
                            674,
                            675
                        ],
                        "comments": [],
                        "lines": [
                            "int String::lastIndexOf(const String &s2) const {",
                            "    return lastIndexOf(s2, len() - s2.len());"
                        ]
                    },
                    {
                        "line_numbers": [
                            678,
                            679
                        ],
                        "comments": [],
                        "lines": [
                            "int String::lastIndexOf(const String &s2, unsigned int fromIndex) const {",
                            "    if(s2.len() == 0 || len() == 0 || s2.len() > len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            681,
                            682
                        ],
                        "comments": [],
                        "lines": [
                            "    if(fromIndex >= len())",
                            "        fromIndex = len() - 1;"
                        ]
                    },
                    {
                        "line_numbers": [
                            684,
                            685,
                            686
                        ],
                        "comments": [],
                        "lines": [
                            "    for(char *p = wbuffer(); p <= wbuffer() + fromIndex; p++) {",
                            "        p = strstr(p, s2.buffer());",
                            "        if(!p)"
                        ]
                    },
                    {
                        "line_numbers": [
                            688,
                            689
                        ],
                        "comments": [],
                        "lines": [
                            "        if((unsigned int) (p - wbuffer()) <= fromIndex)",
                            "            found = p - buffer();"
                        ]
                    },
                    {
                        "line_numbers": [
                            694
                        ],
                        "comments": [],
                        "lines": [
                            "String String::substring(unsigned int left, unsigned int right) const {"
                        ]
                    },
                    {
                        "line_numbers": [
                            701
                        ],
                        "comments": [],
                        "lines": [
                            "    if(left >= len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            703,
                            704,
                            705,
                            706,
                            707,
                            708
                        ],
                        "comments": [
                            "    char temp = buffer()[right];  // save the replaced character",
                            "    out = wbuffer() + left;  // pointer arithmetic"
                        ],
                        "lines": [
                            "    if(right > len())",
                            "        right = len();",
                            "    wbuffer()[right] = '\\0';",
                            "    wbuffer()[right] = temp;  //restore character"
                        ]
                    },
                    {
                        "line_numbers": [
                            716,
                            717
                        ],
                        "comments": [],
                        "lines": [
                            "void String::replace(char find, char replace) {",
                            "    if(!buffer())"
                        ]
                    },
                    {
                        "line_numbers": [
                            719,
                            720
                        ],
                        "comments": [],
                        "lines": [
                            "    for(char *p = wbuffer(); *p; p++) {",
                            "        if(*p == find)"
                        ]
                    },
                    {
                        "line_numbers": [
                            725,
                            726
                        ],
                        "comments": [],
                        "lines": [
                            "void String::replace(const String& find, const String& replace) {",
                            "    if(len() == 0 || find.len() == 0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            728,
                            729
                        ],
                        "comments": [],
                        "lines": [
                            "    int diff = replace.len() - find.len();",
                            "    char *readFrom = wbuffer();"
                        ]
                    },
                    {
                        "line_numbers": [
                            732,
                            733,
                            734
                        ],
                        "comments": [],
                        "lines": [
                            "        while((foundAt = strstr(readFrom, find.buffer())) != NULL) {",
                            "            memmove(foundAt, replace.buffer(), replace.len());",
                            "            readFrom = foundAt + replace.len();"
                        ]
                    },
                    {
                        "line_numbers": [
                            737,
                            738
                        ],
                        "comments": [],
                        "lines": [
                            "        char *writeTo = wbuffer();",
                            "        while((foundAt = strstr(readFrom, find.buffer())) != NULL) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            740
                        ],
                        "comments": [],
                        "lines": [
                            "            memmove(writeTo, readFrom, n);"
                        ]
                    },
                    {
                        "line_numbers": [
                            742,
                            743,
                            744,
                            745
                        ],
                        "comments": [],
                        "lines": [
                            "            memmove(writeTo, replace.buffer(), replace.len());",
                            "            writeTo += replace.len();",
                            "            readFrom = foundAt + find.len();",
                            "            setLen(len() + diff);"
                        ]
                    },
                    {
                        "line_numbers": [
                            747
                        ],
                        "comments": [],
                        "lines": [
                            "        memmove(writeTo, readFrom, strlen(readFrom)+1);"
                        ]
                    },
                    {
                        "line_numbers": [
                            750,
                            751
                        ],
                        "comments": [],
                        "lines": [
                            "        while((foundAt = strstr(readFrom, find.buffer())) != NULL) {",
                            "            readFrom = foundAt + find.len();"
                        ]
                    },
                    {
                        "line_numbers": [
                            754
                        ],
                        "comments": [],
                        "lines": [
                            "        if(size == len())"
                        ]
                    },
                    {
                        "line_numbers": [
                            756,
                            757,
                            758
                        ],
                        "comments": [
                            "            return; // XXX: tell user!"
                        ],
                        "lines": [
                            "        if(size > capacity() && !changeBuffer(size))",
                            "        int index = len() - 1;"
                        ]
                    },
                    {
                        "line_numbers": [
                            760,
                            761,
                            762,
                            763,
                            764,
                            765
                        ],
                        "comments": [],
                        "lines": [
                            "            readFrom = wbuffer() + index + find.len();",
                            "            memmove(readFrom + diff, readFrom, len() - (readFrom - buffer()));",
                            "\t    int newLen = len() + diff;",
                            "            memmove(wbuffer() + index, replace.buffer(), replace.len());",
                            "            setLen(newLen);",
                            "            wbuffer()[newLen] = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            771
                        ],
                        "comments": [],
                        "lines": [
                            "void String::remove(unsigned int index) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            778,
                            779
                        ],
                        "comments": [],
                        "lines": [
                            "void String::remove(unsigned int index, unsigned int count) {",
                            "    if(index >= len()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            785,
                            786
                        ],
                        "comments": [],
                        "lines": [
                            "    if(count > len() - index) {",
                            "        count = len() - index;"
                        ]
                    },
                    {
                        "line_numbers": [
                            788,
                            789,
                            790,
                            791,
                            792
                        ],
                        "comments": [],
                        "lines": [
                            "    char *writeTo = wbuffer() + index;",
                            "    unsigned int newlen = len() - count;",
                            "    setLen(newlen);",
                            "    memmove(writeTo, wbuffer() + index + count, newlen - index);",
                            "    wbuffer()[newlen] = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            795,
                            796
                        ],
                        "comments": [],
                        "lines": [
                            "void String::toLowerCase(void) {",
                            "    if(!buffer())"
                        ]
                    },
                    {
                        "line_numbers": [
                            798
                        ],
                        "comments": [],
                        "lines": [
                            "    for(char *p = wbuffer(); *p; p++) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            803,
                            804
                        ],
                        "comments": [],
                        "lines": [
                            "void String::toUpperCase(void) {",
                            "    if(!buffer())"
                        ]
                    },
                    {
                        "line_numbers": [
                            806
                        ],
                        "comments": [],
                        "lines": [
                            "    for(char *p = wbuffer(); *p; p++) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            811,
                            812
                        ],
                        "comments": [],
                        "lines": [
                            "void String::trim(void) {",
                            "    if(!buffer() || len() == 0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            814,
                            815
                        ],
                        "comments": [],
                        "lines": [
                            "    char *begin = wbuffer();",
                            "    while(isspace(*begin))"
                        ]
                    },
                    {
                        "line_numbers": [
                            817,
                            818
                        ],
                        "comments": [],
                        "lines": [
                            "    char *end = wbuffer() + len() - 1;",
                            "    while(isspace(*end) && end >= begin)"
                        ]
                    },
                    {
                        "line_numbers": [
                            820,
                            821,
                            822,
                            823,
                            824
                        ],
                        "comments": [],
                        "lines": [
                            "    unsigned int newlen = end + 1 - begin;",
                            "    setLen(newlen);",
                            "    if(begin > buffer())",
                            "        memmove(wbuffer(), begin, newlen);",
                            "    wbuffer()[newlen] = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            831,
                            832,
                            833
                        ],
                        "comments": [],
                        "lines": [
                            "long String::toInt(void) const {",
                            "    if (buffer())",
                            "        return atol(buffer());"
                        ]
                    },
                    {
                        "line_numbers": [
                            837,
                            838,
                            839
                        ],
                        "comments": [],
                        "lines": [
                            "float String::toFloat(void) const {",
                            "    if (buffer())",
                            "        return atof(buffer());"
                        ]
                    },
                    {
                        "line_numbers": [
                            843,
                            844,
                            845,
                            846,
                            847
                        ],
                        "comments": [],
                        "lines": [
                            "double String::toDouble(void) const",
                            "{",
                            "    if (buffer())",
                            "        return atof(buffer());",
                            "    return 0.0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            851,
                            852
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "const String emptyString;"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            728,
                            729,
                            730,
                            731
                        ],
                        "comments": [
                            "    char temp = buffer[right];  // save the replaced character",
                            "    out = buffer + left;  // pointer arithmetic"
                        ],
                        "lines": [
                            "    buffer[right] = '\\0';",
                            "    buffer[right] = temp;  //restore character"
                        ]
                    },
                    {
                        "line_numbers": [
                            739,
                            740,
                            741
                        ],
                        "comments": [],
                        "lines": [
                            "void String::replace(char find, char replace)",
                            "{",
                            "    if(!buffer) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            743,
                            744,
                            745
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "    for(char *p = buffer; *p; p++) {",
                            "        if(*p == find) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            747
                        ],
                        "comments": [],
                        "lines": [
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            751,
                            752,
                            753
                        ],
                        "comments": [],
                        "lines": [
                            "void String::replace(const String& find, const String& replace)",
                            "{",
                            "    if(len == 0 || find.len == 0) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            755,
                            756,
                            757
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "    int diff = replace.len - find.len;",
                            "    char *readFrom = buffer;"
                        ]
                    },
                    {
                        "line_numbers": [
                            760,
                            761,
                            762
                        ],
                        "comments": [],
                        "lines": [
                            "        while((foundAt = strstr(readFrom, find.buffer)) != NULL) {",
                            "            memcpy(foundAt, replace.buffer, replace.len);",
                            "            readFrom = foundAt + replace.len;"
                        ]
                    },
                    {
                        "line_numbers": [
                            765,
                            766
                        ],
                        "comments": [],
                        "lines": [
                            "        char *writeTo = buffer;",
                            "        while((foundAt = strstr(readFrom, find.buffer)) != NULL) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            768
                        ],
                        "comments": [],
                        "lines": [
                            "            memcpy(writeTo, readFrom, n);"
                        ]
                    },
                    {
                        "line_numbers": [
                            770,
                            771,
                            772,
                            773
                        ],
                        "comments": [],
                        "lines": [
                            "            memcpy(writeTo, replace.buffer, replace.len);",
                            "            writeTo += replace.len;",
                            "            readFrom = foundAt + find.len;",
                            "            len += diff;"
                        ]
                    },
                    {
                        "line_numbers": [
                            775
                        ],
                        "comments": [],
                        "lines": [
                            "        strcpy(writeTo, readFrom);"
                        ]
                    },
                    {
                        "line_numbers": [
                            778,
                            779
                        ],
                        "comments": [],
                        "lines": [
                            "        while((foundAt = strstr(readFrom, find.buffer)) != NULL) {",
                            "            readFrom = foundAt + find.len;"
                        ]
                    },
                    {
                        "line_numbers": [
                            782
                        ],
                        "comments": [],
                        "lines": [
                            "        if(size == len) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            784,
                            785,
                            786,
                            787,
                            788
                        ],
                        "comments": [
                            "            return;    // XXX: tell user!"
                        ],
                        "lines": [
                            "        }",
                            "        if(size > capacity && !changeBuffer(size)) {",
                            "        }",
                            "        int index = len - 1;"
                        ]
                    },
                    {
                        "line_numbers": [
                            790,
                            791,
                            792,
                            793,
                            794
                        ],
                        "comments": [],
                        "lines": [
                            "            readFrom = buffer + index + find.len;",
                            "            memmove(readFrom + diff, readFrom, len - (readFrom - buffer));",
                            "            len += diff;",
                            "            buffer[len] = 0;",
                            "            memcpy(buffer + index, replace.buffer, replace.len);"
                        ]
                    },
                    {
                        "line_numbers": [
                            800,
                            801
                        ],
                        "comments": [],
                        "lines": [
                            "void String::remove(unsigned int index)",
                            "{"
                        ]
                    },
                    {
                        "line_numbers": [
                            808,
                            809,
                            810
                        ],
                        "comments": [],
                        "lines": [
                            "void String::remove(unsigned int index, unsigned int count)",
                            "{",
                            "    if(index >= len) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            816,
                            817
                        ],
                        "comments": [],
                        "lines": [
                            "    if(count > len - index) {",
                            "        count = len - index;"
                        ]
                    },
                    {
                        "line_numbers": [
                            819,
                            820,
                            821,
                            822
                        ],
                        "comments": [],
                        "lines": [
                            "    char *writeTo = buffer + index;",
                            "    len = len - count;",
                            "    strncpy(writeTo, buffer + index + count, len - index);",
                            "    buffer[len] = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            825,
                            826,
                            827
                        ],
                        "comments": [],
                        "lines": [
                            "void String::toLowerCase(void)",
                            "{",
                            "    if(!buffer) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            829,
                            830
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "    for(char *p = buffer; *p; p++) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            835,
                            836,
                            837
                        ],
                        "comments": [],
                        "lines": [
                            "void String::toUpperCase(void)",
                            "{",
                            "    if(!buffer) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            839,
                            840
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "    for(char *p = buffer; *p; p++) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            845,
                            846,
                            847
                        ],
                        "comments": [],
                        "lines": [
                            "void String::trim(void)",
                            "{",
                            "    if(!buffer || len == 0) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            849,
                            850,
                            851
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "    char *begin = buffer;",
                            "    while(isspace(*begin)) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            853,
                            854,
                            855
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "    char *end = buffer + len - 1;",
                            "    while(isspace(*end) && end >= begin) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            857,
                            858,
                            859,
                            860,
                            861,
                            862
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "    len = end + 1 - begin;",
                            "    if(begin > buffer) {",
                            "        memcpy(buffer, begin, len);",
                            "    }",
                            "    buffer[len] = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            869,
                            870,
                            871,
                            872,
                            873
                        ],
                        "comments": [],
                        "lines": [
                            "long String::toInt(void) const",
                            "{",
                            "    if(buffer) {",
                            "        return atol(buffer);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            877,
                            878,
                            879,
                            880,
                            881
                        ],
                        "comments": [],
                        "lines": [
                            "float String::toFloat(void) const",
                            "{",
                            "    if(buffer) {",
                            "        return atof(buffer);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            885,
                            886,
                            887,
                            888,
                            889
                        ],
                        "comments": [],
                        "lines": [
                            "double String::toDouble(void) const {",
                            "    if (buffer) {",
                            "        return atof(buffer);",
                            "    }",
                            "    return 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            892,
                            893,
                            894,
                            895,
                            896,
                            897,
                            898,
                            899,
                            900,
                            901,
                            902,
                            903,
                            904,
                            905,
                            906,
                            907,
                            908,
                            909,
                            910,
                            911,
                            912,
                            913,
                            914,
                            915,
                            916,
                            917
                        ],
                        "comments": [
                            "    // To avoid possible time-based attacks present function",
                            "    // compares given strings in a constant time."
                        ],
                        "lines": [
                            "unsigned char String::equalsConstantTime(const String &s2) const {",
                            "    if(len != s2.len)",
                            "        return 0;",
                            "    //at this point lengths are the same",
                            "    if(len == 0)",
                            "        return 1;",
                            "    //at this point lenghts are the same and non-zero",
                            "    const char *p1 = buffer;",
                            "    const char *p2 = s2.buffer;",
                            "    unsigned int equalchars = 0;",
                            "    unsigned int diffchars = 0;",
                            "    while(*p1) {",
                            "        if(*p1 == *p2)",
                            "            ++equalchars;",
                            "        else",
                            "            ++diffchars;",
                            "        ++p1;",
                            "        ++p2;",
                            "    }",
                            "    //the following should force a constant time eval of the condition without a compiler \"logical shortcut\"",
                            "    unsigned char equalcond = (equalchars == len);",
                            "    unsigned char diffcond = (diffchars == 0);",
                            "    return (equalcond & diffcond); //bitwise AND",
                            "}"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "45": "    *this = pstr; // see operator =",
                "156": "    // Can we use SSO here to avoid allocation?",
                "159": "            // Already using SSO, nothing to do",
                "162": "        } else { // if bufptr && !sso()",
                "163": "            // Using bufptr, need to shrink into sso_buff",
                "172": "    // Fallthrough to normal allocator",
                "174": "    // Make sure we can fit newsize in the buffer",
                "181": "        size_t oldSize = capacity() + 1; // include NULL.",
                "183": "            // Copy the SSO buffer into allocated space",
                "192": "        setLen(oldLen); // Needed in case of SSO where len() never existed",
                "302": "    // Special case if we're concatting ourself (s += s;) since we may end up",
                "303": "    // realloc'ing the buffer and moving s.buffer in the method called",
                "542": "    // To avoid possible time-based attacks present function",
                "543": "    // compares given strings in a constant time.",
                "705": "    char temp = buffer()[right];  // save the replaced character",
                "707": "    out = wbuffer() + left;  // pointer arithmetic",
                "749": "        unsigned int size = len(); // compute size needed for result",
                "757": "            return; // XXX: tell user!",
                "850": "// global empty string to allow returning const String& with nothing"
            },
            "comment_deleted_diff": {
                "728": "    char temp = buffer[right];  // save the replaced character",
                "730": "    out = buffer + left;  // pointer arithmetic",
                "777": "        unsigned int size = len; // compute size needed for result",
                "786": "            return;    // XXX: tell user!",
                "893": "    // To avoid possible time-based attacks present function",
                "894": "    // compares given strings in a constant time."
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "fd089d8fd3a6b40c2b3741c70da2902222b6d61a",
            "timestamp": "2019-08-27T20:05:36+03:00",
            "author": "Earle F. Philhower, III",
            "commit_message": "Pull in ESP8266 String::replace() fixes, others (#3143)\n\nPull in bugfixes from the ESP8266 repo for problems in the SSO\r\nimplementation of replace().  See the following patches for full\r\ndetails:\r\n\r\nhttps://github.com/esp8266/Arduino/commit/54240d2cc51e8b134fc6dc583f5a2b21f19755d8#diff-8d9e71e16d437343017df828f0528f63\r\nhttps://github.com/esp8266/Arduino/commit/78a1a66e6dcd0437167869c363cd29160c35fe96#diff-8d9e71e16d437343017df828f0528f63\r\nhttps://github.com/esp8266/Arduino/commit/4e9358445a161939f7d8246fbc365a035693749a#diff-8d9e71e16d437343017df828f0528f63\r\n\r\nFixes #3140",
            "additions": 29,
            "deletions": 20,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            164,
                            165,
                            166
                        ],
                        "comments": [
                            "        } else { // if bufptr && !isSSO()",
                            "            // Using bufptr, need to shrink into sso.buff"
                        ],
                        "lines": [
                            "            char temp[sizeof(sso.buff)];"
                        ]
                    },
                    {
                        "line_numbers": [
                            169
                        ],
                        "comments": [],
                        "lines": [
                            "            uint16_t oldLen = len();"
                        ]
                    },
                    {
                        "line_numbers": [
                            171
                        ],
                        "comments": [],
                        "lines": [
                            "\t    setLen(oldLen);"
                        ]
                    },
                    {
                        "line_numbers": [
                            183,
                            184
                        ],
                        "comments": [],
                        "lines": [
                            "    char *newbuffer = (char *) realloc(isSSO() ? nullptr : wbuffer(), newSize);",
                            "    if (newbuffer) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            186
                        ],
                        "comments": [],
                        "lines": [
                            "        if (isSSO()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            188
                        ],
                        "comments": [],
                        "lines": [
                            "            memmove(newbuffer, sso.buff, sizeof(sso.buff));"
                        ]
                    },
                    {
                        "line_numbers": [
                            213
                        ],
                        "comments": [],
                        "lines": [
                            "    memmove(wbuffer(), cstr, length + 1);"
                        ]
                    },
                    {
                        "line_numbers": [
                            231
                        ],
                        "comments": [],
                        "lines": [
                            "            memmove(wbuffer(), rhs.buffer(), rhs.length() + 1);"
                        ]
                    },
                    {
                        "line_numbers": [
                            236
                        ],
                        "comments": [],
                        "lines": [
                            "            if (!isSSO()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            242
                        ],
                        "comments": [],
                        "lines": [
                            "    if (rhs.isSSO()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            244
                        ],
                        "comments": [],
                        "lines": [
                            "        memmove(sso.buff, rhs.sso.buff, sizeof(sso.buff));"
                        ]
                    },
                    {
                        "line_numbers": [
                            316
                        ],
                        "comments": [],
                        "lines": [
                            "        memmove(wbuffer() + len(), buffer(), len());"
                        ]
                    },
                    {
                        "line_numbers": [
                            333,
                            334,
                            335,
                            336,
                            337,
                            338
                        ],
                        "comments": [
                            "        // compatible with SSO in ram #6155 (case \"x += x.c_str()\")",
                            "        // compatible with source in flash #6367"
                        ],
                        "lines": [
                            "    if (cstr >= wbuffer() && cstr < wbuffer() + len())",
                            "        memmove(wbuffer() + len(), cstr, length + 1);",
                            "    else",
                            "        memcpy_P(wbuffer() + len(), cstr, length + 1);"
                        ]
                    },
                    {
                        "line_numbers": [
                            404
                        ],
                        "comments": [],
                        "lines": [
                            "    memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            162,
                            163,
                            164
                        ],
                        "comments": [
                            "        } else { // if bufptr && !sso()",
                            "            // Using bufptr, need to shrink into sso_buff"
                        ],
                        "lines": [
                            "            char temp[sizeof(sso_buf)];"
                        ]
                    },
                    {
                        "line_numbers": [
                            179,
                            180
                        ],
                        "comments": [],
                        "lines": [
                            "    char *newbuffer = (char *) realloc(sso() ? nullptr : wbuffer(), newSize);",
                            "    if(newbuffer) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            182
                        ],
                        "comments": [],
                        "lines": [
                            "        if (sso()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            184
                        ],
                        "comments": [],
                        "lines": [
                            "            memcpy(newbuffer, sso_buf, sizeof(sso_buf));"
                        ]
                    },
                    {
                        "line_numbers": [
                            209
                        ],
                        "comments": [],
                        "lines": [
                            "    strcpy(wbuffer(), cstr);"
                        ]
                    },
                    {
                        "line_numbers": [
                            219
                        ],
                        "comments": [],
                        "lines": [
                            "    strcpy_P(wbuffer(), (PGM_P)pstr);"
                        ]
                    },
                    {
                        "line_numbers": [
                            227
                        ],
                        "comments": [],
                        "lines": [
                            "            strcpy(wbuffer(), rhs.buffer());"
                        ]
                    },
                    {
                        "line_numbers": [
                            232
                        ],
                        "comments": [],
                        "lines": [
                            "            if (!sso()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            238
                        ],
                        "comments": [],
                        "lines": [
                            "    if (rhs.sso()) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            240
                        ],
                        "comments": [],
                        "lines": [
                            "        memmove(sso_buf, rhs.sso_buf, sizeof(sso_buf));"
                        ]
                    },
                    {
                        "line_numbers": [
                            312
                        ],
                        "comments": [],
                        "lines": [
                            "        memcpy(wbuffer() + len(), buffer(), len());"
                        ]
                    },
                    {
                        "line_numbers": [
                            329
                        ],
                        "comments": [],
                        "lines": [
                            "    strcpy(wbuffer() + len(), cstr);"
                        ]
                    },
                    {
                        "line_numbers": [
                            395
                        ],
                        "comments": [],
                        "lines": [
                            "    strcpy_P(wbuffer() + len(), (PGM_P)str);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "164": "        } else { // if bufptr && !isSSO()",
                "165": "            // Using bufptr, need to shrink into sso.buff",
                "223": "    memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here",
                "334": "        // compatible with SSO in ram #6155 (case \"x += x.c_str()\")",
                "337": "        // compatible with source in flash #6367"
            },
            "comment_deleted_diff": {
                "162": "        } else { // if bufptr && !sso()",
                "163": "            // Using bufptr, need to shrink into sso_buff"
            },
            "comment_modified_diff": {}
        }
    ],
    "WString.h": [],
    "base64.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 65,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65
                        ],
                        "comments": [
                            "    // base64 needs more size then the source data"
                        ],
                        "lines": [
                            "    size_t size = ((length * 1.6f) + 1);",
                            "    char * buffer = (char *) malloc(size);",
                            "    if(buffer) {",
                            "        base64_encodestate _state;",
                            "        base64_init_encodestate(&_state);",
                            "        int len = base64_encode_block((const char *) &data[0], length, &buffer[0], &_state);",
                            "        len = base64_encode_blockend((buffer + len), &_state);",
                            "",
                            "        String base64 = String(buffer);",
                            "        free(buffer);",
                            "        return base64;",
                            "    }",
                            "    return String(\"-FAIL-\");",
                            "}",
                            "",
                            "/**",
                            " * convert input data to base64",
                            " * @param text String",
                            " * @return String",
                            " */",
                            "String base64::encode(String text)",
                            "{",
                            "    return base64::encode((uint8_t *) text.c_str(), text.length());",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "40": "    // base64 needs more size then the source data"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "c92b61739743e6df0768bbcba1e0b53755ec91d8",
            "timestamp": "2018-04-16T16:34:39+02:00",
            "author": "Craig Leres",
            "commit_message": "Convert the few remaining cr/lf files to use lf for eol. (#1316)\n\nIf you develop on windows and need cr/lf files, see this:\r\n\r\n    https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_formatting_and_whitespace\r\n\r\n    Git can handle this by auto-converting CRLF line endings into LF\r\n    when you add a file to the index, and vice versa when it checks out\r\n    code onto your filesystem. You can turn on this functionality with\r\n    the core.autocrlf setting. If you're on a Windows machine, set it\r\n    to true - this converts LF endings into CRLF when you check out code:\r\n\r\n    $ git config --global core.autocrlf true",
            "additions": 65,
            "deletions": 65,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65
                        ],
                        "comments": [
                            "    // base64 needs more size then the source data"
                        ],
                        "lines": [
                            "    size_t size = ((length * 1.6f) + 1);",
                            "    char * buffer = (char *) malloc(size);",
                            "    if(buffer) {",
                            "        base64_encodestate _state;",
                            "        base64_init_encodestate(&_state);",
                            "        int len = base64_encode_block((const char *) &data[0], length, &buffer[0], &_state);",
                            "        len = base64_encode_blockend((buffer + len), &_state);",
                            "",
                            "        String base64 = String(buffer);",
                            "        free(buffer);",
                            "        return base64;",
                            "    }",
                            "    return String(\"-FAIL-\");",
                            "}",
                            "",
                            "/**",
                            " * convert input data to base64",
                            " * @param text String",
                            " * @return String",
                            " */",
                            "String base64::encode(String text)",
                            "{",
                            "    return base64::encode((uint8_t *) text.c_str(), text.length());",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65
                        ],
                        "comments": [
                            "    // base64 needs more size then the source data"
                        ],
                        "lines": [
                            "    size_t size = ((length * 1.6f) + 1);",
                            "    char * buffer = (char *) malloc(size);",
                            "    if(buffer) {",
                            "        base64_encodestate _state;",
                            "        base64_init_encodestate(&_state);",
                            "        int len = base64_encode_block((const char *) &data[0], length, &buffer[0], &_state);",
                            "        len = base64_encode_blockend((buffer + len), &_state);",
                            "",
                            "        String base64 = String(buffer);",
                            "        free(buffer);",
                            "        return base64;",
                            "    }",
                            "    return String(\"-FAIL-\");",
                            "}",
                            "",
                            "/**",
                            " * convert input data to base64",
                            " * @param text String",
                            " * @return String",
                            " */",
                            "String base64::encode(String text)",
                            "{",
                            "    return base64::encode((uint8_t *) text.c_str(), text.length());",
                            "}",
                            ""
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "40": "    // base64 needs more size then the source data"
            },
            "comment_deleted_diff": {
                "40": "    // base64 needs more size then the source data"
            },
            "comment_modified_diff": {
                "40": "    // base64 needs more size then the source data"
            }
        },
        {
            "commit": "259ff80d603d70c106d09f83e4e8518f6140777a",
            "timestamp": "2018-11-19T17:01:38+01:00",
            "author": "Marcel Kottmann",
            "commit_message": "use libbase64 macro to calculate base64 length (#2007)",
            "additions": 1,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            40,
                            41
                        ],
                        "comments": [
                            "    // base64 needs more size then the source data"
                        ],
                        "lines": [
                            "    size_t size = ((length * 1.6f) + 1);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "40": "    // base64 needs more size then the source data"
            },
            "comment_modified_diff": {}
        }
    ],
    "base64.h": [],
    "binary.h": [],
    "cbuf.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 196,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196
                        ],
                        "comments": [
                            "    // not lose any data",
                            "    // if data can be lost use remove or flush before resize"
                        ],
                        "lines": [
                            "    if((newSize < bytes_available) || (newSize == _size)) {",
                            "        return _size;",
                            "    }",
                            "",
                            "    char *newbuf = new char[newSize];",
                            "    char *oldbuf = _buf;",
                            "",
                            "    if(!newbuf) {",
                            "        return _size;",
                            "    }",
                            "",
                            "    if(_buf) {",
                            "        read(newbuf, bytes_available);",
                            "        memset((newbuf + bytes_available), 0x00, (newSize - bytes_available));",
                            "    }",
                            "",
                            "    _begin = newbuf;",
                            "    _end = newbuf + bytes_available;",
                            "    _bufend = newbuf + newSize;",
                            "    _size = newSize;",
                            "",
                            "    _buf = newbuf;",
                            "    delete[] oldbuf;",
                            "",
                            "    return _size;",
                            "}",
                            "",
                            "size_t cbuf::available() const",
                            "{",
                            "    if(_end >= _begin) {",
                            "        return _end - _begin;",
                            "    }",
                            "    return _size - (_begin - _end);",
                            "}",
                            "",
                            "size_t cbuf::size()",
                            "{",
                            "    return _size;",
                            "}",
                            "",
                            "size_t cbuf::room() const",
                            "{",
                            "    if(_end >= _begin) {",
                            "        return _size - (_end - _begin) - 1;",
                            "    }",
                            "    return _begin - _end - 1;",
                            "}",
                            "",
                            "int cbuf::peek()",
                            "{",
                            "    if(empty()) {",
                            "        return -1;",
                            "    }",
                            "",
                            "    return static_cast<int>(*_begin);",
                            "}",
                            "",
                            "size_t cbuf::peek(char *dst, size_t size)",
                            "{",
                            "    size_t bytes_available = available();",
                            "    size_t size_to_read = (size < bytes_available) ? size : bytes_available;",
                            "    size_t size_read = size_to_read;",
                            "    char * begin = _begin;",
                            "    if(_end < _begin && size_to_read > (size_t) (_bufend - _begin)) {",
                            "        size_t top_size = _bufend - _begin;",
                            "        memcpy(dst, _begin, top_size);",
                            "        begin = _buf;",
                            "        size_to_read -= top_size;",
                            "        dst += top_size;",
                            "    }",
                            "    memcpy(dst, begin, size_to_read);",
                            "    return size_read;",
                            "}",
                            "",
                            "int cbuf::read()",
                            "{",
                            "    if(empty()) {",
                            "        return -1;",
                            "    }",
                            "",
                            "    char result = *_begin;",
                            "    _begin = wrap_if_bufend(_begin + 1);",
                            "    return static_cast<int>(result);",
                            "}",
                            "",
                            "size_t cbuf::read(char* dst, size_t size)",
                            "{",
                            "    size_t bytes_available = available();",
                            "    size_t size_to_read = (size < bytes_available) ? size : bytes_available;",
                            "    size_t size_read = size_to_read;",
                            "    if(_end < _begin && size_to_read > (size_t) (_bufend - _begin)) {",
                            "        size_t top_size = _bufend - _begin;",
                            "        memcpy(dst, _begin, top_size);",
                            "        _begin = _buf;",
                            "        size_to_read -= top_size;",
                            "        dst += top_size;",
                            "    }",
                            "    memcpy(dst, _begin, size_to_read);",
                            "    _begin = wrap_if_bufend(_begin + size_to_read);",
                            "    return size_read;",
                            "}",
                            "",
                            "size_t cbuf::write(char c)",
                            "{",
                            "    if(full()) {",
                            "        return 0;",
                            "    }",
                            "",
                            "    *_end = c;",
                            "    _end = wrap_if_bufend(_end + 1);",
                            "    return 1;",
                            "}",
                            "",
                            "size_t cbuf::write(const char* src, size_t size)",
                            "{",
                            "    size_t bytes_available = room();",
                            "    size_t size_to_write = (size < bytes_available) ? size : bytes_available;",
                            "    size_t size_written = size_to_write;",
                            "    if(_end >= _begin && size_to_write > (size_t) (_bufend - _end)) {",
                            "        size_t top_size = _bufend - _end;",
                            "        memcpy(_end, src, top_size);",
                            "        _end = _buf;",
                            "        size_to_write -= top_size;",
                            "        src += top_size;",
                            "    }",
                            "    memcpy(_end, src, size_to_write);",
                            "    _end = wrap_if_bufend(_end + size_to_write);",
                            "    return size_written;",
                            "}",
                            "",
                            "void cbuf::flush()",
                            "{",
                            "    _begin = _buf;",
                            "    _end = _buf;",
                            "}",
                            "",
                            "size_t cbuf::remove(size_t size)",
                            "{",
                            "    size_t bytes_available = available();",
                            "    if(size >= bytes_available) {",
                            "        flush();",
                            "        return 0;",
                            "    }",
                            "    size_t size_to_remove = (size < bytes_available) ? size : bytes_available;",
                            "    if(_end < _begin && size_to_remove > (size_t) (_bufend - _begin)) {",
                            "        size_t top_size = _bufend - _begin;",
                            "        _begin = _buf;",
                            "        size_to_remove -= top_size;",
                            "    }",
                            "    _begin = wrap_if_bufend(_begin + size_to_remove);",
                            "    return available();",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "43": "    // not lose any data",
                "44": "    // if data can be lost use remove or flush before resize"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "cbuf.h": [],
    "esp32-hal-gpio.c": [],
    "esp32-hal-gpio.h": [],
    "esp32-hal-i2c.c": [],
    "esp32-hal-i2c.h": [],
    "esp32-hal-log.h": [],
    "esp32-hal-matrix.c": [],
    "esp32-hal-matrix.h": [],
    "esp32-hal-misc.c": [],
    "esp32-hal-spi.c": [],
    "esp32-hal-spi.h": [],
    "esp32-hal-uart.c": [],
    "esp32-hal-uart.h": [],
    "esp32-hal.h": [],
    "AUTHORS": [],
    "LICENSE": [],
    "cdecode.c": [],
    "cdecode.h": [],
    "cencode.c": [],
    "cencode.h": [],
    "main.cpp": [],
    "pgmspace.h": [],
    "stdlib_noniso.h": [],
    "wiring_private.h": [],
    "keywords.txt": [],
    "library.properties": [],
    "SPI.cpp": [
        {
            "commit": "2eaf846134f0ed45331775876e91e619b916f533",
            "timestamp": "2017-07-31T22:50:57+03:00",
            "author": "Glen McGillan",
            "commit_message": "Spi pattern fix (#502)\n\n* Add files via upload\r\n\r\nCalls to writePattern() don't send the desired number of bytes when the pattern size doesn't divide evenly into the hardware FIFO size (e.g. sending 18-bit RGB data, 11 patterns take 63 bytes, so 1/64th of the data is never sent).\r\n\r\n* Add files via upload\r\n\r\nRemove white space changes.",
            "additions": 3,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            245
                        ],
                        "comments": [
                            "    const uint8_t max_bytes_FIFO = r * size;    // Max number of whole patterns (in bytes) that can fit into the hardware FIFO"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            248
                        ],
                        "comments": [],
                        "lines": [
                            "        if(byte > max_bytes_FIFO) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            250
                        ],
                        "comments": [],
                        "lines": [
                            "            byte -= max_bytes_FIFO;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "245": "    const uint8_t max_bytes_FIFO = r * size;    // Max number of whole patterns (in bytes) that can fit into the hardware FIFO"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "SPI.h": [],
    "HTTPSRequest.ino": [],
    "NTPClient.ino": [],
    "WiFiAccessPoint.ino": [],
    "WiFiClient.ino": [],
    "WiFiClientBasic.ino": [],
    "WiFiClientEvents.ino": [],
    "WiFiMulti.ino": [],
    "WiFiScan.ino": [],
    "WiFiTelnetToSerial.ino": [],
    "WiFiWebServer.ino": [],
    "WiFi.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 96,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------------- Debug ------------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * Output WiFi settings to an object derived from Print interface (like Serial).",
                            " * @param p Print interface",
                            " */",
                            "void WiFiClass::printDiag(Print& p)",
                            "{",
                            "    const char* modes[] = { \"NULL\", \"STA\", \"AP\", \"STA+AP\" };",
                            "",
                            "    wifi_mode_t mode;",
                            "    esp_wifi_get_mode(&mode);",
                            "",
                            "    uint8_t primaryChan;",
                            "    wifi_second_chan_t secondChan;",
                            "    esp_wifi_get_channel(&primaryChan, &secondChan);",
                            "",
                            "    bool autoConnect;",
                            "    esp_wifi_get_auto_connect(&autoConnect);",
                            "",
                            "    p.print(\"Mode: \");",
                            "    p.println(modes[mode]);",
                            "",
                            "    p.print(\"Channel: \");",
                            "    p.println(primaryChan);",
                            "    /*",
                            "        p.print(\"AP id: \");",
                            "        p.println(wifi_station_get_current_ap_id());",
                            "",
                            "        p.print(\"Status: \");",
                            "        p.println(wifi_station_get_connect_status());",
                            "    */",
                            "    p.print(\"Auto connect: \");",
                            "    p.println(autoConnect);",
                            "",
                            "    wifi_config_t conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &conf);",
                            "",
                            "    const char* ssid = reinterpret_cast<const char*>(conf.sta.ssid);",
                            "    p.print(\"SSID (\");",
                            "    p.print(strlen(ssid));",
                            "    p.print(\"): \");",
                            "    p.println(ssid);",
                            "",
                            "    const char* passphrase = reinterpret_cast<const char*>(conf.sta.password);",
                            "    p.print(\"Passphrase (\");",
                            "    p.print(strlen(passphrase));",
                            "    p.print(\"): \");",
                            "    p.println(passphrase);",
                            "",
                            "    p.print(\"BSSID set: \");",
                            "    p.println(conf.sta.bssid_set);",
                            "}",
                            "",
                            "WiFiClass WiFi;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "39": "// -----------------------------------------------------------------------------------------------------------------------",
                "40": "// ---------------------------------------------------------- Debug ------------------------------------------------------",
                "41": "// -----------------------------------------------------------------------------------------------------------------------"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "WiFi.h": [],
    "WiFiAP.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 234,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- Private functions ------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ----------------------------------------------------- AP function -----------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "        // enable AP failed",
                            "        // fail SSID too long or missing!",
                            "        // fail passphrase to long or short!",
                            "        // enable AP failed"
                        ],
                        "lines": [
                            "",
                            "static bool softap_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs);",
                            "",
                            "",
                            "",
                            "/**",
                            " * compare two AP configurations",
                            " * @param lhs softap_config",
                            " * @param rhs softap_config",
                            " * @return equal",
                            " */",
                            "static bool softap_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs)",
                            "{",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.ap.ssid), reinterpret_cast<const char*>(rhs.ap.ssid)) != 0) {",
                            "        return false;",
                            "    }",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.ap.password), reinterpret_cast<const char*>(rhs.ap.password)) != 0) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.channel != rhs.ap.channel) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.ssid_hidden != rhs.ap.ssid_hidden) {",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "",
                            "/**",
                            " * Set up an access point",
                            " * @param ssid          Pointer to the SSID (max 63 char).",
                            " * @param passphrase    (for WPA2 min 8 char, for open use NULL)",
                            " * @param channel       WiFi channel number, 1 - 13.",
                            " * @param ssid_hidden   Network cloaking (0 = broadcast SSID, 1 = hide SSID)",
                            " */",
                            "bool WiFiAPClass::softAP(const char* ssid, const char* passphrase, int channel, int ssid_hidden)",
                            "{",
                            "",
                            "    if(!WiFi.enableAP(true)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!ssid || *ssid == 0 || strlen(ssid) > 31) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && (strlen(passphrase) > 63 || strlen(passphrase) < 8)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_wifi_start();",
                            "",
                            "    wifi_config_t conf;",
                            "    strcpy(reinterpret_cast<char*>(conf.ap.ssid), ssid);",
                            "    conf.ap.channel = channel;",
                            "    conf.ap.ssid_len = strlen(ssid);",
                            "    conf.ap.ssid_hidden = ssid_hidden;",
                            "    conf.ap.max_connection = 4;",
                            "    conf.ap.beacon_interval = 100;",
                            "",
                            "    if(!passphrase || strlen(passphrase) == 0) {",
                            "        conf.ap.authmode = WIFI_AUTH_OPEN;",
                            "        *conf.ap.password = 0;",
                            "    } else {",
                            "        conf.ap.authmode = WIFI_AUTH_WPA2_PSK;",
                            "        strcpy(reinterpret_cast<char*>(conf.ap.password), passphrase);",
                            "    }",
                            "",
                            "    wifi_config_t conf_current;",
                            "    esp_wifi_get_config(WIFI_IF_AP, &conf_current);",
                            "    if(softap_config_equal(conf, conf_current)) {",
                            "        //DEBUGV(\"softap config unchanged\");",
                            "        return true;",
                            "    }",
                            "",
                            "    bool ret;",
                            "",
                            "    ret = esp_wifi_set_config(WIFI_IF_AP, &conf) == ESP_OK;",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Configure access point",
                            " * @param local_ip      access point IP",
                            " * @param gateway       gateway IP",
                            " * @param subnet        subnet mask",
                            " */",
                            "bool WiFiAPClass::softAPConfig(IPAddress local_ip, IPAddress gateway, IPAddress subnet)",
                            "{",
                            "",
                            "    if(!WiFi.enableAP(true)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    tcpip_adapter_ip_info_t info;",
                            "    info.ip.addr = static_cast<uint32_t>(local_ip);",
                            "    info.gw.addr = static_cast<uint32_t>(gateway);",
                            "    info.netmask.addr = static_cast<uint32_t>(subnet);",
                            "    tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP);",
                            "    if(tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_AP, &info)) {",
                            "        return tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP);",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "",
                            "",
                            "/**",
                            " * Disconnect from the network (close AP)",
                            " * @param wifioff disable mode?",
                            " * @return one value of wl_status_t enum",
                            " */",
                            "bool WiFiAPClass::softAPdisconnect(bool wifioff)",
                            "{",
                            "    bool ret;",
                            "    wifi_config_t conf;",
                            "    *conf.ap.ssid = 0;",
                            "    *conf.ap.password = 0;",
                            "    ret = esp_wifi_set_config(WIFI_IF_AP, &conf) == ESP_OK;",
                            "",
                            "    if(wifioff) {",
                            "        ret = WiFi.enableAP(false) == ESP_OK;",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the count of the Station / client that are connected to the softAP interface",
                            " * @return Stations count",
                            " */",
                            "uint8_t WiFiAPClass::softAPgetStationNum()",
                            "{",
                            "    uint16_t number;",
                            "    if(esp_wifi_get_ap_num(&number) == ESP_OK) {",
                            "        return number;",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface IP address.",
                            " * @return IPAddress softAP IP",
                            " */",
                            "IPAddress WiFiAPClass::softAPIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_AP, &ip);",
                            "    return IPAddress(ip.ip.addr);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the softAP interface MAC address.",
                            " * @param mac   pointer to uint8_t array with length WL_MAC_ADDR_LENGTH",
                            " * @return      pointer to uint8_t*",
                            " */",
                            "uint8_t* WiFiAPClass::softAPmacAddress(uint8_t* mac)",
                            "{",
                            "    esp_wifi_get_mac(WIFI_IF_AP, mac);",
                            "    return mac;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface MAC address.",
                            " * @return String mac",
                            " */",
                            "String WiFiAPClass::softAPmacAddress(void)",
                            "{",
                            "    uint8_t mac[6];",
                            "    char macStr[18] = { 0 };",
                            "    esp_wifi_get_mac(WIFI_IF_AP, mac);",
                            "",
                            "    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "    return String(macStr);",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "44": "// -----------------------------------------------------------------------------------------------------------------------",
                "45": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "46": "// -----------------------------------------------------------------------------------------------------------------------",
                "75": "// -----------------------------------------------------------------------------------------------------------------------",
                "76": "// ----------------------------------------------------- AP function -----------------------------------------------------",
                "77": "// -----------------------------------------------------------------------------------------------------------------------",
                "91": "        // enable AP failed",
                "96": "        // fail SSID too long or missing!",
                "101": "        // fail passphrase to long or short!",
                "148": "        // enable AP failed"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "f6a4b024c7d33a2057695decd2bbf68928b4fb05",
            "timestamp": "2018-04-06T19:02:21+03:00",
            "author": "Shawn A",
            "commit_message": "fixes #1249 (#1269)",
            "additions": 2,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            189
                        ],
                        "comments": [
                            "    conf.ap.authmode  = WIFI_AUTH_OPEN; // auth must be open if pass=0"
                        ],
                        "lines": []
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "189": "    conf.ap.authmode  = WIFI_AUTH_OPEN; // auth must be open if pass=0"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "c92b61739743e6df0768bbcba1e0b53755ec91d8",
            "timestamp": "2018-04-16T16:34:39+02:00",
            "author": "Craig Leres",
            "commit_message": "Convert the few remaining cr/lf files to use lf for eol. (#1316)\n\nIf you develop on windows and need cr/lf files, see this:\r\n\r\n    https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_formatting_and_whitespace\r\n\r\n    Git can handle this by auto-converting CRLF line endings into LF\r\n    when you add a file to the index, and vice versa when it checks out\r\n    code onto your filesystem. You can turn on this functionality with\r\n    the core.autocrlf setting. If you're on a Windows machine, set it\r\n    to true - this converts LF endings into CRLF when you check out code:\r\n\r\n    $ git config --global core.autocrlf true",
            "additions": 293,
            "deletions": 293,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- Private functions ------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ----------------------------------------------------- AP function -----------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "        // enable AP failed",
                            "        // fail SSID too long or missing!",
                            "        // fail passphrase to long or short!",
                            "        // enable AP failed",
                            "    conf.ap.authmode  = WIFI_AUTH_OPEN; // auth must be open if pass=0"
                        ],
                        "lines": [
                            "",
                            "static bool softap_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs);",
                            "",
                            "",
                            "",
                            "/**",
                            " * compare two AP configurations",
                            " * @param lhs softap_config",
                            " * @param rhs softap_config",
                            " * @return equal",
                            " */",
                            "static bool softap_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs)",
                            "{",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.ap.ssid), reinterpret_cast<const char*>(rhs.ap.ssid)) != 0) {",
                            "        return false;",
                            "    }",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.ap.password), reinterpret_cast<const char*>(rhs.ap.password)) != 0) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.channel != rhs.ap.channel) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.ssid_hidden != rhs.ap.ssid_hidden) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.max_connection != rhs.ap.max_connection) {",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "",
                            "/**",
                            " * Set up an access point",
                            " * @param ssid              Pointer to the SSID (max 63 char).",
                            " * @param passphrase        (for WPA2 min 8 char, for open use NULL)",
                            " * @param channel           WiFi channel number, 1 - 13.",
                            " * @param ssid_hidden       Network cloaking (0 = broadcast SSID, 1 = hide SSID)",
                            " * @param max_connection    Max simultaneous connected clients, 1 - 4.",
                            "*/",
                            "bool WiFiAPClass::softAP(const char* ssid, const char* passphrase, int channel, int ssid_hidden, int max_connection)",
                            "{",
                            "",
                            "    if(!WiFi.enableAP(true)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!ssid || *ssid == 0 || strlen(ssid) > 31) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && (strlen(passphrase) > 63 || strlen(passphrase) < 8)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_wifi_start();",
                            "",
                            "    wifi_config_t conf;",
                            "    strcpy(reinterpret_cast<char*>(conf.ap.ssid), ssid);",
                            "    conf.ap.channel = channel;",
                            "    conf.ap.ssid_len = strlen(ssid);",
                            "    conf.ap.ssid_hidden = ssid_hidden;",
                            "    conf.ap.max_connection = max_connection;",
                            "    conf.ap.beacon_interval = 100;",
                            "",
                            "    if(!passphrase || strlen(passphrase) == 0) {",
                            "        conf.ap.authmode = WIFI_AUTH_OPEN;",
                            "        *conf.ap.password = 0;",
                            "    } else {",
                            "        conf.ap.authmode = WIFI_AUTH_WPA2_PSK;",
                            "        strcpy(reinterpret_cast<char*>(conf.ap.password), passphrase);",
                            "    }",
                            "",
                            "    wifi_config_t conf_current;",
                            "    esp_wifi_get_config(WIFI_IF_AP, &conf_current);",
                            "    if(!softap_config_equal(conf, conf_current) && esp_wifi_set_config(WIFI_IF_AP, &conf) != ESP_OK) {",
                            "        return false;",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Configure access point",
                            " * @param local_ip      access point IP",
                            " * @param gateway       gateway IP",
                            " * @param subnet        subnet mask",
                            " */",
                            "bool WiFiAPClass::softAPConfig(IPAddress local_ip, IPAddress gateway, IPAddress subnet)",
                            "{",
                            "",
                            "    if(!WiFi.enableAP(true)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_wifi_start();",
                            "",
                            "    tcpip_adapter_ip_info_t info;",
                            "    info.ip.addr = static_cast<uint32_t>(local_ip);",
                            "    info.gw.addr = static_cast<uint32_t>(gateway);",
                            "    info.netmask.addr = static_cast<uint32_t>(subnet);",
                            "    tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP);",
                            "    if(tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_AP, &info) == ESP_OK) {",
                            "        dhcps_lease_t lease;",
                            "        lease.enable = true;",
                            "        lease.start_ip.addr = static_cast<uint32_t>(local_ip) + (1 << 24);",
                            "        lease.end_ip.addr = static_cast<uint32_t>(local_ip) + (11 << 24);",
                            "",
                            "        tcpip_adapter_dhcps_option(",
                            "            (tcpip_adapter_option_mode_t)TCPIP_ADAPTER_OP_SET,",
                            "            (tcpip_adapter_option_id_t)REQUESTED_IP_ADDRESS,",
                            "            (void*)&lease, sizeof(dhcps_lease_t)",
                            "        );",
                            "",
                            "        return tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP) == ESP_OK;",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "",
                            "",
                            "/**",
                            " * Disconnect from the network (close AP)",
                            " * @param wifioff disable mode?",
                            " * @return one value of wl_status_t enum",
                            " */",
                            "bool WiFiAPClass::softAPdisconnect(bool wifioff)",
                            "{",
                            "    bool ret;",
                            "    wifi_config_t conf;",
                            "    *conf.ap.ssid     = 0;",
                            "    *conf.ap.password = 0;",
                            "    ret = esp_wifi_set_config(WIFI_IF_AP, &conf) == ESP_OK;",
                            "",
                            "    if(wifioff) {",
                            "        ret = WiFi.enableAP(false) == ESP_OK;",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the count of the Station / client that are connected to the softAP interface",
                            " * @return Stations count",
                            " */",
                            "uint8_t WiFiAPClass::softAPgetStationNum()",
                            "{",
                            "    wifi_sta_list_t clients;",
                            "    if(esp_wifi_ap_get_sta_list(&clients) == ESP_OK) {",
                            "        return clients.num;",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface IP address.",
                            " * @return IPAddress softAP IP",
                            " */",
                            "IPAddress WiFiAPClass::softAPIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_AP, &ip);",
                            "    return IPAddress(ip.ip.addr);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the softAP interface MAC address.",
                            " * @param mac   pointer to uint8_t array with length WL_MAC_ADDR_LENGTH",
                            " * @return      pointer to uint8_t*",
                            " */",
                            "uint8_t* WiFiAPClass::softAPmacAddress(uint8_t* mac)",
                            "{",
                            "    esp_wifi_get_mac(WIFI_IF_AP, mac);",
                            "    return mac;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface MAC address.",
                            " * @return String mac",
                            " */",
                            "String WiFiAPClass::softAPmacAddress(void)",
                            "{",
                            "    uint8_t mac[6];",
                            "    char macStr[18] = { 0 };",
                            "    esp_wifi_get_mac(WIFI_IF_AP, mac);",
                            "",
                            "    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "    return String(macStr);",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface Host name.",
                            " * @return char array hostname",
                            " */",
                            "const char * WiFiAPClass::softAPgetHostname()",
                            "{",
                            "    const char * hostname;",
                            "    if(tcpip_adapter_get_hostname(TCPIP_ADAPTER_IF_AP, &hostname)) {",
                            "        return NULL;",
                            "    }",
                            "    return hostname;",
                            "}",
                            "",
                            "/**",
                            " * Set the softAP    interface Host name.",
                            " * @param  hostname  pointer to const string",
                            " * @return true on   success",
                            " */",
                            "bool WiFiAPClass::softAPsetHostname(const char * hostname)",
                            "{",
                            "    return tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_AP, hostname) == ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * Enable IPv6 on the softAP interface.",
                            " * @return true on success",
                            " */",
                            "bool WiFiAPClass::softAPenableIpV6()",
                            "{",
                            "    return tcpip_adapter_create_ip6_linklocal(TCPIP_ADAPTER_IF_AP) == ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface IPv6 address.",
                            " * @return IPv6Address softAP IPv6",
                            " */",
                            "IPv6Address WiFiAPClass::softAPIPv6()",
                            "{",
                            "    static ip6_addr_t addr;",
                            "    if(tcpip_adapter_get_ip6_linklocal(TCPIP_ADAPTER_IF_AP, &addr)) {",
                            "        return IPv6Address();",
                            "    }",
                            "    return IPv6Address(addr.addr);",
                            "}"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- Private functions ------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ----------------------------------------------------- AP function -----------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "        // enable AP failed",
                            "        // fail SSID too long or missing!",
                            "        // fail passphrase to long or short!",
                            "        // enable AP failed",
                            "    conf.ap.authmode  = WIFI_AUTH_OPEN; // auth must be open if pass=0"
                        ],
                        "lines": [
                            "",
                            "static bool softap_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs);",
                            "",
                            "",
                            "",
                            "/**",
                            " * compare two AP configurations",
                            " * @param lhs softap_config",
                            " * @param rhs softap_config",
                            " * @return equal",
                            " */",
                            "static bool softap_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs)",
                            "{",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.ap.ssid), reinterpret_cast<const char*>(rhs.ap.ssid)) != 0) {",
                            "        return false;",
                            "    }",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.ap.password), reinterpret_cast<const char*>(rhs.ap.password)) != 0) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.channel != rhs.ap.channel) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.ssid_hidden != rhs.ap.ssid_hidden) {",
                            "        return false;",
                            "    }",
                            "    if(lhs.ap.max_connection != rhs.ap.max_connection) {",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "",
                            "/**",
                            " * Set up an access point",
                            " * @param ssid              Pointer to the SSID (max 63 char).",
                            " * @param passphrase        (for WPA2 min 8 char, for open use NULL)",
                            " * @param channel           WiFi channel number, 1 - 13.",
                            " * @param ssid_hidden       Network cloaking (0 = broadcast SSID, 1 = hide SSID)",
                            " * @param max_connection    Max simultaneous connected clients, 1 - 4.",
                            "*/",
                            "bool WiFiAPClass::softAP(const char* ssid, const char* passphrase, int channel, int ssid_hidden, int max_connection)",
                            "{",
                            "",
                            "    if(!WiFi.enableAP(true)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!ssid || *ssid == 0 || strlen(ssid) > 31) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && (strlen(passphrase) > 63 || strlen(passphrase) < 8)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_wifi_start();",
                            "",
                            "    wifi_config_t conf;",
                            "    strcpy(reinterpret_cast<char*>(conf.ap.ssid), ssid);",
                            "    conf.ap.channel = channel;",
                            "    conf.ap.ssid_len = strlen(ssid);",
                            "    conf.ap.ssid_hidden = ssid_hidden;",
                            "    conf.ap.max_connection = max_connection;",
                            "    conf.ap.beacon_interval = 100;",
                            "",
                            "    if(!passphrase || strlen(passphrase) == 0) {",
                            "        conf.ap.authmode = WIFI_AUTH_OPEN;",
                            "        *conf.ap.password = 0;",
                            "    } else {",
                            "        conf.ap.authmode = WIFI_AUTH_WPA2_PSK;",
                            "        strcpy(reinterpret_cast<char*>(conf.ap.password), passphrase);",
                            "    }",
                            "",
                            "    wifi_config_t conf_current;",
                            "    esp_wifi_get_config(WIFI_IF_AP, &conf_current);",
                            "    if(!softap_config_equal(conf, conf_current) && esp_wifi_set_config(WIFI_IF_AP, &conf) != ESP_OK) {",
                            "        return false;",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Configure access point",
                            " * @param local_ip      access point IP",
                            " * @param gateway       gateway IP",
                            " * @param subnet        subnet mask",
                            " */",
                            "bool WiFiAPClass::softAPConfig(IPAddress local_ip, IPAddress gateway, IPAddress subnet)",
                            "{",
                            "",
                            "    if(!WiFi.enableAP(true)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_wifi_start();",
                            "",
                            "    tcpip_adapter_ip_info_t info;",
                            "    info.ip.addr = static_cast<uint32_t>(local_ip);",
                            "    info.gw.addr = static_cast<uint32_t>(gateway);",
                            "    info.netmask.addr = static_cast<uint32_t>(subnet);",
                            "    tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP);",
                            "    if(tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_AP, &info) == ESP_OK) {",
                            "        dhcps_lease_t lease;",
                            "        lease.enable = true;",
                            "        lease.start_ip.addr = static_cast<uint32_t>(local_ip) + (1 << 24);",
                            "        lease.end_ip.addr = static_cast<uint32_t>(local_ip) + (11 << 24);",
                            "",
                            "        tcpip_adapter_dhcps_option(",
                            "            (tcpip_adapter_option_mode_t)TCPIP_ADAPTER_OP_SET,",
                            "            (tcpip_adapter_option_id_t)REQUESTED_IP_ADDRESS,",
                            "            (void*)&lease, sizeof(dhcps_lease_t)",
                            "        );",
                            "",
                            "        return tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP) == ESP_OK;",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "",
                            "",
                            "/**",
                            " * Disconnect from the network (close AP)",
                            " * @param wifioff disable mode?",
                            " * @return one value of wl_status_t enum",
                            " */",
                            "bool WiFiAPClass::softAPdisconnect(bool wifioff)",
                            "{",
                            "    bool ret;",
                            "    wifi_config_t conf;",
                            "    *conf.ap.ssid     = 0;",
                            "    *conf.ap.password = 0;",
                            "    ret = esp_wifi_set_config(WIFI_IF_AP, &conf) == ESP_OK;",
                            "",
                            "    if(wifioff) {",
                            "        ret = WiFi.enableAP(false) == ESP_OK;",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the count of the Station / client that are connected to the softAP interface",
                            " * @return Stations count",
                            " */",
                            "uint8_t WiFiAPClass::softAPgetStationNum()",
                            "{",
                            "    wifi_sta_list_t clients;",
                            "    if(esp_wifi_ap_get_sta_list(&clients) == ESP_OK) {",
                            "        return clients.num;",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface IP address.",
                            " * @return IPAddress softAP IP",
                            " */",
                            "IPAddress WiFiAPClass::softAPIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_AP, &ip);",
                            "    return IPAddress(ip.ip.addr);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the softAP interface MAC address.",
                            " * @param mac   pointer to uint8_t array with length WL_MAC_ADDR_LENGTH",
                            " * @return      pointer to uint8_t*",
                            " */",
                            "uint8_t* WiFiAPClass::softAPmacAddress(uint8_t* mac)",
                            "{",
                            "    esp_wifi_get_mac(WIFI_IF_AP, mac);",
                            "    return mac;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface MAC address.",
                            " * @return String mac",
                            " */",
                            "String WiFiAPClass::softAPmacAddress(void)",
                            "{",
                            "    uint8_t mac[6];",
                            "    char macStr[18] = { 0 };",
                            "    esp_wifi_get_mac(WIFI_IF_AP, mac);",
                            "",
                            "    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "    return String(macStr);",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface Host name.",
                            " * @return char array hostname",
                            " */",
                            "const char * WiFiAPClass::softAPgetHostname()",
                            "{",
                            "    const char * hostname;",
                            "    if(tcpip_adapter_get_hostname(TCPIP_ADAPTER_IF_AP, &hostname)) {",
                            "        return NULL;",
                            "    }",
                            "    return hostname;",
                            "}",
                            "",
                            "/**",
                            " * Set the softAP    interface Host name.",
                            " * @param  hostname  pointer to const string",
                            " * @return true on   success",
                            " */",
                            "bool WiFiAPClass::softAPsetHostname(const char * hostname)",
                            "{",
                            "    return tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_AP, hostname) == ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * Enable IPv6 on the softAP interface.",
                            " * @return true on success",
                            " */",
                            "bool WiFiAPClass::softAPenableIpV6()",
                            "{",
                            "    return tcpip_adapter_create_ip6_linklocal(TCPIP_ADAPTER_IF_AP) == ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * Get the softAP interface IPv6 address.",
                            " * @return IPv6Address softAP IPv6",
                            " */",
                            "IPv6Address WiFiAPClass::softAPIPv6()",
                            "{",
                            "    static ip6_addr_t addr;",
                            "    if(tcpip_adapter_get_ip6_linklocal(TCPIP_ADAPTER_IF_AP, &addr)) {",
                            "        return IPv6Address();",
                            "    }",
                            "    return IPv6Address(addr.addr);",
                            "}"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "45": "// -----------------------------------------------------------------------------------------------------------------------",
                "46": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "47": "// -----------------------------------------------------------------------------------------------------------------------",
                "79": "// -----------------------------------------------------------------------------------------------------------------------",
                "80": "// ----------------------------------------------------- AP function -----------------------------------------------------",
                "81": "// -----------------------------------------------------------------------------------------------------------------------",
                "96": "        // enable AP failed",
                "101": "        // fail SSID too long or missing!",
                "106": "        // fail passphrase to long or short!",
                "148": "        // enable AP failed",
                "189": "    conf.ap.authmode  = WIFI_AUTH_OPEN; // auth must be open if pass=0"
            },
            "comment_deleted_diff": {
                "45": "// -----------------------------------------------------------------------------------------------------------------------",
                "46": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "47": "// -----------------------------------------------------------------------------------------------------------------------",
                "79": "// -----------------------------------------------------------------------------------------------------------------------",
                "80": "// ----------------------------------------------------- AP function -----------------------------------------------------",
                "81": "// -----------------------------------------------------------------------------------------------------------------------",
                "96": "        // enable AP failed",
                "101": "        // fail SSID too long or missing!",
                "106": "        // fail passphrase to long or short!",
                "148": "        // enable AP failed",
                "189": "    conf.ap.authmode  = WIFI_AUTH_OPEN; // auth must be open if pass=0"
            },
            "comment_modified_diff": {
                "45": "// -----------------------------------------------------------------------------------------------------------------------",
                "46": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "47": "// -----------------------------------------------------------------------------------------------------------------------",
                "79": "// -----------------------------------------------------------------------------------------------------------------------",
                "80": "// ----------------------------------------------------- AP function -----------------------------------------------------",
                "81": "// -----------------------------------------------------------------------------------------------------------------------",
                "96": "        // enable AP failed",
                "101": "        // fail SSID too long or missing!",
                "106": "        // fail passphrase to long or short!",
                "148": "        // enable AP failed",
                "189": "    conf.ap.authmode  = WIFI_AUTH_OPEN; // auth must be open if pass=0"
            }
        },
        {
            "commit": "14ff311479065c84c01eb75b7efc94627e230bcf",
            "timestamp": "2018-11-19T16:43:59+01:00",
            "author": "Mark D",
            "commit_message": "make WiFi.softAP() more robust (#1925)\n\n* make WiFi.softAP() more robust\r\n\r\n* WiFi.softAP() revert fallback to WIFI_AUTH_OPEN",
            "additions": 10,
            "deletions": 7,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            102,
                            103
                        ],
                        "comments": [
                            "        // fail SSID missing"
                        ],
                        "lines": [
                            "        log_e(\"SSID missing!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            107,
                            108,
                            109
                        ],
                        "comments": [
                            "        // fail passphrase too short"
                        ],
                        "lines": [
                            "    if(passphrase && (strlen(passphrase) > 0 && strlen(passphrase) < 8)) {",
                            "        log_e(\"passphrase too short!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            116
                        ],
                        "comments": [],
                        "lines": [
                            "    strlcpy(reinterpret_cast<char*>(conf.ap.ssid), ssid, sizeof(conf.ap.ssid));"
                        ]
                    },
                    {
                        "line_numbers": [
                            118
                        ],
                        "comments": [],
                        "lines": [
                            "    conf.ap.ssid_len = strlen(reinterpret_cast<char *>(conf.ap.ssid));"
                        ]
                    },
                    {
                        "line_numbers": [
                            128
                        ],
                        "comments": [],
                        "lines": [
                            "        strlcpy(reinterpret_cast<char*>(conf.ap.password), passphrase, sizeof(conf.ap.password));"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            101
                        ],
                        "comments": [
                            "        // fail SSID too long or missing!"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            105,
                            106
                        ],
                        "comments": [
                            "        // fail passphrase to long or short!"
                        ],
                        "lines": [
                            "    if(passphrase && (strlen(passphrase) > 63 || strlen(passphrase) < 8)) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            113
                        ],
                        "comments": [],
                        "lines": [
                            "    strcpy(reinterpret_cast<char*>(conf.ap.ssid), ssid);"
                        ]
                    },
                    {
                        "line_numbers": [
                            115
                        ],
                        "comments": [],
                        "lines": [
                            "    conf.ap.ssid_len = strlen(ssid);"
                        ]
                    },
                    {
                        "line_numbers": [
                            125
                        ],
                        "comments": [],
                        "lines": [
                            "        strcpy(reinterpret_cast<char*>(conf.ap.password), passphrase);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "102": "        // fail SSID missing",
                "108": "        // fail passphrase too short"
            },
            "comment_deleted_diff": {
                "101": "        // fail SSID too long or missing!",
                "106": "        // fail passphrase to long or short!"
            },
            "comment_modified_diff": {}
        }
    ],
    "WiFiAP.h": [],
    "WiFiClient.cpp": [
        {
            "commit": "770830aa01c883ba4a5219b77e1cb20bf5a8ef09",
            "timestamp": "2017-03-01T00:37:00+02:00",
            "author": "David Schroeder",
            "commit_message": "Revise WiFiClient::Write to handle EAGAIN (#240)\n\nThe send call may return EAGAIN. This indicates a recoverable error and a retry should be attempted. The current implementation treats this as a fatal error. Further, the current implementation strips the error code, setting it to 0, which prevents the caller from handling it directly. \r\nThis change utilizes select to verify the socket is available prior to calling send and will retry on an EAGAIN condition.",
            "additions": 38,
            "deletions": 6,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202
                        ],
                        "comments": [
                            "        FD_ZERO(&set);        // empties the set",
                            "        FD_SET(socketFileDescriptor, &set); // adds FD to the set"
                        ],
                        "lines": [
                            "        tv.tv_sec = 0;",
                            "        tv.tv_usec = WIFI_CLIENT_SELECT_TIMEOUT_US;",
                            "        retry--;",
                            "",
                            "        if(select(socketFileDescriptor + 1, NULL, &set, NULL, &tv) < 0) {",
                            "            return 0;",
                            "        }",
                            "",
                            "        if(FD_ISSET(socketFileDescriptor, &set)) {",
                            "            res = send(socketFileDescriptor, (void*) buf, size, MSG_DONTWAIT);",
                            "            if(res < 0) {",
                            "                log_e(\"%d\", errno);",
                            "                if(errno != EAGAIN) {",
                            "                    //if resource was busy, can try again, otherwise give up",
                            "                    stop();",
                            "                    res = 0;",
                            "                    retry = 0;",
                            "                }",
                            "            } else {",
                            "                //completed successfully",
                            "                retry = 0;",
                            "            }",
                            "        }"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "178": "        FD_ZERO(&set);        // empties the set",
                "179": "        FD_SET(socketFileDescriptor, &set); // adds FD to the set"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "6fc96b977f5b4b110cb174fff3327ef9245ee0d6",
            "timestamp": "2017-03-02T02:49:53+02:00",
            "author": "me-no-dev",
            "commit_message": "Add WiFiClient flush to clear all non-read data in RX\n\nfixes: https://github.com/espressif/arduino-esp32/issues/119",
            "additions": 27,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280
                        ],
                        "comments": [
                            "// Though flushing means to send all pending data,",
                            "// seems that in Arduino it also means to clear RX"
                        ],
                        "lines": [
                            "void WiFiClient::flush() {",
                            "    size_t a = available(), toRead = 0;",
                            "    if(!a){",
                            "        return;//nothing to flush",
                            "    }",
                            "    uint8_t * buf = (uint8_t *)malloc(WIFI_CLIENT_FLUSH_BUFFER_SIZE);",
                            "    if(!buf){",
                            "        return;//memory error",
                            "    }",
                            "    while(a){",
                            "        toRead = (a>WIFI_CLIENT_FLUSH_BUFFER_SIZE)?WIFI_CLIENT_FLUSH_BUFFER_SIZE:a;",
                            "        if(recv(fd(), buf, toRead, MSG_DONTWAIT) < 0) {",
                            "            if(errno != EWOULDBLOCK){",
                            "                log_e(\"%d\", errno);",
                            "                stop();",
                            "                break;",
                            "            }",
                            "            delay(1);//give some time",
                            "        }",
                            "        a = available();",
                            "    }",
                            "    free(buf);",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "255": "// Though flushing means to send all pending data,",
                "256": "// seems that in Arduino it also means to clear RX"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "06a76eebe8788111e0540d77ac3708c6dac4de4b",
            "timestamp": "2017-05-22T14:16:07+02:00",
            "author": "bbx10",
            "commit_message": "Remote tcp disconnect not detected (#389)\n\n* Add setNoDelay and getNoDelay to WiFiServer class\r\n\r\n* Remote TCP disconnect not detected",
            "additions": 22,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            300,
                            301,
                            302,
                            303
                        ],
                        "comments": [
                            "            // Should never happen since requested 0 bytes"
                        ],
                        "lines": [
                            "            _connected = true;",
                            "        }",
                            "    }"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "300": "            // Should never happen since requested 0 bytes"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "37ef5a43e360bbb95def6be8a997d0c7a75ccf33",
            "timestamp": "2017-07-31T22:51:41+03:00",
            "author": "bbx10",
            "commit_message": "Handle partial socket send (#503)\n\nsend() can return a value > 0 but less than size indicating it was able to accept some of the data in buffer. The caller must try again after updating the buffer pointer and size remaining.",
            "additions": 18,
            "deletions": 6,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            232
                        ],
                        "comments": [
                            "                // Try again"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            236
                        ],
                        "comments": [],
                        "lines": [
                            "    return totalBytesSent;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "232": "                // Try again"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "611db61d84906a012d8c86efeb0893498fb8ba9d",
            "timestamp": "2018-05-14T13:01:22+02:00",
            "author": "chemicstry",
            "commit_message": "Fix WiFiClient error handling (#1388)",
            "additions": 1,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            331
                        ],
                        "comments": [
                            "            // Should never happen since requested 0 bytes"
                        ],
                        "lines": []
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "331": "            // Should never happen since requested 0 bytes"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "5cfff190e9bc6edd7c9dfc31f8af50957c863872",
            "timestamp": "2018-12-03T16:17:16+01:00",
            "author": "Luc",
            "commit_message": "removing log (#2140)\n\n* Use right function for BSSID\r\n\r\n* removing log",
            "additions": 2,
            "deletions": 3,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            442,
                            443
                        ],
                        "comments": [
                            "        // avoid unused var warning by gcc"
                        ],
                        "lines": [
                            "        (void)res;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "442": "        // avoid unused var warning by gcc"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "89351e3ade9a62edd891e363de08c124395dc0ad",
            "timestamp": "2020-01-20T16:08:17+02:00",
            "author": "Guil-T",
            "commit_message": "Update WiFiClient.cpp (#3608)\n\nfixed the connected() function so that it only checks errno if recv returns a value of -1.\r\n\r\n\"in the even of an error, errno is set to indicate the error\" --manpage\r\n\r\nThis fixes the ESP32 Webserver when dealing with a modern webserver with a slow SD card.",
            "additions": 22,
            "deletions": 17,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519
                        ],
                        "comments": [
                            "        // recv only sets errno if res is -1"
                        ],
                        "lines": [
                            "        if (res < 0){",
                            "          switch (errno) {",
                            "              case EWOULDBLOCK:",
                            "              case ENOENT: //caused by vfs",
                            "                  _connected = true;",
                            "                  break;",
                            "              case ENOTCONN:",
                            "              case EPIPE:",
                            "              case ECONNRESET:",
                            "              case ECONNREFUSED:",
                            "              case ECONNABORTED:",
                            "                  _connected = false;",
                            "                  log_d(\"Disconnected: RES: %d, ERR: %d\", res, errno);",
                            "                  break;",
                            "              default:",
                            "                  log_i(\"Unexpected: RES: %d, ERR: %d\", res, errno);",
                            "                  _connected = true;",
                            "                  break;",
                            "          }",
                            "        } else {",
                            "          _connected = true;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "498": "        // recv only sets errno if res is -1"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "bb0a194bb78592cff3e198b661bf36b2d79ee833",
            "timestamp": "2020-01-21T12:36:03+02:00",
            "author": "Mark D",
            "commit_message": "fix WiFiClient.connected() (#3654)\n\nWiFiClient.connected() was hanging thinking there was still a connection when the remote had already closed. The one-liner in this patch addresses recv() returning 0 and errno==128. I couldn't find the corresponding errno for 128 but its caught by the case statement which includes EPIPE, ENOTCONN, ECONNRESET and ECONNABORTED so I assume its one of those. Broken pipe maybe?\r\n```c\r\n[D][WiFiClient.cpp:511] connected(): Disconnected: RES: 0, ERR: 128\r\n```\r\nEDIT: added comment to reflect that recv() can set errno when it returns 0.",
            "additions": 2,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            498,
                            499
                        ],
                        "comments": [
                            "        // recv only sets errno if res is <= 0"
                        ],
                        "lines": [
                            "        if (res <= 0){"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            498,
                            499
                        ],
                        "comments": [
                            "        // recv only sets errno if res is -1"
                        ],
                        "lines": [
                            "        if (res < 0){"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "498": "        // recv only sets errno if res is <= 0"
            },
            "comment_deleted_diff": {
                "498": "        // recv only sets errno if res is -1"
            },
            "comment_modified_diff": {
                "498": "        // recv only sets errno if res is -1"
            }
        },
        {
            "commit": "b2c678877c04428f06ec5f1f59cc4d204bcd05ec",
            "timestamp": "2020-01-29T12:18:54+02:00",
            "author": "chuck todd",
            "commit_message": "std::shared_ptr Memory Leak (#3680)\n\n* std::shared_ptr Memory Leak\r\n\r\nclientSocketHande and _rxBuffer are std::shared_ptr, the stop() call was not correctly releasing them and the operator= had similar problems fix for #3679\r\n\r\n* operator= second attempt\r\n\r\n* operator= third time",
            "additions": 2,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            199,
                            200
                        ],
                        "comments": [
                            "    clientSocketHandle.reset(); // clientSocketHandle = NULL;",
                            "    _rxBuffer.reset(); // _rxBuffer = NULL;"
                        ],
                        "lines": []
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "199": "    clientSocketHandle.reset(); // clientSocketHandle = NULL;",
                "200": "    _rxBuffer.reset(); // _rxBuffer = NULL;"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "109ba7a3b44cf0d89068aa0ec812271d3bc4acbc",
            "timestamp": "2020-01-29T12:30:08+02:00",
            "author": "Me No Dev",
            "commit_message": "Revert \"std::shared_ptr Memory Leak (#3680)\" (#3682)\n\nThis reverts commit b2c678877c04428f06ec5f1f59cc4d204bcd05ec.",
            "additions": 2,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            199,
                            200
                        ],
                        "comments": [
                            "    clientSocketHandle.reset(); // clientSocketHandle = NULL;",
                            "    _rxBuffer.reset(); // _rxBuffer = NULL;"
                        ],
                        "lines": []
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "199": "    clientSocketHandle.reset(); // clientSocketHandle = NULL;",
                "200": "    _rxBuffer.reset(); // _rxBuffer = NULL;"
            },
            "comment_modified_diff": {}
        }
    ],
    "WiFiClient.h": [],
    "WiFiGeneric.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 333,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ------------------------------------------------- Generic WiFi function -----------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// arduino dont like std::vectors move static here",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ------------------------------------------------ Generic Network function ---------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------"
                        ],
                        "lines": [
                            "",
                            "static std::vector<WiFiEventCbList_t> cbEventList;",
                            "",
                            "bool WiFiGenericClass::_persistent = true;",
                            "wifi_mode_t WiFiGenericClass::_forceSleepLastMode = WIFI_MODE_NULL;",
                            "",
                            "WiFiGenericClass::WiFiGenericClass()",
                            "{",
                            "",
                            "}",
                            "",
                            "/**",
                            " * set callback function",
                            " * @param cbEvent WiFiEventCb",
                            " * @param event optional filter (WIFI_EVENT_MAX is all events)",
                            " */",
                            "void WiFiGenericClass::onEvent(WiFiEventCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "    WiFiEventCbList_t newEventHandler;",
                            "    newEventHandler.cb = cbEvent;",
                            "    newEventHandler.event = event;",
                            "    cbEventList.push_back(newEventHandler);",
                            "}",
                            "",
                            "/**",
                            " * removes a callback form event handler",
                            " * @param cbEvent WiFiEventCb",
                            " * @param event optional filter (WIFI_EVENT_MAX is all events)",
                            " */",
                            "void WiFiGenericClass::removeEvent(WiFiEventCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.cb == cbEvent && entry.event == event) {",
                            "            cbEventList.erase(cbEventList.begin() + i);",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * callback for WiFi events",
                            " * @param arg",
                            " */",
                            "esp_err_t WiFiGenericClass::_eventCallback(void *arg, system_event_t *event)",
                            "{",
                            "    log_d(\"wifi evt: %d\", event->event_id);",
                            "",
                            "    if(event->event_id == SYSTEM_EVENT_SCAN_DONE) {",
                            "        WiFiScanClass::_scanDone();",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_DISCONNECTED) {",
                            "        uint8_t reason = event->event_info.disconnected.reason;",
                            "        if(reason == WIFI_REASON_NO_AP_FOUND) {",
                            "            WiFiSTAClass::_setStatus(WL_NO_SSID_AVAIL);",
                            "        } else if(reason == WIFI_REASON_AUTH_FAIL || reason == WIFI_REASON_ASSOC_FAIL) {",
                            "            WiFiSTAClass::_setStatus(WL_CONNECT_FAILED);",
                            "        } else if(reason == WIFI_REASON_BEACON_TIMEOUT || reason == WIFI_REASON_HANDSHAKE_TIMEOUT) {",
                            "            WiFiSTAClass::_setStatus(WL_CONNECTION_LOST);",
                            "        } else {",
                            "            WiFiSTAClass::_setStatus(WL_DISCONNECTED);",
                            "        }",
                            "        log_d(\"wifi reason: %d\", reason);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_START) {",
                            "        WiFiSTAClass::_setStatus(WL_DISCONNECTED);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_STOP) {",
                            "        WiFiSTAClass::_setStatus(WL_NO_SHIELD);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_GOT_IP) {",
                            "        WiFiSTAClass::_setStatus(WL_CONNECTED);",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.cb) {",
                            "            if(entry.event == (system_event_id_t) event->event_id || entry.event == SYSTEM_EVENT_MAX) {",
                            "                entry.cb((system_event_id_t) event->event_id);",
                            "            }",
                            "        }",
                            "    }",
                            "    return ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * Return the current channel associated with the network",
                            " * @return channel (1-13)",
                            " */",
                            "int32_t WiFiGenericClass::channel(void)",
                            "{",
                            "    uint8_t primaryChan;",
                            "    wifi_second_chan_t secondChan;",
                            "    esp_wifi_get_channel(&primaryChan, &secondChan);",
                            "    return primaryChan;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * store WiFi config in SDK flash area",
                            " * @param persistent",
                            " */",
                            "void WiFiGenericClass::persistent(bool persistent)",
                            "{",
                            "    _persistent = persistent;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * set new mode",
                            " * @param m WiFiMode_t",
                            " */",
                            "bool WiFiGenericClass::mode(wifi_mode_t m)",
                            "{",
                            "    if(getMode() == m) {",
                            "        return true;",
                            "    }",
                            "    return esp_wifi_set_mode(m) == ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * get WiFi mode",
                            " * @return WiFiMode",
                            " */",
                            "wifi_mode_t WiFiGenericClass::getMode()",
                            "{",
                            "    uint8_t mode;",
                            "    esp_wifi_get_mode((wifi_mode_t*)&mode);",
                            "    return (wifi_mode_t)mode;",
                            "}",
                            "",
                            "/**",
                            " * control STA mode",
                            " * @param enable bool",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::enableSTA(bool enable)",
                            "{",
                            "",
                            "    wifi_mode_t currentMode = getMode();",
                            "    bool isEnabled = ((currentMode & WIFI_MODE_STA) != 0);",
                            "",
                            "    if(isEnabled != enable) {",
                            "        if(enable) {",
                            "            return mode((wifi_mode_t)(currentMode | WIFI_MODE_STA));",
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_STA)));",
                            "        }",
                            "    } else {",
                            "        return true;",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * control AP mode",
                            " * @param enable bool",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::enableAP(bool enable)",
                            "{",
                            "",
                            "    wifi_mode_t currentMode = getMode();",
                            "    bool isEnabled = ((currentMode & WIFI_MODE_AP) != 0);",
                            "",
                            "    if(isEnabled != enable) {",
                            "        if(enable) {",
                            "            return mode((wifi_mode_t)(currentMode | WIFI_MODE_AP));",
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_AP)));",
                            "        }",
                            "    } else {",
                            "        return true;",
                            "    }",
                            "}",
                            "",
                            "",
                            "",
                            "void wifi_dns_found_callback(const char *name, const ip_addr_t *ipaddr, void *callback_arg);",
                            "",
                            "/**",
                            " * Resolve the given hostname to an IP address.",
                            " * @param aHostname     Name to be resolved",
                            " * @param aResult       IPAddress structure to store the returned IP address",
                            " * @return 1 if aIPAddrString was successfully converted to an IP address,",
                            " *          else error code",
                            " */",
                            "static bool _dns_busy = false;",
                            "",
                            "int WiFiGenericClass::hostByName(const char* aHostname, IPAddress& aResult)",
                            "{",
                            "    ip_addr_t addr;",
                            "    aResult = static_cast<uint32_t>(0);",
                            "    err_t err = dns_gethostbyname(aHostname, &addr, &wifi_dns_found_callback, &aResult);",
                            "    _dns_busy = err == ERR_INPROGRESS;",
                            "    while(_dns_busy);",
                            "    if(err == ERR_INPROGRESS && aResult) {",
                            "        //found by search",
                            "    } else if(err == ERR_OK && addr.u_addr.ip4.addr) {",
                            "        aResult = addr.u_addr.ip4.addr;",
                            "    } else {",
                            "        return 0;",
                            "    }",
                            "    return 1;",
                            "}",
                            "",
                            "/**",
                            " * DNS callback",
                            " * @param name",
                            " * @param ipaddr",
                            " * @param callback_arg",
                            " */",
                            "void wifi_dns_found_callback(const char *name, const ip_addr_t *ipaddr, void *callback_arg)",
                            "{",
                            "    if(ipaddr) {",
                            "        (*reinterpret_cast<IPAddress*>(callback_arg)) = ipaddr->u_addr.ip4.addr;",
                            "    }",
                            "    _dns_busy = false;",
                            "}",
                            "",
                            "/**",
                            " * Boot and start WiFi",
                            " * This method get's called on boot if you use any of the WiFi methods.",
                            " * If you do not link to this library, WiFi will not be started.",
                            " * */",
                            "#include \"nvs_flash.h\"",
                            "",
                            "void bootWiFi()",
                            "{",
                            "    esp_err_t err;",
                            "    wifi_init_config_t cfg;",
                            "    wifi_mode_t mode = WIFI_MODE_NULL;",
                            "    bool auto_connect = false;",
                            "",
                            "    err = nvs_flash_init();",
                            "    if (err != ESP_OK) {",
                            "        log_e(\"nvs_flash_init fail %d\", err);",
                            "        return;",
                            "    }",
                            "",
                            "    system_init();",
                            "    tcpip_adapter_init();",
                            "    esp_event_loop_init(WiFiGenericClass::_eventCallback, NULL);",
                            "",
                            "    cfg.event_handler = &esp_event_send;",
                            "    err = esp_wifi_init(&cfg);",
                            "    if (err != ESP_OK) {",
                            "        log_e(\"esp_wifi_init fail %d\\n\", err);",
                            "        return;",
                            "    }",
                            "",
                            "    err = esp_wifi_start();",
                            "    if (err != ESP_OK) {",
                            "        log_e(\"esp_wifi_start fail %d\\n\", err);",
                            "        return;",
                            "    }",
                            "",
                            "    err = esp_wifi_get_mode(&mode);",
                            "    if (err != ESP_OK) {",
                            "        log_e(\"esp_wifi_get_mode fail %d\\n\", err);",
                            "        return;",
                            "    }",
                            "",
                            "    err = esp_wifi_get_auto_connect(&auto_connect);",
                            "    if ((mode == WIFI_MODE_STA || mode == WIFI_MODE_APSTA) && auto_connect) {",
                            "        err = esp_wifi_connect();",
                            "        if (err != ESP_OK) {",
                            "            log_e(\"esp_wifi_connect fail %d\\n\", err);",
                            "        }",
                            "    }",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "54": "// -----------------------------------------------------------------------------------------------------------------------",
                "55": "// ------------------------------------------------- Generic WiFi function -----------------------------------------------",
                "56": "// -----------------------------------------------------------------------------------------------------------------------",
                "58": "// arduino dont like std::vectors move static here",
                "236": "// -----------------------------------------------------------------------------------------------------------------------",
                "237": "// ------------------------------------------------ Generic Network function ---------------------------------------------",
                "238": "// -----------------------------------------------------------------------------------------------------------------------"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "bb8b2554297680b835ff69650debd13026b8e570",
            "timestamp": "2018-03-04T21:05:24+01:00",
            "author": "Marco Tombesi",
            "commit_message": "fix issue 1081 and 1086 Wifi connection error when using STATIC IP settings (#1129)",
            "additions": 3,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            320,
                            321
                        ],
                        "comments": [
                            "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)"
                        ],
                        "lines": [
                            "\t\t{"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "320": "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "c92b61739743e6df0768bbcba1e0b53755ec91d8",
            "timestamp": "2018-04-16T16:34:39+02:00",
            "author": "Craig Leres",
            "commit_message": "Convert the few remaining cr/lf files to use lf for eol. (#1316)\n\nIf you develop on windows and need cr/lf files, see this:\r\n\r\n    https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_formatting_and_whitespace\r\n\r\n    Git can handle this by auto-converting CRLF line endings into LF\r\n    when you add a file to the index, and vice versa when it checks out\r\n    code onto your filesystem. You can turn on this functionality with\r\n    the core.autocrlf setting. If you're on a Windows machine, set it\r\n    to true - this converts LF endings into CRLF when you check out code:\r\n\r\n    $ git config --global core.autocrlf true",
            "additions": 497,
            "deletions": 497,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ------------------------------------------------- Generic WiFi function -----------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// arduino dont like std::vectors move static here",
                            "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ------------------------------------------------ Generic Network function ---------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------"
                        ],
                        "lines": [
                            "",
                            "typedef struct {",
                            "    WiFiEventCb cb;",
                            "    WiFiEventFullCb fcb;",
                            "    WiFiEventSysCb scb;",
                            "    system_event_id_t event;",
                            "} WiFiEventCbList_t;",
                            "",
                            "static std::vector<WiFiEventCbList_t> cbEventList;",
                            "",
                            "bool WiFiGenericClass::_persistent = true;",
                            "wifi_mode_t WiFiGenericClass::_forceSleepLastMode = WIFI_MODE_NULL;",
                            "",
                            "WiFiGenericClass::WiFiGenericClass()",
                            "{",
                            "",
                            "}",
                            "",
                            "/**",
                            " * set callback function",
                            " * @param cbEvent WiFiEventCb",
                            " * @param event optional filter (WIFI_EVENT_MAX is all events)",
                            " */",
                            "void WiFiGenericClass::onEvent(WiFiEventCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "    WiFiEventCbList_t newEventHandler;",
                            "    newEventHandler.cb = cbEvent;",
                            "    newEventHandler.fcb = NULL;",
                            "    newEventHandler.scb = NULL;",
                            "    newEventHandler.event = event;",
                            "    cbEventList.push_back(newEventHandler);",
                            "}",
                            "",
                            "void WiFiGenericClass::onEvent(WiFiEventFullCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "    WiFiEventCbList_t newEventHandler;",
                            "    newEventHandler.cb = NULL;",
                            "    newEventHandler.fcb = cbEvent;",
                            "    newEventHandler.scb = NULL;",
                            "    newEventHandler.event = event;",
                            "    cbEventList.push_back(newEventHandler);",
                            "}",
                            "",
                            "void WiFiGenericClass::onEvent(WiFiEventSysCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "    WiFiEventCbList_t newEventHandler;",
                            "    newEventHandler.cb = NULL;",
                            "    newEventHandler.fcb = NULL;",
                            "    newEventHandler.scb = cbEvent;",
                            "    newEventHandler.event = event;",
                            "    cbEventList.push_back(newEventHandler);",
                            "}",
                            "",
                            "/**",
                            " * removes a callback form event handler",
                            " * @param cbEvent WiFiEventCb",
                            " * @param event optional filter (WIFI_EVENT_MAX is all events)",
                            " */",
                            "void WiFiGenericClass::removeEvent(WiFiEventCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.cb == cbEvent && entry.event == event) {",
                            "            cbEventList.erase(cbEventList.begin() + i);",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "void WiFiGenericClass::removeEvent(WiFiEventFullCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.fcb == cbEvent && entry.event == event) {",
                            "            cbEventList.erase(cbEventList.begin() + i);",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "void WiFiGenericClass::removeEvent(WiFiEventSysCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.scb == cbEvent && entry.event == event) {",
                            "            cbEventList.erase(cbEventList.begin() + i);",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * callback for WiFi events",
                            " * @param arg",
                            " */",
                            "#if ARDUHAL_LOG_LEVEL >= ARDUHAL_LOG_LEVEL_DEBUG",
                            "const char * system_event_names[] = { \"WIFI_READY\", \"SCAN_DONE\", \"STA_START\", \"STA_STOP\", \"STA_CONNECTED\", \"STA_DISCONNECTED\", \"STA_AUTHMODE_CHANGE\", \"STA_GOT_IP\", \"STA_LOST_IP\", \"STA_WPS_ER_SUCCESS\", \"STA_WPS_ER_FAILED\", \"STA_WPS_ER_TIMEOUT\", \"STA_WPS_ER_PIN\", \"AP_START\", \"AP_STOP\", \"AP_STACONNECTED\", \"AP_STADISCONNECTED\", \"AP_PROBEREQRECVED\", \"GOT_IP6\", \"ETH_START\", \"ETH_STOP\", \"ETH_CONNECTED\", \"ETH_DISCONNECTED\", \"ETH_GOT_IP\", \"MAX\"};",
                            "#endif",
                            "#if ARDUHAL_LOG_LEVEL >= ARDUHAL_LOG_LEVEL_WARN",
                            "const char * system_event_reasons[] = { \"UNSPECIFIED\", \"AUTH_EXPIRE\", \"AUTH_LEAVE\", \"ASSOC_EXPIRE\", \"ASSOC_TOOMANY\", \"NOT_AUTHED\", \"NOT_ASSOCED\", \"ASSOC_LEAVE\", \"ASSOC_NOT_AUTHED\", \"DISASSOC_PWRCAP_BAD\", \"DISASSOC_SUPCHAN_BAD\", \"IE_INVALID\", \"MIC_FAILURE\", \"4WAY_HANDSHAKE_TIMEOUT\", \"GROUP_KEY_UPDATE_TIMEOUT\", \"IE_IN_4WAY_DIFFERS\", \"GROUP_CIPHER_INVALID\", \"PAIRWISE_CIPHER_INVALID\", \"AKMP_INVALID\", \"UNSUPP_RSN_IE_VERSION\", \"INVALID_RSN_IE_CAP\", \"802_1X_AUTH_FAILED\", \"CIPHER_SUITE_REJECTED\", \"BEACON_TIMEOUT\", \"NO_AP_FOUND\", \"AUTH_FAIL\", \"ASSOC_FAIL\", \"HANDSHAKE_TIMEOUT\" };",
                            "#define reason2str(r) ((r>176)?system_event_reasons[r-177]:system_event_reasons[r-1])",
                            "#endif",
                            "esp_err_t WiFiGenericClass::_eventCallback(void *arg, system_event_t *event)",
                            "{",
                            "    log_d(\"Event: %d - %s\", event->event_id, system_event_names[event->event_id]);",
                            "    if(event->event_id == SYSTEM_EVENT_SCAN_DONE) {",
                            "        WiFiScanClass::_scanDone();",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_DISCONNECTED) {",
                            "        uint8_t reason = event->event_info.disconnected.reason;",
                            "        log_w(\"Reason: %u - %s\", reason, reason2str(reason));",
                            "        if(reason == WIFI_REASON_NO_AP_FOUND) {",
                            "            WiFiSTAClass::_setStatus(WL_NO_SSID_AVAIL);",
                            "        } else if(reason == WIFI_REASON_AUTH_FAIL || reason == WIFI_REASON_ASSOC_FAIL) {",
                            "            WiFiSTAClass::_setStatus(WL_CONNECT_FAILED);",
                            "        } else if(reason == WIFI_REASON_BEACON_TIMEOUT || reason == WIFI_REASON_HANDSHAKE_TIMEOUT) {",
                            "            WiFiSTAClass::_setStatus(WL_CONNECTION_LOST);",
                            "        } else if(reason == WIFI_REASON_AUTH_EXPIRE) {",
                            "            if(WiFi.getAutoReconnect()){",
                            "                WiFi.begin();",
                            "            }",
                            "        } else {",
                            "            WiFiSTAClass::_setStatus(WL_DISCONNECTED);",
                            "        }",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_START) {",
                            "        WiFiSTAClass::_setStatus(WL_DISCONNECTED);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_STOP) {",
                            "        WiFiSTAClass::_setStatus(WL_NO_SHIELD);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_CONNECTED) {",
                            "        WiFiSTAClass::_setStatus(WL_IDLE_STATUS);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_GOT_IP) {",
                            "//#1081 https://github.com/espressif/arduino-esp32/issues/1081",
                            "\t\t{",
                            "            WiFiSTAClass::_setStatus(WL_CONNECTED);",
                            "        }",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.cb || entry.fcb || entry.scb) {",
                            "            if(entry.event == (system_event_id_t) event->event_id || entry.event == SYSTEM_EVENT_MAX) {",
                            "                if(entry.cb){",
                            "                    entry.cb((system_event_id_t) event->event_id);",
                            "                } else if(entry.fcb){",
                            "                    entry.fcb((system_event_id_t) event->event_id, (system_event_info_t) event->event_info);",
                            "                } else {",
                            "                    entry.scb(event);",
                            "                }",
                            "            }",
                            "        }",
                            "    }",
                            "    return ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * Return the current channel associated with the network",
                            " * @return channel (1-13)",
                            " */",
                            "int32_t WiFiGenericClass::channel(void)",
                            "{",
                            "    uint8_t primaryChan;",
                            "    wifi_second_chan_t secondChan;",
                            "    esp_wifi_get_channel(&primaryChan, &secondChan);",
                            "    return primaryChan;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * store WiFi config in SDK flash area",
                            " * @param persistent",
                            " */",
                            "void WiFiGenericClass::persistent(bool persistent)",
                            "{",
                            "    _persistent = persistent;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * set new mode",
                            " * @param m WiFiMode_t",
                            " */",
                            "bool WiFiGenericClass::mode(wifi_mode_t m)",
                            "{",
                            "    wifi_mode_t cm = getMode();",
                            "    if(cm == WIFI_MODE_MAX){",
                            "        return false;",
                            "    }",
                            "    if(cm == m) {",
                            "        return true;",
                            "    }",
                            "    esp_err_t err;",
                            "    err = esp_wifi_set_mode(m);",
                            "    if(err){",
                            "        log_e(\"Could not set mode! %u\", err);",
                            "        return false;",
                            "    }",
                            "    if(m){",
                            "        return espWiFiStart();",
                            "    }",
                            "    return espWiFiStop();",
                            "}",
                            "",
                            "/**",
                            " * get WiFi mode",
                            " * @return WiFiMode",
                            " */",
                            "wifi_mode_t WiFiGenericClass::getMode()",
                            "{",
                            "    if(!wifiLowLevelInit()){",
                            "        return WIFI_MODE_MAX;",
                            "    }",
                            "    uint8_t mode;",
                            "    esp_wifi_get_mode((wifi_mode_t*)&mode);",
                            "    return (wifi_mode_t)mode;",
                            "}",
                            "",
                            "/**",
                            " * control STA mode",
                            " * @param enable bool",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::enableSTA(bool enable)",
                            "{",
                            "",
                            "    wifi_mode_t currentMode = getMode();",
                            "    bool isEnabled = ((currentMode & WIFI_MODE_STA) != 0);",
                            "",
                            "    if(isEnabled != enable) {",
                            "        if(enable) {",
                            "            return mode((wifi_mode_t)(currentMode | WIFI_MODE_STA));",
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_STA)));",
                            "        }",
                            "    } else {",
                            "        return true;",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * control AP mode",
                            " * @param enable bool",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::enableAP(bool enable)",
                            "{",
                            "",
                            "    wifi_mode_t currentMode = getMode();",
                            "    bool isEnabled = ((currentMode & WIFI_MODE_AP) != 0);",
                            "",
                            "    if(isEnabled != enable) {",
                            "        if(enable) {",
                            "            return mode((wifi_mode_t)(currentMode | WIFI_MODE_AP));",
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_AP)));",
                            "        }",
                            "    } else {",
                            "        return true;",
                            "    }",
                            "}",
                            "",
                            "",
                            "",
                            "static bool _dns_busy = false;",
                            "",
                            "/**",
                            " * DNS callback",
                            " * @param name",
                            " * @param ipaddr",
                            " * @param callback_arg",
                            " */",
                            "static void wifi_dns_found_callback(const char *name, const ip_addr_t *ipaddr, void *callback_arg)",
                            "{",
                            "    if(ipaddr) {",
                            "        (*reinterpret_cast<IPAddress*>(callback_arg)) = ipaddr->u_addr.ip4.addr;",
                            "    }",
                            "    _dns_busy = false;",
                            "}",
                            "",
                            "/**",
                            " * Resolve the given hostname to an IP address.",
                            " * @param aHostname     Name to be resolved",
                            " * @param aResult       IPAddress structure to store the returned IP address",
                            " * @return 1 if aIPAddrString was successfully converted to an IP address,",
                            " *          else error code",
                            " */",
                            "int WiFiGenericClass::hostByName(const char* aHostname, IPAddress& aResult)",
                            "{",
                            "    ip_addr_t addr;",
                            "    aResult = static_cast<uint32_t>(0);",
                            "",
                            "    _dns_busy = true;",
                            "    err_t err = dns_gethostbyname(aHostname, &addr, &wifi_dns_found_callback, &aResult);",
                            "    if(err == ERR_OK && addr.u_addr.ip4.addr) {",
                            "        aResult = addr.u_addr.ip4.addr;",
                            "        _dns_busy = false;",
                            "    } else if(err == ERR_INPROGRESS) {",
                            "        while(_dns_busy){",
                            "            delay(1);",
                            "        }",
                            "    } else {",
                            "        _dns_busy = false;",
                            "        return 0;",
                            "    }",
                            "    return 1;",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ------------------------------------------------- Generic WiFi function -----------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// arduino dont like std::vectors move static here",
                            "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ------------------------------------------------ Generic Network function ---------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------"
                        ],
                        "lines": [
                            "",
                            "typedef struct {",
                            "    WiFiEventCb cb;",
                            "    WiFiEventFullCb fcb;",
                            "    WiFiEventSysCb scb;",
                            "    system_event_id_t event;",
                            "} WiFiEventCbList_t;",
                            "",
                            "static std::vector<WiFiEventCbList_t> cbEventList;",
                            "",
                            "bool WiFiGenericClass::_persistent = true;",
                            "wifi_mode_t WiFiGenericClass::_forceSleepLastMode = WIFI_MODE_NULL;",
                            "",
                            "WiFiGenericClass::WiFiGenericClass()",
                            "{",
                            "",
                            "}",
                            "",
                            "/**",
                            " * set callback function",
                            " * @param cbEvent WiFiEventCb",
                            " * @param event optional filter (WIFI_EVENT_MAX is all events)",
                            " */",
                            "void WiFiGenericClass::onEvent(WiFiEventCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "    WiFiEventCbList_t newEventHandler;",
                            "    newEventHandler.cb = cbEvent;",
                            "    newEventHandler.fcb = NULL;",
                            "    newEventHandler.scb = NULL;",
                            "    newEventHandler.event = event;",
                            "    cbEventList.push_back(newEventHandler);",
                            "}",
                            "",
                            "void WiFiGenericClass::onEvent(WiFiEventFullCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "    WiFiEventCbList_t newEventHandler;",
                            "    newEventHandler.cb = NULL;",
                            "    newEventHandler.fcb = cbEvent;",
                            "    newEventHandler.scb = NULL;",
                            "    newEventHandler.event = event;",
                            "    cbEventList.push_back(newEventHandler);",
                            "}",
                            "",
                            "void WiFiGenericClass::onEvent(WiFiEventSysCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "    WiFiEventCbList_t newEventHandler;",
                            "    newEventHandler.cb = NULL;",
                            "    newEventHandler.fcb = NULL;",
                            "    newEventHandler.scb = cbEvent;",
                            "    newEventHandler.event = event;",
                            "    cbEventList.push_back(newEventHandler);",
                            "}",
                            "",
                            "/**",
                            " * removes a callback form event handler",
                            " * @param cbEvent WiFiEventCb",
                            " * @param event optional filter (WIFI_EVENT_MAX is all events)",
                            " */",
                            "void WiFiGenericClass::removeEvent(WiFiEventCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.cb == cbEvent && entry.event == event) {",
                            "            cbEventList.erase(cbEventList.begin() + i);",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "void WiFiGenericClass::removeEvent(WiFiEventFullCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.fcb == cbEvent && entry.event == event) {",
                            "            cbEventList.erase(cbEventList.begin() + i);",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "void WiFiGenericClass::removeEvent(WiFiEventSysCb cbEvent, system_event_id_t event)",
                            "{",
                            "    if(!cbEvent) {",
                            "        return;",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.scb == cbEvent && entry.event == event) {",
                            "            cbEventList.erase(cbEventList.begin() + i);",
                            "        }",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * callback for WiFi events",
                            " * @param arg",
                            " */",
                            "#if ARDUHAL_LOG_LEVEL >= ARDUHAL_LOG_LEVEL_DEBUG",
                            "const char * system_event_names[] = { \"WIFI_READY\", \"SCAN_DONE\", \"STA_START\", \"STA_STOP\", \"STA_CONNECTED\", \"STA_DISCONNECTED\", \"STA_AUTHMODE_CHANGE\", \"STA_GOT_IP\", \"STA_LOST_IP\", \"STA_WPS_ER_SUCCESS\", \"STA_WPS_ER_FAILED\", \"STA_WPS_ER_TIMEOUT\", \"STA_WPS_ER_PIN\", \"AP_START\", \"AP_STOP\", \"AP_STACONNECTED\", \"AP_STADISCONNECTED\", \"AP_PROBEREQRECVED\", \"GOT_IP6\", \"ETH_START\", \"ETH_STOP\", \"ETH_CONNECTED\", \"ETH_DISCONNECTED\", \"ETH_GOT_IP\", \"MAX\"};",
                            "#endif",
                            "#if ARDUHAL_LOG_LEVEL >= ARDUHAL_LOG_LEVEL_WARN",
                            "const char * system_event_reasons[] = { \"UNSPECIFIED\", \"AUTH_EXPIRE\", \"AUTH_LEAVE\", \"ASSOC_EXPIRE\", \"ASSOC_TOOMANY\", \"NOT_AUTHED\", \"NOT_ASSOCED\", \"ASSOC_LEAVE\", \"ASSOC_NOT_AUTHED\", \"DISASSOC_PWRCAP_BAD\", \"DISASSOC_SUPCHAN_BAD\", \"IE_INVALID\", \"MIC_FAILURE\", \"4WAY_HANDSHAKE_TIMEOUT\", \"GROUP_KEY_UPDATE_TIMEOUT\", \"IE_IN_4WAY_DIFFERS\", \"GROUP_CIPHER_INVALID\", \"PAIRWISE_CIPHER_INVALID\", \"AKMP_INVALID\", \"UNSUPP_RSN_IE_VERSION\", \"INVALID_RSN_IE_CAP\", \"802_1X_AUTH_FAILED\", \"CIPHER_SUITE_REJECTED\", \"BEACON_TIMEOUT\", \"NO_AP_FOUND\", \"AUTH_FAIL\", \"ASSOC_FAIL\", \"HANDSHAKE_TIMEOUT\" };",
                            "#define reason2str(r) ((r>176)?system_event_reasons[r-177]:system_event_reasons[r-1])",
                            "#endif",
                            "esp_err_t WiFiGenericClass::_eventCallback(void *arg, system_event_t *event)",
                            "{",
                            "    log_d(\"Event: %d - %s\", event->event_id, system_event_names[event->event_id]);",
                            "    if(event->event_id == SYSTEM_EVENT_SCAN_DONE) {",
                            "        WiFiScanClass::_scanDone();",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_DISCONNECTED) {",
                            "        uint8_t reason = event->event_info.disconnected.reason;",
                            "        log_w(\"Reason: %u - %s\", reason, reason2str(reason));",
                            "        if(reason == WIFI_REASON_NO_AP_FOUND) {",
                            "            WiFiSTAClass::_setStatus(WL_NO_SSID_AVAIL);",
                            "        } else if(reason == WIFI_REASON_AUTH_FAIL || reason == WIFI_REASON_ASSOC_FAIL) {",
                            "            WiFiSTAClass::_setStatus(WL_CONNECT_FAILED);",
                            "        } else if(reason == WIFI_REASON_BEACON_TIMEOUT || reason == WIFI_REASON_HANDSHAKE_TIMEOUT) {",
                            "            WiFiSTAClass::_setStatus(WL_CONNECTION_LOST);",
                            "        } else if(reason == WIFI_REASON_AUTH_EXPIRE) {",
                            "            if(WiFi.getAutoReconnect()){",
                            "                WiFi.begin();",
                            "            }",
                            "        } else {",
                            "            WiFiSTAClass::_setStatus(WL_DISCONNECTED);",
                            "        }",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_START) {",
                            "        WiFiSTAClass::_setStatus(WL_DISCONNECTED);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_STOP) {",
                            "        WiFiSTAClass::_setStatus(WL_NO_SHIELD);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_CONNECTED) {",
                            "        WiFiSTAClass::_setStatus(WL_IDLE_STATUS);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_GOT_IP) {",
                            "//#1081 https://github.com/espressif/arduino-esp32/issues/1081",
                            "\t\t{",
                            "            WiFiSTAClass::_setStatus(WL_CONNECTED);",
                            "        }",
                            "    }",
                            "",
                            "    for(uint32_t i = 0; i < cbEventList.size(); i++) {",
                            "        WiFiEventCbList_t entry = cbEventList[i];",
                            "        if(entry.cb || entry.fcb || entry.scb) {",
                            "            if(entry.event == (system_event_id_t) event->event_id || entry.event == SYSTEM_EVENT_MAX) {",
                            "                if(entry.cb){",
                            "                    entry.cb((system_event_id_t) event->event_id);",
                            "                } else if(entry.fcb){",
                            "                    entry.fcb((system_event_id_t) event->event_id, (system_event_info_t) event->event_info);",
                            "                } else {",
                            "                    entry.scb(event);",
                            "                }",
                            "            }",
                            "        }",
                            "    }",
                            "    return ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * Return the current channel associated with the network",
                            " * @return channel (1-13)",
                            " */",
                            "int32_t WiFiGenericClass::channel(void)",
                            "{",
                            "    uint8_t primaryChan;",
                            "    wifi_second_chan_t secondChan;",
                            "    esp_wifi_get_channel(&primaryChan, &secondChan);",
                            "    return primaryChan;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * store WiFi config in SDK flash area",
                            " * @param persistent",
                            " */",
                            "void WiFiGenericClass::persistent(bool persistent)",
                            "{",
                            "    _persistent = persistent;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * set new mode",
                            " * @param m WiFiMode_t",
                            " */",
                            "bool WiFiGenericClass::mode(wifi_mode_t m)",
                            "{",
                            "    wifi_mode_t cm = getMode();",
                            "    if(cm == WIFI_MODE_MAX){",
                            "        return false;",
                            "    }",
                            "    if(cm == m) {",
                            "        return true;",
                            "    }",
                            "    esp_err_t err;",
                            "    err = esp_wifi_set_mode(m);",
                            "    if(err){",
                            "        log_e(\"Could not set mode! %u\", err);",
                            "        return false;",
                            "    }",
                            "    if(m){",
                            "        return espWiFiStart();",
                            "    }",
                            "    return espWiFiStop();",
                            "}",
                            "",
                            "/**",
                            " * get WiFi mode",
                            " * @return WiFiMode",
                            " */",
                            "wifi_mode_t WiFiGenericClass::getMode()",
                            "{",
                            "    if(!wifiLowLevelInit()){",
                            "        return WIFI_MODE_MAX;",
                            "    }",
                            "    uint8_t mode;",
                            "    esp_wifi_get_mode((wifi_mode_t*)&mode);",
                            "    return (wifi_mode_t)mode;",
                            "}",
                            "",
                            "/**",
                            " * control STA mode",
                            " * @param enable bool",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::enableSTA(bool enable)",
                            "{",
                            "",
                            "    wifi_mode_t currentMode = getMode();",
                            "    bool isEnabled = ((currentMode & WIFI_MODE_STA) != 0);",
                            "",
                            "    if(isEnabled != enable) {",
                            "        if(enable) {",
                            "            return mode((wifi_mode_t)(currentMode | WIFI_MODE_STA));",
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_STA)));",
                            "        }",
                            "    } else {",
                            "        return true;",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * control AP mode",
                            " * @param enable bool",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::enableAP(bool enable)",
                            "{",
                            "",
                            "    wifi_mode_t currentMode = getMode();",
                            "    bool isEnabled = ((currentMode & WIFI_MODE_AP) != 0);",
                            "",
                            "    if(isEnabled != enable) {",
                            "        if(enable) {",
                            "            return mode((wifi_mode_t)(currentMode | WIFI_MODE_AP));",
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_AP)));",
                            "        }",
                            "    } else {",
                            "        return true;",
                            "    }",
                            "}",
                            "",
                            "",
                            "",
                            "static bool _dns_busy = false;",
                            "",
                            "/**",
                            " * DNS callback",
                            " * @param name",
                            " * @param ipaddr",
                            " * @param callback_arg",
                            " */",
                            "static void wifi_dns_found_callback(const char *name, const ip_addr_t *ipaddr, void *callback_arg)",
                            "{",
                            "    if(ipaddr) {",
                            "        (*reinterpret_cast<IPAddress*>(callback_arg)) = ipaddr->u_addr.ip4.addr;",
                            "    }",
                            "    _dns_busy = false;",
                            "}",
                            "",
                            "/**",
                            " * Resolve the given hostname to an IP address.",
                            " * @param aHostname     Name to be resolved",
                            " * @param aResult       IPAddress structure to store the returned IP address",
                            " * @return 1 if aIPAddrString was successfully converted to an IP address,",
                            " *          else error code",
                            " */",
                            "int WiFiGenericClass::hostByName(const char* aHostname, IPAddress& aResult)",
                            "{",
                            "    ip_addr_t addr;",
                            "    aResult = static_cast<uint32_t>(0);",
                            "",
                            "    _dns_busy = true;",
                            "    err_t err = dns_gethostbyname(aHostname, &addr, &wifi_dns_found_callback, &aResult);",
                            "    if(err == ERR_OK && addr.u_addr.ip4.addr) {",
                            "        aResult = addr.u_addr.ip4.addr;",
                            "        _dns_busy = false;",
                            "    } else if(err == ERR_INPROGRESS) {",
                            "        while(_dns_busy){",
                            "            delay(1);",
                            "        }",
                            "    } else {",
                            "        _dns_busy = false;",
                            "        return 0;",
                            "    }",
                            "    return 1;",
                            "}",
                            ""
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "167": "// -----------------------------------------------------------------------------------------------------------------------",
                "168": "// ------------------------------------------------- Generic WiFi function -----------------------------------------------",
                "169": "// -----------------------------------------------------------------------------------------------------------------------",
                "178": "// arduino dont like std::vectors move static here",
                "320": "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)",
                "450": "// -----------------------------------------------------------------------------------------------------------------------",
                "451": "// ------------------------------------------------ Generic Network function ---------------------------------------------",
                "452": "// -----------------------------------------------------------------------------------------------------------------------"
            },
            "comment_deleted_diff": {
                "167": "// -----------------------------------------------------------------------------------------------------------------------",
                "168": "// ------------------------------------------------- Generic WiFi function -----------------------------------------------",
                "169": "// -----------------------------------------------------------------------------------------------------------------------",
                "178": "// arduino dont like std::vectors move static here",
                "320": "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)",
                "450": "// -----------------------------------------------------------------------------------------------------------------------",
                "451": "// ------------------------------------------------ Generic Network function ---------------------------------------------",
                "452": "// -----------------------------------------------------------------------------------------------------------------------"
            },
            "comment_modified_diff": {
                "167": "// -----------------------------------------------------------------------------------------------------------------------",
                "168": "// ------------------------------------------------- Generic WiFi function -----------------------------------------------",
                "169": "// -----------------------------------------------------------------------------------------------------------------------",
                "178": "// arduino dont like std::vectors move static here",
                "320": "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)",
                "450": "// -----------------------------------------------------------------------------------------------------------------------",
                "451": "// ------------------------------------------------ Generic Network function ---------------------------------------------",
                "452": "// -----------------------------------------------------------------------------------------------------------------------"
            }
        },
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 188,
            "deletions": 61,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241
                        ],
                        "comments": [
                            "        _network_event_group,    // The event group being tested.",
                            "        bits,  // The bits within the event group to wait for.",
                            "        pdFALSE,         // BIT_0 and BIT_4 should be cleared before returning.",
                            "        pdTRUE,        // Don't wait for both bits, either bit will do.",
                            "        timeout_ms / portTICK_PERIOD_MS ) & bits; // Wait a maximum of 100ms for either bit to be set."
                        ],
                        "lines": [
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_START) {",
                            "        WiFiSTAClass::_setStatus(WL_DISCONNECTED);",
                            "        setStatusBits(STA_STARTED_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_STOP) {",
                            "        WiFiSTAClass::_setStatus(WL_NO_SHIELD);",
                            "        clearStatusBits(STA_STARTED_BIT | STA_CONNECTED_BIT | STA_HAS_IP_BIT | STA_HAS_IP6_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_CONNECTED) {",
                            "        WiFiSTAClass::_setStatus(WL_IDLE_STATUS);",
                            "        setStatusBits(STA_CONNECTED_BIT);"
                        ]
                    },
                    {
                        "line_numbers": [
                            374,
                            375,
                            376,
                            377
                        ],
                        "comments": [],
                        "lines": [
                            "        clearStatusBits(STA_CONNECTED_BIT | STA_HAS_IP_BIT | STA_HAS_IP6_BIT);",
                            "        if(reason >= WIFI_REASON_BEACON_TIMEOUT && reason != WIFI_REASON_AUTH_FAIL && WiFi.getAutoReconnect()){",
                            "            WiFi.begin();",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414
                        ],
                        "comments": [],
                        "lines": [
                            "        WiFiSTAClass::_setStatus(WL_CONNECTED);",
                            "        setStatusBits(STA_HAS_IP_BIT | STA_CONNECTED_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_STA_LOST_IP) {",
                            "        WiFiSTAClass::_setStatus(WL_IDLE_STATUS);",
                            "        clearStatusBits(STA_HAS_IP_BIT);",
                            "",
                            "    } else if(event->event_id == SYSTEM_EVENT_AP_START) {",
                            "        setStatusBits(AP_STARTED_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_AP_STOP) {",
                            "        clearStatusBits(AP_STARTED_BIT | AP_HAS_CLIENT_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_AP_STACONNECTED) {",
                            "        setStatusBits(AP_HAS_CLIENT_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_AP_STADISCONNECTED) {",
                            "        wifi_sta_list_t clients;",
                            "        if(esp_wifi_ap_get_sta_list(&clients) != ESP_OK || !clients.num){",
                            "            clearStatusBits(AP_HAS_CLIENT_BIT);",
                            "        }",
                            "",
                            "    } else if(event->event_id == SYSTEM_EVENT_ETH_START) {",
                            "        setStatusBits(ETH_STARTED_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_ETH_STOP) {",
                            "        clearStatusBits(ETH_STARTED_BIT | ETH_CONNECTED_BIT | ETH_HAS_IP_BIT | ETH_HAS_IP6_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_ETH_CONNECTED) {",
                            "        setStatusBits(ETH_CONNECTED_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_ETH_DISCONNECTED) {",
                            "        clearStatusBits(ETH_CONNECTED_BIT | ETH_HAS_IP_BIT | ETH_HAS_IP6_BIT);",
                            "    } else if(event->event_id == SYSTEM_EVENT_ETH_GOT_IP) {",
                            "        setStatusBits(ETH_CONNECTED_BIT | ETH_HAS_IP_BIT);",
                            "",
                            "    } else if(event->event_id == SYSTEM_EVENT_GOT_IP6) {",
                            "        if(event->event_info.got_ip6.if_index == TCPIP_ADAPTER_IF_AP){",
                            "            setStatusBits(AP_HAS_IP6_BIT);",
                            "        } else if(event->event_info.got_ip6.if_index == TCPIP_ADAPTER_IF_STA){",
                            "            setStatusBits(STA_CONNECTED_BIT | STA_HAS_IP6_BIT);",
                            "        } else if(event->event_info.got_ip6.if_index == TCPIP_ADAPTER_IF_ETH){",
                            "            setStatusBits(ETH_CONNECTED_BIT | ETH_HAS_IP6_BIT);"
                        ]
                    },
                    {
                        "line_numbers": [
                            441,
                            442,
                            443,
                            444,
                            445
                        ],
                        "comments": [],
                        "lines": [
                            "    uint8_t primaryChan = 0;",
                            "    wifi_second_chan_t secondChan = WIFI_SECOND_CHAN_NONE;",
                            "    if(!lowLevelInitDone){",
                            "        return primaryChan;",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            471,
                            472,
                            473,
                            474,
                            475
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!cm && m){",
                            "        if(!espWiFiStart(_persistent)){",
                            "            return false;",
                            "        }",
                            "    } else if(cm && !m){"
                        ]
                    },
                    {
                        "line_numbers": [
                            485
                        ],
                        "comments": [],
                        "lines": [
                            "    return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            494,
                            495
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!_esp_wifi_started){",
                            "        return WIFI_MODE_NULL;"
                        ]
                    },
                    {
                        "line_numbers": [
                            497,
                            498,
                            499,
                            500,
                            501,
                            502
                        ],
                        "comments": [],
                        "lines": [
                            "    wifi_mode_t mode;",
                            "    if(esp_wifi_get_mode(&mode) == ESP_ERR_WIFI_NOT_INIT){",
                            "        log_w(\"WiFi not started\");",
                            "        return WIFI_MODE_NULL;",
                            "    }",
                            "    return mode;"
                        ]
                    },
                    {
                        "line_numbers": [
                            520
                        ],
                        "comments": [],
                        "lines": [
                            "        return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_STA)));"
                        ]
                    },
                    {
                        "line_numbers": [
                            522
                        ],
                        "comments": [],
                        "lines": [
                            "    return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            540
                        ],
                        "comments": [],
                        "lines": [
                            "        return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_AP)));"
                        ]
                    },
                    {
                        "line_numbers": [
                            542
                        ],
                        "comments": [],
                        "lines": [
                            "    return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599
                        ],
                        "comments": [],
                        "lines": [
                            "/**",
                            " * control modem sleep when only in STA mode",
                            " * @param enable bool",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::setSleep(bool enable)",
                            "{",
                            "    if((getMode() & WIFI_MODE_STA) == 0){",
                            "        log_w(\"STA has not been started\");",
                            "        return false;",
                            "    }",
                            "    return esp_wifi_set_ps(enable?WIFI_PS_MIN_MODEM:WIFI_PS_NONE) == ESP_OK;",
                            "}",
                            "",
                            "/**",
                            " * get modem sleep enabled",
                            " * @return true if modem sleep is enabled",
                            " */",
                            "bool WiFiGenericClass::getSleep()",
                            "{",
                            "    wifi_ps_type_t ps;",
                            "    if((getMode() & WIFI_MODE_STA) == 0){",
                            "        log_w(\"STA has not been started\");",
                            "        return false;",
                            "    }",
                            "    if(esp_wifi_get_ps(&ps) == ESP_OK){",
                            "        return ps == WIFI_PS_MIN_MODEM;",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * control wifi tx power",
                            " * @param power enum maximum wifi tx power",
                            " * @return ok",
                            " */",
                            "bool WiFiGenericClass::setTxPower(wifi_power_t power){",
                            "    if((getStatusBits() & (STA_STARTED_BIT | AP_STARTED_BIT)) == 0){",
                            "        log_w(\"Neither AP or STA has been started\");",
                            "        return false;",
                            "    }",
                            "    return esp_wifi_set_max_tx_power(power) == ESP_OK;",
                            "}",
                            "",
                            "wifi_power_t WiFiGenericClass::getTxPower(){",
                            "    int8_t power;",
                            "    if((getStatusBits() & (STA_STARTED_BIT | AP_STARTED_BIT)) == 0){",
                            "        log_w(\"Neither AP or STA has been started\");",
                            "        return WIFI_POWER_19_5dBm;",
                            "    }",
                            "    if(esp_wifi_get_max_tx_power(&power)){",
                            "        return WIFI_POWER_19_5dBm;",
                            "    }",
                            "    return (wifi_power_t)power;",
                            "}"
                        ]
                    },
                    {
                        "line_numbers": [
                            616
                        ],
                        "comments": [],
                        "lines": [
                            "    xEventGroupSetBits(_network_event_group, WIFI_DNS_DONE_BIT);"
                        ]
                    },
                    {
                        "line_numbers": [
                            630,
                            631
                        ],
                        "comments": [],
                        "lines": [
                            "    waitStatusBits(WIFI_DNS_IDLE_BIT, 5000);",
                            "    clearStatusBits(WIFI_DNS_IDLE_BIT);"
                        ]
                    },
                    {
                        "line_numbers": [
                            636,
                            637,
                            638,
                            639,
                            640,
                            641
                        ],
                        "comments": [],
                        "lines": [
                            "        waitStatusBits(WIFI_DNS_DONE_BIT, 4000);",
                            "        clearStatusBits(WIFI_DNS_DONE_BIT);",
                            "    }",
                            "    setStatusBits(WIFI_DNS_IDLE_BIT);",
                            "    if((uint32_t)aResult == 0){",
                            "        log_e(\"DNS Failed for %s\", aHostname);"
                        ]
                    },
                    {
                        "line_numbers": [
                            643
                        ],
                        "comments": [],
                        "lines": [
                            "    return (uint32_t)aResult != 0;"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            331,
                            332,
                            333
                        ],
                        "comments": [
                            "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)"
                        ],
                        "lines": [
                            "\t\t{",
                            "            WiFiSTAClass::_setStatus(WL_CONNECTED);"
                        ]
                    },
                    {
                        "line_numbers": [
                            360,
                            361
                        ],
                        "comments": [],
                        "lines": [
                            "    uint8_t primaryChan;",
                            "    wifi_second_chan_t secondChan;"
                        ]
                    },
                    {
                        "line_numbers": [
                            383,
                            384,
                            385
                        ],
                        "comments": [],
                        "lines": [
                            "    if (!_esp_wifi_started) {",
                            "         wifiLowLevelInit(_persistent);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            387,
                            388,
                            389
                        ],
                        "comments": [],
                        "lines": [
                            "    if(cm == WIFI_MODE_MAX){",
                            "        return false;",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            393,
                            394,
                            395
                        ],
                        "comments": [],
                        "lines": [
                            "    if(m){",
                            "        espWiFiStart(_persistent);",
                            "    } else {"
                        ]
                    },
                    {
                        "line_numbers": [
                            405,
                            406,
                            407,
                            408
                        ],
                        "comments": [],
                        "lines": [
                            "    if(m){",
                            "        return espWiFiStart(_persistent);",
                            "    }",
                            "    return espWiFiStop();"
                        ]
                    },
                    {
                        "line_numbers": [
                            417,
                            418,
                            419
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!wifiLowLevelInit(_persistent)){",
                            "        return WIFI_MODE_MAX;",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            421,
                            422,
                            423
                        ],
                        "comments": [],
                        "lines": [
                            "    uint8_t mode;",
                            "    esp_wifi_get_mode((wifi_mode_t*)&mode);",
                            "    return (wifi_mode_t)mode;"
                        ]
                    },
                    {
                        "line_numbers": [
                            440,
                            441
                        ],
                        "comments": [],
                        "lines": [
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_STA)));"
                        ]
                    },
                    {
                        "line_numbers": [
                            443,
                            444
                        ],
                        "comments": [],
                        "lines": [
                            "    } else {",
                            "        return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            462,
                            463
                        ],
                        "comments": [],
                        "lines": [
                            "        } else {",
                            "            return mode((wifi_mode_t)(currentMode & (~WIFI_MODE_AP)));"
                        ]
                    },
                    {
                        "line_numbers": [
                            465,
                            466
                        ],
                        "comments": [],
                        "lines": [
                            "    } else {",
                            "        return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            475,
                            476
                        ],
                        "comments": [],
                        "lines": [
                            "static bool _dns_busy = false;",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            488
                        ],
                        "comments": [],
                        "lines": [
                            "    _dns_busy = false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            502,
                            503
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "    _dns_busy = true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            507
                        ],
                        "comments": [],
                        "lines": [
                            "        _dns_busy = false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            509,
                            510,
                            511,
                            512,
                            513,
                            514
                        ],
                        "comments": [],
                        "lines": [
                            "        while(_dns_busy){",
                            "            delay(1);",
                            "        }",
                            "    } else {",
                            "        _dns_busy = false;",
                            "        return 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            516
                        ],
                        "comments": [],
                        "lines": [
                            "    return 1;"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "235": "        _network_event_group,    // The event group being tested.",
                "236": "        bits,  // The bits within the event group to wait for.",
                "237": "        pdFALSE,         // BIT_0 and BIT_4 should be cleared before returning.",
                "238": "        pdTRUE,        // Don't wait for both bits, either bit will do.",
                "239": "        timeout_ms / portTICK_PERIOD_MS ) & bits; // Wait a maximum of 100ms for either bit to be set."
            },
            "comment_deleted_diff": {
                "331": "//        if(WiFiSTAClass::status() == WL_IDLE_STATUS)"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "91b9fae111b8e601d8bdbcddf2dd430e0170706a",
            "timestamp": "2019-08-20T16:42:55+03:00",
            "author": "Ahmed Al-Qaidom",
            "commit_message": "Add generic IP utilities (#3038)\n\n* Add generic IP calculations\r\n\r\nAdd:\r\ncalculateNetworkID(IPAddress ip, IPAddress subnet) => Calculate the network id using the ip and subnet (e.g. 192.168.0.0)\r\ncalculateBroadcast(IPAddress ip, IPAddress subnet) => Calculate the broadcast ip using the ip and subnet (e.g. 192.168.0.255)\r\ncalculateSubnetCIDR(IPAddress subnetMask) => Calculate the subnet CIDR using the subnet (e.g. 24)\r\n\r\nAdd:\r\nbroadcastIP() => Retrieve the network id (e.g. 192.168.0.0)\r\nnetworkID() => Retrieve the broadcast IP (e.g. 192.168.0.255)\r\nsubnetCIDR() => Retrieve the subnet CIDR (e.g. 24)\r\n\r\nAdd:\r\nbroadcastIP() => Retrieve the network id (e.g. 192.168.0.0)\r\nnetworkID() => Retrieve the broadcast IP (e.g. 192.168.0.255)\r\nsubnetCIDR() => Retrieve the subnet CIDR (e.g. 24)\r\n\r\nAdd:\r\nsoftAPBroadcastIP() => Retrieve the network id (e.g. 192.168.0.0)\r\nsoftAPNetwrokID() => Retrieve the broadcast IP (e.g. 192.168.0.255)\r\nsoftAPSubnetCIDR() => Retrieve the subnet CIDR (e.g. 24)",
            "additions": 42,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            681,
                            682,
                            683,
                            684,
                            685,
                            686,
                            687,
                            688,
                            689,
                            690,
                            691,
                            692,
                            693,
                            694,
                            695,
                            696,
                            697,
                            698,
                            699,
                            700
                        ],
                        "comments": [
                            "\t\tif (subnetMask[i] == 0x80)  // 128",
                            "\t\telse if (subnetMask[i] == 0xC0)  // 192",
                            "\t\telse if (subnetMask[i] == 0xE0)  // 224",
                            "\t\telse if (subnetMask[i] == 0xF0)  // 242",
                            "\t\telse if (subnetMask[i] == 0xF8)  // 248",
                            "\t\telse if (subnetMask[i] == 0xFC)  // 252",
                            "\t\telse if (subnetMask[i] == 0xFE)  // 254",
                            "\t\telse if (subnetMask[i] == 0xFF)  // 255"
                        ],
                        "lines": [
                            "\t\t\tCIDR += 1;",
                            "\t\t\tCIDR += 2;",
                            "\t\t\tCIDR += 3;",
                            "\t\t\tCIDR += 4;",
                            "\t\t\tCIDR += 5;",
                            "\t\t\tCIDR += 6;",
                            "\t\t\tCIDR += 7;",
                            "\t\t\tCIDR += 8;",
                            "\t}",
                            "",
                            "\treturn CIDR;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "681": "\t\tif (subnetMask[i] == 0x80)  // 128",
                "683": "\t\telse if (subnetMask[i] == 0xC0)  // 192",
                "685": "\t\telse if (subnetMask[i] == 0xE0)  // 224",
                "687": "\t\telse if (subnetMask[i] == 0xF0)  // 242",
                "689": "\t\telse if (subnetMask[i] == 0xF8)  // 248",
                "691": "\t\telse if (subnetMask[i] == 0xFC)  // 252",
                "693": "\t\telse if (subnetMask[i] == 0xFE)  // 254",
                "695": "\t\telse if (subnetMask[i] == 0xFF)  // 255"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "WiFiGeneric.h": [],
    "WiFiMulti.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 218,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218
                        ],
                        "comments": [
                            "            // scan is running",
                            "            // scan done analyze",
                            "                        if(ssid_scan == entry.ssid) { // SSID match",
                            "                            if(rssi_scan > bestNetworkDb) { // best network",
                            "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                            "            // clean up ram",
                            "                // wait for connection or fail",
                            "            // start scan",
                            "            // scan wifi async mode",
                            "// ##################################################################################",
                            "        // fail SSID to long or missing!",
                            "        // fail passphrase to long!"
                        ],
                        "lines": [
                            "            return WL_NO_SSID_AVAIL;",
                            "        } else if(scanResult > 0) {",
                            "            WifiAPlist_t bestNetwork { NULL, NULL };",
                            "            int bestNetworkDb = INT_MIN;",
                            "            uint8_t bestBSSID[6];",
                            "            int32_t bestChannel = 0;",
                            "",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] scan done\\n\");",
                            "            delay(0);",
                            "",
                            "            if(scanResult <= 0) {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] no networks found\\n\");",
                            "            } else {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] %d networks found\\n\", scanResult);",
                            "                for(int8_t i = 0; i < scanResult; ++i) {",
                            "",
                            "                    String ssid_scan;",
                            "                    int32_t rssi_scan;",
                            "                    uint8_t sec_scan;",
                            "                    uint8_t* BSSID_scan;",
                            "                    int32_t chan_scan;",
                            "",
                            "                    WiFi.getNetworkInfo(i, ssid_scan, sec_scan, rssi_scan, BSSID_scan, chan_scan);",
                            "",
                            "                    bool known = false;",
                            "                    for(uint32_t x = 0; x < APlist.size(); x++) {",
                            "                        WifiAPlist_t entry = APlist[x];",
                            "",
                            "                            known = true;",
                            "                                    bestNetworkDb = rssi_scan;",
                            "                                    bestChannel = chan_scan;",
                            "                                    memcpy((void*) &bestNetwork, (void*) &entry, sizeof(bestNetwork));",
                            "                                    memcpy((void*) &bestBSSID, (void*) BSSID_scan, sizeof(bestBSSID));",
                            "                                }",
                            "                            }",
                            "                            break;",
                            "                        }",
                            "                    }",
                            "",
                            "                    if(known) {",
                            "                        DEBUG_WIFI_MULTI(\" ---> \");",
                            "                    } else {",
                            "                        DEBUG_WIFI_MULTI(\"      \");",
                            "                    }",
                            "",
                            "                    DEBUG_WIFI_MULTI(\" %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\\n\", i, chan_scan, BSSID_scan[0], BSSID_scan[1], BSSID_scan[2], BSSID_scan[3], BSSID_scan[4], BSSID_scan[5], ssid_scan.c_str(), rssi_scan, (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*');",
                            "                    delay(0);",
                            "                }",
                            "            }",
                            "",
                            "            WiFi.scanDelete();",
                            "",
                            "            DEBUG_WIFI_MULTI(\"\\n\\n\");",
                            "            delay(0);",
                            "",
                            "            if(bestNetwork.ssid) {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] Connecting BSSID: %02X:%02X:%02X:%02X:%02X:%02X SSID: %s Channal: %d (%d)\\n\", bestBSSID[0], bestBSSID[1], bestBSSID[2], bestBSSID[3], bestBSSID[4], bestBSSID[5], bestNetwork.ssid, bestChannel, bestNetworkDb);",
                            "",
                            "                WiFi.begin(bestNetwork.ssid, bestNetwork.passphrase, bestChannel, bestBSSID);",
                            "                status = WiFi.status();",
                            "",
                            "                while(status != WL_CONNECTED && status != WL_NO_SSID_AVAIL && status != WL_CONNECT_FAILED) {",
                            "                    delay(10);",
                            "                    status = WiFi.status();",
                            "                }",
                            "",
                            "                IPAddress ip;",
                            "                uint8_t * mac;",
                            "                switch(status) {",
                            "                case 3:",
                            "                    ip = WiFi.localIP();",
                            "                    mac = WiFi.BSSID();",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting done.\\n\");",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] SSID: %s\\n\", WiFi.SSID());",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] IP: %d.%d.%d.%d\\n\", ip[0], ip[1], ip[2], ip[3]);",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] MAC: %02X:%02X:%02X:%02X:%02X:%02X\\n\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Channel: %d\\n\", WiFi.channel());",
                            "                    break;",
                            "                case 1:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed AP not found.\\n\");",
                            "                    break;",
                            "                case 4:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed.\\n\");",
                            "                    break;",
                            "                default:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed (%d).\\n\", status);",
                            "                    break;",
                            "                }",
                            "            } else {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] no matching wifi found!\\n\");",
                            "            }",
                            "        } else {",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] delete old wifi config...\\n\");",
                            "            WiFi.disconnect();",
                            "",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] start scan\\n\");",
                            "            WiFi.scanNetworks(true);",
                            "        }",
                            "    }",
                            "    return status;",
                            "}",
                            "",
                            "",
                            "bool WiFiMulti::APlistAdd(const char* ssid, const char *passphrase)",
                            "{",
                            "",
                            "    WifiAPlist_t newAP;",
                            "",
                            "    if(!ssid || *ssid == 0x00 || strlen(ssid) > 31) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] no ssid or ssid to long\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 63) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] passphrase to long\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    newAP.ssid = strdup(ssid);",
                            "",
                            "    if(!newAP.ssid) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] fail newAP.ssid == 0\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && *passphrase != 0x00) {",
                            "        newAP.passphrase = strdup(passphrase);",
                            "        if(!newAP.passphrase) {",
                            "            DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] fail newAP.passphrase == 0\\n\");",
                            "            free(newAP.ssid);",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    APlist.push_back(newAP);",
                            "    DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] add SSID: %s\\n\", newAP.ssid);",
                            "    return true;",
                            "}",
                            "",
                            "void WiFiMulti::APlistClean(void)",
                            "{",
                            "    for(uint32_t i = 0; i < APlist.size(); i++) {",
                            "        WifiAPlist_t entry = APlist[i];",
                            "        if(entry.ssid) {",
                            "            free(entry.ssid);",
                            "        }",
                            "        if(entry.passphrase) {",
                            "            free(entry.passphrase);",
                            "        }",
                            "    }",
                            "    APlist.clear();",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "54": "            // scan is running",
                "57": "            // scan done analyze",
                "84": "                        if(ssid_scan == entry.ssid) { // SSID match",
                "86": "                            if(rssi_scan > bestNetworkDb) { // best network",
                "87": "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                "109": "            // clean up ram",
                "121": "                // wait for connection or fail",
                "153": "            // start scan",
                "158": "            // scan wifi async mode",
                "165": "// ##################################################################################",
                "173": "        // fail SSID to long or missing!",
                "179": "        // fail passphrase to long!"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "2ded419486a6ed444195ce99e54f486b7bb8f792",
            "timestamp": "2018-04-06T19:10:06+03:00",
            "author": "FloX",
            "commit_message": "Update WiFiMulti.cpp (#1220)\n\n* Update WiFiMulti.cpp\r\n\r\nadded 5 sec timeout from ESP8266\r\n\r\n* Update WiFiMulti.cpp\r\n\r\n* Update WiFiMulti.h",
            "additions": 5,
            "deletions": 4,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            122,
                            123
                        ],
                        "comments": [
                            "                // wait for connection, fail, or timeout"
                        ],
                        "lines": [
                            "                while(status != WL_CONNECTED && status != WL_NO_SSID_AVAIL && status != WL_CONNECT_FAILED && (millis() - startTime) <= connectTimeout) {"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            121,
                            122
                        ],
                        "comments": [
                            "                // wait for connection or fail"
                        ],
                        "lines": [
                            "                while(status != WL_CONNECTED && status != WL_NO_SSID_AVAIL && status != WL_CONNECT_FAILED) {"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "122": "                // wait for connection, fail, or timeout"
            },
            "comment_deleted_diff": {
                "121": "                // wait for connection or fail"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "c92b61739743e6df0768bbcba1e0b53755ec91d8",
            "timestamp": "2018-04-16T16:34:39+02:00",
            "author": "Craig Leres",
            "commit_message": "Convert the few remaining cr/lf files to use lf for eol. (#1316)\n\nIf you develop on windows and need cr/lf files, see this:\r\n\r\n    https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_formatting_and_whitespace\r\n\r\n    Git can handle this by auto-converting CRLF line endings into LF\r\n    when you add a file to the index, and vice versa when it checks out\r\n    code onto your filesystem. You can turn on this functionality with\r\n    the core.autocrlf setting. If you're on a Windows machine, set it\r\n    to true - this converts LF endings into CRLF when you check out code:\r\n\r\n    $ git config --global core.autocrlf true",
            "additions": 219,
            "deletions": 219,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219
                        ],
                        "comments": [
                            "            // scan is running",
                            "            // scan done analyze",
                            "                        if(ssid_scan == entry.ssid) { // SSID match",
                            "                            if(rssi_scan > bestNetworkDb) { // best network",
                            "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                            "            // clean up ram",
                            "                // wait for connection, fail, or timeout",
                            "            // start scan",
                            "            // scan wifi async mode",
                            "// ##################################################################################",
                            "        // fail SSID to long or missing!",
                            "        // fail passphrase to long!"
                        ],
                        "lines": [
                            "            return WL_NO_SSID_AVAIL;",
                            "        } else if(scanResult > 0) {",
                            "            WifiAPlist_t bestNetwork { NULL, NULL };",
                            "            int bestNetworkDb = INT_MIN;",
                            "            uint8_t bestBSSID[6];",
                            "            int32_t bestChannel = 0;",
                            "",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] scan done\\n\");",
                            "            delay(0);",
                            "",
                            "            if(scanResult <= 0) {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] no networks found\\n\");",
                            "            } else {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] %d networks found\\n\", scanResult);",
                            "                for(int8_t i = 0; i < scanResult; ++i) {",
                            "",
                            "                    String ssid_scan;",
                            "                    int32_t rssi_scan;",
                            "                    uint8_t sec_scan;",
                            "                    uint8_t* BSSID_scan;",
                            "                    int32_t chan_scan;",
                            "",
                            "                    WiFi.getNetworkInfo(i, ssid_scan, sec_scan, rssi_scan, BSSID_scan, chan_scan);",
                            "",
                            "                    bool known = false;",
                            "                    for(uint32_t x = 0; x < APlist.size(); x++) {",
                            "                        WifiAPlist_t entry = APlist[x];",
                            "",
                            "                            known = true;",
                            "                                    bestNetworkDb = rssi_scan;",
                            "                                    bestChannel = chan_scan;",
                            "                                    memcpy((void*) &bestNetwork, (void*) &entry, sizeof(bestNetwork));",
                            "                                    memcpy((void*) &bestBSSID, (void*) BSSID_scan, sizeof(bestBSSID));",
                            "                                }",
                            "                            }",
                            "                            break;",
                            "                        }",
                            "                    }",
                            "",
                            "                    if(known) {",
                            "                        DEBUG_WIFI_MULTI(\" ---> \");",
                            "                    } else {",
                            "                        DEBUG_WIFI_MULTI(\"      \");",
                            "                    }",
                            "",
                            "                    DEBUG_WIFI_MULTI(\" %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\\n\", i, chan_scan, BSSID_scan[0], BSSID_scan[1], BSSID_scan[2], BSSID_scan[3], BSSID_scan[4], BSSID_scan[5], ssid_scan.c_str(), rssi_scan, (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*');",
                            "                    delay(0);",
                            "                }",
                            "            }",
                            "",
                            "            WiFi.scanDelete();",
                            "",
                            "            DEBUG_WIFI_MULTI(\"\\n\\n\");",
                            "            delay(0);",
                            "",
                            "            if(bestNetwork.ssid) {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] Connecting BSSID: %02X:%02X:%02X:%02X:%02X:%02X SSID: %s Channal: %d (%d)\\n\", bestBSSID[0], bestBSSID[1], bestBSSID[2], bestBSSID[3], bestBSSID[4], bestBSSID[5], bestNetwork.ssid, bestChannel, bestNetworkDb);",
                            "",
                            "                WiFi.begin(bestNetwork.ssid, bestNetwork.passphrase, bestChannel, bestBSSID);",
                            "                status = WiFi.status();",
                            "",
                            "                auto startTime = millis();",
                            "                while(status != WL_CONNECTED && status != WL_NO_SSID_AVAIL && status != WL_CONNECT_FAILED && (millis() - startTime) <= connectTimeout) {",
                            "                    delay(10);",
                            "                    status = WiFi.status();",
                            "                }",
                            "",
                            "                IPAddress ip;",
                            "                uint8_t * mac;",
                            "                switch(status) {",
                            "                case 3:",
                            "                    ip = WiFi.localIP();",
                            "                    mac = WiFi.BSSID();",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting done.\\n\");",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] SSID: %s\\n\", WiFi.SSID());",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] IP: %d.%d.%d.%d\\n\", ip[0], ip[1], ip[2], ip[3]);",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] MAC: %02X:%02X:%02X:%02X:%02X:%02X\\n\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Channel: %d\\n\", WiFi.channel());",
                            "                    break;",
                            "                case 1:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed AP not found.\\n\");",
                            "                    break;",
                            "                case 4:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed.\\n\");",
                            "                    break;",
                            "                default:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed (%d).\\n\", status);",
                            "                    break;",
                            "                }",
                            "            } else {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] no matching wifi found!\\n\");",
                            "            }",
                            "        } else {",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] delete old wifi config...\\n\");",
                            "            WiFi.disconnect();",
                            "",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] start scan\\n\");",
                            "            WiFi.scanNetworks(true);",
                            "        }",
                            "    }",
                            "    return status;",
                            "}",
                            "",
                            "",
                            "bool WiFiMulti::APlistAdd(const char* ssid, const char *passphrase)",
                            "{",
                            "",
                            "    WifiAPlist_t newAP;",
                            "",
                            "    if(!ssid || *ssid == 0x00 || strlen(ssid) > 31) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] no ssid or ssid to long\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 63) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] passphrase to long\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    newAP.ssid = strdup(ssid);",
                            "",
                            "    if(!newAP.ssid) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] fail newAP.ssid == 0\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && *passphrase != 0x00) {",
                            "        newAP.passphrase = strdup(passphrase);",
                            "        if(!newAP.passphrase) {",
                            "            DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] fail newAP.passphrase == 0\\n\");",
                            "            free(newAP.ssid);",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    APlist.push_back(newAP);",
                            "    DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] add SSID: %s\\n\", newAP.ssid);",
                            "    return true;",
                            "}",
                            "",
                            "void WiFiMulti::APlistClean(void)",
                            "{",
                            "    for(uint32_t i = 0; i < APlist.size(); i++) {",
                            "        WifiAPlist_t entry = APlist[i];",
                            "        if(entry.ssid) {",
                            "            free(entry.ssid);",
                            "        }",
                            "        if(entry.passphrase) {",
                            "            free(entry.passphrase);",
                            "        }",
                            "    }",
                            "    APlist.clear();",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219
                        ],
                        "comments": [
                            "            // scan is running",
                            "            // scan done analyze",
                            "                        if(ssid_scan == entry.ssid) { // SSID match",
                            "                            if(rssi_scan > bestNetworkDb) { // best network",
                            "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                            "            // clean up ram",
                            "                // wait for connection, fail, or timeout",
                            "            // start scan",
                            "            // scan wifi async mode",
                            "// ##################################################################################",
                            "        // fail SSID to long or missing!",
                            "        // fail passphrase to long!"
                        ],
                        "lines": [
                            "            return WL_NO_SSID_AVAIL;",
                            "        } else if(scanResult > 0) {",
                            "            WifiAPlist_t bestNetwork { NULL, NULL };",
                            "            int bestNetworkDb = INT_MIN;",
                            "            uint8_t bestBSSID[6];",
                            "            int32_t bestChannel = 0;",
                            "",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] scan done\\n\");",
                            "            delay(0);",
                            "",
                            "            if(scanResult <= 0) {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] no networks found\\n\");",
                            "            } else {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] %d networks found\\n\", scanResult);",
                            "                for(int8_t i = 0; i < scanResult; ++i) {",
                            "",
                            "                    String ssid_scan;",
                            "                    int32_t rssi_scan;",
                            "                    uint8_t sec_scan;",
                            "                    uint8_t* BSSID_scan;",
                            "                    int32_t chan_scan;",
                            "",
                            "                    WiFi.getNetworkInfo(i, ssid_scan, sec_scan, rssi_scan, BSSID_scan, chan_scan);",
                            "",
                            "                    bool known = false;",
                            "                    for(uint32_t x = 0; x < APlist.size(); x++) {",
                            "                        WifiAPlist_t entry = APlist[x];",
                            "",
                            "                            known = true;",
                            "                                    bestNetworkDb = rssi_scan;",
                            "                                    bestChannel = chan_scan;",
                            "                                    memcpy((void*) &bestNetwork, (void*) &entry, sizeof(bestNetwork));",
                            "                                    memcpy((void*) &bestBSSID, (void*) BSSID_scan, sizeof(bestBSSID));",
                            "                                }",
                            "                            }",
                            "                            break;",
                            "                        }",
                            "                    }",
                            "",
                            "                    if(known) {",
                            "                        DEBUG_WIFI_MULTI(\" ---> \");",
                            "                    } else {",
                            "                        DEBUG_WIFI_MULTI(\"      \");",
                            "                    }",
                            "",
                            "                    DEBUG_WIFI_MULTI(\" %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\\n\", i, chan_scan, BSSID_scan[0], BSSID_scan[1], BSSID_scan[2], BSSID_scan[3], BSSID_scan[4], BSSID_scan[5], ssid_scan.c_str(), rssi_scan, (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*');",
                            "                    delay(0);",
                            "                }",
                            "            }",
                            "",
                            "            WiFi.scanDelete();",
                            "",
                            "            DEBUG_WIFI_MULTI(\"\\n\\n\");",
                            "            delay(0);",
                            "",
                            "            if(bestNetwork.ssid) {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] Connecting BSSID: %02X:%02X:%02X:%02X:%02X:%02X SSID: %s Channal: %d (%d)\\n\", bestBSSID[0], bestBSSID[1], bestBSSID[2], bestBSSID[3], bestBSSID[4], bestBSSID[5], bestNetwork.ssid, bestChannel, bestNetworkDb);",
                            "",
                            "                WiFi.begin(bestNetwork.ssid, bestNetwork.passphrase, bestChannel, bestBSSID);",
                            "                status = WiFi.status();",
                            "",
                            "                auto startTime = millis();",
                            "                while(status != WL_CONNECTED && status != WL_NO_SSID_AVAIL && status != WL_CONNECT_FAILED && (millis() - startTime) <= connectTimeout) {",
                            "                    delay(10);",
                            "                    status = WiFi.status();",
                            "                }",
                            "",
                            "                IPAddress ip;",
                            "                uint8_t * mac;",
                            "                switch(status) {",
                            "                case 3:",
                            "                    ip = WiFi.localIP();",
                            "                    mac = WiFi.BSSID();",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting done.\\n\");",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] SSID: %s\\n\", WiFi.SSID());",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] IP: %d.%d.%d.%d\\n\", ip[0], ip[1], ip[2], ip[3]);",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] MAC: %02X:%02X:%02X:%02X:%02X:%02X\\n\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Channel: %d\\n\", WiFi.channel());",
                            "                    break;",
                            "                case 1:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed AP not found.\\n\");",
                            "                    break;",
                            "                case 4:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed.\\n\");",
                            "                    break;",
                            "                default:",
                            "                    DEBUG_WIFI_MULTI(\"[WIFI] Connecting Failed (%d).\\n\", status);",
                            "                    break;",
                            "                }",
                            "            } else {",
                            "                DEBUG_WIFI_MULTI(\"[WIFI] no matching wifi found!\\n\");",
                            "            }",
                            "        } else {",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] delete old wifi config...\\n\");",
                            "            WiFi.disconnect();",
                            "",
                            "            DEBUG_WIFI_MULTI(\"[WIFI] start scan\\n\");",
                            "            WiFi.scanNetworks(true);",
                            "        }",
                            "    }",
                            "    return status;",
                            "}",
                            "",
                            "",
                            "bool WiFiMulti::APlistAdd(const char* ssid, const char *passphrase)",
                            "{",
                            "",
                            "    WifiAPlist_t newAP;",
                            "",
                            "    if(!ssid || *ssid == 0x00 || strlen(ssid) > 31) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] no ssid or ssid to long\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 63) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] passphrase to long\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    newAP.ssid = strdup(ssid);",
                            "",
                            "    if(!newAP.ssid) {",
                            "        DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] fail newAP.ssid == 0\\n\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && *passphrase != 0x00) {",
                            "        newAP.passphrase = strdup(passphrase);",
                            "        if(!newAP.passphrase) {",
                            "            DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] fail newAP.passphrase == 0\\n\");",
                            "            free(newAP.ssid);",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    APlist.push_back(newAP);",
                            "    DEBUG_WIFI_MULTI(\"[WIFI][APlistAdd] add SSID: %s\\n\", newAP.ssid);",
                            "    return true;",
                            "}",
                            "",
                            "void WiFiMulti::APlistClean(void)",
                            "{",
                            "    for(uint32_t i = 0; i < APlist.size(); i++) {",
                            "        WifiAPlist_t entry = APlist[i];",
                            "        if(entry.ssid) {",
                            "            free(entry.ssid);",
                            "        }",
                            "        if(entry.passphrase) {",
                            "            free(entry.passphrase);",
                            "        }",
                            "    }",
                            "    APlist.clear();",
                            "}",
                            ""
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "54": "            // scan is running",
                "57": "            // scan done analyze",
                "84": "                        if(ssid_scan == entry.ssid) { // SSID match",
                "86": "                            if(rssi_scan > bestNetworkDb) { // best network",
                "87": "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                "109": "            // clean up ram",
                "122": "                // wait for connection, fail, or timeout",
                "154": "            // start scan",
                "159": "            // scan wifi async mode",
                "166": "// ##################################################################################",
                "174": "        // fail SSID to long or missing!",
                "180": "        // fail passphrase to long!"
            },
            "comment_deleted_diff": {
                "54": "            // scan is running",
                "57": "            // scan done analyze",
                "84": "                        if(ssid_scan == entry.ssid) { // SSID match",
                "86": "                            if(rssi_scan > bestNetworkDb) { // best network",
                "87": "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                "109": "            // clean up ram",
                "122": "                // wait for connection, fail, or timeout",
                "154": "            // start scan",
                "159": "            // scan wifi async mode",
                "166": "// ##################################################################################",
                "174": "        // fail SSID to long or missing!",
                "180": "        // fail passphrase to long!"
            },
            "comment_modified_diff": {
                "54": "            // scan is running",
                "57": "            // scan done analyze",
                "84": "                        if(ssid_scan == entry.ssid) { // SSID match",
                "86": "                            if(rssi_scan > bestNetworkDb) { // best network",
                "87": "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                "109": "            // clean up ram",
                "122": "                // wait for connection, fail, or timeout",
                "154": "            // start scan",
                "159": "            // scan wifi async mode",
                "166": "// ##################################################################################",
                "174": "        // fail SSID to long or missing!",
                "180": "        // fail passphrase to long!"
            }
        },
        {
            "commit": "aa2393b5738551d7d3ee3d48649a5224e97641a5",
            "timestamp": "2019-02-14T12:52:52+01:00",
            "author": "acevest",
            "commit_message": "remove useless condition in if statement (#2371)\n\n* fix log error code format\r\n\r\n* remove useless condition in if statement",
            "additions": 89,
            "deletions": 87,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92
                        ],
                        "comments": [
                            "        // scan is running",
                            "        // scan done analyze",
                            "                    if(ssid_scan == entry.ssid) { // SSID match",
                            "                        if(rssi_scan > bestNetworkDb) { // best network",
                            "                            if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan"
                        ],
                        "lines": [
                            "        return WL_NO_SSID_AVAIL;",
                            "    } else if(scanResult > 0) {",
                            "        WifiAPlist_t bestNetwork { NULL, NULL };",
                            "        int bestNetworkDb = INT_MIN;",
                            "        uint8_t bestBSSID[6];",
                            "        int32_t bestChannel = 0;",
                            "",
                            "        log_i(\"[WIFI] scan done\");",
                            "",
                            "        if(scanResult <= 0) {",
                            "            log_e(\"[WIFI] no networks found\");",
                            "        } else {",
                            "            log_i(\"[WIFI] %d networks found\", scanResult);",
                            "            for(int8_t i = 0; i < scanResult; ++i) {",
                            "",
                            "                String ssid_scan;",
                            "                int32_t rssi_scan;",
                            "                uint8_t sec_scan;",
                            "                uint8_t* BSSID_scan;",
                            "                int32_t chan_scan;",
                            "",
                            "                WiFi.getNetworkInfo(i, ssid_scan, sec_scan, rssi_scan, BSSID_scan, chan_scan);",
                            "",
                            "                bool known = false;",
                            "                for(uint32_t x = 0; x < APlist.size(); x++) {",
                            "                    WifiAPlist_t entry = APlist[x];",
                            "",
                            "                        known = true;",
                            "                                bestNetworkDb = rssi_scan;",
                            "                                bestChannel = chan_scan;",
                            "                                memcpy((void*) &bestNetwork, (void*) &entry, sizeof(bestNetwork));",
                            "                                memcpy((void*) &bestBSSID, (void*) BSSID_scan, sizeof(bestBSSID));"
                        ]
                    },
                    {
                        "line_numbers": [
                            95
                        ],
                        "comments": [],
                        "lines": [
                            "                        break;"
                        ]
                    },
                    {
                        "line_numbers": [
                            97
                        ],
                        "comments": [],
                        "lines": [
                            "                }"
                        ]
                    },
                    {
                        "line_numbers": [
                            99,
                            100,
                            101,
                            102
                        ],
                        "comments": [],
                        "lines": [
                            "                if(known) {",
                            "                    log_d(\" --->   %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\", i, chan_scan, BSSID_scan[0], BSSID_scan[1], BSSID_scan[2], BSSID_scan[3], BSSID_scan[4], BSSID_scan[5], ssid_scan.c_str(), rssi_scan, (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*');",
                            "                } else {",
                            "                    log_d(\"       %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\", i, chan_scan, BSSID_scan[0], BSSID_scan[1], BSSID_scan[2], BSSID_scan[3], BSSID_scan[4], BSSID_scan[5], ssid_scan.c_str(), rssi_scan, (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*');"
                        ]
                    },
                    {
                        "line_numbers": [
                            105
                        ],
                        "comments": [],
                        "lines": [
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            108
                        ],
                        "comments": [],
                        "lines": [
                            "        WiFi.scanDelete();"
                        ]
                    },
                    {
                        "line_numbers": [
                            110,
                            111
                        ],
                        "comments": [],
                        "lines": [
                            "        if(bestNetwork.ssid) {",
                            "            log_i(\"[WIFI] Connecting BSSID: %02X:%02X:%02X:%02X:%02X:%02X SSID: %s Channal: %d (%d)\", bestBSSID[0], bestBSSID[1], bestBSSID[2], bestBSSID[3], bestBSSID[4], bestBSSID[5], bestNetwork.ssid, bestChannel, bestNetworkDb);"
                        ]
                    },
                    {
                        "line_numbers": [
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119
                        ],
                        "comments": [
                            "            // wait for connection, fail, or timeout"
                        ],
                        "lines": [
                            "            WiFi.begin(bestNetwork.ssid, bestNetwork.passphrase, bestChannel, bestBSSID);",
                            "            status = WiFi.status();",
                            "",
                            "            auto startTime = millis();",
                            "            while(status != WL_CONNECTED && status != WL_NO_SSID_AVAIL && status != WL_CONNECT_FAILED && (millis() - startTime) <= connectTimeout) {",
                            "                delay(10);"
                        ]
                    },
                    {
                        "line_numbers": [
                            121
                        ],
                        "comments": [],
                        "lines": [
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139
                        ],
                        "comments": [],
                        "lines": [
                            "            switch(status) {",
                            "            case 3:",
                            "                log_i(\"[WIFI] Connecting done.\");",
                            "                log_d(\"[WIFI] SSID: %s\", WiFi.SSID().c_str());",
                            "                log_d(\"[WIFI] IP: %s\", WiFi.localIP().toString().c_str());",
                            "                log_d(\"[WIFI] MAC: %s\", WiFi.BSSIDstr().c_str());",
                            "                log_d(\"[WIFI] Channel: %d\", WiFi.channel());",
                            "                break;",
                            "            case 1:",
                            "                log_e(\"[WIFI] Connecting Failed AP not found.\");",
                            "                break;",
                            "            case 4:",
                            "                log_e(\"[WIFI] Connecting Failed.\");",
                            "                break;",
                            "            default:",
                            "                log_e(\"[WIFI] Connecting Failed (%d).\", status);",
                            "                break;"
                        ]
                    },
                    {
                        "line_numbers": [
                            142
                        ],
                        "comments": [],
                        "lines": [
                            "            log_e(\"[WIFI] no matching wifi found!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151
                        ],
                        "comments": [
                            "        // start scan",
                            "        // scan wifi async mode"
                        ],
                        "lines": [
                            "    } else {",
                            "        log_d(\"[WIFI] delete old wifi config...\");",
                            "        WiFi.disconnect();",
                            "",
                            "        log_d(\"[WIFI] start scan\");",
                            "        WiFi.scanNetworks(true);"
                        ]
                    },
                    {
                        "line_numbers": [
                            153
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91
                        ],
                        "comments": [
                            "            // scan is running",
                            "            // scan done analyze",
                            "                        if(ssid_scan == entry.ssid) { // SSID match",
                            "                            if(rssi_scan > bestNetworkDb) { // best network",
                            "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan"
                        ],
                        "lines": [
                            "            return WL_NO_SSID_AVAIL;",
                            "        } else if(scanResult > 0) {",
                            "            WifiAPlist_t bestNetwork { NULL, NULL };",
                            "            int bestNetworkDb = INT_MIN;",
                            "            uint8_t bestBSSID[6];",
                            "            int32_t bestChannel = 0;",
                            "",
                            "            log_i(\"[WIFI] scan done\");",
                            "",
                            "            if(scanResult <= 0) {",
                            "                log_e(\"[WIFI] no networks found\");",
                            "            } else {",
                            "                log_i(\"[WIFI] %d networks found\", scanResult);",
                            "                for(int8_t i = 0; i < scanResult; ++i) {",
                            "",
                            "                    String ssid_scan;",
                            "                    int32_t rssi_scan;",
                            "                    uint8_t sec_scan;",
                            "                    uint8_t* BSSID_scan;",
                            "                    int32_t chan_scan;",
                            "",
                            "                    WiFi.getNetworkInfo(i, ssid_scan, sec_scan, rssi_scan, BSSID_scan, chan_scan);",
                            "",
                            "                    bool known = false;",
                            "                    for(uint32_t x = 0; x < APlist.size(); x++) {",
                            "                        WifiAPlist_t entry = APlist[x];",
                            "",
                            "                            known = true;",
                            "                                    bestNetworkDb = rssi_scan;",
                            "                                    bestChannel = chan_scan;",
                            "                                    memcpy((void*) &bestNetwork, (void*) &entry, sizeof(bestNetwork));",
                            "                                    memcpy((void*) &bestBSSID, (void*) BSSID_scan, sizeof(bestBSSID));",
                            "                                }"
                        ]
                    },
                    {
                        "line_numbers": [
                            93
                        ],
                        "comments": [],
                        "lines": [
                            "                            break;"
                        ]
                    },
                    {
                        "line_numbers": [
                            97,
                            98,
                            99,
                            100,
                            101
                        ],
                        "comments": [],
                        "lines": [
                            "                    if(known) {",
                            "                        log_d(\" --->   %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\", i, chan_scan, BSSID_scan[0], BSSID_scan[1], BSSID_scan[2], BSSID_scan[3], BSSID_scan[4], BSSID_scan[5], ssid_scan.c_str(), rssi_scan, (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*');",
                            "                    } else {",
                            "                        log_d(\"       %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\", i, chan_scan, BSSID_scan[0], BSSID_scan[1], BSSID_scan[2], BSSID_scan[3], BSSID_scan[4], BSSID_scan[5], ssid_scan.c_str(), rssi_scan, (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*');",
                            "                    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            106
                        ],
                        "comments": [],
                        "lines": [
                            "            WiFi.scanDelete();"
                        ]
                    },
                    {
                        "line_numbers": [
                            108,
                            109
                        ],
                        "comments": [],
                        "lines": [
                            "            if(bestNetwork.ssid) {",
                            "                log_i(\"[WIFI] Connecting BSSID: %02X:%02X:%02X:%02X:%02X:%02X SSID: %s Channal: %d (%d)\", bestBSSID[0], bestBSSID[1], bestBSSID[2], bestBSSID[3], bestBSSID[4], bestBSSID[5], bestNetwork.ssid, bestChannel, bestNetworkDb);"
                        ]
                    },
                    {
                        "line_numbers": [
                            111
                        ],
                        "comments": [],
                        "lines": [
                            "                WiFi.begin(bestNetwork.ssid, bestNetwork.passphrase, bestChannel, bestBSSID);"
                        ]
                    },
                    {
                        "line_numbers": [
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119
                        ],
                        "comments": [
                            "                // wait for connection, fail, or timeout"
                        ],
                        "lines": [
                            "",
                            "                auto startTime = millis();",
                            "                while(status != WL_CONNECTED && status != WL_NO_SSID_AVAIL && status != WL_CONNECT_FAILED && (millis() - startTime) <= connectTimeout) {",
                            "                    delay(10);",
                            "                    status = WiFi.status();",
                            "                }"
                        ]
                    },
                    {
                        "line_numbers": [
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140
                        ],
                        "comments": [],
                        "lines": [
                            "                switch(status) {",
                            "                case 3:",
                            "                    log_i(\"[WIFI] Connecting done.\");",
                            "                    log_d(\"[WIFI] SSID: %s\", WiFi.SSID().c_str());",
                            "                    log_d(\"[WIFI] IP: %s\", WiFi.localIP().toString().c_str());",
                            "                    log_d(\"[WIFI] MAC: %s\", WiFi.BSSIDstr().c_str());",
                            "                    log_d(\"[WIFI] Channel: %d\", WiFi.channel());",
                            "                    break;",
                            "                case 1:",
                            "                    log_e(\"[WIFI] Connecting Failed AP not found.\");",
                            "                    break;",
                            "                case 4:",
                            "                    log_e(\"[WIFI] Connecting Failed.\");",
                            "                    break;",
                            "                default:",
                            "                    log_e(\"[WIFI] Connecting Failed (%d).\", status);",
                            "                    break;",
                            "                }",
                            "            } else {",
                            "                log_e(\"[WIFI] no matching wifi found!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            144,
                            145,
                            146,
                            147,
                            148,
                            149
                        ],
                        "comments": [
                            "            // scan wifi async mode"
                        ],
                        "lines": [
                            "            log_d(\"[WIFI] delete old wifi config...\");",
                            "            WiFi.disconnect();",
                            "",
                            "            log_d(\"[WIFI] start scan\");",
                            "            WiFi.scanNetworks(true);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "56": "        // scan is running",
                "59": "        // scan done analyze",
                "85": "                    if(ssid_scan == entry.ssid) { // SSID match",
                "87": "                        if(rssi_scan > bestNetworkDb) { // best network",
                "88": "                            if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                "107": "        // clean up ram",
                "117": "            // wait for connection, fail, or timeout",
                "145": "        // start scan",
                "150": "        // scan wifi async mode"
            },
            "comment_deleted_diff": {
                "54": "            // scan is running",
                "57": "            // scan done analyze",
                "83": "                        if(ssid_scan == entry.ssid) { // SSID match",
                "85": "                            if(rssi_scan > bestNetworkDb) { // best network",
                "86": "                                if(sec_scan == WIFI_AUTH_OPEN || entry.passphrase) { // check for passphrase if not open wlan",
                "105": "            // clean up ram",
                "115": "                // wait for connection, fail, or timeout",
                "143": "            // start scan",
                "148": "            // scan wifi async mode"
            },
            "comment_modified_diff": {
                "85": "                            if(rssi_scan > bestNetworkDb) { // best network"
            }
        },
        {
            "commit": "476660f763bf334a194c2f30586a7be8245f9c39",
            "timestamp": "2019-07-09T19:21:01+03:00",
            "author": "Nathan Phillips",
            "commit_message": "Cleanup WiFiMulti (#2955)\n\n* Use macros for switch case labels\r\n\r\n* Fixed spelling error in \"too\"\r\n\r\n* Fix spacing\r\n\r\n* Inline private functions that are only called once",
            "additions": 50,
            "deletions": 65,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85
                        ],
                        "comments": [
                            "        // fail SSID too long or missing!",
                            "        // fail passphrase too long!"
                        ],
                        "lines": [
                            "        log_e(\"[WIFI][APlistAdd] no ssid or ssid too long\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 63) {",
                            "        log_e(\"[WIFI][APlistAdd] passphrase too long\");",
                            "        return false;",
                            "    }",
                            "",
                            "    newAP.ssid = strdup(ssid);",
                            "",
                            "    if(!newAP.ssid) {",
                            "        log_e(\"[WIFI][APlistAdd] fail newAP.ssid == 0\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && *passphrase != 0x00) {",
                            "        newAP.passphrase = strdup(passphrase);",
                            "        if(!newAP.passphrase) {",
                            "            log_e(\"[WIFI][APlistAdd] fail newAP.passphrase == 0\");",
                            "            free(newAP.ssid);",
                            "            return false;",
                            "        }",
                            "    } else {",
                            "        newAP.passphrase = NULL;",
                            "    }",
                            "",
                            "    APlist.push_back(newAP);",
                            "    log_i(\"[WIFI][APlistAdd] add SSID: %s\", newAP.ssid);",
                            "    return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            94
                        ],
                        "comments": [],
                        "lines": [
                            "            if(WiFi.SSID()==APlist[x].ssid) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            164
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            173
                        ],
                        "comments": [],
                        "lines": [
                            "            case WL_CONNECTED:"
                        ]
                    },
                    {
                        "line_numbers": [
                            180
                        ],
                        "comments": [],
                        "lines": [
                            "            case WL_NO_SSID_AVAIL:"
                        ]
                    },
                    {
                        "line_numbers": [
                            183
                        ],
                        "comments": [],
                        "lines": [
                            "            case WL_CONNECT_FAILED:"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219
                        ],
                        "comments": [
                            "// ##################################################################################",
                            "        // fail SSID to long or missing!",
                            "        // fail passphrase to long!"
                        ],
                        "lines": [
                            "",
                            "bool WiFiMulti::APlistAdd(const char* ssid, const char *passphrase)",
                            "{",
                            "",
                            "    WifiAPlist_t newAP;",
                            "",
                            "    if(!ssid || *ssid == 0x00 || strlen(ssid) > 31) {",
                            "        log_e(\"[WIFI][APlistAdd] no ssid or ssid to long\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 63) {",
                            "        log_e(\"[WIFI][APlistAdd] passphrase to long\");",
                            "        return false;",
                            "    }",
                            "",
                            "    newAP.ssid = strdup(ssid);",
                            "",
                            "    if(!newAP.ssid) {",
                            "        log_e(\"[WIFI][APlistAdd] fail newAP.ssid == 0\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(passphrase && *passphrase != 0x00) {",
                            "        newAP.passphrase = strdup(passphrase);",
                            "        if(!newAP.passphrase) {",
                            "            log_e(\"[WIFI][APlistAdd] fail newAP.passphrase == 0\");",
                            "            free(newAP.ssid);",
                            "            return false;",
                            "        }",
                            "    } else {",
                            "        newAP.passphrase = NULL;",
                            "    }",
                            "",
                            "    APlist.push_back(newAP);",
                            "    log_i(\"[WIFI][APlistAdd] add SSID: %s\", newAP.ssid);",
                            "    return true;",
                            "}",
                            "",
                            "void WiFiMulti::APlistClean(void)",
                            "{",
                            "    for(uint32_t i = 0; i < APlist.size(); i++) {",
                            "        WifiAPlist_t entry = APlist[i];",
                            "        if(entry.ssid) {",
                            "            free(entry.ssid);",
                            "        }",
                            "        if(entry.passphrase) {",
                            "            free(entry.passphrase);",
                            "        }",
                            "    }",
                            "    APlist.clear();",
                            "}",
                            ""
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "54": "        // fail SSID too long or missing!",
                "60": "        // fail passphrase too long!"
            },
            "comment_deleted_diff": {
                "164": "// ##################################################################################",
                "172": "        // fail SSID to long or missing!",
                "178": "        // fail passphrase to long!"
            },
            "comment_modified_diff": {}
        }
    ],
    "WiFiMulti.h": [],
    "WiFiSTA.cpp": [
        {
            "commit": "5f3a205955ce7fdb9ae1a4dc60d4ef25c300e901",
            "timestamp": "2016-10-06T07:09:44-06:00",
            "author": "me-no-dev",
            "commit_message": "initial import",
            "additions": 455,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- Private functions ------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- STA function -----------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "        // enable STA failed",
                            "        // fail SSID too long or missing!",
                            "        // fail passphrase too long!",
                            "        // enable STA failed",
                            "        // Set DNS1-Server",
                            "        // Set DNS2-Server"
                        ],
                        "lines": [
                            "",
                            "static bool sta_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs);",
                            "",
                            "",
                            "/**",
                            " * compare two STA configurations",
                            " * @param lhs station_config",
                            " * @param rhs station_config",
                            " * @return equal",
                            " */",
                            "static bool sta_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs)",
                            "{",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.sta.ssid), reinterpret_cast<const char*>(rhs.sta.ssid)) != 0) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.sta.password), reinterpret_cast<const char*>(rhs.sta.password)) != 0) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(lhs.sta.bssid_set != rhs.sta.bssid_set) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(lhs.sta.bssid_set) {",
                            "        if(memcmp(lhs.sta.bssid, rhs.sta.bssid, 6) != 0) {",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "bool WiFiSTAClass::_useStaticIp = false;",
                            "wl_status_t WiFiSTAClass::_status = WL_NO_SHIELD;",
                            "/**",
                            " * Start Wifi connection",
                            " * if passphrase is set the most secure supported mode will be automatically selected",
                            " * @param ssid const char*          Pointer to the SSID string.",
                            " * @param passphrase const char *   Optional. Passphrase. Valid characters in a passphrase must be between ASCII 32-126 (decimal).",
                            " * @param bssid uint8_t[6]          Optional. BSSID / MAC of AP",
                            " * @param channel                   Optional. Channel of AP",
                            " * @param connect                   Optional. call connect",
                            " * @return",
                            " */",
                            "wl_status_t WiFiSTAClass::begin(const char* ssid, const char *passphrase, int32_t channel, const uint8_t* bssid, bool connect)",
                            "{",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    if(!ssid || *ssid == 0x00 || strlen(ssid) > 31) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 63) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    wifi_config_t conf;",
                            "    strcpy(reinterpret_cast<char*>(conf.sta.ssid), ssid);",
                            "",
                            "    if(passphrase) {",
                            "        strcpy(reinterpret_cast<char*>(conf.sta.password), passphrase);",
                            "    } else {",
                            "        *conf.sta.password = 0;",
                            "    }",
                            "",
                            "    if(bssid) {",
                            "        conf.sta.bssid_set = 1;",
                            "        memcpy((void *) &conf.sta.bssid[0], (void *) bssid, 6);",
                            "    } else {",
                            "        conf.sta.bssid_set = 0;",
                            "    }",
                            "",
                            "    wifi_config_t current_conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &current_conf);",
                            "    if(!sta_config_equal(current_conf, conf)) {",
                            "        esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    }",
                            "",
                            "",
                            "",
                            "    if(channel > 0 && channel <= 13) {",
                            "        esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);",
                            "    }",
                            "",
                            "    if(!_useStaticIp) {",
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "    }",
                            "",
                            "    if(connect) {",
                            "        esp_wifi_connect();",
                            "    }",
                            "",
                            "    return status();",
                            "}",
                            "",
                            "wl_status_t WiFiSTAClass::begin(char* ssid, char *passphrase, int32_t channel, const uint8_t* bssid, bool connect)",
                            "{",
                            "    return begin((const char*) ssid, (const char*) passphrase, channel, bssid, connect);",
                            "}",
                            "",
                            "/**",
                            " * Use to connect to SDK config.",
                            " * @return wl_status_t",
                            " */",
                            "wl_status_t WiFiSTAClass::begin()",
                            "{",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "    esp_wifi_start();",
                            "    esp_wifi_connect();",
                            "",
                            "    if(!_useStaticIp) {",
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "    }",
                            "    return status();",
                            "}",
                            "",
                            "void WiFiSTAClass::_setStatus(wl_status_t status)",
                            "{",
                            "    _status = status;",
                            "    //log_i(\"wifi status: %d\", status);",
                            "}",
                            "",
                            "/**",
                            " * Change IP configuration settings disabling the dhcp client",
                            " * @param local_ip   Static ip configuration",
                            " * @param gateway    Static gateway configuration",
                            " * @param subnet     Static Subnet mask",
                            " * @param dns1       Static DNS server 1",
                            " * @param dns2       Static DNS server 2",
                            " */",
                            "bool WiFiSTAClass::config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1, IPAddress dns2)",
                            "{",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    tcpip_adapter_ip_info_t info;",
                            "    info.ip.addr = static_cast<uint32_t>(local_ip);",
                            "    info.gw.addr = static_cast<uint32_t>(gateway);",
                            "    info.netmask.addr = static_cast<uint32_t>(subnet);",
                            "",
                            "    tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA);",
                            "    if(tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_STA, &info)) {",
                            "        _useStaticIp = true;",
                            "    } else {",
                            "        return false;",
                            "    }",
                            "    ip_addr_t d;",
                            "",
                            "    if(dns1 != (uint32_t)0x00000000) {",
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns1);",
                            "        dns_setserver(0, &d);",
                            "    }",
                            "",
                            "    if(dns2 != (uint32_t)0x00000000) {",
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns2);",
                            "        dns_setserver(1, &d);",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "/**",
                            " * will force a disconnect an then start reconnecting to AP",
                            " * @return ok",
                            " */",
                            "bool WiFiSTAClass::reconnect()",
                            "{",
                            "    if((WiFi.getMode() & WIFI_MODE_STA) != 0) {",
                            "        if(esp_wifi_disconnect() == ESP_OK) {",
                            "            return esp_wifi_connect() == ESP_OK;",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * Disconnect from the network",
                            " * @param wifioff",
                            " * @return  one value of wl_status_t enum",
                            " */",
                            "bool WiFiSTAClass::disconnect(bool wifioff)",
                            "{",
                            "    bool ret;",
                            "    wifi_config_t conf;",
                            "    *conf.sta.ssid = 0;",
                            "    *conf.sta.password = 0;",
                            "",
                            "    esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    ret = esp_wifi_set_config(WIFI_IF_STA, &conf) == ESP_OK;",
                            "",
                            "    if(wifioff) {",
                            "        WiFi.enableSTA(false);",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * is STA interface connected?",
                            " * @return true if STA is connected to an AD",
                            " */",
                            "bool WiFiSTAClass::isConnected()",
                            "{",
                            "    return (status() == WL_CONNECTED);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Setting the ESP32 station to connect to the AP (which is recorded)",
                            " * automatically or not when powered on. Enable auto-connect by default.",
                            " * @param autoConnect bool",
                            " * @return if saved",
                            " */",
                            "bool WiFiSTAClass::setAutoConnect(bool autoConnect)",
                            "{",
                            "    bool ret;",
                            "    ret = esp_wifi_set_auto_connect(autoConnect);",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * Checks if ESP32 station mode will connect to AP",
                            " * automatically or not when it is powered on.",
                            " * @return auto connect",
                            " */",
                            "bool WiFiSTAClass::getAutoConnect()",
                            "{",
                            "    bool autoConnect;",
                            "    esp_wifi_get_auto_connect(&autoConnect);",
                            "    return autoConnect;",
                            "}",
                            "",
                            "/**",
                            " * Wait for WiFi connection to reach a result",
                            " * returns the status reached or disconnect if STA is off",
                            " * @return wl_status_t",
                            " */",
                            "uint8_t WiFiSTAClass::waitForConnectResult()",
                            "{",
                            "    //1 and 3 have STA enabled",
                            "    if((WiFiGenericClass::getMode() & WIFI_MODE_STA) == 0) {",
                            "        return WL_DISCONNECTED;",
                            "    }",
                            "    int i = 0;",
                            "    while(status() >= WL_DISCONNECTED && i++ < 100) {",
                            "        delay(100);",
                            "    }",
                            "    return status();",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface IP address.",
                            " * @return IPAddress station IP",
                            " */",
                            "IPAddress WiFiSTAClass::localIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.ip.addr);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the station interface MAC address.",
                            " * @param mac   pointer to uint8_t array with length WL_MAC_ADDR_LENGTH",
                            " * @return      pointer to uint8_t *",
                            " */",
                            "uint8_t* WiFiSTAClass::macAddress(uint8_t* mac)",
                            "{",
                            "    esp_wifi_get_mac(WIFI_IF_STA, mac);",
                            "    return mac;",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface MAC address.",
                            " * @return String mac",
                            " */",
                            "String WiFiSTAClass::macAddress(void)",
                            "{",
                            "    uint8_t mac[6];",
                            "    char macStr[18] = { 0 };",
                            "    esp_wifi_get_mac(WIFI_IF_STA, mac);",
                            "",
                            "    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "    return String(macStr);",
                            "}",
                            "",
                            "/**",
                            " * Get the interface subnet mask address.",
                            " * @return IPAddress subnetMask",
                            " */",
                            "IPAddress WiFiSTAClass::subnetMask()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.netmask.addr);",
                            "}",
                            "",
                            "/**",
                            " * Get the gateway ip address.",
                            " * @return IPAddress gatewayIP",
                            " */",
                            "IPAddress WiFiSTAClass::gatewayIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.gw.addr);",
                            "}",
                            "",
                            "/**",
                            " * Get the DNS ip address.",
                            " * @param dns_no",
                            " * @return IPAddress DNS Server IP",
                            " */",
                            "IPAddress WiFiSTAClass::dnsIP(uint8_t dns_no)",
                            "{",
                            "    ip_addr_t dns_ip = dns_getserver(dns_no);",
                            "    return IPAddress(dns_ip.u_addr.ip4.addr);",
                            "}",
                            "",
                            "/**",
                            " * Return Connection status.",
                            " * @return one of the value defined in wl_status_t",
                            " *",
                            " */",
                            "wl_status_t WiFiSTAClass::status()",
                            "{",
                            "    return WiFiSTAClass::_status;",
                            "}",
                            "",
                            "/**",
                            " * Return the current SSID associated with the network",
                            " * @return SSID",
                            " */",
                            "String WiFiSTAClass::SSID() const",
                            "{",
                            "    wifi_config_t conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &conf);",
                            "    return String(reinterpret_cast<char*>(conf.sta.ssid));",
                            "}",
                            "",
                            "/**",
                            " * Return the current pre shared key associated with the network",
                            " * @return  psk string",
                            " */",
                            "String WiFiSTAClass::psk() const",
                            "{",
                            "    wifi_config_t conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &conf);",
                            "    return String(reinterpret_cast<char*>(conf.sta.password));",
                            "}",
                            "",
                            "/**",
                            " * Return the current bssid / mac associated with the network if configured",
                            " * @return bssid uint8_t *",
                            " */",
                            "uint8_t* WiFiSTAClass::BSSID(void)",
                            "{",
                            "    static uint8_t bssid[6];",
                            "    wifi_config_t conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &conf);",
                            "    memcpy(bssid, conf.sta.bssid, 6);",
                            "    return reinterpret_cast<uint8_t*>(bssid);",
                            "}",
                            "",
                            "/**",
                            " * Return the current bssid / mac associated with the network if configured",
                            " * @return String bssid mac",
                            " */",
                            "String WiFiSTAClass::BSSIDstr(void)",
                            "{",
                            "    char mac[18] = { 0 };",
                            "    wifi_config_t conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &conf);",
                            "    sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", conf.sta.bssid[0], conf.sta.bssid[1], conf.sta.bssid[2], conf.sta.bssid[3], conf.sta.bssid[4], conf.sta.bssid[5]);",
                            "    return String(mac);",
                            "}",
                            "",
                            "/**",
                            " * Return the current network RSSI.",
                            " * @return  RSSI value",
                            " */",
                            "int32_t WiFiSTAClass::RSSI(void)",
                            "{",
                            "    return 0;//wifi_station_get_rssi();",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "48": "// -----------------------------------------------------------------------------------------------------------------------",
                "49": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "50": "// -----------------------------------------------------------------------------------------------------------------------",
                "84": "// -----------------------------------------------------------------------------------------------------------------------",
                "85": "// ---------------------------------------------------- STA function -----------------------------------------------------",
                "86": "// -----------------------------------------------------------------------------------------------------------------------",
                "104": "        // enable STA failed",
                "109": "        // fail SSID too long or missing!",
                "114": "        // fail passphrase too long!",
                "170": "        // enable STA failed",
                "217": "        // Set DNS1-Server",
                "223": "        // Set DNS2-Server"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "79e5d4c40da01306bfc03aa7150440d1fcb65f41",
            "timestamp": "2017-12-04T17:46:49+01:00",
            "author": "Masaki Koyanagi",
            "commit_message": "Allow PSK instead of passphrase in WiFiSTA::begin (#897)",
            "additions": 5,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            122,
                            123,
                            124,
                            125
                        ],
                        "comments": [
                            "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK"
                        ],
                        "lines": [
                            "            memcpy(reinterpret_cast<char*>(conf.sta.password), passphrase, 64);",
                            "        else",
                            "            strcpy(reinterpret_cast<char*>(conf.sta.password), passphrase);"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "122": "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "c92b61739743e6df0768bbcba1e0b53755ec91d8",
            "timestamp": "2018-04-16T16:34:39+02:00",
            "author": "Craig Leres",
            "commit_message": "Convert the few remaining cr/lf files to use lf for eol. (#1316)\n\nIf you develop on windows and need cr/lf files, see this:\r\n\r\n    https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_formatting_and_whitespace\r\n\r\n    Git can handle this by auto-converting CRLF line endings into LF\r\n    when you add a file to the index, and vice versa when it checks out\r\n    code onto your filesystem. You can turn on this functionality with\r\n    the core.autocrlf setting. If you're on a Windows machine, set it\r\n    to true - this converts LF endings into CRLF when you check out code:\r\n\r\n    $ git config --global core.autocrlf true",
            "additions": 642,
            "deletions": 642,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- Private functions ------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- STA function -----------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "        // enable STA failed",
                            "        // fail SSID too long or missing!",
                            "        // fail passphrase too long!",
                            "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK",
                            "        // enable STA failed",
                            "        // Set DNS1-Server",
                            "        // Set DNS2-Server"
                        ],
                        "lines": [
                            "",
                            "static bool sta_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs);",
                            "",
                            "",
                            "/**",
                            " * compare two STA configurations",
                            " * @param lhs station_config",
                            " * @param rhs station_config",
                            " * @return equal",
                            " */",
                            "static bool sta_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs)",
                            "{",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.sta.ssid), reinterpret_cast<const char*>(rhs.sta.ssid)) != 0) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.sta.password), reinterpret_cast<const char*>(rhs.sta.password)) != 0) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(lhs.sta.bssid_set != rhs.sta.bssid_set) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(lhs.sta.bssid_set) {",
                            "        if(memcmp(lhs.sta.bssid, rhs.sta.bssid, 6) != 0) {",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "bool WiFiSTAClass::_autoReconnect = true;",
                            "bool WiFiSTAClass::_useStaticIp = false;",
                            "wl_status_t WiFiSTAClass::_status = WL_NO_SHIELD;",
                            "/**",
                            " * Start Wifi connection",
                            " * if passphrase is set the most secure supported mode will be automatically selected",
                            " * @param ssid const char*          Pointer to the SSID string.",
                            " * @param passphrase const char *   Optional. Passphrase. Valid characters in a passphrase must be between ASCII 32-126 (decimal).",
                            " * @param bssid uint8_t[6]          Optional. BSSID / MAC of AP",
                            " * @param channel                   Optional. Channel of AP",
                            " * @param connect                   Optional. call connect",
                            " * @return",
                            " */",
                            "wl_status_t WiFiSTAClass::begin(const char* ssid, const char *passphrase, int32_t channel, const uint8_t* bssid, bool connect)",
                            "{",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    if(!ssid || *ssid == 0x00 || strlen(ssid) > 31) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 64) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    wifi_config_t conf;",
                            "    strcpy(reinterpret_cast<char*>(conf.sta.ssid), ssid);",
                            "",
                            "    if(passphrase) {",
                            "            memcpy(reinterpret_cast<char*>(conf.sta.password), passphrase, 64);",
                            "        else",
                            "            strcpy(reinterpret_cast<char*>(conf.sta.password), passphrase);",
                            "    } else {",
                            "        *conf.sta.password = 0;",
                            "    }",
                            "",
                            "    if(bssid) {",
                            "        conf.sta.bssid_set = 1;",
                            "        memcpy((void *) &conf.sta.bssid[0], (void *) bssid, 6);",
                            "    } else {",
                            "        conf.sta.bssid_set = 0;",
                            "    }",
                            "",
                            "    wifi_config_t current_conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &current_conf);",
                            "    if(!sta_config_equal(current_conf, conf)) {",
                            "        esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    }",
                            "",
                            "    if(channel > 0 && channel <= 13) {",
                            "        esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);",
                            "    }",
                            "",
                            "    esp_wifi_start();",
                            "    if(connect) {",
                            "        esp_wifi_connect();",
                            "    }",
                            "",
                            "    if(!_useStaticIp) {",
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "    } else {",
                            "        tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA);",
                            "    }",
                            "",
                            "    return status();",
                            "}",
                            "",
                            "wl_status_t WiFiSTAClass::begin(char* ssid, char *passphrase, int32_t channel, const uint8_t* bssid, bool connect)",
                            "{",
                            "    return begin((const char*) ssid, (const char*) passphrase, channel, bssid, connect);",
                            "}",
                            "",
                            "/**",
                            " * Use to connect to SDK config.",
                            " * @return wl_status_t",
                            " */",
                            "wl_status_t WiFiSTAClass::begin()",
                            "{",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "    esp_wifi_start();",
                            "    esp_wifi_connect();",
                            "",
                            "    if(!_useStaticIp) {",
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "    } else {",
                            "        tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA);",
                            "    }",
                            "",
                            "    return status();",
                            "}",
                            "",
                            "void WiFiSTAClass::_setStatus(wl_status_t status)",
                            "{",
                            "    _status = status;",
                            "    //log_i(\"wifi status: %d\", status);",
                            "}",
                            "",
                            "/**",
                            " * Change IP configuration settings disabling the dhcp client",
                            " * @param local_ip   Static ip configuration",
                            " * @param gateway    Static gateway configuration",
                            " * @param subnet     Static Subnet mask",
                            " * @param dns1       Static DNS server 1",
                            " * @param dns2       Static DNS server 2",
                            " */",
                            "bool WiFiSTAClass::config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1, IPAddress dns2)",
                            "{",
                            "    esp_err_t err = ESP_OK;",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return false;",
                            "    }",
                            "    esp_wifi_start();",
                            "",
                            "    tcpip_adapter_ip_info_t info;",
                            "",
                            "    if(local_ip != (uint32_t)0x00000000){",
                            "        info.ip.addr = static_cast<uint32_t>(local_ip);",
                            "        info.gw.addr = static_cast<uint32_t>(gateway);",
                            "        info.netmask.addr = static_cast<uint32_t>(subnet);",
                            "    } else {",
                            "        info.ip.addr = 0;",
                            "        info.gw.addr = 0;",
                            "        info.netmask.addr = 0;",
                            "    }",
                            "",
                            "    err = tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA);",
                            "    if(err != ESP_OK && err != ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED){",
                            "        log_e(\"DHCP could not be stopped! Error: %d\", err);",
                            "        return false;",
                            "    }",
                            "",
                            "    err = tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_STA, &info);",
                            "    if(err != ERR_OK){",
                            "        log_e(\"STA IP could not be configured! Error: %d\", err);",
                            "        return false;",
                            "    }",
                            "",
                            "    if(info.ip.addr){",
                            "        _useStaticIp = true;",
                            "    } else {",
                            "        err = tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "        if(err != ESP_OK && err != ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED){",
                            "            log_w(\"DHCP could not be started! Error: %d\", err);",
                            "            return false;",
                            "        }",
                            "        _useStaticIp = false;",
                            "    }",
                            "",
                            "    ip_addr_t d;",
                            "    d.type = IPADDR_TYPE_V4;",
                            "",
                            "    if(dns1 != (uint32_t)0x00000000) {",
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns1);",
                            "        dns_setserver(0, &d);",
                            "    }",
                            "",
                            "    if(dns2 != (uint32_t)0x00000000) {",
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns2);",
                            "        dns_setserver(1, &d);",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "/**",
                            " * will force a disconnect an then start reconnecting to AP",
                            " * @return ok",
                            " */",
                            "bool WiFiSTAClass::reconnect()",
                            "{",
                            "    if((WiFi.getMode() & WIFI_MODE_STA) != 0) {",
                            "        if(esp_wifi_disconnect() == ESP_OK) {",
                            "            return esp_wifi_connect() == ESP_OK;",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * Disconnect from the network",
                            " * @param wifioff",
                            " * @return  one value of wl_status_t enum",
                            " */",
                            "bool WiFiSTAClass::disconnect(bool wifioff)",
                            "{",
                            "    bool ret;",
                            "    wifi_config_t conf;",
                            "    *conf.sta.ssid = 0;",
                            "    *conf.sta.password = 0;",
                            "",
                            "    WiFi.getMode();",
                            "    esp_wifi_start();",
                            "    esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    ret = esp_wifi_disconnect() == ESP_OK;",
                            "",
                            "    if(wifioff) {",
                            "        WiFi.enableSTA(false);",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * is STA interface connected?",
                            " * @return true if STA is connected to an AD",
                            " */",
                            "bool WiFiSTAClass::isConnected()",
                            "{",
                            "    return (status() == WL_CONNECTED);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Setting the ESP32 station to connect to the AP (which is recorded)",
                            " * automatically or not when powered on. Enable auto-connect by default.",
                            " * @param autoConnect bool",
                            " * @return if saved",
                            " */",
                            "bool WiFiSTAClass::setAutoConnect(bool autoConnect)",
                            "{",
                            "    bool ret;",
                            "    ret = esp_wifi_set_auto_connect(autoConnect);",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * Checks if ESP32 station mode will connect to AP",
                            " * automatically or not when it is powered on.",
                            " * @return auto connect",
                            " */",
                            "bool WiFiSTAClass::getAutoConnect()",
                            "{",
                            "    bool autoConnect;",
                            "    esp_wifi_get_auto_connect(&autoConnect);",
                            "    return autoConnect;",
                            "}",
                            "",
                            "bool WiFiSTAClass::setAutoReconnect(bool autoReconnect)",
                            "{",
                            "    _autoReconnect = autoReconnect;",
                            "    return true;",
                            "}",
                            "",
                            "bool WiFiSTAClass::getAutoReconnect()",
                            "{",
                            "    return _autoReconnect;",
                            "}",
                            "",
                            "/**",
                            " * Wait for WiFi connection to reach a result",
                            " * returns the status reached or disconnect if STA is off",
                            " * @return wl_status_t",
                            " */",
                            "uint8_t WiFiSTAClass::waitForConnectResult()",
                            "{",
                            "    //1 and 3 have STA enabled",
                            "    if((WiFiGenericClass::getMode() & WIFI_MODE_STA) == 0) {",
                            "        return WL_DISCONNECTED;",
                            "    }",
                            "    int i = 0;",
                            "    while((!status() || status() >= WL_DISCONNECTED) && i++ < 100) {",
                            "        delay(100);",
                            "    }",
                            "    return status();",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface IP address.",
                            " * @return IPAddress station IP",
                            " */",
                            "IPAddress WiFiSTAClass::localIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.ip.addr);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the station interface MAC address.",
                            " * @param mac   pointer to uint8_t array with length WL_MAC_ADDR_LENGTH",
                            " * @return      pointer to uint8_t *",
                            " */",
                            "uint8_t* WiFiSTAClass::macAddress(uint8_t* mac)",
                            "{",
                            "    esp_wifi_get_mac(WIFI_IF_STA, mac);",
                            "    return mac;",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface MAC address.",
                            " * @return String mac",
                            " */",
                            "String WiFiSTAClass::macAddress(void)",
                            "{",
                            "    uint8_t mac[6];",
                            "    char macStr[18] = { 0 };",
                            "    esp_wifi_get_mac(WIFI_IF_STA, mac);",
                            "",
                            "    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "    return String(macStr);",
                            "}",
                            "",
                            "/**",
                            " * Get the interface subnet mask address.",
                            " * @return IPAddress subnetMask",
                            " */",
                            "IPAddress WiFiSTAClass::subnetMask()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.netmask.addr);",
                            "}",
                            "",
                            "/**",
                            " * Get the gateway ip address.",
                            " * @return IPAddress gatewayIP",
                            " */",
                            "IPAddress WiFiSTAClass::gatewayIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.gw.addr);",
                            "}",
                            "",
                            "/**",
                            " * Get the DNS ip address.",
                            " * @param dns_no",
                            " * @return IPAddress DNS Server IP",
                            " */",
                            "IPAddress WiFiSTAClass::dnsIP(uint8_t dns_no)",
                            "{",
                            "    ip_addr_t dns_ip = dns_getserver(dns_no);",
                            "    return IPAddress(dns_ip.u_addr.ip4.addr);",
                            "}",
                            "",
                            "/**",
                            " * Return Connection status.",
                            " * @return one of the value defined in wl_status_t",
                            " *",
                            " */",
                            "wl_status_t WiFiSTAClass::status()",
                            "{",
                            "    return WiFiSTAClass::_status;",
                            "}",
                            "",
                            "/**",
                            " * Return the current SSID associated with the network",
                            " * @return SSID",
                            " */",
                            "String WiFiSTAClass::SSID() const",
                            "{",
                            "    wifi_ap_record_t info;",
                            "    if(!esp_wifi_sta_get_ap_info(&info)) {",
                            "        return String(reinterpret_cast<char*>(info.ssid));",
                            "    }",
                            "    return String();",
                            "}",
                            "",
                            "/**",
                            " * Return the current pre shared key associated with the network",
                            " * @return  psk string",
                            " */",
                            "String WiFiSTAClass::psk() const",
                            "{",
                            "    wifi_config_t conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &conf);",
                            "    return String(reinterpret_cast<char*>(conf.sta.password));",
                            "}",
                            "",
                            "/**",
                            " * Return the current bssid / mac associated with the network if configured",
                            " * @return bssid uint8_t *",
                            " */",
                            "uint8_t* WiFiSTAClass::BSSID(void)",
                            "{",
                            "    static uint8_t bssid[6];",
                            "    wifi_ap_record_t info;",
                            "    if(!esp_wifi_sta_get_ap_info(&info)) {",
                            "        memcpy(bssid, info.bssid, 6);",
                            "        return reinterpret_cast<uint8_t*>(bssid);",
                            "    }",
                            "    return NULL;",
                            "}",
                            "",
                            "/**",
                            " * Return the current bssid / mac associated with the network if configured",
                            " * @return String bssid mac",
                            " */",
                            "String WiFiSTAClass::BSSIDstr(void)",
                            "{",
                            "    uint8_t* bssid = BSSID();",
                            "    if(!bssid){",
                            "        return String();",
                            "    }",
                            "    char mac[18] = { 0 };",
                            "    sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);",
                            "    return String(mac);",
                            "}",
                            "",
                            "/**",
                            " * Return the current network RSSI.",
                            " * @return  RSSI value",
                            " */",
                            "int8_t WiFiSTAClass::RSSI(void)",
                            "{",
                            "    wifi_ap_record_t info;",
                            "    if(!esp_wifi_sta_get_ap_info(&info)) {",
                            "        return info.rssi;",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface Host name.",
                            " * @return char array hostname",
                            " */",
                            "const char * WiFiSTAClass::getHostname()",
                            "{",
                            "    const char * hostname;",
                            "    if(tcpip_adapter_get_hostname(TCPIP_ADAPTER_IF_STA, &hostname)){",
                            "        return NULL;",
                            "    }",
                            "    return hostname;",
                            "}",
                            "",
                            "/**",
                            " * Set the station interface Host name.",
                            " * @param  hostname  pointer to const string",
                            " * @return true on   success",
                            " */",
                            "bool WiFiSTAClass::setHostname(const char * hostname)",
                            "{",
                            "    return tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_STA, hostname) == 0;",
                            "}",
                            "",
                            "/**",
                            " * Enable IPv6 on the station interface.",
                            " * @return true on success",
                            " */",
                            "bool WiFiSTAClass::enableIpV6()",
                            "{",
                            "    return tcpip_adapter_create_ip6_linklocal(TCPIP_ADAPTER_IF_STA) == 0;",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface IPv6 address.",
                            " * @return IPv6Address",
                            " */",
                            "IPv6Address WiFiSTAClass::localIPv6()",
                            "{",
                            "    static ip6_addr_t addr;",
                            "    if(tcpip_adapter_get_ip6_linklocal(TCPIP_ADAPTER_IF_STA, &addr)){",
                            "        return IPv6Address();",
                            "    }",
                            "    return IPv6Address(addr.addr);",
                            "}",
                            "",
                            "",
                            "bool WiFiSTAClass::_smartConfigStarted = false;",
                            "bool WiFiSTAClass::_smartConfigDone = false;",
                            "",
                            "",
                            "bool WiFiSTAClass::beginSmartConfig() {",
                            "    if (_smartConfigStarted) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if (!WiFi.mode(WIFI_STA)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_wifi_disconnect();",
                            "",
                            "    esp_err_t err;",
                            "    err = esp_smartconfig_start(reinterpret_cast<sc_callback_t>(&WiFiSTAClass::_smartConfigCallback), 1);",
                            "    if (err == ESP_OK) {",
                            "        _smartConfigStarted = true;",
                            "        _smartConfigDone = false;",
                            "        return true;",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "bool WiFiSTAClass::stopSmartConfig() {",
                            "    if (!_smartConfigStarted) {",
                            "        return true;",
                            "    }",
                            "",
                            "    if (esp_smartconfig_stop() == ESP_OK) {",
                            "        _smartConfigStarted = false;",
                            "        return true;",
                            "    }",
                            "",
                            "    return false;",
                            "}",
                            "",
                            "bool WiFiSTAClass::smartConfigDone() {",
                            "    if (!_smartConfigStarted) {",
                            "        return false;",
                            "    }",
                            "",
                            "    return _smartConfigDone;",
                            "}",
                            "",
                            "#if ARDUHAL_LOG_LEVEL >= ARDUHAL_LOG_LEVEL_DEBUG",
                            "const char * sc_status_strings[] = {",
                            "    \"WAIT\",",
                            "    \"FIND_CHANNEL\",",
                            "    \"GETTING_SSID_PSWD\",",
                            "    \"LINK\",",
                            "    \"LINK_OVER\"",
                            "};",
                            "",
                            "const char * sc_type_strings[] = {",
                            "    \"ESPTOUCH\",",
                            "    \"AIRKISS\",",
                            "    \"ESPTOUCH_AIRKISS\"",
                            "};",
                            "#endif",
                            "",
                            "void WiFiSTAClass::_smartConfigCallback(uint32_t st, void* result) {",
                            "    smartconfig_status_t status = (smartconfig_status_t) st;",
                            "    log_d(\"Status: %s\", sc_status_strings[st % 5]);",
                            "    if (status == SC_STATUS_GETTING_SSID_PSWD) {",
                            "        smartconfig_type_t * type = (smartconfig_type_t *)result;",
                            "        log_d(\"Type: %s\", sc_type_strings[*type % 3]);",
                            "    } else if (status == SC_STATUS_LINK) {",
                            "        wifi_sta_config_t *sta_conf = reinterpret_cast<wifi_sta_config_t *>(result);",
                            "        log_d(\"SSID: %s\", (char *)(sta_conf->ssid));",
                            "        sta_conf->bssid_set = 0;",
                            "        esp_wifi_set_config(WIFI_IF_STA, (wifi_config_t *)sta_conf);",
                            "        esp_wifi_connect();",
                            "        _smartConfigDone = true;",
                            "    } else if (status == SC_STATUS_LINK_OVER) {",
                            "        if(result){",
                            "            ip4_addr_t * ip = (ip4_addr_t *)result;",
                            "            log_d(\"Sender IP: \" IPSTR, IP2STR(ip));",
                            "        }",
                            "        WiFi.stopSmartConfig();",
                            "    }",
                            "}"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642
                        ],
                        "comments": [
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- Private functions ------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "// ---------------------------------------------------- STA function -----------------------------------------------------",
                            "// -----------------------------------------------------------------------------------------------------------------------",
                            "        // enable STA failed",
                            "        // fail SSID too long or missing!",
                            "        // fail passphrase too long!",
                            "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK",
                            "        // enable STA failed",
                            "        // Set DNS1-Server",
                            "        // Set DNS2-Server"
                        ],
                        "lines": [
                            "",
                            "static bool sta_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs);",
                            "",
                            "",
                            "/**",
                            " * compare two STA configurations",
                            " * @param lhs station_config",
                            " * @param rhs station_config",
                            " * @return equal",
                            " */",
                            "static bool sta_config_equal(const wifi_config_t& lhs, const wifi_config_t& rhs)",
                            "{",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.sta.ssid), reinterpret_cast<const char*>(rhs.sta.ssid)) != 0) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(strcmp(reinterpret_cast<const char*>(lhs.sta.password), reinterpret_cast<const char*>(rhs.sta.password)) != 0) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(lhs.sta.bssid_set != rhs.sta.bssid_set) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(lhs.sta.bssid_set) {",
                            "        if(memcmp(lhs.sta.bssid, rhs.sta.bssid, 6) != 0) {",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "bool WiFiSTAClass::_autoReconnect = true;",
                            "bool WiFiSTAClass::_useStaticIp = false;",
                            "wl_status_t WiFiSTAClass::_status = WL_NO_SHIELD;",
                            "/**",
                            " * Start Wifi connection",
                            " * if passphrase is set the most secure supported mode will be automatically selected",
                            " * @param ssid const char*          Pointer to the SSID string.",
                            " * @param passphrase const char *   Optional. Passphrase. Valid characters in a passphrase must be between ASCII 32-126 (decimal).",
                            " * @param bssid uint8_t[6]          Optional. BSSID / MAC of AP",
                            " * @param channel                   Optional. Channel of AP",
                            " * @param connect                   Optional. call connect",
                            " * @return",
                            " */",
                            "wl_status_t WiFiSTAClass::begin(const char* ssid, const char *passphrase, int32_t channel, const uint8_t* bssid, bool connect)",
                            "{",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    if(!ssid || *ssid == 0x00 || strlen(ssid) > 31) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    if(passphrase && strlen(passphrase) > 64) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "",
                            "    wifi_config_t conf;",
                            "    strcpy(reinterpret_cast<char*>(conf.sta.ssid), ssid);",
                            "",
                            "    if(passphrase) {",
                            "            memcpy(reinterpret_cast<char*>(conf.sta.password), passphrase, 64);",
                            "        else",
                            "            strcpy(reinterpret_cast<char*>(conf.sta.password), passphrase);",
                            "    } else {",
                            "        *conf.sta.password = 0;",
                            "    }",
                            "",
                            "    if(bssid) {",
                            "        conf.sta.bssid_set = 1;",
                            "        memcpy((void *) &conf.sta.bssid[0], (void *) bssid, 6);",
                            "    } else {",
                            "        conf.sta.bssid_set = 0;",
                            "    }",
                            "",
                            "    wifi_config_t current_conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &current_conf);",
                            "    if(!sta_config_equal(current_conf, conf)) {",
                            "        esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    }",
                            "",
                            "    if(channel > 0 && channel <= 13) {",
                            "        esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);",
                            "    }",
                            "",
                            "    esp_wifi_start();",
                            "    if(connect) {",
                            "        esp_wifi_connect();",
                            "    }",
                            "",
                            "    if(!_useStaticIp) {",
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "    } else {",
                            "        tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA);",
                            "    }",
                            "",
                            "    return status();",
                            "}",
                            "",
                            "wl_status_t WiFiSTAClass::begin(char* ssid, char *passphrase, int32_t channel, const uint8_t* bssid, bool connect)",
                            "{",
                            "    return begin((const char*) ssid, (const char*) passphrase, channel, bssid, connect);",
                            "}",
                            "",
                            "/**",
                            " * Use to connect to SDK config.",
                            " * @return wl_status_t",
                            " */",
                            "wl_status_t WiFiSTAClass::begin()",
                            "{",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            "    esp_wifi_start();",
                            "    esp_wifi_connect();",
                            "",
                            "    if(!_useStaticIp) {",
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "    } else {",
                            "        tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA);",
                            "    }",
                            "",
                            "    return status();",
                            "}",
                            "",
                            "void WiFiSTAClass::_setStatus(wl_status_t status)",
                            "{",
                            "    _status = status;",
                            "    //log_i(\"wifi status: %d\", status);",
                            "}",
                            "",
                            "/**",
                            " * Change IP configuration settings disabling the dhcp client",
                            " * @param local_ip   Static ip configuration",
                            " * @param gateway    Static gateway configuration",
                            " * @param subnet     Static Subnet mask",
                            " * @param dns1       Static DNS server 1",
                            " * @param dns2       Static DNS server 2",
                            " */",
                            "bool WiFiSTAClass::config(IPAddress local_ip, IPAddress gateway, IPAddress subnet, IPAddress dns1, IPAddress dns2)",
                            "{",
                            "    esp_err_t err = ESP_OK;",
                            "",
                            "    if(!WiFi.enableSTA(true)) {",
                            "        return false;",
                            "    }",
                            "    esp_wifi_start();",
                            "",
                            "    tcpip_adapter_ip_info_t info;",
                            "",
                            "    if(local_ip != (uint32_t)0x00000000){",
                            "        info.ip.addr = static_cast<uint32_t>(local_ip);",
                            "        info.gw.addr = static_cast<uint32_t>(gateway);",
                            "        info.netmask.addr = static_cast<uint32_t>(subnet);",
                            "    } else {",
                            "        info.ip.addr = 0;",
                            "        info.gw.addr = 0;",
                            "        info.netmask.addr = 0;",
                            "    }",
                            "",
                            "    err = tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA);",
                            "    if(err != ESP_OK && err != ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED){",
                            "        log_e(\"DHCP could not be stopped! Error: %d\", err);",
                            "        return false;",
                            "    }",
                            "",
                            "    err = tcpip_adapter_set_ip_info(TCPIP_ADAPTER_IF_STA, &info);",
                            "    if(err != ERR_OK){",
                            "        log_e(\"STA IP could not be configured! Error: %d\", err);",
                            "        return false;",
                            "    }",
                            "",
                            "    if(info.ip.addr){",
                            "        _useStaticIp = true;",
                            "    } else {",
                            "        err = tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);",
                            "        if(err != ESP_OK && err != ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED){",
                            "            log_w(\"DHCP could not be started! Error: %d\", err);",
                            "            return false;",
                            "        }",
                            "        _useStaticIp = false;",
                            "    }",
                            "",
                            "    ip_addr_t d;",
                            "    d.type = IPADDR_TYPE_V4;",
                            "",
                            "    if(dns1 != (uint32_t)0x00000000) {",
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns1);",
                            "        dns_setserver(0, &d);",
                            "    }",
                            "",
                            "    if(dns2 != (uint32_t)0x00000000) {",
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns2);",
                            "        dns_setserver(1, &d);",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "/**",
                            " * will force a disconnect an then start reconnecting to AP",
                            " * @return ok",
                            " */",
                            "bool WiFiSTAClass::reconnect()",
                            "{",
                            "    if((WiFi.getMode() & WIFI_MODE_STA) != 0) {",
                            "        if(esp_wifi_disconnect() == ESP_OK) {",
                            "            return esp_wifi_connect() == ESP_OK;",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * Disconnect from the network",
                            " * @param wifioff",
                            " * @return  one value of wl_status_t enum",
                            " */",
                            "bool WiFiSTAClass::disconnect(bool wifioff)",
                            "{",
                            "    bool ret;",
                            "    wifi_config_t conf;",
                            "    *conf.sta.ssid = 0;",
                            "    *conf.sta.password = 0;",
                            "",
                            "    WiFi.getMode();",
                            "    esp_wifi_start();",
                            "    esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    ret = esp_wifi_disconnect() == ESP_OK;",
                            "",
                            "    if(wifioff) {",
                            "        WiFi.enableSTA(false);",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * is STA interface connected?",
                            " * @return true if STA is connected to an AD",
                            " */",
                            "bool WiFiSTAClass::isConnected()",
                            "{",
                            "    return (status() == WL_CONNECTED);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Setting the ESP32 station to connect to the AP (which is recorded)",
                            " * automatically or not when powered on. Enable auto-connect by default.",
                            " * @param autoConnect bool",
                            " * @return if saved",
                            " */",
                            "bool WiFiSTAClass::setAutoConnect(bool autoConnect)",
                            "{",
                            "    bool ret;",
                            "    ret = esp_wifi_set_auto_connect(autoConnect);",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * Checks if ESP32 station mode will connect to AP",
                            " * automatically or not when it is powered on.",
                            " * @return auto connect",
                            " */",
                            "bool WiFiSTAClass::getAutoConnect()",
                            "{",
                            "    bool autoConnect;",
                            "    esp_wifi_get_auto_connect(&autoConnect);",
                            "    return autoConnect;",
                            "}",
                            "",
                            "bool WiFiSTAClass::setAutoReconnect(bool autoReconnect)",
                            "{",
                            "    _autoReconnect = autoReconnect;",
                            "    return true;",
                            "}",
                            "",
                            "bool WiFiSTAClass::getAutoReconnect()",
                            "{",
                            "    return _autoReconnect;",
                            "}",
                            "",
                            "/**",
                            " * Wait for WiFi connection to reach a result",
                            " * returns the status reached or disconnect if STA is off",
                            " * @return wl_status_t",
                            " */",
                            "uint8_t WiFiSTAClass::waitForConnectResult()",
                            "{",
                            "    //1 and 3 have STA enabled",
                            "    if((WiFiGenericClass::getMode() & WIFI_MODE_STA) == 0) {",
                            "        return WL_DISCONNECTED;",
                            "    }",
                            "    int i = 0;",
                            "    while((!status() || status() >= WL_DISCONNECTED) && i++ < 100) {",
                            "        delay(100);",
                            "    }",
                            "    return status();",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface IP address.",
                            " * @return IPAddress station IP",
                            " */",
                            "IPAddress WiFiSTAClass::localIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.ip.addr);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Get the station interface MAC address.",
                            " * @param mac   pointer to uint8_t array with length WL_MAC_ADDR_LENGTH",
                            " * @return      pointer to uint8_t *",
                            " */",
                            "uint8_t* WiFiSTAClass::macAddress(uint8_t* mac)",
                            "{",
                            "    esp_wifi_get_mac(WIFI_IF_STA, mac);",
                            "    return mac;",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface MAC address.",
                            " * @return String mac",
                            " */",
                            "String WiFiSTAClass::macAddress(void)",
                            "{",
                            "    uint8_t mac[6];",
                            "    char macStr[18] = { 0 };",
                            "    esp_wifi_get_mac(WIFI_IF_STA, mac);",
                            "",
                            "    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "    return String(macStr);",
                            "}",
                            "",
                            "/**",
                            " * Get the interface subnet mask address.",
                            " * @return IPAddress subnetMask",
                            " */",
                            "IPAddress WiFiSTAClass::subnetMask()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.netmask.addr);",
                            "}",
                            "",
                            "/**",
                            " * Get the gateway ip address.",
                            " * @return IPAddress gatewayIP",
                            " */",
                            "IPAddress WiFiSTAClass::gatewayIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip);",
                            "    return IPAddress(ip.gw.addr);",
                            "}",
                            "",
                            "/**",
                            " * Get the DNS ip address.",
                            " * @param dns_no",
                            " * @return IPAddress DNS Server IP",
                            " */",
                            "IPAddress WiFiSTAClass::dnsIP(uint8_t dns_no)",
                            "{",
                            "    ip_addr_t dns_ip = dns_getserver(dns_no);",
                            "    return IPAddress(dns_ip.u_addr.ip4.addr);",
                            "}",
                            "",
                            "/**",
                            " * Return Connection status.",
                            " * @return one of the value defined in wl_status_t",
                            " *",
                            " */",
                            "wl_status_t WiFiSTAClass::status()",
                            "{",
                            "    return WiFiSTAClass::_status;",
                            "}",
                            "",
                            "/**",
                            " * Return the current SSID associated with the network",
                            " * @return SSID",
                            " */",
                            "String WiFiSTAClass::SSID() const",
                            "{",
                            "    wifi_ap_record_t info;",
                            "    if(!esp_wifi_sta_get_ap_info(&info)) {",
                            "        return String(reinterpret_cast<char*>(info.ssid));",
                            "    }",
                            "    return String();",
                            "}",
                            "",
                            "/**",
                            " * Return the current pre shared key associated with the network",
                            " * @return  psk string",
                            " */",
                            "String WiFiSTAClass::psk() const",
                            "{",
                            "    wifi_config_t conf;",
                            "    esp_wifi_get_config(WIFI_IF_STA, &conf);",
                            "    return String(reinterpret_cast<char*>(conf.sta.password));",
                            "}",
                            "",
                            "/**",
                            " * Return the current bssid / mac associated with the network if configured",
                            " * @return bssid uint8_t *",
                            " */",
                            "uint8_t* WiFiSTAClass::BSSID(void)",
                            "{",
                            "    static uint8_t bssid[6];",
                            "    wifi_ap_record_t info;",
                            "    if(!esp_wifi_sta_get_ap_info(&info)) {",
                            "        memcpy(bssid, info.bssid, 6);",
                            "        return reinterpret_cast<uint8_t*>(bssid);",
                            "    }",
                            "    return NULL;",
                            "}",
                            "",
                            "/**",
                            " * Return the current bssid / mac associated with the network if configured",
                            " * @return String bssid mac",
                            " */",
                            "String WiFiSTAClass::BSSIDstr(void)",
                            "{",
                            "    uint8_t* bssid = BSSID();",
                            "    if(!bssid){",
                            "        return String();",
                            "    }",
                            "    char mac[18] = { 0 };",
                            "    sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);",
                            "    return String(mac);",
                            "}",
                            "",
                            "/**",
                            " * Return the current network RSSI.",
                            " * @return  RSSI value",
                            " */",
                            "int8_t WiFiSTAClass::RSSI(void)",
                            "{",
                            "    wifi_ap_record_t info;",
                            "    if(!esp_wifi_sta_get_ap_info(&info)) {",
                            "        return info.rssi;",
                            "    }",
                            "    return 0;",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface Host name.",
                            " * @return char array hostname",
                            " */",
                            "const char * WiFiSTAClass::getHostname()",
                            "{",
                            "    const char * hostname;",
                            "    if(tcpip_adapter_get_hostname(TCPIP_ADAPTER_IF_STA, &hostname)){",
                            "        return NULL;",
                            "    }",
                            "    return hostname;",
                            "}",
                            "",
                            "/**",
                            " * Set the station interface Host name.",
                            " * @param  hostname  pointer to const string",
                            " * @return true on   success",
                            " */",
                            "bool WiFiSTAClass::setHostname(const char * hostname)",
                            "{",
                            "    return tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_STA, hostname) == 0;",
                            "}",
                            "",
                            "/**",
                            " * Enable IPv6 on the station interface.",
                            " * @return true on success",
                            " */",
                            "bool WiFiSTAClass::enableIpV6()",
                            "{",
                            "    return tcpip_adapter_create_ip6_linklocal(TCPIP_ADAPTER_IF_STA) == 0;",
                            "}",
                            "",
                            "/**",
                            " * Get the station interface IPv6 address.",
                            " * @return IPv6Address",
                            " */",
                            "IPv6Address WiFiSTAClass::localIPv6()",
                            "{",
                            "    static ip6_addr_t addr;",
                            "    if(tcpip_adapter_get_ip6_linklocal(TCPIP_ADAPTER_IF_STA, &addr)){",
                            "        return IPv6Address();",
                            "    }",
                            "    return IPv6Address(addr.addr);",
                            "}",
                            "",
                            "",
                            "bool WiFiSTAClass::_smartConfigStarted = false;",
                            "bool WiFiSTAClass::_smartConfigDone = false;",
                            "",
                            "",
                            "bool WiFiSTAClass::beginSmartConfig() {",
                            "    if (_smartConfigStarted) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if (!WiFi.mode(WIFI_STA)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_wifi_disconnect();",
                            "",
                            "    esp_err_t err;",
                            "    err = esp_smartconfig_start(reinterpret_cast<sc_callback_t>(&WiFiSTAClass::_smartConfigCallback), 1);",
                            "    if (err == ESP_OK) {",
                            "        _smartConfigStarted = true;",
                            "        _smartConfigDone = false;",
                            "        return true;",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "bool WiFiSTAClass::stopSmartConfig() {",
                            "    if (!_smartConfigStarted) {",
                            "        return true;",
                            "    }",
                            "",
                            "    if (esp_smartconfig_stop() == ESP_OK) {",
                            "        _smartConfigStarted = false;",
                            "        return true;",
                            "    }",
                            "",
                            "    return false;",
                            "}",
                            "",
                            "bool WiFiSTAClass::smartConfigDone() {",
                            "    if (!_smartConfigStarted) {",
                            "        return false;",
                            "    }",
                            "",
                            "    return _smartConfigDone;",
                            "}",
                            "",
                            "#if ARDUHAL_LOG_LEVEL >= ARDUHAL_LOG_LEVEL_DEBUG",
                            "const char * sc_status_strings[] = {",
                            "    \"WAIT\",",
                            "    \"FIND_CHANNEL\",",
                            "    \"GETTING_SSID_PSWD\",",
                            "    \"LINK\",",
                            "    \"LINK_OVER\"",
                            "};",
                            "",
                            "const char * sc_type_strings[] = {",
                            "    \"ESPTOUCH\",",
                            "    \"AIRKISS\",",
                            "    \"ESPTOUCH_AIRKISS\"",
                            "};",
                            "#endif",
                            "",
                            "void WiFiSTAClass::_smartConfigCallback(uint32_t st, void* result) {",
                            "    smartconfig_status_t status = (smartconfig_status_t) st;",
                            "    log_d(\"Status: %s\", sc_status_strings[st % 5]);",
                            "    if (status == SC_STATUS_GETTING_SSID_PSWD) {",
                            "        smartconfig_type_t * type = (smartconfig_type_t *)result;",
                            "        log_d(\"Type: %s\", sc_type_strings[*type % 3]);",
                            "    } else if (status == SC_STATUS_LINK) {",
                            "        wifi_sta_config_t *sta_conf = reinterpret_cast<wifi_sta_config_t *>(result);",
                            "        log_d(\"SSID: %s\", (char *)(sta_conf->ssid));",
                            "        sta_conf->bssid_set = 0;",
                            "        esp_wifi_set_config(WIFI_IF_STA, (wifi_config_t *)sta_conf);",
                            "        esp_wifi_connect();",
                            "        _smartConfigDone = true;",
                            "    } else if (status == SC_STATUS_LINK_OVER) {",
                            "        if(result){",
                            "            ip4_addr_t * ip = (ip4_addr_t *)result;",
                            "            log_d(\"Sender IP: \" IPSTR, IP2STR(ip));",
                            "        }",
                            "        WiFi.stopSmartConfig();",
                            "    }",
                            "}"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "47": "// -----------------------------------------------------------------------------------------------------------------------",
                "48": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "49": "// -----------------------------------------------------------------------------------------------------------------------",
                "83": "// -----------------------------------------------------------------------------------------------------------------------",
                "84": "// ---------------------------------------------------- STA function -----------------------------------------------------",
                "85": "// -----------------------------------------------------------------------------------------------------------------------",
                "104": "        // enable STA failed",
                "109": "        // fail SSID too long or missing!",
                "114": "        // fail passphrase too long!",
                "122": "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK",
                "174": "        // enable STA failed",
                "251": "        // Set DNS1-Server",
                "257": "        // Set DNS2-Server"
            },
            "comment_deleted_diff": {
                "47": "// -----------------------------------------------------------------------------------------------------------------------",
                "48": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "49": "// -----------------------------------------------------------------------------------------------------------------------",
                "83": "// -----------------------------------------------------------------------------------------------------------------------",
                "84": "// ---------------------------------------------------- STA function -----------------------------------------------------",
                "85": "// -----------------------------------------------------------------------------------------------------------------------",
                "104": "        // enable STA failed",
                "109": "        // fail SSID too long or missing!",
                "114": "        // fail passphrase too long!",
                "122": "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK",
                "174": "        // enable STA failed",
                "251": "        // Set DNS1-Server",
                "257": "        // Set DNS2-Server"
            },
            "comment_modified_diff": {
                "47": "// -----------------------------------------------------------------------------------------------------------------------",
                "48": "// ---------------------------------------------------- Private functions ------------------------------------------------",
                "49": "// -----------------------------------------------------------------------------------------------------------------------",
                "83": "// -----------------------------------------------------------------------------------------------------------------------",
                "84": "// ---------------------------------------------------- STA function -----------------------------------------------------",
                "85": "// -----------------------------------------------------------------------------------------------------------------------",
                "104": "        // enable STA failed",
                "109": "        // fail SSID too long or missing!",
                "114": "        // fail passphrase too long!",
                "122": "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK",
                "174": "        // enable STA failed",
                "251": "        // Set DNS1-Server",
                "257": "        // Set DNS2-Server"
            }
        },
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 117,
            "deletions": 98,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            138
                        ],
                        "comments": [
                            "        if (strlen(passphrase) == 64){ // it's not a passphrase, is the PSK"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            140
                        ],
                        "comments": [],
                        "lines": [
                            "        } else {"
                        ]
                    },
                    {
                        "line_numbers": [
                            142
                        ],
                        "comments": [],
                        "lines": [
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            148,
                            149,
                            150,
                            151
                        ],
                        "comments": [],
                        "lines": [
                            "    }",
                            "",
                            "    if(channel > 0 && channel <= 13) {",
                            "        conf.sta.channel = channel;"
                        ]
                    },
                    {
                        "line_numbers": [
                            157,
                            158,
                            159,
                            160
                        ],
                        "comments": [],
                        "lines": [
                            "        if(esp_wifi_disconnect()){",
                            "            log_e(\"disconnect failed!\");",
                            "            return WL_CONNECT_FAILED;",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            162,
                            163,
                            164
                        ],
                        "comments": [],
                        "lines": [
                            "        esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    } else if(status() == WL_CONNECTED){",
                            "        return WL_CONNECTED;"
                        ]
                    },
                    {
                        "line_numbers": [
                            168,
                            169,
                            170,
                            171
                        ],
                        "comments": [],
                        "lines": [
                            "        if(tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA) == ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED){",
                            "            log_e(\"dhcp client start failed!\");",
                            "            return WL_CONNECT_FAILED;",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            176,
                            177,
                            178,
                            179,
                            180
                        ],
                        "comments": [],
                        "lines": [
                            "    if(connect && esp_wifi_connect()) {",
                            "        log_e(\"connect failed!\");",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            197
                        ],
                        "comments": [],
                        "lines": [
                            "        log_e(\"STA enable failed!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            202,
                            203,
                            204,
                            205
                        ],
                        "comments": [],
                        "lines": [
                            "        if(tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA) == ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED){",
                            "            log_e(\"dhcp client start failed!\");",
                            "            return WL_CONNECT_FAILED;",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            210,
                            211,
                            212,
                            213,
                            214
                        ],
                        "comments": [],
                        "lines": [
                            "    if(status() != WL_CONNECTED && esp_wifi_connect()){",
                            "        log_e(\"connect failed!\");",
                            "        return WL_CONNECT_FAILED;",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            218,
                            219,
                            220,
                            221,
                            222
                        ],
                        "comments": [],
                        "lines": [
                            "/**",
                            " * will force a disconnect an then start reconnecting to AP",
                            " * @return ok",
                            " */",
                            "bool WiFiSTAClass::reconnect()"
                        ]
                    },
                    {
                        "line_numbers": [
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258
                        ],
                        "comments": [],
                        "lines": [
                            "    if(WiFi.getMode() & WIFI_MODE_STA) {",
                            "        if(esp_wifi_disconnect() == ESP_OK) {",
                            "            return esp_wifi_connect() == ESP_OK;",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * Disconnect from the network",
                            " * @param wifioff",
                            " * @return  one value of wl_status_t enum",
                            " */",
                            "bool WiFiSTAClass::disconnect(bool wifioff, bool eraseap)",
                            "{",
                            "    wifi_config_t conf;",
                            "",
                            "    if(WiFi.getMode() & WIFI_MODE_STA){",
                            "        if(eraseap){",
                            "            memset(&conf, 0, sizeof(wifi_config_t));",
                            "            if(esp_wifi_set_config(WIFI_IF_STA, &conf)){",
                            "                log_e(\"clear config failed!\");",
                            "            }",
                            "        }",
                            "        if(esp_wifi_disconnect()){",
                            "            log_e(\"disconnect failed!\");",
                            "            return false;",
                            "        }",
                            "        if(wifioff) {",
                            "             return WiFi.enableSTA(false);",
                            "        }",
                            "        return true;",
                            "    }",
                            "",
                            "    return false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            305,
                            306
                        ],
                        "comments": [],
                        "lines": [
                            "        if(err == ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED){",
                            "            log_e(\"dhcp client start failed!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            348
                        ],
                        "comments": [],
                        "lines": [
                            "    /*bool ret;"
                        ]
                    },
                    {
                        "line_numbers": [
                            350,
                            351
                        ],
                        "comments": [],
                        "lines": [
                            "    return ret;*/",
                            "    return false;//now deprecated"
                        ]
                    },
                    {
                        "line_numbers": [
                            361
                        ],
                        "comments": [],
                        "lines": [
                            "    /*bool autoConnect;"
                        ]
                    },
                    {
                        "line_numbers": [
                            363,
                            364
                        ],
                        "comments": [],
                        "lines": [
                            "    return autoConnect;*/",
                            "    return false;//now deprecated"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            104
                        ],
                        "comments": [
                            "        // enable STA failed"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            124
                        ],
                        "comments": [],
                        "lines": [
                            "        else"
                        ]
                    },
                    {
                        "line_numbers": [
                            126,
                            127
                        ],
                        "comments": [],
                        "lines": [
                            "    } else {",
                            "        *conf.sta.password = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            133,
                            134
                        ],
                        "comments": [],
                        "lines": [
                            "    } else {",
                            "        conf.sta.bssid_set = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            140,
                            141,
                            142,
                            143,
                            144,
                            145
                        ],
                        "comments": [],
                        "lines": [
                            "        esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    }",
                            "",
                            "    if(channel > 0 && channel <= 13) {",
                            "        esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            147,
                            148,
                            149
                        ],
                        "comments": [],
                        "lines": [
                            "    esp_wifi_start();",
                            "    if(connect) {",
                            "        esp_wifi_connect();"
                        ]
                    },
                    {
                        "line_numbers": [
                            153
                        ],
                        "comments": [],
                        "lines": [
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);"
                        ]
                    },
                    {
                        "line_numbers": [
                            177,
                            178
                        ],
                        "comments": [],
                        "lines": [
                            "    esp_wifi_start();",
                            "    esp_wifi_connect();"
                        ]
                    },
                    {
                        "line_numbers": [
                            181
                        ],
                        "comments": [],
                        "lines": [
                            "        tcpip_adapter_dhcpc_start(TCPIP_ADAPTER_IF_STA);"
                        ]
                    },
                    {
                        "line_numbers": [
                            189
                        ],
                        "comments": [],
                        "lines": [
                            "void WiFiSTAClass::_setStatus(wl_status_t status)"
                        ]
                    },
                    {
                        "line_numbers": [
                            191,
                            192
                        ],
                        "comments": [],
                        "lines": [
                            "    _status = status;",
                            "    //log_i(\"wifi status: %d\", status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            210
                        ],
                        "comments": [],
                        "lines": [
                            "    esp_wifi_start();"
                        ]
                    },
                    {
                        "line_numbers": [
                            240,
                            241
                        ],
                        "comments": [],
                        "lines": [
                            "        if(err != ESP_OK && err != ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED){",
                            "            log_w(\"DHCP could not be started! Error: %d\", err);"
                        ]
                    },
                    {
                        "line_numbers": [
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302
                        ],
                        "comments": [],
                        "lines": [
                            "/**",
                            " * will force a disconnect an then start reconnecting to AP",
                            " * @return ok",
                            " */",
                            "bool WiFiSTAClass::reconnect()",
                            "{",
                            "    if((WiFi.getMode() & WIFI_MODE_STA) != 0) {",
                            "        if(esp_wifi_disconnect() == ESP_OK) {",
                            "            return esp_wifi_connect() == ESP_OK;",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * Disconnect from the network",
                            " * @param wifioff",
                            " * @return  one value of wl_status_t enum",
                            " */",
                            "bool WiFiSTAClass::disconnect(bool wifioff)",
                            "{",
                            "    bool ret;",
                            "    wifi_config_t conf;",
                            "    *conf.sta.ssid = 0;",
                            "    *conf.sta.password = 0;",
                            "",
                            "    WiFi.getMode();",
                            "    esp_wifi_start();",
                            "    esp_wifi_set_config(WIFI_IF_STA, &conf);",
                            "    ret = esp_wifi_disconnect() == ESP_OK;",
                            "",
                            "    if(wifioff) {",
                            "        WiFi.enableSTA(false);",
                            "    }",
                            "",
                            "    return ret;",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            321
                        ],
                        "comments": [],
                        "lines": [
                            "    bool ret;"
                        ]
                    },
                    {
                        "line_numbers": [
                            323
                        ],
                        "comments": [],
                        "lines": [
                            "    return ret;"
                        ]
                    },
                    {
                        "line_numbers": [
                            333
                        ],
                        "comments": [],
                        "lines": [
                            "    bool autoConnect;"
                        ]
                    },
                    {
                        "line_numbers": [
                            335
                        ],
                        "comments": [],
                        "lines": [
                            "    return autoConnect;"
                        ]
                    },
                    {
                        "line_numbers": [
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446
                        ],
                        "comments": [],
                        "lines": [
                            "/**",
                            " * Return Connection status.",
                            " * @return one of the value defined in wl_status_t",
                            " *",
                            " */",
                            "wl_status_t WiFiSTAClass::status()",
                            "{",
                            "    return WiFiSTAClass::_status;",
                            "}",
                            ""
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "138": "        if (strlen(passphrase) == 64){ // it's not a passphrase, is the PSK"
            },
            "comment_deleted_diff": {
                "104": "        // enable STA failed",
                "109": "        // fail SSID too long or missing!",
                "114": "        // fail passphrase too long!",
                "122": "        if (strlen(passphrase) == 64) // it's not a passphrase, is the PSK",
                "174": "        // enable STA failed"
            },
            "comment_modified_diff": {}
        }
    ],
    "WiFiSTA.h": [],
    "WiFiScan.cpp": [],
    "WiFiScan.h": [],
    "WiFiType.h": [],
    "Wire.cpp": [
        {
            "commit": "7998e2321dbf17c6fa7292466651ca4590e06ab4",
            "timestamp": "2018-04-06T19:05:48+03:00",
            "author": "chuck todd",
            "commit_message": "Preserver custom pin assigments (#1239)\n\nThis code allows Wire.begin() to assign the default values of SDA, and SCL only if they have not been previously configured.  Arduino libraries that use Wire() usually re-init the I2C interface in their initialization code with a call to Wire.begin().  If a user app sets custom pins assignment in setup(); These assignments will be overwritten with the default values  whenever Wire.begin() is called.",
            "additions": 14,
            "deletions": 6,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            49
                        ],
                        "comments": [
                            "    if(sdaPin < 0) { // default param passed"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            51,
                            52
                        ],
                        "comments": [
                            "            else sdaPin = sda; // reuse prior pin"
                        ],
                        "lines": [
                            "            if(sda==-1) sdaPin = SDA; //use Default Pin"
                        ]
                    },
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57
                        ],
                        "comments": [
                            "            } else sdaPin = sda; // reuse prior pin"
                        ],
                        "lines": [
                            "            if(sda==-1) {",
                            "                log_e(\"no Default SDA Pin for Second Peripheral\");",
                            "                return; //no Default pin for Second Peripheral"
                        ]
                    },
                    {
                        "line_numbers": [
                            66,
                            67,
                            68,
                            69
                        ],
                        "comments": [
                            "            } else sclPin = scl; // reuse prior pin"
                        ],
                        "lines": [
                            "            if(scl==-1){",
                            "                log_e(\"no Default SCL Pin for Second Peripheral\");",
                            "                return; //no Default pin for Second Peripheral"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "49": "    if(sdaPin < 0) { // default param passed",
                "52": "            else sdaPin = sda; // reuse prior pin",
                "57": "            } else sdaPin = sda; // reuse prior pin",
                "61": "    if(sclPin < 0) { // default param passed",
                "63": "            if(scl==-1) sclPin = SCL; // use Default pin",
                "64": "            else sclPin = scl; // reuse prior pin",
                "69": "            } else sclPin = scl; // reuse prior pin"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 205,
            "deletions": 68,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            68,
                            69
                        ],
                        "comments": [
                            "                sdaPin = sda;    // reuse prior pin"
                        ],
                        "lines": [
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            74,
                            75,
                            76
                        ],
                        "comments": [
                            "                sdaPin = sda;    // reuse prior pin"
                        ],
                        "lines": [
                            "            } else {",
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            82,
                            83,
                            84,
                            85,
                            86
                        ],
                        "comments": [
                            "                sclPin = SCL;    // use Default pin",
                            "                sclPin = scl;    // reuse prior pin"
                        ],
                        "lines": [
                            "            if(scl == -1) {",
                            "            } else {",
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            88
                        ],
                        "comments": [],
                        "lines": [
                            "            if(scl == -1) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            91,
                            92,
                            93
                        ],
                        "comments": [
                            "                sclPin = scl;    // reuse prior pin"
                        ],
                        "lines": [
                            "            } else {",
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            99,
                            100,
                            101,
                            102
                        ],
                        "comments": [],
                        "lines": [
                            "    i2c = i2cInit(num, sdaPin, sclPin, frequency);",
                            "    if(!i2c) {",
                            "        return;",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            108
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::setTimeOut(uint16_t timeOutMillis)"
                        ]
                    },
                    {
                        "line_numbers": [
                            110
                        ],
                        "comments": [],
                        "lines": [
                            "    _timeOutMillis = timeOutMillis;"
                        ]
                    },
                    {
                        "line_numbers": [
                            113
                        ],
                        "comments": [],
                        "lines": [
                            "uint16_t TwoWire::getTimeOut()"
                        ]
                    },
                    {
                        "line_numbers": [
                            115
                        ],
                        "comments": [],
                        "lines": [
                            "    return _timeOutMillis;"
                        ]
                    },
                    {
                        "line_numbers": [
                            118
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::setClock(uint32_t frequency)"
                        ]
                    },
                    {
                        "line_numbers": [
                            120
                        ],
                        "comments": [],
                        "lines": [
                            "    i2cSetFrequency(i2c, frequency);"
                        ]
                    },
                    {
                        "line_numbers": [
                            123
                        ],
                        "comments": [],
                        "lines": [
                            "size_t TwoWire::getClock()"
                        ]
                    },
                    {
                        "line_numbers": [
                            125
                        ],
                        "comments": [],
                        "lines": [
                            "    return i2cGetFrequency(i2c);"
                        ]
                    },
                    {
                        "line_numbers": [
                            128,
                            129,
                            130
                        ],
                        "comments": [],
                        "lines": [
                            "/* stickBreaker Nov 2017 ISR, and bigblock 64k-1",
                            " */",
                            "i2c_err_t TwoWire::writeTransmission(uint16_t address, uint8_t *buff, uint16_t size, bool sendStop)"
                        ]
                    },
                    {
                        "line_numbers": [
                            132,
                            133
                        ],
                        "comments": [],
                        "lines": [
                            "    last_error = i2cWrite(i2c, address, buff, size, sendStop, _timeOutMillis);",
                            "    return last_error;"
                        ]
                    },
                    {
                        "line_numbers": [
                            136
                        ],
                        "comments": [],
                        "lines": [
                            "i2c_err_t TwoWire::readTransmission(uint16_t address, uint8_t *buff, uint16_t size, bool sendStop, uint32_t *readCount)"
                        ]
                    },
                    {
                        "line_numbers": [
                            138,
                            139
                        ],
                        "comments": [],
                        "lines": [
                            "    last_error = i2cRead(i2c, address, buff, size, sendStop, _timeOutMillis, readCount);",
                            "    return last_error;"
                        ]
                    },
                    {
                        "line_numbers": [
                            142
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::beginTransmission(uint16_t address)"
                        ]
                    },
                    {
                        "line_numbers": [
                            144,
                            145,
                            146,
                            147
                        ],
                        "comments": [
                            "    txIndex = txQueued; // allow multiple beginTransmission(),write(),endTransmission(false) until endTransmission(true)"
                        ],
                        "lines": [
                            "    transmitting = 1;",
                            "    txAddress = address;",
                            "    txLength = txQueued;"
                        ]
                    },
                    {
                        "line_numbers": [
                            150,
                            151,
                            152
                        ],
                        "comments": [
                            "uint8_t TwoWire::endTransmission(bool sendStop)  // Assumes Wire.beginTransaction(), Wire.write()"
                        ],
                        "lines": [
                            "/*stickbreaker isr",
                            " */"
                        ]
                    },
                    {
                        "line_numbers": [
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167
                        ],
                        "comments": [
                            "        txQueued = 0; // the SendStop=true will restart all Queueing",
                            "            // txlength is howmany bytes in txbuffer have been use"
                        ],
                        "lines": [
                            "    if(transmitting == 1) {",
                            "        last_error = writeTransmission(txAddress, &txBuffer[txQueued], txLength - txQueued, sendStop);",
                            "        rxIndex = 0;",
                            "        rxLength = rxQueued;",
                            "        rxQueued = 0;",
                            "        if(last_error == I2C_ERROR_CONTINUE){",
                            "            txQueued = txLength;",
                            "        }",
                            "    } else {",
                            "        last_error = I2C_ERROR_NO_BEGIN;",
                            "        flush();",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            170,
                            171
                        ],
                        "comments": [],
                        "lines": [
                            "    transmitting = 0;",
                            "    return last_error;"
                        ]
                    },
                    {
                        "line_numbers": [
                            174,
                            175,
                            176
                        ],
                        "comments": [],
                        "lines": [
                            "/* @stickBreaker 11/2017 fix for ReSTART timeout, ISR",
                            " */",
                            "uint8_t TwoWire::requestFrom(uint16_t address, uint8_t size, bool sendStop)"
                        ]
                    },
                    {
                        "line_numbers": [
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188
                        ],
                        "comments": [
                            "    uint32_t cnt = rxQueued; // currently queued reads, next available position in rxBuffer",
                            "    if(cnt < (I2C_BUFFER_LENGTH-1) && (size + cnt) <= I2C_BUFFER_LENGTH) { // any room left in rxBuffer",
                            "    } else { // no room to receive more!"
                        ],
                        "lines": [
                            "    //use internal Wire rxBuffer, multiple requestFrom()'s may be pending, try to share rxBuffer",
                            "        rxQueued += size;",
                            "        log_e(\"rxBuff overflow %d\", cnt + size);",
                            "        cnt = 0;",
                            "        last_error = I2C_ERROR_MEMORY;",
                            "        flush();",
                            "        return cnt;",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198
                        ],
                        "comments": [
                            "    txQueued = 0; // the SendStop=true will restart all Queueing"
                        ],
                        "lines": [
                            "    last_error = readTransmission(address, &rxBuffer[cnt], size, sendStop, &cnt);",
                            "    rxIndex = 0;",
                            "    rxLength = rxQueued;",
                            "    rxQueued = 0;",
                            "    if(last_error != I2C_ERROR_OK){",
                            "        cnt = 0;",
                            "    }",
                            "    return cnt;"
                        ]
                    },
                    {
                        "line_numbers": [
                            210
                        ],
                        "comments": [],
                        "lines": [
                            "        return 1;"
                        ]
                    },
                    {
                        "line_numbers": [
                            212
                        ],
                        "comments": [],
                        "lines": [
                            "    return 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            223
                        ],
                        "comments": [],
                        "lines": [
                            "        return quantity;"
                        ]
                    },
                    {
                        "line_numbers": [
                            225
                        ],
                        "comments": [],
                        "lines": [
                            "    return 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358
                        ],
                        "comments": [
                            "    i2cFlush(i2c); // cleanup"
                        ],
                        "lines": [
                            "    rxQueued = 0;",
                            "    txQueued = 0;",
                            "}",
                            "",
                            "uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)",
                            "{",
                            "    return requestFrom(static_cast<uint16_t>(address), static_cast<size_t>(quantity), static_cast<bool>(sendStop));",
                            "}",
                            "",
                            "uint8_t TwoWire::requestFrom(uint16_t address, uint8_t quantity, uint8_t sendStop)",
                            "{",
                            "    return requestFrom(address, static_cast<size_t>(quantity), static_cast<bool>(sendStop));",
                            "}",
                            "",
                            "uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)",
                            "{",
                            "    return requestFrom(static_cast<uint16_t>(address), static_cast<size_t>(quantity), true);",
                            "}",
                            "",
                            "uint8_t TwoWire::requestFrom(uint16_t address, uint8_t quantity)",
                            "{",
                            "    return requestFrom(address, static_cast<size_t>(quantity), true);",
                            "}",
                            "",
                            "uint8_t TwoWire::requestFrom(int address, int quantity)",
                            "{",
                            "    return requestFrom(static_cast<uint16_t>(address), static_cast<size_t>(quantity), true);",
                            "}",
                            "",
                            "uint8_t TwoWire::requestFrom(int address, int quantity, int sendStop)",
                            "{",
                            "    return static_cast<uint8_t>(requestFrom(static_cast<uint16_t>(address), static_cast<size_t>(quantity), static_cast<bool>(sendStop)));",
                            "}",
                            "",
                            "void TwoWire::beginTransmission(int address)",
                            "{",
                            "    beginTransmission(static_cast<uint16_t>(address));",
                            "}",
                            "",
                            "void TwoWire::beginTransmission(uint8_t address)",
                            "{",
                            "    beginTransmission(static_cast<uint16_t>(address));",
                            "}",
                            "",
                            "uint8_t TwoWire::endTransmission(void)",
                            "{",
                            "    return endTransmission(true);",
                            "}",
                            "",
                            "uint8_t TwoWire::endTransmission(uint8_t sendStop)",
                            "{",
                            "    return endTransmission(static_cast<bool>(sendStop));",
                            "}",
                            "",
                            "/* stickbreaker Nov2017 better error reporting",
                            " */",
                            "uint8_t TwoWire::lastError()",
                            "{",
                            "    return (uint8_t)last_error;",
                            "}",
                            "",
                            "const char ERRORTEXT[] =",
                            "    \"OK\\0\"",
                            "    \"DEVICE\\0\"",
                            "    \"ACK\\0\"",
                            "    \"TIMEOUT\\0\"",
                            "    \"BUS\\0\"",
                            "    \"BUSY\\0\"",
                            "    \"MEMORY\\0\"",
                            "    \"CONTINUE\\0\"",
                            "    \"NO_BEGIN\\0\"",
                            "    \"\\0\";",
                            "",
                            "",
                            "char * TwoWire::getErrorText(uint8_t err)",
                            "{",
                            "    uint8_t t = 0;",
                            "    bool found = false;",
                            "    char * message = (char*)&ERRORTEXT;",
                            "",
                            "    while(!found && message[0]) {",
                            "        found = t == err;",
                            "        if(!found) {",
                            "            message = message + strlen(message) + 1;",
                            "            t++;",
                            "        }",
                            "    }",
                            "    if(!found) {",
                            "        return NULL;",
                            "    } else {",
                            "        return message;",
                            "    }",
                            "}",
                            "",
                            "/*stickbreaker Dump i2c Interrupt buffer, i2c isr Debugging",
                            " */",
                            "void TwoWire::dumpInts()",
                            "{",
                            "    i2cDumpInts(num);"
                        ]
                    },
                    {
                        "line_numbers": [
                            361
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::dumpI2C()"
                        ]
                    },
                    {
                        "line_numbers": [
                            363
                        ],
                        "comments": [],
                        "lines": [
                            "    i2cDumpI2c(i2c);"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            52
                        ],
                        "comments": [
                            "            else sdaPin = sda; // reuse prior pin"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            66
                        ],
                        "comments": [],
                        "lines": [
                            "            if(scl==-1){"
                        ]
                    },
                    {
                        "line_numbers": [
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76
                        ],
                        "comments": [],
                        "lines": [
                            "        }",
                            "    }",
                            "",
                            "    if(i2c == NULL) {",
                            "        i2c = i2cInit(num, 0, false);",
                            "        if(i2c == NULL) {",
                            "            return;"
                        ]
                    },
                    {
                        "line_numbers": [
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89
                        ],
                        "comments": [],
                        "lines": [
                            "    i2cSetFrequency(i2c, frequency);",
                            "",
                            "    if(sda >= 0 && sda != sdaPin) {",
                            "        i2cDetachSDA(i2c, sda);",
                            "    }",
                            "",
                            "    if(scl >= 0 && scl != sclPin) {",
                            "        i2cDetachSCL(i2c, scl);",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            92,
                            93,
                            94
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "    i2cAttachSDA(i2c, sda);",
                            "    i2cAttachSCL(i2c, scl);"
                        ]
                    },
                    {
                        "line_numbers": [
                            98
                        ],
                        "comments": [],
                        "lines": [
                            "    i2cInitFix(i2c);"
                        ]
                    },
                    {
                        "line_numbers": [
                            101
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::setClock(uint32_t frequency)"
                        ]
                    },
                    {
                        "line_numbers": [
                            103
                        ],
                        "comments": [],
                        "lines": [
                            "    i2cSetFrequency(i2c, frequency);"
                        ]
                    },
                    {
                        "line_numbers": [
                            106
                        ],
                        "comments": [],
                        "lines": [
                            "size_t TwoWire::requestFrom(uint8_t address, size_t size, bool sendStop)"
                        ]
                    },
                    {
                        "line_numbers": [
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114
                        ],
                        "comments": [],
                        "lines": [
                            "    if(size > I2C_BUFFER_LENGTH) {",
                            "        size = I2C_BUFFER_LENGTH;",
                            "    }",
                            "    size_t read = (i2cRead(i2c, address, false, rxBuffer, size, sendStop) == 0)?size:0;",
                            "    rxIndex = 0;",
                            "    rxLength = read;",
                            "    return read;"
                        ]
                    },
                    {
                        "line_numbers": [
                            117
                        ],
                        "comments": [],
                        "lines": [
                            "uint8_t TwoWire::endTransmission(uint8_t sendStop)"
                        ]
                    },
                    {
                        "line_numbers": [
                            119,
                            120,
                            121,
                            122,
                            123
                        ],
                        "comments": [],
                        "lines": [
                            "    int8_t ret = i2cWrite(i2c, txAddress, false, txBuffer, txLength, sendStop);",
                            "    txIndex = 0;",
                            "    txLength = 0;",
                            "    transmitting = 0;",
                            "    return ret;"
                        ]
                    },
                    {
                        "line_numbers": [
                            126
                        ],
                        "comments": [],
                        "lines": [
                            "uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)"
                        ]
                    },
                    {
                        "line_numbers": [
                            128
                        ],
                        "comments": [],
                        "lines": [
                            "    return requestFrom(address, static_cast<size_t>(quantity), static_cast<bool>(sendStop));"
                        ]
                    },
                    {
                        "line_numbers": [
                            131
                        ],
                        "comments": [],
                        "lines": [
                            "uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)"
                        ]
                    },
                    {
                        "line_numbers": [
                            133
                        ],
                        "comments": [],
                        "lines": [
                            "    return requestFrom(address, static_cast<size_t>(quantity), true);"
                        ]
                    },
                    {
                        "line_numbers": [
                            136
                        ],
                        "comments": [],
                        "lines": [
                            "uint8_t TwoWire::requestFrom(int address, int quantity)"
                        ]
                    },
                    {
                        "line_numbers": [
                            138
                        ],
                        "comments": [],
                        "lines": [
                            "    return requestFrom(static_cast<uint8_t>(address), static_cast<size_t>(quantity), true);"
                        ]
                    },
                    {
                        "line_numbers": [
                            141
                        ],
                        "comments": [],
                        "lines": [
                            "uint8_t TwoWire::requestFrom(int address, int quantity, int sendStop)"
                        ]
                    },
                    {
                        "line_numbers": [
                            143
                        ],
                        "comments": [],
                        "lines": [
                            "    return requestFrom(static_cast<uint8_t>(address), static_cast<size_t>(quantity), static_cast<bool>(sendStop));"
                        ]
                    },
                    {
                        "line_numbers": [
                            146
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::beginTransmission(uint8_t address)"
                        ]
                    },
                    {
                        "line_numbers": [
                            148,
                            149
                        ],
                        "comments": [],
                        "lines": [
                            "    transmitting = 1;",
                            "    txAddress = address;"
                        ]
                    },
                    {
                        "line_numbers": [
                            154
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::beginTransmission(int address)"
                        ]
                    },
                    {
                        "line_numbers": [
                            156,
                            157
                        ],
                        "comments": [],
                        "lines": [
                            "    beginTransmission((uint8_t)address);",
                            "}"
                        ]
                    },
                    {
                        "line_numbers": [
                            159,
                            160,
                            161
                        ],
                        "comments": [],
                        "lines": [
                            "uint8_t TwoWire::endTransmission(void)",
                            "{",
                            "    return endTransmission(true);"
                        ]
                    },
                    {
                        "line_numbers": [
                            174
                        ],
                        "comments": [],
                        "lines": [
                            "    return 1;"
                        ]
                    },
                    {
                        "line_numbers": [
                            186
                        ],
                        "comments": [],
                        "lines": [
                            "    return quantity;"
                        ]
                    },
                    {
                        "line_numbers": [
                            222
                        ],
                        "comments": [],
                        "lines": [
                            "void TwoWire::reset(void)"
                        ]
                    },
                    {
                        "line_numbers": [
                            224,
                            225,
                            226
                        ],
                        "comments": [],
                        "lines": [
                            "    i2cReset( i2c );",
                            "    i2c = NULL;",
                            "    begin( sda, scl );"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "68": "                sdaPin = sda;    // reuse prior pin",
                "75": "                sdaPin = sda;    // reuse prior pin",
                "83": "                sclPin = SCL;    // use Default pin",
                "85": "                sclPin = scl;    // reuse prior pin",
                "92": "                sclPin = scl;    // reuse prior pin",
                "146": "    txIndex = txQueued; // allow multiple beginTransmission(),write(),endTransmission(false) until endTransmission(true)",
                "152": "uint8_t TwoWire::endTransmission(bool sendStop)  // Assumes Wire.beginTransaction(), Wire.write()",
                "159": "        txQueued = 0; // the SendStop=true will restart all Queueing",
                "161": "            // txlength is howmany bytes in txbuffer have been use",
                "179": "    uint32_t cnt = rxQueued; // currently queued reads, next available position in rxBuffer",
                "180": "    if(cnt < (I2C_BUFFER_LENGTH-1) && (size + cnt) <= I2C_BUFFER_LENGTH) { // any room left in rxBuffer",
                "182": "    } else { // no room to receive more!",
                "194": "    txQueued = 0; // the SendStop=true will restart all Queueing",
                "261": "    i2cFlush(i2c); // cleanup"
            },
            "comment_deleted_diff": {
                "52": "            else sdaPin = sda; // reuse prior pin",
                "57": "            } else sdaPin = sda; // reuse prior pin",
                "63": "            if(scl==-1) sclPin = SCL; // use Default pin",
                "64": "            else sclPin = scl; // reuse prior pin",
                "69": "            } else sclPin = scl; // reuse prior pin"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "b05430cfd9f273d627baa6c4dac6c215d6cde902",
            "timestamp": "2018-08-14T11:51:15+02:00",
            "author": "chuck todd",
            "commit_message": "Wire ReSTART fix, with others (#1717)\n\n* ReSTART fix, Sequencing fix\r\n\r\npr #1665 introduce a problem with ReSTART, when solving this problem I found an interaction between the TxFifo refill, RxFifo empty and CMD[] fill.  during certain sequences a dataqueue command would be skipped, this skipping resulted in a mismatch between the contents of the TxFifo and the i2c command sequence.  The problem manifested as an ACK error. \r\nIn addition to this required bug fix I propose:\r\n* `Wire.begin()` be changed from a `void` to a `bool` this will allow the reset functionality of `Wire.begin()` to be reported.  Currently `Wire.begin()` attempts to reset the i2c Peripheral, but cannot report success/failure.\r\n* `Wire.busy()` be added. this `bool` function returns the hardware status of the bus. This status can be use in multi-master environments for application level interleaving of commands, also in single master environment, it can be used to detect a 'hung' bus.  With the functional change to `Wire.begin()` this allows app level recover of a hung bus.\r\n* `Wire.lastError()` value updated for all errors, previously when interleaving `Wire.endTransmission(false)` and `Wire.readTransmission(false)`, the 128 byte `Wire.write()` buffer was exhausted without generating and error(very exotic). I discovered this error when I created a sequence of directed reads to a EEPROM. Each directed read used 2 bytes of the 128 byte `write()` buffer, so after 64 consecutive ReSTART writes with ReSTART reads, `Wire()`  had no room to record the directed address bytes.  It generated just a NAK check without setting the EEPROMs internal register address.  The succeeding ReSTART read succeeded at incorrect address.\r\n* Changes to the HAL layer:\r\n** added `i2cGetStatus()` which returns the i2c peripheral status word, used to detect bus_busy currently\r\n** added `i2cDebug()` programmatic control of debug buffer output\r\n** changed `i2cAddQueue()` to allow data_only queue element this will allow a i2c transaction to use multiple data pointers.\r\n** removed direct access to DumpInts(), DumpI2c() from app, use i2cDebug() to set trigger points \r\n \r\n*\r\n\r\n* Update esp32-hal-i2c.c\r\n\r\n* Update Wire.cpp\r\n\r\n* ReSTART, Sequencing\r\n\r\npr #1665 introduce a problem with ReSTART, when solving this problem I found an interaction between the TxFifo refill, RxFifo empty and CMD[] fill.  during certain sequences a dataqueue command would be skipped, this skipping resulted in a mismatch between the contents of the TxFifo and the i2c command sequence.  The problem manifested as an ACK error. \r\nIn addition to this required bug fix I propose:\r\n* `Wire.begin()` be changed from a `void` to a `bool` this will allow the reset functionality of `Wire.begin()` to be reported.  Currently `Wire.begin()` attempts to reset the i2c Peripheral, but cannot report success/failure.\r\n* `Wire.busy()` be added. this `bool` function returns the hardware status of the bus. This status can be use in multi-master environments for application level interleaving of commands, also in single master environment, it can be used to detect a 'hung' bus.  With the functional change to `Wire.begin()` this allows app level recover of a hung bus.\r\n* `Wire.lastError()` value updated for all errors, previously when interleaving `Wire.endTransmission(false)` and `Wire.readTransmission(false)`, the 128 byte `Wire.write()` buffer was exhausted without generating and error(very exotic). I discovered this error when I created a sequence of directed reads to a EEPROM. Each directed read used 2 bytes of the 128 byte `write()` buffer, so after 64 consecutive ReSTART writes with ReSTART reads, `Wire()`  had no room to record the directed address bytes.  It generated just a NAK check without setting the EEPROMs internal register address.  The succeeding ReSTART read succeeded at incorrect address.\r\n* Changes to the HAL layer:\r\n** added `i2cGetStatus()` which returns the i2c peripheral status word, used to detect bus_busy currently\r\n** added `i2cDebug()` programmatic control of debug buffer output\r\n** changed `i2cAddQueue()` to allow data_only queue element this will allow a i2c transaction to use multiple data pointers.\r\n** removed direct access to DumpInts(), DumpI2c() from app, use i2cDebug() to set trigger points \r\n \r\n*\r\n\r\n* Forgot DebugFlags Return\r\n\r\n@andriyadi found this, total brain fade on my part.",
            "additions": 18,
            "deletions": 17,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            215
                        ],
                        "comments": [
                            "    last_error = I2C_ERROR_NO_BEGIN; // no begin, not transmitting"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            221,
                            222,
                            223
                        ],
                        "comments": [],
                        "lines": [
                            "    for(size_t i = 0; i < quantity; ++i) {",
                            "        if(!write(data[i])) {",
                            "            return i;"
                        ]
                    },
                    {
                        "line_numbers": [
                            226,
                            227
                        ],
                        "comments": [],
                        "lines": [
                            "    return quantity;",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            358,
                            359,
                            360
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "uint32_t TwoWire::setDebugFlags( uint32_t setBits, uint32_t resetBits){",
                            "  return i2cDebug(i2c,setBits,resetBits);"
                        ]
                    },
                    {
                        "line_numbers": [
                            363,
                            364
                        ],
                        "comments": [],
                        "lines": [
                            "bool TwoWire::busy(void){",
                            "  return ((i2cGetStatus(i2c) & 16 )==16);"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "215": "    last_error = I2C_ERROR_NO_BEGIN; // no begin, not transmitting"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "7a332864ab554f4fc42aba4cdcadf997635bf65c",
            "timestamp": "2018-12-03T16:16:43+01:00",
            "author": "chuck todd",
            "commit_message": "I2C ReSTART returns Success  (#2141)\n\n* Don't Return I2C_ERROR_CONTINUE on ReSTART\r\n\r\nReSTART operations on the ESP32 have to be handled differently than on AVR chips, so ReSTART operations(`Wire.endTransmission(false), Wire.requestFrom(id,size,false);` are queued until a STOP is send (`Wire.endTransmission(TRUE), Wire.endTransmission(), Wire.requestFrom(id,size), Wire.requestFrom(id,size,TRUE)). To indicate the queuing I had used `I2C_ERROR_CONTINUE`, this caused compatibility issues with the existing Arduino I2C Code base. So, back to Lying to the public(for their own good of course) about success!  This update just returns `I2C_ERROR_OK` on ReSTART commands.\r\n\r\n* add comments\r\n\r\nadd comments\r\n\r\n* Change Return error for ReSTART operation to I2C_ERROR_OK\r\n\r\nThis change restores compatibility with pre-existing Arduino Libraries.  The ReSTART queuing operations are hidden behind the scenes.  Wire.endTransmission(id,len,FALSE); will know return I2C_ERROR_OK instead of I2C_ERROR_CONTINUE, Wire.lastError() will return the true condition of I2C_ERROR_CONTINUE.",
            "additions": 18,
            "deletions": 10,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            157
                        ],
                        "comments": [
                            "            // txlength is howmany bytes in txbuffer have been use"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            161,
                            162,
                            163,
                            164,
                            165
                        ],
                        "comments": [
                            "          txQueued = 0; // the SendStop=true will restart all Queueing"
                        ],
                        "lines": [
                            "        } else if( last_error == I2C_ERROR_OK){",
                            "          rxIndex = 0;",
                            "          rxLength = rxQueued;",
                            "          rxQueued = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204
                        ],
                        "comments": [
                            "    if( last_error != I2C_ERROR_CONTINUE){ // not a  buffered ReSTART operation",
                            "      // so this operation actually moved data, queuing is done.",
                            "        txQueued = 0; // the SendStop=true will restart all Queueing or error condition",
                            "    if(last_error != I2C_ERROR_OK){ // ReSTART on read does not return any data"
                        ],
                        "lines": [
                            "",
                            "    rxLength = cnt;",
                            "",
                            "        rxQueued = 0;",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            207
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            161
                        ],
                        "comments": [
                            "        txQueued = 0; // the SendStop=true will restart all Queueing"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            173
                        ],
                        "comments": [],
                        "lines": [
                            "    return last_error;"
                        ]
                    },
                    {
                        "line_numbers": [
                            194,
                            195,
                            196,
                            197
                        ],
                        "comments": [
                            "    txQueued = 0; // the SendStop=true will restart all Queueing"
                        ],
                        "lines": [
                            "    rxLength = rxQueued;",
                            "    rxQueued = 0;",
                            "    if(last_error != I2C_ERROR_OK){"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "157": "            // txlength is howmany bytes in txbuffer have been use",
                "165": "          txQueued = 0; // the SendStop=true will restart all Queueing",
                "174": "    return (last_error == I2C_ERROR_CONTINUE)?I2C_ERROR_OK:last_error; // Don't return Continue for compatibility.",
                "198": "    if( last_error != I2C_ERROR_CONTINUE){ // not a  buffered ReSTART operation",
                "199": "      // so this operation actually moved data, queuing is done.",
                "201": "        txQueued = 0; // the SendStop=true will restart all Queueing or error condition",
                "204": "    if(last_error != I2C_ERROR_OK){ // ReSTART on read does not return any data"
            },
            "comment_deleted_diff": {
                "161": "        txQueued = 0; // the SendStop=true will restart all Queueing",
                "163": "            // txlength is howmany bytes in txbuffer have been use",
                "196": "    txQueued = 0; // the SendStop=true will restart all Queueing"
            },
            "comment_modified_diff": {}
        }
    ],
    "Wire.h": [],
    "package_esp32_index.template.json": [],
    "platform.txt": [],
    "programmers.txt": [],
    "esptool.py": [],
    "get.py": [],
    "bootloader.bin": [],
    "partitions_singleapp.bin": [],
    "bt.h": [],
    "sdkconfig.h": [],
    "gpio.h": [],
    "ledc.h": [],
    "periph_ctrl.h": [],
    "esp_attr.h": [],
    "esp_deepsleep.h": [],
    "esp_err.h": [],
    "esp_event.h": [],
    "esp_event_loop.h": [],
    "esp_intr.h": [],
    "esp_ipc.h": [],
    "esp_smartconfig.h": [],
    "esp_ssc.h": [],
    "esp_system.h": [],
    "esp_task.h": [],
    "esp_types.h": [],
    "esp_wifi.h": [],
    "esp_wifi_types.h": [],
    "aes.h": [],
    "sha.h": [],
    "bigint.h": [],
    "cache.h": [],
    "crc.h": [],
    "efuse.h": [],
    "ets_sys.h": [],
    "libc_stubs.h": [],
    "lldesc.h": [],
    "md5_hash.h": [],
    "miniz.h": [],
    "queue.h": [],
    "rtc.h": [],
    "secure_boot.h": [],
    "spi_flash.h": [],
    "tbconsole.h": [],
    "tjpgd.h": [],
    "uart.h": [],
    "bb_reg.h": [],
    "boot_mode.h": [],
    "cpu.h": [],
    "dport_reg.h": [],
    "efuse_reg.h": [],
    "gpio_reg.h": [],
    "gpio_sd_reg.h": [],
    "gpio_sd_struct.h": [],
    "gpio_sig_map.h": [],
    "gpio_struct.h": [],
    "i2c_reg.h": [],
    "i2c_struct.h": [],
    "i2s_reg.h": [],
    "i2s_struct.h": [],
    "io_mux_reg.h": [],
    "ledc_reg.h": [],
    "ledc_struct.h": [],
    "pcnt_reg.h": [],
    "pcnt_struct.h": [],
    "pid.h": [],
    "rmt_reg.h": [],
    "rmt_struct.h": [],
    "rtc_cntl_reg.h": [],
    "rtc_io_reg.h": [],
    "saradc_reg.h": [],
    "soc.h": [],
    "spi_reg.h": [],
    "spi_struct.h": [],
    "timer_group_reg.h": [],
    "timer_group_struct.h": [],
    "uart_reg.h": [],
    "uart_struct.h": [],
    "uhci_reg.h": [],
    "uhci_struct.h": [],
    "board.h": [],
    "c6x-compat.h": [],
    "cacheasm.h": [],
    "cacheattrasm.h": [],
    "core-isa.h": [],
    "core-matmap.h": [],
    "core.h": [],
    "defs.h": [],
    "specreg.h": [],
    "system.h": [],
    "tie-asm.h": [],
    "tie.h": [],
    "core-macros.h": [],
    "coreasm.h": [],
    "corebits.h": [],
    "debugfs.h": [],
    "feedback.h": [],
    "gdbio.h": [],
    "hal.h": [],
    "jtag-xtensa.h": [],
    "lcd-splc780d-4bitmode-board.h": [],
    "lcd-splc780d-4bitmode.h": [],
    "lcd-splc780d.h": [],
    "overlay.h": [],
    "overlay_os_asm.h": [],
    "sim.h": [],
    "simboard.h": [],
    "simcall-errno.h": [],
    "simcall-fcntl.h": [],
    "simcall.h": [],
    "xt_DFP_assist.h": [],
    "xt_FP.h": [],
    "xt_MAC16.h": [],
    "xt_MUL32.h": [],
    "xt_booleans.h": [],
    "xt_coprocessors.h": [],
    "xt_core.h": [],
    "xt_debug.h": [],
    "xt_density.h": [],
    "xt_exceptions.h": [],
    "xt_externalregisters.h": [],
    "xt_integerdivide.h": [],
    "xt_interrupt.h": [],
    "xt_ioports.h": [],
    "xt_misc.h": [],
    "xt_mmu.h": [],
    "xt_mul.h": [],
    "xt_regwin.h": [],
    "xt_scmpr.h": [],
    "xt_sync.h": [],
    "xt_timer.h": [],
    "xt_trace.h": [],
    "trax-api.h": [],
    "trax-core-config.h": [],
    "trax-proto.h": [],
    "trax-util.h": [],
    "trax.h": [],
    "traxfile.h": [],
    "traxreg.h": [],
    "uart-16550-board.h": [],
    "uart-16550.h": [],
    "udma.h": [],
    "xdm-regs.h": [],
    "xmon.h": [],
    "xmp-library.h": [],
    "xos.h": [],
    "xos_common.h": [],
    "xos_cond.h": [],
    "xos_errors.h": [],
    "xos_event.h": [],
    "xos_internal.h": [],
    "xos_msgq.h": [],
    "xos_mutex.h": [],
    "xos_params.h": [],
    "xos_regaccess.h": [],
    "xos_semaphore.h": [],
    "xos_stopwatch.h": [],
    "xos_syslog.h": [],
    "xos_thread.h": [],
    "xos_timer.h": [],
    "xos_types.h": [],
    "xt_perf_consts.h": [],
    "xt_perfmon.h": [],
    "xt_profiling.h": [],
    "xt_reftb.h": [],
    "xtav110.h": [],
    "xtav200.h": [],
    "xtav60.h": [],
    "lcd-splc780d-board.h": [],
    "xtbsp.h": [],
    "xtensa-libdb-macros.h": [],
    "xtensa-versions.h": [],
    "xtensa-xer.h": [],
    "xtkc705.h": [],
    "xtload-api.h": [],
    "xtml605.h": [],
    "xtruntime-core-state.h": [],
    "xtruntime-frames.h": [],
    "xtruntime.h": [],
    "xtutil.h": [],
    "ascii.h": [],
    "asciitab.h": [],
    "chardata.h": [],
    "expat.h": [],
    "expat_config.h": [],
    "expat_external.h": [],
    "iasciitab.h": [],
    "internal.h": [],
    "latin1tab.h": [],
    "minicheck.h": [],
    "nametab.h": [],
    "utf8tab.h": [],
    "xmlrole.h": [],
    "xmltok.h": [],
    "xmltok_impl.h": [],
    "FreeRTOS.h": [],
    "FreeRTOSConfig.h": [],
    "StackMacros.h": [],
    "croutine.h": [],
    "deprecated_definitions.h": [],
    "event_groups.h": [],
    "heap_regions.h": [],
    "heap_regions_debug.h": [],
    "list.h": [],
    "mpu_wrappers.h": [],
    "panic.h": [],
    "portable.h": [],
    "portbenchmark.h": [],
    "portmacro.h": [],
    "porttrace.h": [],
    "projdefs.h": [],
    "ringbuf.h": [],
    "semphr.h": [],
    "task.h": [],
    "timers.h": [],
    "xtensa_api.h": [],
    "xtensa_config.h": [],
    "xtensa_context.h": [],
    "xtensa_rtos.h": [],
    "xtensa_timer.h": [],
    "cJSON.h": [],
    "cJSON_Utils.h": [],
    "esp_log.h": [],
    "dhcpserver.h": [],
    "sntp.h": [],
    "sntp_opts.h": [],
    "cc.h": [],
    "perf.h": [],
    "sys_arch.h": [],
    "api.h": [],
    "arch.h": [],
    "autoip.h": [],
    "debug.h": [],
    "def.h": [],
    "dhcp.h": [],
    "dhcp6.h": [],
    "dns.h": [],
    "err.h": [],
    "ethip6.h": [],
    "icmp.h": [],
    "icmp6.h": [],
    "igmp.h": [],
    "inet.h": [],
    "inet_chksum.h": [],
    "init.h": [],
    "ip.h": [],
    "ip4.h": [],
    "ip4_addr.h": [],
    "ip6.h": [],
    "ip6_addr.h": [],
    "ip6_frag.h": [],
    "ip_addr.h": [],
    "ip_frag.h": [],
    "lwip_debug.h": [],
    "mem.h": [],
    "memp.h": [],
    "mld6.h": [],
    "nd6.h": [],
    "netbuf.h": [],
    "netdb.h": [],
    "netif.h": [],
    "netifapi.h": [],
    "opt.h": [],
    "pbuf.h": [],
    "pppapi.h": [],
    "api_msg.h": [],
    "memp_priv.h": [],
    "memp_std.h": [],
    "tcp_priv.h": [],
    "tcpip_priv.h": [],
    "raw.h": [],
    "sio.h": [],
    "snmp.h": [],
    "sockets.h": [],
    "stats.h": [],
    "sys.h": [],
    "tcp.h": [],
    "tcpip.h": [],
    "udp.h": [],
    "lwipopts.h": [],
    "etharp.h": [],
    "ethernet.h": [],
    "lowpan6.h": [],
    "lowpan6_opts.h": [],
    "ccp.h": [],
    "chap-md5.h": [],
    "chap-new.h": [],
    "chap_ms.h": [],
    "eap.h": [],
    "ecp.h": [],
    "eui64.h": [],
    "fsm.h": [],
    "ipcp.h": [],
    "ipv6cp.h": [],
    "lcp.h": [],
    "magic.h": [],
    "mppe.h": [],
    "arc4.h": [],
    "des.h": [],
    "md4.h": [],
    "md5.h": [],
    "sha1.h": [],
    "ppp.h": [],
    "ppp_impl.h": [],
    "pppcrypt.h": [],
    "pppdebug.h": [],
    "pppoe.h": [],
    "pppol2tp.h": [],
    "pppos.h": [],
    "upap.h": [],
    "vj.h": [],
    "slipif.h": [],
    "wlanif.h": [],
    "socket.h": [],
    "aes_alt.h": [],
    "aesni.h": [],
    "asn1.h": [],
    "asn1write.h": [],
    "bignum.h": [],
    "blowfish.h": [],
    "bn_mul.h": [],
    "camellia.h": [],
    "ccm.h": [],
    "certs.h": [],
    "check_config.h": [],
    "cipher.h": [],
    "cipher_internal.h": [],
    "compat-1.3.h": [],
    "config.h": [],
    "ctr_drbg.h": [],
    "dhm.h": [],
    "ecdh.h": [],
    "ecdsa.h": [],
    "ecjpake.h": [],
    "entropy.h": [],
    "entropy_poll.h": [],
    "error.h": [],
    "esp_config.h": [],
    "gcm.h": [],
    "havege.h": [],
    "hmac_drbg.h": [],
    "md.h": [],
    "md2.h": [],
    "md_internal.h": [],
    "memory_buffer_alloc.h": [],
    "net.h": [],
    "oid.h": [],
    "padlock.h": [],
    "pem.h": [],
    "pk.h": [],
    "pk_internal.h": [],
    "pkcs11.h": [],
    "pkcs12.h": [],
    "pkcs5.h": [],
    "platform.h": [],
    "ripemd160.h": [],
    "rsa.h": [],
    "sha256.h": [],
    "sha512.h": [],
    "ssl.h": [],
    "ssl_cache.h": [],
    "ssl_ciphersuites.h": [],
    "ssl_cookie.h": [],
    "ssl_internal.h": [],
    "ssl_ticket.h": [],
    "threading.h": [],
    "timing.h": [],
    "version.h": [],
    "x509.h": [],
    "x509_crl.h": [],
    "x509_crt.h": [],
    "x509_csr.h": [],
    "xtea.h": [],
    "sha1_alt.h": [],
    "sha256_alt.h": [],
    "sha512_alt.h": [],
    "_ansi.h": [],
    "_syslist.h": [],
    "alloca.h": [],
    "ar.h": [],
    "argz.h": [],
    "assert.h": [],
    "complex.h": [],
    "ctype.h": [],
    "dirent.h": [],
    "envlock.h": [],
    "envz.h": [],
    "errno.h": [],
    "fastmath.h": [],
    "fcntl.h": [],
    "fenv.h": [],
    "fnmatch.h": [],
    "getopt.h": [],
    "glob.h": [],
    "grp.h": [],
    "iconv.h": [],
    "ieeefp.h": [],
    "inttypes.h": [],
    "langinfo.h": [],
    "libgen.h": [],
    "limits.h": [],
    "locale.h": [],
    "_default_types.h": [],
    "_types.h": [],
    "ansi.h": [],
    "endian.h": [],
    "malloc.h": [],
    "param.h": [],
    "setjmp-dj.h": [],
    "setjmp.h": [],
    "stdlib.h": [],
    "termios.h": [],
    "time.h": [],
    "types.h": [],
    "math.h": [],
    "newlib.h": [],
    "paths.h": [],
    "pthread.h": [],
    "pwd.h": [],
    "reent.h": [],
    "regdef.h": [],
    "regex.h": [],
    "sched.h": [],
    "search.h": [],
    "signal.h": [],
    "spawn.h": [],
    "stdatomic.h": [],
    "stdint.h": [],
    "stdio.h": [],
    "stdio_ext.h": [],
    "string.h": [],
    "strings.h": [],
    "_default_fcntl.h": [],
    "_intsup.h": [],
    "cdefs.h": [],
    "custom_file.h": [],
    "dir.h": [],
    "features.h": [],
    "file.h": [],
    "iconvnls.h": [],
    "lock.h": [],
    "resource.h": [],
    "stat.h": [],
    "syslimits.h": [],
    "timeb.h": [],
    "times.h": [],
    "unistd.h": [],
    "utime.h": [],
    "wait.h": [],
    "tar.h": [],
    "tgmath.h": [],
    "unctrl.h": [],
    "utmp.h": [],
    "wchar.h": [],
    "wctype.h": [],
    "wordexp.h": [],
    "http_parser.h": [],
    "nghttp2.h": [],
    "nghttp2ver.h": [],
    "nghttp2_buf.h": [],
    "nghttp2_callbacks.h": [],
    "nghttp2_frame.h": [],
    "nghttp2_hd.h": [],
    "nghttp2_hd_huffman.h": [],
    "nghttp2_helper.h": [],
    "nghttp2_http.h": [],
    "nghttp2_int.h": [],
    "nghttp2_map.h": [],
    "nghttp2_mem.h": [],
    "nghttp2_net.h": [],
    "nghttp2_npn.h": [],
    "nghttp2_option.h": [],
    "nghttp2_outbound_item.h": [],
    "nghttp2_pq.h": [],
    "nghttp2_priority_spec.h": [],
    "nghttp2_queue.h": [],
    "nghttp2_rcbuf.h": [],
    "nghttp2_session.h": [],
    "nghttp2_stream.h": [],
    "nghttp2_submit.h": [],
    "nvs.h": [],
    "nvs_flash.h": [],
    "esp_spi_flash.h": [],
    "tcpip_adapter.h": [],
    "esp32.common.ld": [],
    "esp32.ld": [],
    "esp32.peripherals.ld": [],
    "esp32.rom.ld": [],
    "esp32_out.ld": [],
    "libbt.a": [],
    "libbtdm_app.a": [],
    "libc.a": [],
    "libcore.a": [],
    "libcrypto.a": [],
    "libdriver.a": [],
    "libesp32.a": [],
    "libexpat.a": [],
    "libfreertos.a": [],
    "libg.a": [],
    "libhal.a": [],
    "libjson.a": [],
    "liblog.a": [],
    "liblwip.a": [],
    "libm.a": [],
    "libmbedtls.a": [],
    "libnet80211.a": [],
    "libnghttp.a": [],
    "libnvs_flash.a": [],
    "libphy.a": [],
    "libpp.a": [],
    "librtc.a": [],
    "libsmartconfig.a": [],
    "libspi_flash.a": [],
    "libtcpip_adapter.a": [],
    "libwpa.a": [],
    "pins_arduino.h": [],
    "esp_brownout.h": [],
    "esp_gdbstub.h": [],
    "esp_heap_alloc_caps.h": [],
    "esp_int_wdt.h": [],
    "esp_panic.h": [],
    "esp_task_wdt.h": [],
    "esp_wifi_internal.h": [],
    "heap_alloc_caps.h": [],
    "esp_vfs.h": [],
    "esp_vfs_dev.h": [],
    "libnewlib.a": [],
    "libvfs.a": [],
    "esp_crosscore_int.h": [],
    "esp_flash_data_types.h": [],
    "frc_timer_reg.h": [],
    "esp_partition.h": [],
    "byteswap.h": [],
    "aes_i.h": [],
    "aes_wrap.h": [],
    "common.h": [],
    "crypto.h": [],
    "dh_group5.h": [],
    "dh_groups.h": [],
    "includes.h": [],
    "md5_i.h": [],
    "random.h": [],
    "sha1_i.h": [],
    "os.h": [],
    "ap_config.h": [],
    "eapol_common.h": [],
    "hostapd.h": [],
    "ieee80211_crypto.h": [],
    "ieee802_11_defs.h": [],
    "ieee802_1x.h": [],
    "sta_info.h": [],
    "state_machine.h": [],
    "wpa.h": [],
    "wpa_auth.h": [],
    "wpa_auth_i.h": [],
    "wpa_auth_ie.h": [],
    "wpa_common.h": [],
    "wpa_debug.h": [],
    "wpa_i.h": [],
    "wpa_ie.h": [],
    "wpabuf.h": [],
    "wpas_glue.h": [],
    "eap_common.h": [],
    "eap_config.h": [],
    "eap_defs.h": [],
    "eap_i.h": [],
    "eap_tls.h": [],
    "eap_tls_common.h": [],
    "libtommath.h": [],
    "pkcs1.h": [],
    "pkcs8.h": [],
    "tls.h": [],
    "tlsv1_client.h": [],
    "tlsv1_client_i.h": [],
    "tlsv1_common.h": [],
    "tlsv1_cred.h": [],
    "tlsv1_record.h": [],
    "tlsv1_server.h": [],
    "tlsv1_server_i.h": [],
    "x509v3.h": [],
    "ext_password.h": [],
    "ext_password_i.h": [],
    "eri.h": [],
    "xtensa-debug-module.h": [],
    "libcoexist.a": [],
    "libopenssl.a": [],
    "libwpa_supplicant.a": [],
    "libxtensa-debug-module.a": [],
    "Kconfig": [],
    "component.mk": [],
    "esp32-hal-ledc.c": [],
    "esp32-hal-sd.c": [],
    "WiFiServer.cpp": [],
    "WiFiServer.h": [],
    "WiFiUdp.cpp": [
        {
            "commit": "3e87dcf748102d7762f0c29032543dd9cfacf11a",
            "timestamp": "2017-02-08T23:10:16+02:00",
            "author": "Martin Sloup",
            "commit_message": "beginPacket can be used without listening on socket (#185)\n\nCurrently there is bug in WiFiUDP library when you want to use beginPacket(...) without listening on socket (without calling begin(...) first). You can't send any data because socket is not open and also tx_buffer is not allocated which cause crash while writing data to tx_buffer.",
            "additions": 22,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142
                        ],
                        "comments": [
                            "  // allocate tx_buffer if is necessary"
                        ],
                        "lines": [
                            "  if(!tx_buffer){",
                            "    tx_buffer = new char[1460];",
                            "    if(!tx_buffer){",
                            "      log_e(\"could not create tx buffer: %d\", errno);",
                            "      return 0;",
                            "    }",
                            "  }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155
                        ],
                        "comments": [
                            "  // check whereas socket is already open"
                        ],
                        "lines": [
                            "",
                            "  if (udp_server != -1)",
                            "    return 1;",
                            "",
                            "  if ((udp_server=socket(AF_INET, SOCK_DGRAM, 0)) == -1){",
                            "    log_e(\"could not create socket: %d\", errno);",
                            "    return 0;",
                            "  }",
                            "",
                            "  fcntl(udp_server, F_SETFL, O_NONBLOCK);",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "134": "  // allocate tx_buffer if is necessary",
                "145": "  // check whereas socket is already open"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "WiFiUdp.h": [],
    "rmt.h": [],
    "esp_eth.h": [],
    "libapp_update.a": [],
    "libbootloader_support.a": [],
    "libethernet.a": [],
    "libmicro-ecc.a": [],
    "libulp.a": [],
    "IPv6Address.cpp": [],
    "IPv6Address.h": [],
    "WiFiIPv6.ino": [],
    "WiFiSmartConfig.ino": [],
    "esp32-hal-time.c": [],
    "gen_esp32part.exe": [],
    "gen_esp32part.py": [],
    "default.csv": [],
    "platformio-build.py": [],
    "alarm.h": [],
    "allocator.h": [],
    "avct_api.h": [],
    "avdt_api.h": [],
    "avdt_defs.h": [],
    "avdtc_api.h": [],
    "avrc_api.h": [],
    "avrc_defs.h": [],
    "bdaddr.h": [],
    "blufi_int.h": [],
    "bt_common_types.h": [],
    "bt_defs.h": [],
    "bt_sdp.h": [],
    "bt_target.h": [],
    "bt_trace.h": [],
    "bt_types.h": [],
    "bt_vendor_lib.h": [],
    "bta_api.h": [],
    "bta_dm_ci.h": [],
    "bta_dm_co.h": [],
    "bta_gatt_api.h": [],
    "bta_gattc_ci.h": [],
    "bta_gattc_co.h": [],
    "bta_gattc_int.h": [],
    "bta_gatts_co.h": [],
    "bta_gatts_int.h": [],
    "bta_hh_api.h": [],
    "bta_hh_co.h": [],
    "bta_sdp_api.h": [],
    "bta_sys.h": [],
    "bta_sys_int.h": [],
    "btc_blufi_prf.h": [],
    "btc_gap_ble.h": [],
    "btc_gap_bt.h": [],
    "btc_gatt_util.h": [],
    "btc_gattc.h": [],
    "btc_gatts.h": [],
    "btc_main.h": [],
    "btc_manage.h": [],
    "btc_sdp.h": [],
    "btc_task.h": [],
    "bte.h": [],
    "bte_appl.h": [],
    "btm_api.h": [],
    "btm_ble_api.h": [],
    "btm_ble_int.h": [],
    "btm_int.h": [],
    "btu.h": [],
    "buffer.h": [],
    "buffer_allocator.h": [],
    "button_pro.h": [],
    "controller.h": [],
    "device_features.h": [],
    "dis_api.h": [],
    "dyn_mem.h": [],
    "esp_blufi_api.h": [],
    "esp_bt_defs.h": [],
    "esp_bt_device.h": [],
    "esp_bt_main.h": [],
    "esp_gap_ble_api.h": [],
    "esp_gatt_defs.h": [],
    "esp_gattc_api.h": [],
    "esp_gatts_api.h": [],
    "event_mask.h": [],
    "fixed_queue.h": [],
    "future.h": [],
    "gap_api.h": [],
    "gap_int.h": [],
    "gatt_api.h": [],
    "gatt_int.h": [],
    "gattdefs.h": [],
    "gki.h": [],
    "gki_common.h": [],
    "gki_int.h": [],
    "gki_target.h": [],
    "hash_functions.h": [],
    "hash_map.h": [],
    "hci_hal.h": [],
    "hci_internals.h": [],
    "hci_layer.h": [],
    "hci_packet_factory.h": [],
    "hci_packet_parser.h": [],
    "hcidefs.h": [],
    "hcimsgs.h": [],
    "hid_le_prf.h": [],
    "hiddefs.h": [],
    "hidh_api.h": [],
    "interop.h": [],
    "interop_database.h": [],
    "l2c_api.h": [],
    "l2c_int.h": [],
    "l2cap_client.h": [],
    "l2cdefs.h": [],
    "osi.h": [],
    "osi_arch.h": [],
    "p_256_ecc_pp.h": [],
    "p_256_multprecision.h": [],
    "packet_fragmenter.h": [],
    "port_api.h": [],
    "port_ext.h": [],
    "profiles_api.h": [],
    "rfcdefs.h": [],
    "sdp_api.h": [],
    "sdpdefs.h": [],
    "sdpint.h": [],
    "smp_api.h": [],
    "smp_int.h": [],
    "srvc_api.h": [],
    "thread.h": [],
    "utl.h": [],
    "wx_airsync_prf.h": [],
    "ssl_dbg.h": [],
    "ssl_opt.h": [],
    "ssl_pm.h": [],
    "ssl_port.h": [],
    "libcoap.a": [],
    "libcxx.a": [],
    "libfatfs.a": [],
    "libmdns.a": [],
    "libsdmmc.a": [],
    "libwpa2.a": [],
    "libwps.a": [],
    "ESP32NVS.cpp": [
        {
            "commit": "bfa979a90074339b8e605746d7e3882d815ac80f",
            "timestamp": "2017-02-08T23:09:42+02:00",
            "author": "me-no-dev",
            "commit_message": "Add initial NVS Arduino implementation",
            "additions": 397,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "",
                            "#include \"ESP32NVS.h\"",
                            "",
                            "#include \"nvs.h\"",
                            "",
                            "const char * nvs_errors[] = { \"OTHER\", \"NOT_INITIALIZED\", \"NOT_FOUND\", \"TYPE_MISMATCH\", \"READ_ONLY\", \"NOT_ENOUGH_SPACE\", \"INVALID_NAME\", \"INVALID_HANDLE\", \"REMOVE_FAILED\", \"KEY_TOO_LONG\", \"PAGE_FULL\", \"INVALID_STATE\", \"INVALID_LENGHT\"};",
                            "#define nvs_error(e) (((e)>ESP_ERR_NVS_BASE)?nvs_errors[(e)&~(ESP_ERR_NVS_BASE)]:nvs_errors[0])",
                            "",
                            "NVSClass::NVSClass()",
                            "    :_handle(0)",
                            "    ,_started(false)",
                            "    ,_readOnly(false)",
                            "{}",
                            "",
                            "NVSClass::~NVSClass(){",
                            "    end();",
                            "}",
                            "",
                            "bool NVSClass::begin(const char * name, bool readOnly){",
                            "    if(_started){",
                            "        return false;",
                            "    }",
                            "    _readOnly = readOnly;",
                            "    esp_err_t err = nvs_open(name, readOnly?NVS_READONLY:NVS_READWRITE, &_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_open failed: %s\", nvs_error(err));",
                            "        return false;",
                            "    }",
                            "    _started = true;",
                            "    return true;",
                            "}",
                            "",
                            "void NVSClass::end(){",
                            "    if(!_started){",
                            "        return;",
                            "    }",
                            "    nvs_close(_handle);",
                            "    _started = false;",
                            "}",
                            "",
                            "/*",
                            " * Erase",
                            " * */",
                            "",
                            "bool NVSClass::erase(){",
                            "    if(!_started || _readOnly){",
                            "        return false;",
                            "    }",
                            "    esp_err_t err = nvs_erase_all(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_erase_all fail: %s\", nvs_error(err));",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "bool NVSClass::erase(const char * key){",
                            "    if(!_started || !key || _readOnly){",
                            "        return false;",
                            "    }",
                            "    esp_err_t err = nvs_erase_key(_handle, key);",
                            "    if(err){",
                            "        log_e(\"nvs_erase_key fail: %s %s\", key, nvs_error(err));",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "/*",
                            " * Write",
                            " * */",
                            "",
                            "size_t NVSClass::writeChar(const char* key, int8_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_i8(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_i8 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 1;",
                            "}",
                            "",
                            "size_t NVSClass::writeUChar(const char* key, uint8_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_u8(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_u8 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 1;",
                            "}",
                            "",
                            "size_t NVSClass::writeShort(const char* key, int16_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_i16(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_i16 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 2;",
                            "}",
                            "",
                            "size_t NVSClass::writeUShort(const char* key, uint16_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_u16(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_u16 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 2;",
                            "}",
                            "",
                            "size_t NVSClass::writeInt(const char* key, int32_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_i32(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_i32 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 4;",
                            "}",
                            "",
                            "size_t NVSClass::writeUInt(const char* key, uint32_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_u32(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_u32 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 4;",
                            "}",
                            "",
                            "size_t NVSClass::writeLong(const char* key, int64_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_i64(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_i64 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 8;",
                            "}",
                            "",
                            "size_t NVSClass::writeULong(const char* key, uint64_t value){",
                            "    if(!_started || !key || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_u64(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_u64 fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return 8;",
                            "}",
                            "",
                            "size_t NVSClass::writeString(const char* key, const char* value){",
                            "    if(!_started || !key || !value || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_str(_handle, key, value);",
                            "    if(err){",
                            "        log_e(\"nvs_set_str fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return strlen(value);",
                            "}",
                            "",
                            "size_t NVSClass::writeBytes(const char* key, const void* value, size_t len){",
                            "    if(!_started || !key || !value || !len || _readOnly){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_set_blob(_handle, key, value, len);",
                            "    if(err){",
                            "        log_e(\"nvs_set_blob fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    err = nvs_commit(_handle);",
                            "    if(err){",
                            "        log_e(\"nvs_commit fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return len;",
                            "}",
                            "",
                            "/*",
                            " * Read",
                            " * */",
                            "",
                            "int8_t NVSClass::readChar(const char* key){",
                            "    int8_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_i8(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_i8 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "uint8_t NVSClass::readUChar(const char* key){",
                            "    uint8_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_u8(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_u8 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "int16_t NVSClass::readShort(const char* key){",
                            "    int16_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_i16(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_i16 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "uint16_t NVSClass::readUShort(const char* key){",
                            "    uint16_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_u16(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_u16 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "int32_t NVSClass::readInt(const char* key){",
                            "    int32_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_i32(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_i32 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "uint32_t NVSClass::readUInt(const char* key){",
                            "    uint32_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_u32(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_u32 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "int64_t NVSClass::readLong(const char* key){",
                            "    int64_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_i64(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_i64 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "uint64_t NVSClass::readULong(const char* key){",
                            "    uint64_t value = 0;",
                            "    if(!_started || !key){",
                            "        return value;",
                            "    }",
                            "    esp_err_t err = nvs_get_u64(_handle, key, &value);",
                            "    if(err){",
                            "        log_e(\"nvs_get_u64 fail: %s %s\", key, nvs_error(err));",
                            "    }",
                            "    return value;",
                            "}",
                            "",
                            "String NVSClass::readString(const char* key){",
                            "    char * value = NULL;",
                            "    size_t len = 0;",
                            "    if(!_started || !key){",
                            "        return String();",
                            "    }",
                            "    esp_err_t err = nvs_get_str(_handle, key, value, &len);",
                            "    if(err){",
                            "        log_e(\"nvs_get_str len fail: %s %s\", key, nvs_error(err));",
                            "        return String();",
                            "    }",
                            "    char buf[len];",
                            "    value = buf;",
                            "    err = nvs_get_str(_handle, key, value, &len);",
                            "    if(err){",
                            "        log_e(\"nvs_get_str fail: %s %s\", key, nvs_error(err));",
                            "        return String();",
                            "    }",
                            "    return String(buf);",
                            "}",
                            "",
                            "size_t NVSClass::readBytes(const char* key, void * buf, size_t maxLen){",
                            "    size_t len = 0;",
                            "    if(!_started || !key || !buf || !maxLen){",
                            "        return 0;",
                            "    }",
                            "    esp_err_t err = nvs_get_blob(_handle, key, NULL, &len);",
                            "    if(err){",
                            "        log_e(\"nvs_get_blob len fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    if(len > maxLen){",
                            "        log_e(\"not enough space in buffer: %u < %u\", maxLen, len);",
                            "        return 0;",
                            "    }",
                            "    err = nvs_get_blob(_handle, key, buf, &len);",
                            "    if(err){",
                            "        log_e(\"nvs_get_blob fail: %s %s\", key, nvs_error(err));",
                            "        return 0;",
                            "    }",
                            "    return len;",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "6": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "8": "// Unless required by applicable law or agreed to in writing, software",
                "9": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "10": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "11": "// See the License for the specific language governing permissions and",
                "12": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "ESP32NVS.h": [],
    "boot_app0.bin": [],
    "default.bin": [],
    "StartCounter.ino": [],
    "WiFiClientSecure.ino": [],
    "WiFiClientSecure.cpp": [],
    "WiFiClientSecure.h": [],
    "ssl_client.cpp": [
        {
            "commit": "8ab3231e31cb3b94d80cbfd7dd1c1eac6f646236",
            "timestamp": "2017-02-11T00:20:24+02:00",
            "author": "copercini",
            "commit_message": "Add WiFiClient secure lib (#184)\n\n* Provide SSL/TLS functions to ESP32 with Arduino IDE\r\n\r\n* Generate a new random number in case of reconnection",
            "additions": 327,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327
                        ],
                        "comments": [
                            "        // TODO: implement match CN verification",
                            "                // Hostname set here should match CN in server certificate"
                        ],
                        "lines": [
                            "",
                            "        DEBUG_PRINT( \"Setting hostname for TLS session...\\n\");",
                            "",
                            "        if((ret = mbedtls_ssl_set_hostname(&ssl_client->ssl_ctx, host)) != 0)",
                            "        {",
                            "            printf( \"mbedtls_ssl_set_hostname returned -0x%x\\n\", -ret);",
                            "            break;",
                            "        }",
                            "        */",
                            "",
                            "        DEBUG_PRINT( \"Setting up the SSL/TLS structure...\\n\");",
                            "",
                            "        if ((ret = mbedtls_ssl_config_defaults(&ssl_client->ssl_conf,",
                            "                                               MBEDTLS_SSL_IS_CLIENT,",
                            "                                               MBEDTLS_SSL_TRANSPORT_STREAM,",
                            "                                               MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {",
                            "            printf( \"mbedtls_ssl_config_defaults returned %d\\n\", ret);",
                            "            break;",
                            "        }",
                            "",
                            "        mbedtls_ssl_conf_rng(&ssl_client->ssl_conf, mbedtls_ctr_drbg_random, &ssl_client->drbg_ctx);",
                            "#ifdef MBEDTLS_DEBUG_C",
                            "        mbedtls_debug_set_threshold(MBEDTLS_DEBUG_LEVEL);",
                            "        mbedtls_ssl_conf_dbg(&ssl_client->ssl_conf, mbedtls_debug, NULL);",
                            "#endif",
                            "",
                            "        if ((ret = mbedtls_ssl_setup(&ssl_client->ssl_ctx, &ssl_client->ssl_conf)) != 0) {",
                            "            printf( \"mbedtls_ssl_setup returned -0x%x\\n\\n\", -ret);",
                            "            break;",
                            "        }",
                            "",
                            "        mbedtls_ssl_set_bio(&ssl_client->ssl_ctx, &ssl_client->socket, mbedtls_net_send, mbedtls_net_recv, NULL );",
                            "",
                            "        DEBUG_PRINT( \"Performing the SSL/TLS handshake...\\n\");",
                            "",
                            "        while ((ret = mbedtls_ssl_handshake(&ssl_client->ssl_ctx)) != 0) {",
                            "            if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE && ret != -76) {",
                            "                printf( \"mbedtls_ssl_handshake returned -0x%x\\n\", -ret);",
                            "                break;",
                            "            }",
                            "            delay(10);",
                            "            vPortYield();",
                            "        }",
                            "",
                            "",
                            "        if (cli_cert != NULL && cli_key != NULL) {",
                            "            DEBUG_PRINT(\"Protocol is %s \\nCiphersuite is %s\\n\", mbedtls_ssl_get_version(&ssl_client->ssl_ctx), mbedtls_ssl_get_ciphersuite(&ssl_client->ssl_ctx));",
                            "            if ((ret = mbedtls_ssl_get_record_expansion(&ssl_client->ssl_ctx)) >= 0) {",
                            "                DEBUG_PRINT(\"Record expansion is %d\\n\", ret);",
                            "            } else {",
                            "                DEBUG_PRINT(\"Record expansion is unknown (compression)\\n\");",
                            "            }",
                            "        }",
                            "",
                            "",
                            "            DEBUG_PRINT( \"Verifying peer X.509 certificate...\\n\");",
                            "",
                            "            if ((flags = mbedtls_ssl_get_verify_result(&ssl_client->ssl_ctx)) != 0) {",
                            "                printf( \"Failed to verify peer certificate!\\n\");",
                            "                bzero(buf, sizeof(buf));",
                            "                mbedtls_x509_crt_verify_info(buf, sizeof(buf), \"  ! \", flags);",
                            "                printf( \"verification info: %s\\n\", buf);",
                            "                stop_ssl_socket(ssl_client, rootCABuff, cli_cert, cli_key);  //It's not safe continue.",
                            "            } else {",
                            "                DEBUG_PRINT( \"Certificate verified.\\n\");",
                            "            }",
                            "",
                            "    } while (0);",
                            "",
                            "    DEBUG_PRINT(\"Free heap after TLS %u\\n\", xPortGetFreeHeapSize());",
                            "",
                            "    return ssl_client->socket;",
                            "}",
                            "",
                            "",
                            "void stop_ssl_socket(sslclient_context *ssl_client, unsigned char *rootCABuff, unsigned char *cli_cert, unsigned char *cli_key)",
                            "{",
                            "    DEBUG_PRINT( \"\\nCleaning SSL connection.\\n\");",
                            "    close(ssl_client->socket);",
                            "    ssl_client->socket = -1;",
                            "    mbedtls_ssl_free(&ssl_client->ssl_ctx);",
                            "    mbedtls_ssl_config_free(&ssl_client->ssl_conf);",
                            "    mbedtls_ctr_drbg_free(&ssl_client->drbg_ctx);",
                            "    mbedtls_entropy_free(&ssl_client->entropy_ctx);",
                            "",
                            "    if (rootCABuff != NULL) {",
                            "        mbedtls_x509_crt_free(&ssl_client->ca_cert);",
                            "    }",
                            "",
                            "    if (cli_cert != NULL) {",
                            "        mbedtls_x509_crt_free(&ssl_client->client_cert);",
                            "    }",
                            "",
                            "    if (cli_key != NULL) {",
                            "        mbedtls_pk_free(&ssl_client->client_key);",
                            "    }",
                            "}",
                            "",
                            "",
                            "int data_to_read(sslclient_context *ssl_client)",
                            "{",
                            "",
                            "    int ret, res;",
                            "    ret = mbedtls_ssl_read(&ssl_client->ssl_ctx, NULL, 0);",
                            "    //printf(\"RET: %i\\n\",ret);   //for low level debug",
                            "    res = mbedtls_ssl_get_bytes_avail(&ssl_client->ssl_ctx);",
                            "    //printf(\"RES: %i\\n\",res);",
                            "    if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE && ret < 0 && ret != -76) {",
                            "        printf(\"MbedTLS error %i\", ret);",
                            "    }",
                            "",
                            "    return res;",
                            "}",
                            "",
                            "",
                            "",
                            "int send_ssl_data(sslclient_context *ssl_client, const uint8_t *data, uint16_t len)",
                            "{",
                            "    //DEBUG_PRINT( \"Writing HTTP request...\\n\");  //for low level debug",
                            "    int ret = -1;",
                            "",
                            "    while ((ret = mbedtls_ssl_write(&ssl_client->ssl_ctx, data, len)) <= 0) {",
                            "        if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE && ret != -76) {",
                            "            printf( \"mbedtls_ssl_write returned -0x%x\\n\", -ret);",
                            "            break;",
                            "        }",
                            "    }",
                            "",
                            "    len = ret;",
                            "    //DEBUG_PRINT( \"%d bytes written\\n\", len);  //for low level debug",
                            "    return ret;",
                            "}",
                            "",
                            "",
                            "",
                            "int get_ssl_receive(sslclient_context *ssl_client, uint8_t *data, int length)",
                            "{",
                            "    //DEBUG_PRINT( \"Reading HTTP response...\\n\");   //for low level debug",
                            "    int ret = -1;",
                            "",
                            "    ret = mbedtls_ssl_read(&ssl_client->ssl_ctx, data, length);",
                            "",
                            "    //DEBUG_PRINT( \"%d bytes readed\\n\", ret);   //for low level debug",
                            "    return ret;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "181": "        // TODO: implement match CN verification",
                "185": "                // Hostname set here should match CN in server certificate"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "ad179548e41b410b9040700a783ff4de350da7c9",
            "timestamp": "2017-08-23T21:33:26-03:00",
            "author": "copercini",
            "commit_message": "SNI support (#592)\n\nServer Name Indication (SNI) support for WiFiClientSecure\r\n\r\nFix https://github.com/espressif/arduino-esp32/issues/571 and https://github.com/espressif/arduino-esp32/issues/550",
            "additions": 18,
            "deletions": 17,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            100,
                            101,
                            102
                        ],
                        "comments": [
                            "    // MBEDTLS_SSL_VERIFY_REQUIRED if a CA certificate is defined on Arduino IDE and",
                            "    // MBEDTLS_SSL_VERIFY_NONE if not."
                        ],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            139
                        ],
                        "comments": [],
                        "lines": [
                            "    log_i(\"Setting hostname for TLS session...\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            142,
                            143,
                            144
                        ],
                        "comments": [],
                        "lines": [
                            "    if((ret = mbedtls_ssl_set_hostname(&ssl_client->ssl_ctx, host)) != 0){",
                            "        return handle_error(ret);",
                            "\t}"
                        ]
                    },
                    {
                        "line_numbers": [
                            225
                        ],
                        "comments": [],
                        "lines": [
                            "    //log_e(\"RES: %i\",res);    //for low level debug"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            133
                        ],
                        "comments": [
                            "        // TODO: implement match CN verification"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143
                        ],
                        "comments": [
                            "                // Hostname set here should match CN in server certificate"
                        ],
                        "lines": [
                            "        log_i(\"Setting hostname for TLS session...\");",
                            "",
                            "        if((ret = mbedtls_ssl_set_hostname(&ssl_client->ssl_ctx, host)) != 0)",
                            "        {",
                            "            return handle_error(ret);",
                            "",
                            "        }",
                            "    */"
                        ]
                    },
                    {
                        "line_numbers": [
                            224
                        ],
                        "comments": [],
                        "lines": [
                            "    //log_e(\"RES: %i\",res);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "100": "    // MBEDTLS_SSL_VERIFY_REQUIRED if a CA certificate is defined on Arduino IDE and",
                "101": "    // MBEDTLS_SSL_VERIFY_NONE if not.",
                "141": "    // Hostname set here should match CN in server certificate"
            },
            "comment_deleted_diff": {
                "133": "        // TODO: implement match CN verification",
                "137": "                // Hostname set here should match CN in server certificate"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "c92b61739743e6df0768bbcba1e0b53755ec91d8",
            "timestamp": "2018-04-16T16:34:39+02:00",
            "author": "Craig Leres",
            "commit_message": "Convert the few remaining cr/lf files to use lf for eol. (#1316)\n\nIf you develop on windows and need cr/lf files, see this:\r\n\r\n    https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_formatting_and_whitespace\r\n\r\n    Git can handle this by auto-converting CRLF line endings into LF\r\n    when you add a file to the index, and vice versa when it checks out\r\n    code onto your filesystem. You can turn on this functionality with\r\n    the core.autocrlf setting. If you're on a Windows machine, set it\r\n    to true - this converts LF endings into CRLF when you check out code:\r\n\r\n    $ git config --global core.autocrlf true",
            "additions": 264,
            "deletions": 264,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264
                        ],
                        "comments": [
                            "    // MBEDTLS_SSL_VERIFY_REQUIRED if a CA certificate is defined on Arduino IDE and",
                            "    // MBEDTLS_SSL_VERIFY_NONE if not.",
                            "    // Hostname set here should match CN in server certificate"
                        ],
                        "lines": [
                            "",
                            "    if (rootCABuff != NULL) {",
                            "        log_v(\"Loading CA cert\");",
                            "        mbedtls_x509_crt_init(&ssl_client->ca_cert);",
                            "        mbedtls_ssl_conf_authmode(&ssl_client->ssl_conf, MBEDTLS_SSL_VERIFY_REQUIRED);",
                            "        ret = mbedtls_x509_crt_parse(&ssl_client->ca_cert, (const unsigned char *)rootCABuff, strlen(rootCABuff) + 1);",
                            "        mbedtls_ssl_conf_ca_chain(&ssl_client->ssl_conf, &ssl_client->ca_cert, NULL);",
                            "        //mbedtls_ssl_conf_verify(&ssl_client->ssl_ctx, my_verify, NULL );",
                            "        if (ret < 0) {",
                            "            return handle_error(ret);",
                            "        }",
                            "    } else {",
                            "        mbedtls_ssl_conf_authmode(&ssl_client->ssl_conf, MBEDTLS_SSL_VERIFY_NONE);",
                            "        log_i(\"WARNING: Use certificates for a more secure communication!\");",
                            "    }",
                            "",
                            "    if (cli_cert != NULL && cli_key != NULL) {",
                            "        mbedtls_x509_crt_init(&ssl_client->client_cert);",
                            "        mbedtls_pk_init(&ssl_client->client_key);",
                            "",
                            "        log_v(\"Loading CRT cert\");",
                            "",
                            "        ret = mbedtls_x509_crt_parse(&ssl_client->client_cert, (const unsigned char *)cli_cert, strlen(cli_cert) + 1);",
                            "        if (ret < 0) {",
                            "            return handle_error(ret);",
                            "        }",
                            "",
                            "        log_v(\"Loading private key\");",
                            "        ret = mbedtls_pk_parse_key(&ssl_client->client_key, (const unsigned char *)cli_key, strlen(cli_key) + 1, NULL, 0);",
                            "",
                            "        if (ret != 0) {",
                            "            return handle_error(ret);",
                            "        }",
                            "",
                            "        mbedtls_ssl_conf_own_cert(&ssl_client->ssl_conf, &ssl_client->client_cert, &ssl_client->client_key);",
                            "    }",
                            "",
                            "    log_v(\"Setting hostname for TLS session...\");",
                            "",
                            "    if((ret = mbedtls_ssl_set_hostname(&ssl_client->ssl_ctx, host)) != 0){",
                            "        return handle_error(ret);",
                            "\t}",
                            "",
                            "    mbedtls_ssl_conf_rng(&ssl_client->ssl_conf, mbedtls_ctr_drbg_random, &ssl_client->drbg_ctx);",
                            "",
                            "    if ((ret = mbedtls_ssl_setup(&ssl_client->ssl_ctx, &ssl_client->ssl_conf)) != 0) {",
                            "        return handle_error(ret);",
                            "    }",
                            "",
                            "    mbedtls_ssl_set_bio(&ssl_client->ssl_ctx, &ssl_client->socket, mbedtls_net_send, mbedtls_net_recv, NULL );",
                            "",
                            "    log_v(\"Performing the SSL/TLS handshake...\");",
                            "",
                            "    while ((ret = mbedtls_ssl_handshake(&ssl_client->ssl_ctx)) != 0) {",
                            "        if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {",
                            "            return handle_error(ret);",
                            "        }",
                            "\tvTaskDelay(10 / portTICK_PERIOD_MS);",
                            "    }",
                            "",
                            "",
                            "    if (cli_cert != NULL && cli_key != NULL) {",
                            "        log_d(\"Protocol is %s Ciphersuite is %s\", mbedtls_ssl_get_version(&ssl_client->ssl_ctx), mbedtls_ssl_get_ciphersuite(&ssl_client->ssl_ctx));",
                            "        if ((ret = mbedtls_ssl_get_record_expansion(&ssl_client->ssl_ctx)) >= 0) {",
                            "            log_d(\"Record expansion is %d\", ret);",
                            "        } else {",
                            "            log_w(\"Record expansion is unknown (compression)\");",
                            "        }",
                            "    }",
                            "",
                            "    log_v(\"Verifying peer X.509 certificate...\");",
                            "",
                            "    if ((flags = mbedtls_ssl_get_verify_result(&ssl_client->ssl_ctx)) != 0) {",
                            "        bzero(buf, sizeof(buf));",
                            "        mbedtls_x509_crt_verify_info(buf, sizeof(buf), \"  ! \", flags);",
                            "        log_e(\"Failed to verify peer certificate! verification info: %s\", buf);",
                            "        stop_ssl_socket(ssl_client, rootCABuff, cli_cert, cli_key);  //It's not safe continue.",
                            "        return handle_error(ret);",
                            "    } else {",
                            "        log_v(\"Certificate verified.\");",
                            "    }",
                            "",
                            "    if (rootCABuff != NULL) {",
                            "        mbedtls_x509_crt_free(&ssl_client->ca_cert);",
                            "    }",
                            "",
                            "    if (cli_cert != NULL) {",
                            "        mbedtls_x509_crt_free(&ssl_client->client_cert);",
                            "    }",
                            "",
                            "    if (cli_key != NULL) {",
                            "        mbedtls_pk_free(&ssl_client->client_key);",
                            "    }",
                            "",
                            "    log_v(\"Free heap after TLS %u\", xPortGetFreeHeapSize());",
                            "",
                            "    return ssl_client->socket;",
                            "}",
                            "",
                            "",
                            "void stop_ssl_socket(sslclient_context *ssl_client, const char *rootCABuff, const char *cli_cert, const char *cli_key)",
                            "{",
                            "    log_v(\"Cleaning SSL connection.\");",
                            "",
                            "    if (ssl_client->socket >= 0) {",
                            "        close(ssl_client->socket);",
                            "        ssl_client->socket = -1;",
                            "    }",
                            "",
                            "    mbedtls_ssl_free(&ssl_client->ssl_ctx);",
                            "    mbedtls_ssl_config_free(&ssl_client->ssl_conf);",
                            "    mbedtls_ctr_drbg_free(&ssl_client->drbg_ctx);",
                            "    mbedtls_entropy_free(&ssl_client->entropy_ctx);",
                            "}",
                            "",
                            "",
                            "int data_to_read(sslclient_context *ssl_client)",
                            "{",
                            "    int ret, res;",
                            "    ret = mbedtls_ssl_read(&ssl_client->ssl_ctx, NULL, 0);",
                            "    //log_e(\"RET: %i\",ret);   //for low level debug",
                            "    res = mbedtls_ssl_get_bytes_avail(&ssl_client->ssl_ctx);",
                            "    //log_e(\"RES: %i\",res);    //for low level debug",
                            "    if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE && ret < 0) {",
                            "        return handle_error(ret);",
                            "    }",
                            "",
                            "    return res;",
                            "}",
                            "",
                            "",
                            "int send_ssl_data(sslclient_context *ssl_client, const uint8_t *data, uint16_t len)",
                            "{",
                            "    log_v(\"Writing HTTP request...\");  //for low level debug",
                            "    int ret = -1;",
                            "",
                            "    while ((ret = mbedtls_ssl_write(&ssl_client->ssl_ctx, data, len)) <= 0) {",
                            "        if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {",
                            "            return handle_error(ret);",
                            "        }",
                            "    }",
                            "",
                            "    len = ret;",
                            "    //log_v(\"%d bytes written\", len);  //for low level debug",
                            "    return ret;",
                            "}",
                            "",
                            "",
                            "int get_ssl_receive(sslclient_context *ssl_client, uint8_t *data, int length)",
                            "{",
                            "    //log_d( \"Reading HTTP response...\");   //for low level debug",
                            "    int ret = -1;",
                            "",
                            "    ret = mbedtls_ssl_read(&ssl_client->ssl_ctx, data, length);",
                            "",
                            "    //log_v( \"%d bytes read\", ret);   //for low level debug",
                            "    return ret;",
                            "}"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264
                        ],
                        "comments": [
                            "    // MBEDTLS_SSL_VERIFY_REQUIRED if a CA certificate is defined on Arduino IDE and",
                            "    // MBEDTLS_SSL_VERIFY_NONE if not.",
                            "    // Hostname set here should match CN in server certificate"
                        ],
                        "lines": [
                            "",
                            "    if (rootCABuff != NULL) {",
                            "        log_v(\"Loading CA cert\");",
                            "        mbedtls_x509_crt_init(&ssl_client->ca_cert);",
                            "        mbedtls_ssl_conf_authmode(&ssl_client->ssl_conf, MBEDTLS_SSL_VERIFY_REQUIRED);",
                            "        ret = mbedtls_x509_crt_parse(&ssl_client->ca_cert, (const unsigned char *)rootCABuff, strlen(rootCABuff) + 1);",
                            "        mbedtls_ssl_conf_ca_chain(&ssl_client->ssl_conf, &ssl_client->ca_cert, NULL);",
                            "        //mbedtls_ssl_conf_verify(&ssl_client->ssl_ctx, my_verify, NULL );",
                            "        if (ret < 0) {",
                            "            return handle_error(ret);",
                            "        }",
                            "    } else {",
                            "        mbedtls_ssl_conf_authmode(&ssl_client->ssl_conf, MBEDTLS_SSL_VERIFY_NONE);",
                            "        log_i(\"WARNING: Use certificates for a more secure communication!\");",
                            "    }",
                            "",
                            "    if (cli_cert != NULL && cli_key != NULL) {",
                            "        mbedtls_x509_crt_init(&ssl_client->client_cert);",
                            "        mbedtls_pk_init(&ssl_client->client_key);",
                            "",
                            "        log_v(\"Loading CRT cert\");",
                            "",
                            "        ret = mbedtls_x509_crt_parse(&ssl_client->client_cert, (const unsigned char *)cli_cert, strlen(cli_cert) + 1);",
                            "        if (ret < 0) {",
                            "            return handle_error(ret);",
                            "        }",
                            "",
                            "        log_v(\"Loading private key\");",
                            "        ret = mbedtls_pk_parse_key(&ssl_client->client_key, (const unsigned char *)cli_key, strlen(cli_key) + 1, NULL, 0);",
                            "",
                            "        if (ret != 0) {",
                            "            return handle_error(ret);",
                            "        }",
                            "",
                            "        mbedtls_ssl_conf_own_cert(&ssl_client->ssl_conf, &ssl_client->client_cert, &ssl_client->client_key);",
                            "    }",
                            "",
                            "    log_v(\"Setting hostname for TLS session...\");",
                            "",
                            "    if((ret = mbedtls_ssl_set_hostname(&ssl_client->ssl_ctx, host)) != 0){",
                            "        return handle_error(ret);",
                            "\t}",
                            "",
                            "    mbedtls_ssl_conf_rng(&ssl_client->ssl_conf, mbedtls_ctr_drbg_random, &ssl_client->drbg_ctx);",
                            "",
                            "    if ((ret = mbedtls_ssl_setup(&ssl_client->ssl_ctx, &ssl_client->ssl_conf)) != 0) {",
                            "        return handle_error(ret);",
                            "    }",
                            "",
                            "    mbedtls_ssl_set_bio(&ssl_client->ssl_ctx, &ssl_client->socket, mbedtls_net_send, mbedtls_net_recv, NULL );",
                            "",
                            "    log_v(\"Performing the SSL/TLS handshake...\");",
                            "",
                            "    while ((ret = mbedtls_ssl_handshake(&ssl_client->ssl_ctx)) != 0) {",
                            "        if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {",
                            "            return handle_error(ret);",
                            "        }",
                            "\tvTaskDelay(10 / portTICK_PERIOD_MS);",
                            "    }",
                            "",
                            "",
                            "    if (cli_cert != NULL && cli_key != NULL) {",
                            "        log_d(\"Protocol is %s Ciphersuite is %s\", mbedtls_ssl_get_version(&ssl_client->ssl_ctx), mbedtls_ssl_get_ciphersuite(&ssl_client->ssl_ctx));",
                            "        if ((ret = mbedtls_ssl_get_record_expansion(&ssl_client->ssl_ctx)) >= 0) {",
                            "            log_d(\"Record expansion is %d\", ret);",
                            "        } else {",
                            "            log_w(\"Record expansion is unknown (compression)\");",
                            "        }",
                            "    }",
                            "",
                            "    log_v(\"Verifying peer X.509 certificate...\");",
                            "",
                            "    if ((flags = mbedtls_ssl_get_verify_result(&ssl_client->ssl_ctx)) != 0) {",
                            "        bzero(buf, sizeof(buf));",
                            "        mbedtls_x509_crt_verify_info(buf, sizeof(buf), \"  ! \", flags);",
                            "        log_e(\"Failed to verify peer certificate! verification info: %s\", buf);",
                            "        stop_ssl_socket(ssl_client, rootCABuff, cli_cert, cli_key);  //It's not safe continue.",
                            "        return handle_error(ret);",
                            "    } else {",
                            "        log_v(\"Certificate verified.\");",
                            "    }",
                            "",
                            "    if (rootCABuff != NULL) {",
                            "        mbedtls_x509_crt_free(&ssl_client->ca_cert);",
                            "    }",
                            "",
                            "    if (cli_cert != NULL) {",
                            "        mbedtls_x509_crt_free(&ssl_client->client_cert);",
                            "    }",
                            "",
                            "    if (cli_key != NULL) {",
                            "        mbedtls_pk_free(&ssl_client->client_key);",
                            "    }",
                            "",
                            "    log_v(\"Free heap after TLS %u\", xPortGetFreeHeapSize());",
                            "",
                            "    return ssl_client->socket;",
                            "}",
                            "",
                            "",
                            "void stop_ssl_socket(sslclient_context *ssl_client, const char *rootCABuff, const char *cli_cert, const char *cli_key)",
                            "{",
                            "    log_v(\"Cleaning SSL connection.\");",
                            "",
                            "    if (ssl_client->socket >= 0) {",
                            "        close(ssl_client->socket);",
                            "        ssl_client->socket = -1;",
                            "    }",
                            "",
                            "    mbedtls_ssl_free(&ssl_client->ssl_ctx);",
                            "    mbedtls_ssl_config_free(&ssl_client->ssl_conf);",
                            "    mbedtls_ctr_drbg_free(&ssl_client->drbg_ctx);",
                            "    mbedtls_entropy_free(&ssl_client->entropy_ctx);",
                            "}",
                            "",
                            "",
                            "int data_to_read(sslclient_context *ssl_client)",
                            "{",
                            "    int ret, res;",
                            "    ret = mbedtls_ssl_read(&ssl_client->ssl_ctx, NULL, 0);",
                            "    //log_e(\"RET: %i\",ret);   //for low level debug",
                            "    res = mbedtls_ssl_get_bytes_avail(&ssl_client->ssl_ctx);",
                            "    //log_e(\"RES: %i\",res);    //for low level debug",
                            "    if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE && ret < 0) {",
                            "        return handle_error(ret);",
                            "    }",
                            "",
                            "    return res;",
                            "}",
                            "",
                            "",
                            "int send_ssl_data(sslclient_context *ssl_client, const uint8_t *data, uint16_t len)",
                            "{",
                            "    log_v(\"Writing HTTP request...\");  //for low level debug",
                            "    int ret = -1;",
                            "",
                            "    while ((ret = mbedtls_ssl_write(&ssl_client->ssl_ctx, data, len)) <= 0) {",
                            "        if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {",
                            "            return handle_error(ret);",
                            "        }",
                            "    }",
                            "",
                            "    len = ret;",
                            "    //log_v(\"%d bytes written\", len);  //for low level debug",
                            "    return ret;",
                            "}",
                            "",
                            "",
                            "int get_ssl_receive(sslclient_context *ssl_client, uint8_t *data, int length)",
                            "{",
                            "    //log_d( \"Reading HTTP response...\");   //for low level debug",
                            "    int ret = -1;",
                            "",
                            "    ret = mbedtls_ssl_read(&ssl_client->ssl_ctx, data, length);",
                            "",
                            "    //log_v( \"%d bytes read\", ret);   //for low level debug",
                            "    return ret;",
                            "}"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "104": "    // MBEDTLS_SSL_VERIFY_REQUIRED if a CA certificate is defined on Arduino IDE and",
                "105": "    // MBEDTLS_SSL_VERIFY_NONE if not.",
                "145": "    // Hostname set here should match CN in server certificate"
            },
            "comment_deleted_diff": {
                "104": "    // MBEDTLS_SSL_VERIFY_REQUIRED if a CA certificate is defined on Arduino IDE and",
                "105": "    // MBEDTLS_SSL_VERIFY_NONE if not.",
                "145": "    // Hostname set here should match CN in server certificate"
            },
            "comment_modified_diff": {
                "104": "    // MBEDTLS_SSL_VERIFY_REQUIRED if a CA certificate is defined on Arduino IDE and",
                "105": "    // MBEDTLS_SSL_VERIFY_NONE if not.",
                "145": "    // Hostname set here should match CN in server certificate"
            }
        },
        {
            "commit": "00f962439a8d4c7017895ea4dfbdb3f6e6d9b3c4",
            "timestamp": "2018-05-14T13:00:40+02:00",
            "author": "chemicstry",
            "commit_message": "Port SSL fingerprint checking from ESP8266 WiFiClientSecure to ESP32 (#1397)",
            "additions": 146,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410
                        ],
                        "comments": [
                            "// Compare a name from certificate and domain name, return true if they match",
                            "        // Not a wildcard, expect an exact match",
                            "        // Wildcard is not part of leftmost component of domain name",
                            "        // Do not attempt to match (rfc6125 6.4.3.1)",
                            "        // Matching of wildcards such as baz*.example.com and b*z.example.com",
                            "        // is optional. Maybe implement this in the future?",
                            "// Verifies certificate provided by the peer to match specified SHA256 fingerprint",
                            "    // Convert hex string to byte array",
                            "    // Get certificate provided by the peer",
                            "    // Calculate certificate's SHA256 fingerprint",
                            "    // Check if fingerprints match",
                            "    // Additionally check if certificate has domain name if provided",
                            "// Checks if peer certificate has specified domain in CN or SANs",
                            "    // Get certificate provided by the peer",
                            "    // Check for domain name in SANs",
                            "        // Fetch next SAN",
                            "    // Check for domain name in CN",
                            "        // While iterating through DN objects, check for CN object",
                            "        // Fetch next DN object"
                        ],
                        "lines": [
                            "static bool matchName(const std::string& name, const std::string& domainName)",
                            "{",
                            "    size_t wildcardPos = name.find('*');",
                            "    if (wildcardPos == std::string::npos) {",
                            "        return name == domainName;",
                            "    }",
                            "",
                            "    size_t firstDotPos = name.find('.');",
                            "    if (wildcardPos > firstDotPos) {",
                            "        return false;",
                            "    }",
                            "    if (wildcardPos != 0 || firstDotPos != 1) {",
                            "        return false;",
                            "    }",
                            "    size_t domainNameFirstDotPos = domainName.find('.');",
                            "    if (domainNameFirstDotPos == std::string::npos) {",
                            "        return false;",
                            "    }",
                            "    return domainName.substr(domainNameFirstDotPos) == name.substr(firstDotPos);",
                            "}",
                            "",
                            "bool verify_ssl_fingerprint(sslclient_context *ssl_client, const char* fp, const char* domain_name)",
                            "{",
                            "    uint8_t fingerprint_local[32];",
                            "    int len = strlen(fp);",
                            "    int pos = 0;",
                            "    for (size_t i = 0; i < sizeof(fingerprint_local); ++i) {",
                            "        while (pos < len && ((fp[pos] == ' ') || (fp[pos] == ':'))) {",
                            "            ++pos;",
                            "        }",
                            "        if (pos > len - 2) {",
                            "            log_d(\"pos:%d len:%d fingerprint too short\", pos, len);",
                            "            return false;",
                            "        }",
                            "        uint8_t high, low;",
                            "        if (!parseHexNibble(fp[pos], &high) || !parseHexNibble(fp[pos+1], &low)) {",
                            "            log_d(\"pos:%d len:%d invalid hex sequence: %c%c\", pos, len, fp[pos], fp[pos+1]);",
                            "            return false;",
                            "        }",
                            "        pos += 2;",
                            "        fingerprint_local[i] = low | (high << 4);",
                            "    }",
                            "",
                            "    const mbedtls_x509_crt* crt = mbedtls_ssl_get_peer_cert(&ssl_client->ssl_ctx);",
                            "",
                            "    if (!crt)",
                            "    {",
                            "        log_d(\"could not fetch peer certificate\");",
                            "        return false;",
                            "    }",
                            "",
                            "    uint8_t fingerprint_remote[32];",
                            "    mbedtls_sha256_context sha256_ctx;",
                            "    mbedtls_sha256_init(&sha256_ctx);",
                            "    mbedtls_sha256_starts(&sha256_ctx, false);",
                            "    mbedtls_sha256_update(&sha256_ctx, crt->raw.p, crt->raw.len);",
                            "    mbedtls_sha256_finish(&sha256_ctx, fingerprint_remote);",
                            "",
                            "    if (memcmp(fingerprint_local, fingerprint_remote, 32))",
                            "    {",
                            "        log_d(\"fingerprint doesn't match\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if (domain_name)",
                            "        return verify_ssl_dn(ssl_client, domain_name);",
                            "    else",
                            "        return true;",
                            "}",
                            "",
                            "bool verify_ssl_dn(sslclient_context *ssl_client, const char* domain_name)",
                            "{",
                            "    log_d(\"domain name: '%s'\", (domain_name)?domain_name:\"(null)\");",
                            "    std::string domain_name_str(domain_name);",
                            "    std::transform(domain_name_str.begin(), domain_name_str.end(), domain_name_str.begin(), ::tolower);",
                            "",
                            "    const mbedtls_x509_crt* crt = mbedtls_ssl_get_peer_cert(&ssl_client->ssl_ctx);",
                            "",
                            "    const mbedtls_x509_sequence* san = &crt->subject_alt_names;",
                            "    while (san != nullptr)",
                            "    {",
                            "        std::string san_str((const char*)san->buf.p, san->buf.len);",
                            "        std::transform(san_str.begin(), san_str.end(), san_str.begin(), ::tolower);",
                            "",
                            "        if (matchName(san_str, domain_name_str))",
                            "            return true;",
                            "",
                            "        log_d(\"SAN '%s': no match\", san_str.c_str());",
                            "",
                            "        san = san->next;",
                            "    }",
                            "",
                            "    const mbedtls_asn1_named_data* common_name = &crt->subject;",
                            "    while (common_name != nullptr)",
                            "    {",
                            "        if (!MBEDTLS_OID_CMP(MBEDTLS_OID_AT_CN, &common_name->oid))",
                            "        {",
                            "            std::string common_name_str((const char*)common_name->val.p, common_name->val.len);",
                            "",
                            "            if (matchName(common_name_str, domain_name_str))",
                            "                return true;",
                            "",
                            "            log_d(\"CN '%s': not match\", common_name_str.c_str());",
                            "        }",
                            "",
                            "        common_name = common_name->next;",
                            "    }",
                            "",
                            "    return false;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "282": "// Compare a name from certificate and domain name, return true if they match",
                "287": "        // Not a wildcard, expect an exact match",
                "293": "        // Wildcard is not part of leftmost component of domain name",
                "294": "        // Do not attempt to match (rfc6125 6.4.3.1)",
                "298": "        // Matching of wildcards such as baz*.example.com and b*z.example.com",
                "299": "        // is optional. Maybe implement this in the future?",
                "309": "// Verifies certificate provided by the peer to match specified SHA256 fingerprint",
                "312": "    // Convert hex string to byte array",
                "333": "    // Get certificate provided by the peer",
                "342": "    // Calculate certificate's SHA256 fingerprint",
                "350": "    // Check if fingerprints match",
                "357": "    // Additionally check if certificate has domain name if provided",
                "364": "// Checks if peer certificate has specified domain in CN or SANs",
                "371": "    // Get certificate provided by the peer",
                "374": "    // Check for domain name in SANs",
                "386": "        // Fetch next SAN",
                "390": "    // Check for domain name in CN",
                "394": "        // While iterating through DN objects, check for CN object",
                "405": "        // Fetch next DN object"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "af7e489f016c919249a031318d7123589414c04e",
            "timestamp": "2018-12-03T16:17:55+01:00",
            "author": "Thorsten von Eicken",
            "commit_message": "WiFiClientSecure: add support for PSK (pre-shared key) ciphers (#2133)\n\n* WiFiClientSecure: add support for PSK (pre-shared key) ciphers\r\n\r\n* add example for WiFiClientSecure PSK\r\n\r\n* WiFiClientSecure: added README",
            "additions": 31,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148
                        ],
                        "comments": [
                            "        // convert PSK from hex to binary",
                            "        // set mbedtls config"
                        ],
                        "lines": [
                            "        if ((strlen(psKey) & 1) != 0 || strlen(psKey) > 2*MBEDTLS_PSK_MAX_LEN) {",
                            "            log_e(\"pre-shared key not valid hex or too long\");",
                            "            return -1;",
                            "        }",
                            "        unsigned char psk[MBEDTLS_PSK_MAX_LEN];",
                            "        size_t psk_len = strlen(psKey)/2;",
                            "        for (int j=0; j<strlen(psKey); j+= 2) {",
                            "            char c = psKey[j];",
                            "            if (c >= '0' && c <= '9') c -= '0';",
                            "            else if (c >= 'A' && c <= 'F') c -= 'A' - 10;",
                            "            else if (c >= 'a' && c <= 'f') c -= 'a' - 10;",
                            "            else return -1;",
                            "            psk[j/2] = c<<4;",
                            "            c = psKey[j+1];",
                            "            if (c >= '0' && c <= '9') c -= '0';",
                            "            else if (c >= 'A' && c <= 'F') c -= 'A' - 10;",
                            "            else if (c >= 'a' && c <= 'f') c -= 'a' - 10;",
                            "            else return -1;",
                            "            psk[j/2] |= c;",
                            "        }",
                            "        ret = mbedtls_ssl_conf_psk(&ssl_client->ssl_conf, psk, psk_len,",
                            "                 (const unsigned char *)pskIdent, strlen(pskIdent));",
                            "        if (ret != 0) {",
                            "            log_e(\"mbedtls_ssl_conf_psk returned %d\", ret);",
                            "            return handle_error(ret);",
                            "        }"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "121": "        // convert PSK from hex to binary",
                "142": "        // set mbedtls config"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "ssl_client.h": [],
    "Preferences.cpp": [],
    "Preferences.h": [],
    "esp32-hal-bt.c": [],
    "esp32-hal-bt.h": [],
    "SimpleBleDevice.ino": [],
    "SimpleBLE.cpp": [
        {
            "commit": "1d759380a6ff0d201145658bf54c423ffbef4c7b",
            "timestamp": "2017-02-23T01:11:57+02:00",
            "author": "me-no-dev",
            "commit_message": "Major IDF and Arduino Update\n\nWiFi and BlueTooth can now be started and stopped at will.\nbasic functions added to esp32-hal to start and stop the BT radio\nSimpleBLE class added to show the most basic functionality\nExample to show how to switch between BT, WiFi or Both",
            "additions": 338,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License.",
                            "        uint8_t fp;  // filter policy",
                            "        uint16_t interval_min;  // minimum advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s)",
                            "    _ble_adv_param->chn_map = GAP_ADVCHAN_ALL; // 37, 38, 39 channels",
                            "    // Advertising data device local name"
                        ],
                        "lines": [
                            "//",
                            "",
                            "//",
                            "",
                            "#include \"SimpleBLE.h\"",
                            "#include \"esp32-hal-log.h\"",
                            "",
                            "/*  HCI Command opcode group field(OGF) */",
                            "#define HCI_GRP_HOST_CONT_BASEBAND_CMDS    (0x03 << 10)            /* 0x0C00 */",
                            "#define HCI_GRP_BLE_CMDS                   (0x08 << 10)",
                            "",
                            "/*  HCI Command opcode command field(OCF) */",
                            "#define HCI_RESET                          (0x0003 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)",
                            "#define HCI_BLE_WRITE_ADV_ENABLE           (0x000A | HCI_GRP_BLE_CMDS)",
                            "#define HCI_BLE_WRITE_ADV_PARAMS           (0x0006 | HCI_GRP_BLE_CMDS)",
                            "#define HCI_BLE_WRITE_ADV_DATA             (0x0008 | HCI_GRP_BLE_CMDS)",
                            "",
                            "#define HCI_H4_CMD_PREAMBLE_SIZE                (4)",
                            "#define HCIC_PARAM_SIZE_WRITE_ADV_ENABLE        (1)",
                            "#define HCIC_PARAM_SIZE_BLE_WRITE_ADV_PARAMS    (15)",
                            "#define HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA      (31)",
                            "",
                            "/* EIR/AD data type definitions */",
                            "#define BT_DATA_FLAGS               0x01 /* AD flags */",
                            "#define BT_DATA_UUID16_SOME         0x02 /* 16-bit UUID, more available */",
                            "#define BT_DATA_UUID16_ALL          0x03 /* 16-bit UUID, all listed */",
                            "#define BT_DATA_UUID32_SOME         0x04 /* 32-bit UUID, more available */",
                            "#define BT_DATA_UUID32_ALL          0x05 /* 32-bit UUID, all listed */",
                            "#define BT_DATA_UUID128_SOME        0x06 /* 128-bit UUID, more available */",
                            "#define BT_DATA_UUID128_ALL         0x07 /* 128-bit UUID, all listed */",
                            "#define BT_DATA_NAME_SHORTENED      0x08 /* Shortened name */",
                            "#define BT_DATA_NAME_COMPLETE       0x09 /* Complete name */",
                            "#define BT_DATA_TX_POWER            0x0a /* Tx Power */",
                            "#define BT_DATA_SOLICIT16           0x14 /* Solicit UUIDs, 16-bit */",
                            "#define BT_DATA_SOLICIT128          0x15 /* Solicit UUIDs, 128-bit */",
                            "#define BT_DATA_SVC_DATA16          0x16 /* Service data, 16-bit UUID */",
                            "#define BT_DATA_GAP_APPEARANCE      0x19 /* GAP appearance */",
                            "#define BT_DATA_SOLICIT32           0x1f /* Solicit UUIDs, 32-bit */",
                            "#define BT_DATA_SVC_DATA32          0x20 /* Service data, 32-bit UUID */",
                            "#define BT_DATA_SVC_DATA128         0x21 /* Service data, 128-bit UUID */",
                            "#define BT_DATA_MANUFACTURER_DATA   0xff /* Manufacturer Specific Data */",
                            "",
                            "",
                            "/* Advertising types */",
                            "#define     BLE_GAP_ADV_TYPE_ADV_IND         0x00",
                            "#define     BLE_GAP_ADV_TYPE_ADV_DIRECT_IND  0x01",
                            "#define     BLE_GAP_ADV_TYPE_ADV_SCAN_IND    0x02",
                            "#define     BLE_GAP_ADV_TYPE_ADV_NONCONN_IND 0x03",
                            "",
                            "",
                            "/* Advertising Discovery Flags */",
                            "#define     BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE       (0x01)",
                            "#define     BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE       (0x02)",
                            "#define     BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED       (0x04)",
                            "#define     BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER       (0x08)",
                            "#define     BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST             (0x10)",
                            "#define     BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)",
                            "#define     BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)",
                            "",
                            "",
                            "/* Advertising Filter Policies */",
                            "#define     BLE_GAP_ADV_FP_ANY              0x00",
                            "#define     BLE_GAP_ADV_FP_FILTER_SCANREQ   0x01",
                            "#define     BLE_GAP_ADV_FP_FILTER_CONNREQ   0x02",
                            "#define     BLE_GAP_ADV_FP_FILTER_BOTH      0x03",
                            "",
                            "",
                            "/* Advertising Device Address Types */",
                            "#define     BLE_GAP_ADDR_TYPE_PUBLIC                          0x00",
                            "#define     BLE_GAP_ADDR_TYPE_RANDOM_STATIC                   0x01",
                            "#define     BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE       0x02",
                            "#define     BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE   0x03",
                            "",
                            "",
                            "/* GAP Advertising Channel Maps */",
                            "#define     GAP_ADVCHAN_37          0x01",
                            "#define     GAP_ADVCHAN_38          0x02",
                            "#define     GAP_ADVCHAN_39          0x04",
                            "#define     GAP_ADVCHAN_ALL         GAP_ADVCHAN_37 | GAP_ADVCHAN_38 | GAP_ADVCHAN_39",
                            "",
                            "",
                            "/* GAP Filter Policies */",
                            "#define     BLE_GAP_ADV_FP_ANY              0x00",
                            "#define     BLE_GAP_ADV_FP_FILTER_SCANREQ   0x01",
                            "#define     BLE_GAP_ADV_FP_FILTER_CONNREQ   0x02",
                            "#define     BLE_GAP_ADV_FP_FILTER_BOTH      0x03",
                            "",
                            "#define BD_ADDR_LEN     (6)                     /* Device address length */",
                            "",
                            "",
                            "/*",
                            " * BLE System",
                            " *",
                            " * */",
                            "",
                            "/* HCI H4 message type definitions */",
                            "enum {",
                            "    H4_TYPE_COMMAND = 1,",
                            "    H4_TYPE_ACL     = 2,",
                            "    H4_TYPE_SCO     = 3,",
                            "    H4_TYPE_EVENT   = 4",
                            "};",
                            "",
                            "volatile bool _vhci_host_send_available = false;",
                            "volatile bool _vhci_host_command_running = false;",
                            "static uint16_t _vhci_host_command = 0x0000;",
                            "static uint8_t _vhci_host_command_result = 0x00;",
                            "",
                            "//controller is ready to receive command",
                            "static void _on_tx_ready(void)",
                            "{",
                            "    _vhci_host_send_available = true;",
                            "}",
                            "/*",
                            "static void _dump_buf(const char * txt, uint8_t *data, uint16_t len){",
                            "    log_printf(\"%s[%u]:\", txt, len);",
                            "    for (uint16_t i=0; i<len; i++)",
                            "        log_printf(\" %02x\", data[i]);",
                            "    log_printf(\"\\n\");",
                            "}",
                            "*/",
                            "//controller has a packet",
                            "static int _on_rx_data(uint8_t *data, uint16_t len)",
                            "{",
                            "    if(len == 7 && *data == 0x04){",
                            "        //baseband response",
                            "        uint16_t cmd = (((uint16_t)data[5] << 8) | data[4]);",
                            "        uint8_t res = data[6];",
                            "        if(_vhci_host_command_running && _vhci_host_command == cmd){",
                            "            //_dump_buf(\"BLE: res\", data, len);",
                            "            _vhci_host_command_result = res;",
                            "            _vhci_host_command_running = false;",
                            "            return 0;",
                            "        } else if(cmd == 0){",
                            "            log_e(\"error %u\", res);",
                            "        }",
                            "    }",
                            "",
                            "    //_dump_buf(\"BLE: rx\", data, len);",
                            "    return 0;",
                            "}",
                            "",
                            "",
                            "",
                            "",
                            "static esp_vhci_host_callback_t vhci_host_cb = {",
                            "        _on_tx_ready,",
                            "        _on_rx_data",
                            "};",
                            "",
                            "static bool _esp_ble_start()",
                            "{",
                            "    if(btStart()){",
                            "        esp_vhci_host_register_callback(&vhci_host_cb);",
                            "        uint8_t i = 0;",
                            "        while(!esp_vhci_host_check_send_available() && i++ < 100){",
                            "            delay(10);",
                            "        }",
                            "        if(i >= 100){",
                            "            log_e(\"esp_vhci_host_check_send_available failed\");",
                            "            return false;",
                            "        }",
                            "        _vhci_host_send_available = true;",
                            "    } else",
                            "        log_e(\"BT Failed\");",
                            "    return true;",
                            "}",
                            "",
                            "static bool _esp_ble_stop()",
                            "{",
                            "    if(btStarted()){",
                            "        _vhci_host_send_available = false;",
                            "        btStop();",
                            "        esp_vhci_host_register_callback(NULL);",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "//public",
                            "",
                            "static uint8_t ble_send_cmd(uint16_t cmd, uint8_t * data, uint8_t len){",
                            "    static uint8_t buf[36];",
                            "    if(len > 32){",
                            "        //too much data",
                            "        return 2;",
                            "    }",
                            "    uint16_t i = 0;",
                            "    while(!_vhci_host_send_available && i++ < 1000){",
                            "        delay(1);",
                            "    }",
                            "    if(i >= 1000){",
                            "        log_e(\"_vhci_host_send_available failed\");",
                            "        return 1;",
                            "    }",
                            "    uint8_t outlen = len + HCI_H4_CMD_PREAMBLE_SIZE;",
                            "    buf[0] = H4_TYPE_COMMAND;",
                            "    buf[1] = (uint8_t)(cmd & 0xFF);",
                            "    buf[2] = (uint8_t)(cmd >> 8);",
                            "    buf[3] = len;",
                            "    if(len){",
                            "        memcpy(buf+4, data, len);",
                            "    }",
                            "    _vhci_host_send_available = false;",
                            "    _vhci_host_command_running = true;",
                            "    _vhci_host_command = cmd;",
                            "",
                            "    //log_printf(\"BLE: cmd: 0x%04X, data[%u]:\", cmd, len);",
                            "    //for (uint16_t i=0; i<len; i++) log_printf(\" %02x\", buf[i+4]);",
                            "    //log_printf(\"\\n\");",
                            "",
                            "    esp_vhci_host_send_packet(buf, outlen);",
                            "    while(_vhci_host_command_running);",
                            "    int res = _vhci_host_command_result;",
                            "    //log_printf(\"BLE: cmd: 0x%04X, res: %u\\n\", cmd, res);",
                            "    return res;",
                            "}",
                            "",
                            "",
                            "/*",
                            " * BLE Arduino",
                            " *",
                            " * */",
                            "",
                            "enum {",
                            "    UNIT_0_625_MS = 625,  /* Number of microseconds in 0.625 milliseconds. */",
                            "    UNIT_1_25_MS = 1250,  /* Number of microseconds in 1.25 milliseconds. */",
                            "    UNIT_10_MS = 10000  /* Number of microseconds in 10 milliseconds. */",
                            "};",
                            "",
                            "/* BLE Advertising parameters struct */",
                            "typedef struct ble_gap_adv_params_s {",
                            "        uint8_t type;",
                            "        uint8_t own_addr_type;",
                            "        uint8_t addr_type;",
                            "        uint8_t addr[BD_ADDR_LEN];",
                            "        uint16_t interval_max;",
                            "        uint8_t chn_map;",
                            "} ble_adv_params_t;",
                            "",
                            "#define MSEC_TO_UNITS(TIME, RESOLUTION)  (((TIME) * 1000) / (RESOLUTION))",
                            "#define UINT16_TO_STREAM(p, u16)         {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8);}",
                            "#define UINT8_TO_STREAM(p, u8)           {*(p)++ = (uint8_t)(u8);}",
                            "#define BDADDR_TO_STREAM(p, a)           {int i; for (i = 0; i < BD_ADDR_LEN;  i++) *(p)++ = (uint8_t) a[BD_ADDR_LEN - 1 - i];}",
                            "#define ARRAY_TO_STREAM(p, a, len)       {int i; for (i = 0; i < len;          i++) *(p)++ = (uint8_t) a[i];}",
                            "",
                            "SimpleBLE::SimpleBLE()",
                            "{",
                            "    uint8_t peerAddr[BD_ADDR_LEN] = {0x80, 0x81, 0x82, 0x83, 0x84, 0x85};",
                            "    _ble_adv_param = (ble_adv_params_t*)malloc(sizeof(ble_adv_params_t));",
                            "    memset(_ble_adv_param, 0x00, sizeof(ble_adv_params_t));",
                            "    _ble_adv_param->type = BLE_GAP_ADV_TYPE_ADV_NONCONN_IND;//not connectable",
                            "    _ble_adv_param->fp = 0;//any",
                            "    _ble_adv_param->interval_min = 512;",
                            "    _ble_adv_param->interval_max = 1024;",
                            "    _ble_adv_param->addr_type = 0;//public",
                            "    memcpy(_ble_adv_param->addr, peerAddr, BD_ADDR_LEN);",
                            "    local_name = \"esp32\";",
                            "}",
                            "",
                            "SimpleBLE::~SimpleBLE(void)",
                            "{",
                            "    free(_ble_adv_param);",
                            "    _esp_ble_stop();",
                            "}",
                            "",
                            "bool SimpleBLE::begin(String localName)",
                            "{",
                            "    if(!_esp_ble_start()){",
                            "        return false;",
                            "    }",
                            "    ble_send_cmd(HCI_RESET, NULL, 0);",
                            "    if(localName.length()){",
                            "        local_name = localName;",
                            "    }",
                            "    _ble_send_adv_param();",
                            "    _ble_send_adv_data();",
                            "",
                            "    uint8_t adv_enable = 1;",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_ENABLE, &adv_enable, HCIC_PARAM_SIZE_WRITE_ADV_ENABLE);",
                            "    return true;",
                            "}",
                            "",
                            "void SimpleBLE::end()",
                            "{",
                            "    uint8_t adv_enable = 0;",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_ENABLE, &adv_enable, HCIC_PARAM_SIZE_WRITE_ADV_ENABLE);",
                            "    ble_send_cmd(HCI_RESET, NULL, 0);",
                            "    _esp_ble_stop();",
                            "}",
                            "",
                            "void SimpleBLE::_ble_send_adv_param(void)",
                            "{",
                            "    uint8_t dbuf[HCIC_PARAM_SIZE_BLE_WRITE_ADV_PARAMS];",
                            "    uint8_t *buf = dbuf;",
                            "    UINT16_TO_STREAM (buf, _ble_adv_param->interval_min);",
                            "    UINT16_TO_STREAM (buf, _ble_adv_param->interval_max);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->type);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->own_addr_type);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->addr_type);",
                            "    ARRAY_TO_STREAM (buf, _ble_adv_param->addr, BD_ADDR_LEN);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->chn_map);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->fp);",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_PARAMS, dbuf, HCIC_PARAM_SIZE_BLE_WRITE_ADV_PARAMS);",
                            "}",
                            "",
                            "void SimpleBLE::_ble_send_adv_data(void)",
                            "{",
                            "    uint8_t adv_data[HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA + 1] = {",
                            "            0x03, 0x02, BT_DATA_FLAGS, BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE",
                            "    };",
                            "    //zerofill the buffer",
                            "    memset(adv_data+4, 0x00, HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA-4);",
                            "    uint8_t adv_data_len = 4;",
                            "",
                            "    uint8_t name_len = (uint8_t) local_name.length();",
                            "    adv_data[adv_data_len++] = name_len + 1;",
                            "    adv_data[adv_data_len++] = BT_DATA_NAME_COMPLETE;",
                            "    for (int i=0; i<name_len; i++) {",
                            "        adv_data[adv_data_len++] = (uint8_t) local_name.charAt(i);",
                            "    }",
                            "    //send data",
                            "    adv_data[0] = adv_data_len - 1;",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_DATA, (uint8_t *)adv_data, HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA + 1);",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License.",
                "246": "        uint8_t fp;  // filter policy",
                "247": "        uint16_t interval_min;  // minimum advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s)",
                "264": "    _ble_adv_param->chn_map = GAP_ADVCHAN_ALL; // 37, 38, 39 channels",
                "328": "    // Advertising data device local name"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "db09ca8c162a096271333ff3fbdfea1bf5be761c",
            "timestamp": "2017-05-22T17:50:57+03:00",
            "author": "me-no-dev",
            "commit_message": "Make SimpleBLE work again\n\nFixes: https://github.com/espressif/arduino-esp32/issues/373",
            "additions": 67,
            "deletions": 278,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257
                        ],
                        "comments": [
                            "        uint8_t fp;  // filter policy",
                            "        uint16_t interval_min;  // minimum advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s)"
                        ],
                        "lines": [
                            "        uint16_t interval_max;",
                            "        uint8_t chn_map;",
                            "} ble_adv_params_t;",
                            "",
                            "#define MSEC_TO_UNITS(TIME, RESOLUTION)  (((TIME) * 1000) / (RESOLUTION))",
                            "#define UINT16_TO_STREAM(p, u16)         {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8);}",
                            "#define UINT8_TO_STREAM(p, u8)           {*(p)++ = (uint8_t)(u8);}",
                            "#define BDADDR_TO_STREAM(p, a)           {int i; for (i = 0; i < BD_ADDR_LEN;  i++) *(p)++ = (uint8_t) a[BD_ADDR_LEN - 1 - i];}",
                            "#define ARRAY_TO_STREAM(p, a, len)       {int i; for (i = 0; i < len;          i++) *(p)++ = (uint8_t) a[i];}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269
                        ],
                        "comments": [
                            "    _ble_adv_param->chn_map = GAP_ADVCHAN_ALL; // 37, 38, 39 channels"
                        ],
                        "lines": [
                            "    uint8_t peerAddr[BD_ADDR_LEN] = {0x80, 0x81, 0x82, 0x83, 0x84, 0x85};",
                            "    _ble_adv_param = (ble_adv_params_t*)malloc(sizeof(ble_adv_params_t));",
                            "    memset(_ble_adv_param, 0x00, sizeof(ble_adv_params_t));",
                            "    _ble_adv_param->type = BLE_GAP_ADV_TYPE_ADV_NONCONN_IND;//not connectable",
                            "    _ble_adv_param->fp = 0;//any",
                            "    _ble_adv_param->interval_min = 512;",
                            "    _ble_adv_param->interval_max = 1024;",
                            "    _ble_adv_param->addr_type = 0;//public",
                            "    memcpy(_ble_adv_param->addr, peerAddr, BD_ADDR_LEN);"
                        ]
                    },
                    {
                        "line_numbers": [
                            275,
                            276
                        ],
                        "comments": [],
                        "lines": [
                            "    free(_ble_adv_param);",
                            "    _esp_ble_stop();"
                        ]
                    },
                    {
                        "line_numbers": [
                            281,
                            282,
                            283,
                            284
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!_esp_ble_start()){",
                            "        return false;",
                            "    }",
                            "    ble_send_cmd(HCI_RESET, NULL, 0);"
                        ]
                    },
                    {
                        "line_numbers": [
                            288,
                            289,
                            290,
                            291,
                            292,
                            293
                        ],
                        "comments": [],
                        "lines": [
                            "    _ble_send_adv_param();",
                            "    _ble_send_adv_data();",
                            "",
                            "    uint8_t adv_enable = 1;",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_ENABLE, &adv_enable, HCIC_PARAM_SIZE_WRITE_ADV_ENABLE);",
                            "    return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337
                        ],
                        "comments": [
                            "    // Advertising data device local name"
                        ],
                        "lines": [
                            "    uint8_t adv_enable = 0;",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_ENABLE, &adv_enable, HCIC_PARAM_SIZE_WRITE_ADV_ENABLE);",
                            "    ble_send_cmd(HCI_RESET, NULL, 0);",
                            "    _esp_ble_stop();",
                            "}",
                            "",
                            "void SimpleBLE::_ble_send_adv_param(void)",
                            "{",
                            "    uint8_t dbuf[HCIC_PARAM_SIZE_BLE_WRITE_ADV_PARAMS];",
                            "    uint8_t *buf = dbuf;",
                            "    UINT16_TO_STREAM (buf, _ble_adv_param->interval_min);",
                            "    UINT16_TO_STREAM (buf, _ble_adv_param->interval_max);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->type);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->own_addr_type);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->addr_type);",
                            "    ARRAY_TO_STREAM (buf, _ble_adv_param->addr, BD_ADDR_LEN);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->chn_map);",
                            "    UINT8_TO_STREAM (buf, _ble_adv_param->fp);",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_PARAMS, dbuf, HCIC_PARAM_SIZE_BLE_WRITE_ADV_PARAMS);",
                            "}",
                            "",
                            "void SimpleBLE::_ble_send_adv_data(void)",
                            "{",
                            "    uint8_t adv_data[HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA + 1] = {",
                            "            0x03, 0x02, BT_DATA_FLAGS, BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE",
                            "    };",
                            "    //zerofill the buffer",
                            "    memset(adv_data+4, 0x00, HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA-4);",
                            "    uint8_t adv_data_len = 4;",
                            "",
                            "    uint8_t name_len = (uint8_t) local_name.length();",
                            "    adv_data[adv_data_len++] = name_len + 1;",
                            "    adv_data[adv_data_len++] = BT_DATA_NAME_COMPLETE;",
                            "    for (int i=0; i<name_len; i++) {",
                            "        adv_data[adv_data_len++] = (uint8_t) local_name.charAt(i);",
                            "    }",
                            "    //send data",
                            "    adv_data[0] = adv_data_len - 1;",
                            "    ble_send_cmd(HCI_BLE_WRITE_ADV_DATA, (uint8_t *)adv_data, HCIC_PARAM_SIZE_BLE_WRITE_ADV_DATA + 1);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "246": "        uint8_t fp;  // filter policy",
                "247": "        uint16_t interval_min;  // minimum advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s)",
                "264": "    _ble_adv_param->chn_map = GAP_ADVCHAN_ALL; // 37, 38, 39 channels",
                "328": "    // Advertising data device local name"
            },
            "comment_modified_diff": {}
        }
    ],
    "SimpleBLE.h": [],
    "WiFiBlueToothSwitch.ino": [],
    "adc.h": [],
    "dac.h": [],
    "i2s.h": [],
    "rtc_io.h": [],
    "esp_coexist.h": [],
    "esp_deep_sleep.h": [],
    "esp_phy_init.h": [],
    "diskio.h": [],
    "esp_vfs_fat.h": [],
    "librtc_clk.a": [],
    "FS.cpp": [],
    "FS.h": [],
    "FSImpl.h": [],
    "vfs_api.cpp": [
        {
            "commit": "e625b3b08ed7a5bf2ae0d8cbf068ba534f91c23a",
            "timestamp": "2017-03-10T15:25:38+01:00",
            "author": "Me No Dev",
            "commit_message": "Add FS, SD and SD_MMC (#256)",
            "additions": 417,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "",
                            "#include \"vfs_api.h\"",
                            "",
                            "using namespace fs;",
                            "",
                            "FileImplPtr VFSImpl::open(const char* path, const char* mode)",
                            "{",
                            "    if(!_mountpoint) {",
                            "        log_e(\"File system is not mounted\");",
                            "        return FileImplPtr();",
                            "    }",
                            "",
                            "    if(!path || path[0] != '/') {",
                            "        log_e(\"%s does not start with /\", path);",
                            "        return FileImplPtr();",
                            "    }",
                            "",
                            "    char * temp = (char *)malloc(strlen(path)+strlen(_mountpoint)+2);",
                            "    if(!temp) {",
                            "        log_e(\"malloc failed\");",
                            "        return FileImplPtr();",
                            "    }",
                            "",
                            "    sprintf(temp,\"%s%s\", _mountpoint, path);",
                            "",
                            "    struct stat st;",
                            "    //file lound",
                            "    if(!stat(temp, &st)) {",
                            "        free(temp);",
                            "        if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode)) {",
                            "            return std::make_shared<VFSFileImpl>(this, path, mode);",
                            "        }",
                            "        log_e(\"%s has wrong mode 0x%08X\", path, st.st_mode);",
                            "        return FileImplPtr();",
                            "    }",
                            "",
                            "    //file not found but mode permits creation",
                            "    if(mode && mode[0] != 'r') {",
                            "        free(temp);",
                            "        return std::make_shared<VFSFileImpl>(this, path, mode);",
                            "    }",
                            "",
                            "    //try to open this as directory (might be mount point)",
                            "    DIR * d = opendir(temp);",
                            "    if(d) {",
                            "        closedir(d);",
                            "        free(temp);",
                            "        return std::make_shared<VFSFileImpl>(this, path, mode);",
                            "    }",
                            "",
                            "    log_e(\"%s does not exist\", temp);",
                            "    free(temp);",
                            "    return FileImplPtr();",
                            "}",
                            "",
                            "bool VFSImpl::exists(const char* path)",
                            "{",
                            "    if(!_mountpoint) {",
                            "        log_e(\"File system is not mounted\");",
                            "        return false;",
                            "    }",
                            "",
                            "    VFSFileImpl f(this, path, \"r\");",
                            "    if(f) {",
                            "        f.close();",
                            "        return true;",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "static inline int real_rename(const char* f, const char* t)",
                            "{",
                            "    return rename(f,t);",
                            "}",
                            "",
                            "bool VFSImpl::rename(const char* pathFrom, const char* pathTo)",
                            "{",
                            "    if(!_mountpoint) {",
                            "        log_e(\"File system is not mounted\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!pathFrom || pathFrom[0] != '/' || !pathTo || pathTo[0] != '/') {",
                            "        log_e(\"bad arguments\");",
                            "        return false;",
                            "    }",
                            "    if(!exists(pathFrom)) {",
                            "        log_e(\"%s does not exists\", pathFrom);",
                            "        return false;",
                            "    }",
                            "    char * temp1 = (char *)malloc(strlen(pathFrom)+strlen(_mountpoint)+1);",
                            "    if(!temp1) {",
                            "        log_e(\"malloc failed\");",
                            "        return false;",
                            "    }",
                            "    char * temp2 = (char *)malloc(strlen(pathTo)+strlen(_mountpoint)+1);",
                            "    if(!temp2) {",
                            "        free(temp1);",
                            "        log_e(\"malloc failed\");",
                            "        return false;",
                            "    }",
                            "    sprintf(temp1,\"%s%s\", _mountpoint, pathFrom);",
                            "    sprintf(temp2,\"%s%s\", _mountpoint, pathTo);",
                            "    auto rc = real_rename(temp1, temp2);",
                            "    free(temp1);",
                            "    free(temp2);",
                            "    return rc == 0;",
                            "}",
                            "",
                            "bool VFSImpl::remove(const char* path)",
                            "{",
                            "    if(!_mountpoint) {",
                            "        log_e(\"File system is not mounted\");",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!path || path[0] != '/') {",
                            "        log_e(\"bad arguments\");",
                            "        return false;",
                            "    }",
                            "",
                            "    VFSFileImpl f(this, path, \"r\");",
                            "    if(!f || f.isDirectory()) {",
                            "        if(f) {",
                            "            f.close();",
                            "        }",
                            "        log_e(\"%s does not exists or is directory\", path);",
                            "        return false;",
                            "    }",
                            "    f.close();",
                            "",
                            "    char * temp = (char *)malloc(strlen(path)+strlen(_mountpoint)+1);",
                            "    if(!temp) {",
                            "        log_e(\"malloc failed\");",
                            "        return false;",
                            "    }",
                            "    sprintf(temp,\"%s%s\", _mountpoint, path);",
                            "    auto rc = unlink(temp);",
                            "    free(temp);",
                            "    return rc == 0;",
                            "}",
                            "",
                            "static inline int real_mkdir(const char* f)",
                            "{",
                            "    return mkdir(f, ACCESSPERMS);",
                            "}",
                            "",
                            "bool VFSImpl::mkdir(const char *path)",
                            "{",
                            "    if(!_mountpoint) {",
                            "        log_e(\"File system is not mounted\");",
                            "        return false;",
                            "    }",
                            "",
                            "    VFSFileImpl f(this, path, \"r\");",
                            "    if(f && f.isDirectory()) {",
                            "        f.close();",
                            "        //log_w(\"%s already exists\", path);",
                            "        return true;",
                            "    } else if(f) {",
                            "        f.close();",
                            "        log_e(\"%s is a file\", path);",
                            "        return false;",
                            "    }",
                            "",
                            "    char * temp = (char *)malloc(strlen(path)+strlen(_mountpoint)+1);",
                            "    if(!temp) {",
                            "        log_e(\"malloc failed\");",
                            "        return false;",
                            "    }",
                            "    sprintf(temp,\"%s%s\", _mountpoint, path);",
                            "    auto rc = real_mkdir(temp);",
                            "    free(temp);",
                            "    return rc == 0;",
                            "}",
                            "",
                            "bool VFSImpl::rmdir(const char *path)",
                            "{",
                            "    if(!_mountpoint) {",
                            "        log_e(\"File system is not mounted\");",
                            "        return false;",
                            "    }",
                            "",
                            "    VFSFileImpl f(this, path, \"r\");",
                            "    if(!f || !f.isDirectory()) {",
                            "        if(f) {",
                            "            f.close();",
                            "        }",
                            "        log_e(\"%s does not exists or is a file\", path);",
                            "        return false;",
                            "    }",
                            "    f.close();",
                            "",
                            "    char * temp = (char *)malloc(strlen(path)+strlen(_mountpoint)+1);",
                            "    if(!temp) {",
                            "        log_e(\"malloc failed\");",
                            "        return false;",
                            "    }",
                            "    sprintf(temp,\"%s%s\", _mountpoint, path);",
                            "    auto rc = unlink(temp);",
                            "    free(temp);",
                            "    return rc == 0;",
                            "}",
                            "",
                            "",
                            "",
                            "",
                            "VFSFileImpl::VFSFileImpl(VFSImpl* fs, const char* path, const char* mode)",
                            "    : _fs(fs)",
                            "    , _f(NULL)",
                            "    , _d(NULL)",
                            "    , _path(NULL)",
                            "    , _isDirectory(false)",
                            "    , _written(false)",
                            "{",
                            "    char * temp = (char *)malloc(strlen(path)+strlen(_fs->_mountpoint)+1);",
                            "    if(!temp) {",
                            "        return;",
                            "    }",
                            "    sprintf(temp,\"%s%s\", _fs->_mountpoint, path);",
                            "",
                            "    _path = strdup(path);",
                            "    if(!_path) {",
                            "        log_e(\"strdup(%s) failed\", path);",
                            "        free(temp);",
                            "        return;",
                            "    }",
                            "",
                            "    if(!stat(temp, &_stat)) {",
                            "        //file found",
                            "        if (S_ISREG(_stat.st_mode)) {",
                            "            _isDirectory = false;",
                            "            _f = fopen(temp, mode);",
                            "            if(!_f) {",
                            "                log_e(\"fopen(%s) failed\", temp);",
                            "            }",
                            "        } else if(S_ISDIR(_stat.st_mode)) {",
                            "            _isDirectory = true;",
                            "            _d = opendir(temp);",
                            "            if(!_d) {",
                            "                log_e(\"opendir(%s) failed\", temp);",
                            "            }",
                            "        } else {",
                            "            log_e(\"Unknown type 0x%08X for file %s\", ((_stat.st_mode)&_IFMT), temp);",
                            "        }",
                            "    } else {",
                            "        //file not found",
                            "        if(!mode || mode[0] == 'r') {",
                            "            //try to open as directory",
                            "            _d = opendir(temp);",
                            "            if(_d) {",
                            "                _isDirectory = true;",
                            "            } else {",
                            "                _isDirectory = false;",
                            "                //log_w(\"stat(%s) failed\", temp);",
                            "            }",
                            "        } else {",
                            "            //lets create this new file",
                            "            _isDirectory = false;",
                            "            _f = fopen(temp, mode);",
                            "            if(!_f) {",
                            "                log_e(\"fopen(%s) failed\", temp);",
                            "            }",
                            "        }",
                            "    }",
                            "    free(temp);",
                            "}",
                            "",
                            "VFSFileImpl::~VFSFileImpl()",
                            "{",
                            "    close();",
                            "}",
                            "",
                            "void VFSFileImpl::close()",
                            "{",
                            "    if(_path) {",
                            "        free(_path);",
                            "        _path = NULL;",
                            "    }",
                            "    if(_isDirectory && _d) {",
                            "        closedir(_d);",
                            "        _d = NULL;",
                            "        _isDirectory = false;",
                            "    } else if(_f) {",
                            "        fclose(_f);",
                            "        _f = NULL;",
                            "    }",
                            "}",
                            "",
                            "VFSFileImpl::operator bool()",
                            "{",
                            "    return (_isDirectory && _d != NULL) || _f != NULL;",
                            "}",
                            "",
                            "void VFSFileImpl::_getStat() const",
                            "{",
                            "    if(!_path) {",
                            "        return;",
                            "    }",
                            "    char * temp = (char *)malloc(strlen(_path)+strlen(_fs->_mountpoint)+1);",
                            "    if(!temp) {",
                            "        return;",
                            "    }",
                            "    sprintf(temp,\"%s%s\", _fs->_mountpoint, _path);",
                            "    if(!stat(temp, &_stat)) {",
                            "        _written = false;",
                            "    }",
                            "    free(temp);",
                            "}",
                            "",
                            "size_t VFSFileImpl::write(const uint8_t *buf, size_t size)",
                            "{",
                            "    if(_isDirectory || !_f || !buf || !size) {",
                            "        return 0;",
                            "    }",
                            "    _written = true;",
                            "    return fwrite(buf, 1, size, _f);",
                            "}",
                            "",
                            "size_t VFSFileImpl::read(uint8_t* buf, size_t size)",
                            "{",
                            "    if(_isDirectory || !_f || !buf || !size) {",
                            "        return 0;",
                            "    }",
                            "",
                            "    return fread(buf, 1, size, _f);",
                            "}",
                            "",
                            "void VFSFileImpl::flush()",
                            "{",
                            "    if(_isDirectory || !_f) {",
                            "        return;",
                            "    }",
                            "    fflush(_f);",
                            "}",
                            "",
                            "bool VFSFileImpl::seek(uint32_t pos, SeekMode mode)",
                            "{",
                            "    if(_isDirectory || !_f) {",
                            "        return false;",
                            "    }",
                            "    auto rc = fseek(_f, pos, mode);",
                            "    return rc == 0;",
                            "}",
                            "",
                            "size_t VFSFileImpl::position() const",
                            "{",
                            "    if(_isDirectory || !_f) {",
                            "        return 0;",
                            "    }",
                            "    return ftell(_f);",
                            "}",
                            "",
                            "size_t VFSFileImpl::size() const",
                            "{",
                            "    if(_isDirectory || !_f) {",
                            "        return 0;",
                            "    }",
                            "    if (_written) {",
                            "        _getStat();",
                            "    }",
                            "    return _stat.st_size;",
                            "}",
                            "",
                            "const char* VFSFileImpl::name() const",
                            "{",
                            "    return (const char*) _path;",
                            "}",
                            "",
                            "//to implement",
                            "boolean VFSFileImpl::isDirectory(void)",
                            "{",
                            "    return _isDirectory;",
                            "}",
                            "",
                            "FileImplPtr VFSFileImpl::openNextFile(const char* mode)",
                            "{",
                            "    if(!_isDirectory || !_d) {",
                            "        return FileImplPtr();",
                            "    }",
                            "    struct dirent *file = readdir(_d);",
                            "    if(file == NULL) {",
                            "        return FileImplPtr();",
                            "    }",
                            "    if(file->d_type != DT_REG && file->d_type != DT_DIR) {",
                            "        return openNextFile(mode);",
                            "    }",
                            "    String fname = String(file->d_name);",
                            "    String name = String(_path);",
                            "    if(!fname.startsWith(\"/\") && !name.endsWith(\"/\")) {",
                            "        name += \"/\";",
                            "    }",
                            "    name += fname;",
                            "",
                            "    return std::make_shared<VFSFileImpl>(_fs, name.c_str(), mode);",
                            "}",
                            "",
                            "void VFSFileImpl::rewindDirectory(void)",
                            "{",
                            "    if(!_isDirectory || !_d) {",
                            "        return;",
                            "    }",
                            "    rewinddir(_d);",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "67ee7c32e72ca6be40f3437316505dc208509c0d",
            "timestamp": "2019-04-09T21:15:21+02:00",
            "author": "Clemens Kirchgatterer",
            "commit_message": "workaround for FS implementations that do not support fflush() (#2596)\n\nhttps://github.com/espressif/arduino-esp32/issues/1293",
            "additions": 2,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            343,
                            344
                        ],
                        "comments": [
                            "    // workaround for https://github.com/espressif/arduino-esp32/issues/1293"
                        ],
                        "lines": [
                            "    fsync(fileno(_f));"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "343": "    // workaround for https://github.com/espressif/arduino-esp32/issues/1293"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "vfs_api.h": [],
    "SD_Test.ino": [],
    "SD.cpp": [
        {
            "commit": "e625b3b08ed7a5bf2ae0d8cbf068ba534f91c23a",
            "timestamp": "2017-03-10T15:25:38+01:00",
            "author": "Me No Dev",
            "commit_message": "Add FS, SD and SD_MMC (#256)",
            "additions": 76,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "",
                            "#include \"vfs_api.h\"",
                            "#include \"sd_diskio.h\"",
                            "#include \"FS.h\"",
                            "#include \"SD.h\"",
                            "",
                            "using namespace fs;",
                            "",
                            "SDFS::SDFS(FSImplPtr impl): FS(impl), _pdrv(0xFF) {}",
                            "",
                            "bool SDFS::begin(uint8_t ssPin, SPIClass &spi, uint32_t frequency, const char * mountpoint)",
                            "{",
                            "    if(_pdrv != 0xFF) {",
                            "        return true;",
                            "    }",
                            "",
                            "    spi.begin();",
                            "",
                            "    _pdrv = sdcard_init(ssPin, &spi, frequency);",
                            "    if(_pdrv == 0xFF) {",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!sdcard_mount(_pdrv, mountpoint)){",
                            "        sdcard_uninit(_pdrv);",
                            "        _pdrv = 0xFF;",
                            "        return false;",
                            "    }",
                            "",
                            "    _impl->mountpoint(mountpoint);",
                            "    return true;",
                            "}",
                            "",
                            "void SDFS::end()",
                            "{",
                            "    if(_pdrv != 0xFF) {",
                            "        _impl->mountpoint(NULL);",
                            "        sdcard_unmount(_pdrv);",
                            "",
                            "        sdcard_uninit(_pdrv);",
                            "        _pdrv = 0xFF;",
                            "    }",
                            "}",
                            "",
                            "sdcard_type_t SDFS::cardType()",
                            "{",
                            "    if(_pdrv == 0xFF) {",
                            "        return CARD_NONE;",
                            "    }",
                            "    return sdcard_type(_pdrv);",
                            "}",
                            "",
                            "uint64_t SDFS::cardSize()",
                            "{",
                            "    if(_pdrv == 0xFF) {",
                            "        return 0;",
                            "    }",
                            "    size_t sectors = sdcard_num_sectors(_pdrv);",
                            "    size_t sectorSize = sdcard_sector_size(_pdrv);",
                            "    return (uint64_t)sectors * sectorSize;",
                            "}",
                            "",
                            "SDFS SD = SDFS(FSImplPtr(new VFSImpl()));"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "SD.h": [],
    "sd_defines.h": [],
    "sd_diskio.cpp": [
        {
            "commit": "e625b3b08ed7a5bf2ae0d8cbf068ba534f91c23a",
            "timestamp": "2017-03-10T15:25:38+01:00",
            "author": "Me No Dev",
            "commit_message": "Add FS, SD and SD_MMC (#256)",
            "additions": 740,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645,
                            646,
                            647,
                            648,
                            649,
                            650,
                            651,
                            652,
                            653,
                            654,
                            655,
                            656,
                            657,
                            658,
                            659,
                            660,
                            661,
                            662,
                            663,
                            664,
                            665,
                            666,
                            667,
                            668,
                            669,
                            670,
                            671,
                            672,
                            673,
                            674,
                            675,
                            676,
                            677,
                            678,
                            679,
                            680,
                            681,
                            682,
                            683,
                            684,
                            685,
                            686,
                            687,
                            688,
                            689,
                            690,
                            691,
                            692,
                            693,
                            694,
                            695,
                            696,
                            697,
                            698,
                            699,
                            700,
                            701,
                            702,
                            703,
                            704,
                            705,
                            706,
                            707,
                            708,
                            709,
                            710,
                            711,
                            712,
                            713,
                            714,
                            715,
                            716,
                            717,
                            718,
                            719,
                            720,
                            721,
                            722,
                            723,
                            724,
                            725,
                            726,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732,
                            733,
                            734,
                            735,
                            736,
                            737,
                            738,
                            739,
                            740
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "#include \"sd_diskio.h\"",
                            "extern \"C\" {",
                            "    #include \"diskio.h\"",
                            "    #include \"ffconf.h\"",
                            "    #include \"ff.h\"",
                            "    #include \"esp_vfs.h\"",
                            "    #include \"esp_vfs_fat.h\"",
                            "    char CRC7(const char* data, int length);",
                            "    unsigned short CRC16(const char* data, int length);",
                            "}",
                            "",
                            "typedef enum {",
                            "    GO_IDLE_STATE           = 0,",
                            "    SEND_OP_COND            = 1,",
                            "    SEND_CID                = 2,",
                            "    SEND_RELATIVE_ADDR      = 3,",
                            "    SEND_SWITCH_FUNC        = 6,",
                            "    SEND_IF_COND            = 8,",
                            "    SEND_CSD                = 9,",
                            "    STOP_TRANSMISSION       = 12,",
                            "    SEND_STATUS             = 13,",
                            "    SET_BLOCKLEN            = 16,",
                            "    READ_BLOCK_SINGLE       = 17,",
                            "    READ_BLOCK_MULTIPLE     = 18,",
                            "    SEND_NUM_WR_BLOCKS      = 22,",
                            "    SET_WR_BLK_ERASE_COUNT  = 23,",
                            "    WRITE_BLOCK_SINGLE      = 24,",
                            "    WRITE_BLOCK_MULTIPLE    = 25,",
                            "    APP_OP_COND             = 41,",
                            "    APP_CLR_CARD_DETECT     = 42,",
                            "    APP_CMD                 = 55,",
                            "    READ_OCR                = 58,",
                            "    CRC_ON_OFF              = 59",
                            "} ardu_sdcard_command_t;",
                            "",
                            "typedef struct {",
                            "    uint8_t ssPin;",
                            "    SPIClass * spi;",
                            "    int frequency;",
                            "    char * base_path;",
                            "    sdcard_type_t type;",
                            "    unsigned long sectors;",
                            "    bool supports_crc;",
                            "    int status;",
                            "} ardu_sdcard_t;",
                            "",
                            "static ardu_sdcard_t* s_cards[_VOLUMES] = { NULL };",
                            "",
                            "/*",
                            " * SD SPI",
                            " * */",
                            "",
                            "bool sdWait(uint8_t pdrv, int timeout)",
                            "{",
                            "    char resp;",
                            "    uint32_t start = millis();",
                            "",
                            "    do {",
                            "        resp = s_cards[pdrv]->spi->transfer(0xFF);",
                            "    } while (resp == 0x00 && (millis() - start) < (unsigned int)timeout);",
                            "",
                            "    return (resp > 0x00);",
                            "}",
                            "",
                            "void sdStop(uint8_t pdrv)",
                            "{",
                            "    s_cards[pdrv]->spi->write(0xFD);",
                            "}",
                            "",
                            "void sdDeselectCard(uint8_t pdrv)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    digitalWrite(card->ssPin, HIGH);",
                            "    card->spi->write(0xFF);",
                            "}",
                            "",
                            "bool sdSelectCard(uint8_t pdrv)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    digitalWrite(card->ssPin, LOW);",
                            "    card->spi->write(0xFF);",
                            "",
                            "    if (sdWait(pdrv, 500)) {",
                            "        return true;",
                            "    } else {",
                            "        log_e(\"timeout\");",
                            "        sdDeselectCard(pdrv);",
                            "        return false;",
                            "    }",
                            "}",
                            "",
                            "char sdCommand(uint8_t pdrv, char cmd, unsigned int arg, unsigned int* resp)",
                            "{",
                            "    char token;",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "",
                            "    for (int f = 0; f < 3; f++) {",
                            "        if (cmd == SEND_NUM_WR_BLOCKS || cmd == SET_WR_BLK_ERASE_COUNT || cmd == APP_OP_COND || cmd == APP_CLR_CARD_DETECT) {",
                            "            token = sdCommand(pdrv, APP_CMD, 0, NULL);",
                            "            sdDeselectCard(pdrv);",
                            "            if (token > 1) {",
                            "                return token;",
                            "            }",
                            "            if(!sdSelectCard(pdrv)) {",
                            "                return 0xFF;",
                            "            }",
                            "        }",
                            "",
                            "        char cmdPacket[7];",
                            "        cmdPacket[0] = cmd | 0x40;",
                            "        cmdPacket[1] = arg >> 24;",
                            "        cmdPacket[2] = arg >> 16;",
                            "        cmdPacket[3] = arg >> 8;",
                            "        cmdPacket[4] = arg;",
                            "        if(card->supports_crc || cmd == GO_IDLE_STATE || cmd == SEND_IF_COND) {",
                            "            cmdPacket[5] = (CRC7(cmdPacket, 5) << 1) | 0x01;",
                            "        } else {",
                            "            cmdPacket[5] = 0x01;",
                            "        }",
                            "        cmdPacket[6] = 0xFF;",
                            "",
                            "        card->spi->writeBytes((uint8_t*)cmdPacket, (cmd == STOP_TRANSMISSION)?7:6);",
                            "",
                            "        for (int i = 0; i < 9; i++) {",
                            "            token = card->spi->transfer(0xFF);",
                            "            if (!(token & 0x80)) {",
                            "                break;",
                            "            }",
                            "        }",
                            "",
                            "        if (token == 0xFF) {",
                            "            log_e(\"no token received\");",
                            "            break;",
                            "        } else if (token & 0x08) {",
                            "            log_w(\"crc error\");",
                            "            continue;",
                            "        } else if (token > 1) {",
                            "            log_w(\"token error [%u] 0x%x\", cmd, token);",
                            "            break;",
                            "        }",
                            "",
                            "        if (cmd == SEND_STATUS && resp) {",
                            "            *resp = card->spi->transfer(0xFF);",
                            "        } else if ((cmd == SEND_IF_COND || cmd == READ_OCR) && resp) {",
                            "            *resp = card->spi->transfer32(0xFFFFFFFF);",
                            "        }",
                            "",
                            "        break;",
                            "    }",
                            "",
                            "    return token;",
                            "}",
                            "",
                            "bool sdReadBytes(uint8_t pdrv, char* buffer, int length)",
                            "{",
                            "    char token;",
                            "    unsigned short crc;",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "",
                            "    uint32_t start = millis();",
                            "    do {",
                            "        token = card->spi->transfer(0xFF);",
                            "    } while (token == 0xFF && (millis() - start) < 500);",
                            "",
                            "    if (token != 0xFE) {",
                            "        return false;",
                            "    }",
                            "",
                            "    card->spi->transferBytes(NULL, (uint8_t*)buffer, length);",
                            "    crc = card->spi->transfer16(0xFFFF);",
                            "    return (!card->supports_crc || crc == CRC16(buffer, length));",
                            "}",
                            "",
                            "char sdWriteBytes(uint8_t pdrv, const char* buffer, char token)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    unsigned short crc = (card->supports_crc)?CRC16(buffer, 512):0xFFFF;",
                            "    if (!sdWait(pdrv, 500)) {",
                            "        return false;",
                            "    }",
                            "",
                            "    card->spi->write(token);",
                            "    card->spi->writeBytes((uint8_t*)buffer, 512);",
                            "    card->spi->write16(crc);",
                            "    return (card->spi->transfer(0xFF) & 0x1F);",
                            "}",
                            "",
                            "/*",
                            " * SPI SDCARD Communication",
                            " * */",
                            "",
                            "char sdTransaction(uint8_t pdrv, char cmd, unsigned int arg, unsigned int* resp)",
                            "{",
                            "    if(!sdSelectCard(pdrv)) {",
                            "        return 0xFF;",
                            "    }",
                            "    char token = sdCommand(pdrv, cmd, arg, resp);",
                            "    sdDeselectCard(pdrv);",
                            "    return token;",
                            "}",
                            "",
                            "bool sdReadSector(uint8_t pdrv, char* buffer, unsigned long long sector)",
                            "{",
                            "    for (int f = 0; f < 3; f++) {",
                            "        if(!sdSelectCard(pdrv)) {",
                            "            break;",
                            "        }",
                            "        if (!sdCommand(pdrv, READ_BLOCK_SINGLE, (s_cards[pdrv]->type == CARD_SDHC) ? sector : sector << 9, NULL)) {",
                            "            bool success = sdReadBytes(pdrv, buffer, 512);",
                            "            sdDeselectCard(pdrv);",
                            "            if (success) {",
                            "                return true;",
                            "            }",
                            "        } else {",
                            "            break;",
                            "        }",
                            "    }",
                            "    sdDeselectCard(pdrv);",
                            "    return false;",
                            "}",
                            "",
                            "bool sdReadSectors(uint8_t pdrv, char* buffer, unsigned long long sector, int count)",
                            "{",
                            "    for (int f = 0; f < 3;) {",
                            "        if(!sdSelectCard(pdrv)) {",
                            "            break;",
                            "        }",
                            "",
                            "        if (!sdCommand(pdrv, READ_BLOCK_MULTIPLE, (s_cards[pdrv]->type == CARD_SDHC) ? sector : sector << 9, NULL)) {",
                            "            do {",
                            "                if (!sdReadBytes(pdrv, buffer, 512)) {",
                            "                    f++;",
                            "                    break;",
                            "                }",
                            "",
                            "                sector++;",
                            "                buffer += 512;",
                            "                f = 0;",
                            "            } while (--count);",
                            "",
                            "            if (sdCommand(pdrv, STOP_TRANSMISSION, 0, NULL)) {",
                            "                log_e(\"command failed\");",
                            "                break;",
                            "            }",
                            "",
                            "            sdDeselectCard(pdrv);",
                            "            if (count == 0) {",
                            "                return true;",
                            "            }",
                            "        } else {",
                            "            break;",
                            "        }",
                            "    }",
                            "    sdDeselectCard(pdrv);",
                            "    return false;",
                            "}",
                            "",
                            "bool sdWriteSector(uint8_t pdrv, const char* buffer, unsigned long long sector)",
                            "{",
                            "    for (int f = 0; f < 3; f++) {",
                            "        if(!sdSelectCard(pdrv)) {",
                            "            break;",
                            "        }",
                            "        if (!sdCommand(pdrv, WRITE_BLOCK_SINGLE, (s_cards[pdrv]->type == CARD_SDHC) ? sector : sector << 9, NULL)) {",
                            "            char token = sdWriteBytes(pdrv, buffer, 0xFE);",
                            "            sdDeselectCard(pdrv);",
                            "",
                            "            if (token == 0x0A) {",
                            "                continue;",
                            "            } else if (token == 0x0C) {",
                            "                return false;",
                            "            }",
                            "",
                            "            unsigned int resp;",
                            "            if (sdTransaction(pdrv, SEND_STATUS, 0, &resp) || resp) {",
                            "                return false;",
                            "            }",
                            "            return true;",
                            "        } else {",
                            "            break;",
                            "        }",
                            "    }",
                            "    sdDeselectCard(pdrv);",
                            "    return false;",
                            "}",
                            "",
                            "bool sdWriteSectors(uint8_t pdrv, const char* buffer, unsigned long long sector, int count)",
                            "{",
                            "    char token;",
                            "    const char* currentBuffer = buffer;",
                            "    unsigned long long currentSector = sector;",
                            "    int currentCount = count;",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "",
                            "    for (int f = 0; f < 3;) {",
                            "        if (card->type != CARD_MMC) {",
                            "            if (sdTransaction(pdrv, SET_WR_BLK_ERASE_COUNT, currentCount, NULL)) {",
                            "                break;",
                            "            }",
                            "        }",
                            "",
                            "        if(!sdSelectCard(pdrv)) {",
                            "            break;",
                            "        }",
                            "",
                            "        if (!sdCommand(pdrv, WRITE_BLOCK_MULTIPLE, (card->type == CARD_SDHC) ? currentSector : currentSector << 9, NULL)) {",
                            "            do {",
                            "                token = sdWriteBytes(pdrv, currentBuffer, 0xFC);",
                            "                if (token != 0x05) {",
                            "                    f++;",
                            "                    break;",
                            "                }",
                            "                currentBuffer += 512;",
                            "                f = 0;",
                            "            } while (--currentCount);",
                            "",
                            "            if (!sdWait(pdrv, 500)) {",
                            "                break;",
                            "            }",
                            "",
                            "            if (currentCount == 0) {",
                            "                sdStop(pdrv);",
                            "                sdDeselectCard(pdrv);",
                            "",
                            "                unsigned int resp;",
                            "                if (sdTransaction(pdrv, SEND_STATUS, 0, &resp) || resp) {",
                            "                    return false;",
                            "                }",
                            "                return true;",
                            "            } else {",
                            "                if (sdCommand(pdrv, STOP_TRANSMISSION, 0, NULL)) {",
                            "                    break;",
                            "                }",
                            "",
                            "                sdDeselectCard(pdrv);",
                            "",
                            "                if (token == 0x0A) {",
                            "                    unsigned int writtenBlocks = 0;",
                            "                    if (card->type != CARD_MMC && sdSelectCard(pdrv)) {",
                            "                        if (!sdCommand(pdrv, SEND_NUM_WR_BLOCKS, 0, NULL)) {",
                            "                            char acmdData[4];",
                            "                            if (sdReadBytes(pdrv, acmdData, 4)) {",
                            "                                writtenBlocks = acmdData[0] << 24;",
                            "                                writtenBlocks |= acmdData[1] << 16;",
                            "                                writtenBlocks |= acmdData[2] << 8;",
                            "                                writtenBlocks |= acmdData[3];",
                            "                            }",
                            "                        }",
                            "                        sdDeselectCard(pdrv);",
                            "                    }",
                            "                    currentBuffer = buffer + (writtenBlocks << 9);",
                            "                    currentSector = sector + writtenBlocks;",
                            "                    currentCount = count - writtenBlocks;",
                            "                    continue;",
                            "                } else {",
                            "                    return false;",
                            "                }",
                            "            }",
                            "        } else {",
                            "            break;",
                            "        }",
                            "    }",
                            "    sdDeselectCard(pdrv);",
                            "    return false;",
                            "}",
                            "",
                            "unsigned long sdGetSectorsCount(uint8_t pdrv)",
                            "{",
                            "    for (int f = 0; f < 3; f++) {",
                            "        if(!sdSelectCard(pdrv)) {",
                            "            break;",
                            "        }",
                            "",
                            "        if (!sdCommand(pdrv, SEND_CSD, 0, NULL)) {",
                            "            char csd[16];",
                            "            bool success = sdReadBytes(pdrv, csd, 16);",
                            "            sdDeselectCard(pdrv);",
                            "            if (success) {",
                            "                if ((csd[0] >> 6) == 0x01) {",
                            "                    unsigned long size = (",
                            "                         ((unsigned long)(csd[7] & 0x3F) << 16)",
                            "                         | ((unsigned long)csd[8] << 8)",
                            "                         | csd[9]",
                            "                     ) + 1;",
                            "                    return size << 10;",
                            "                }",
                            "                unsigned long size = (",
                            "                     ((unsigned long)(csd[6] & 0x03) << 10)",
                            "                     | ((unsigned long)csd[7] << 2)",
                            "                     | ((csd[8] & 0xC0) >> 6)",
                            "                 ) + 1;",
                            "                size <<= ((",
                            "                     ((csd[9] & 0x03) << 1)",
                            "                     | ((csd[10] & 0x80) >> 7)",
                            "                 ) + 2);",
                            "                size <<= (csd[5] & 0x0F);",
                            "                return size >> 9;",
                            "            }",
                            "        } else {",
                            "            break;",
                            "        }",
                            "    }",
                            "",
                            "    sdDeselectCard(pdrv);",
                            "    return 0;",
                            "}",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "/*",
                            " * FATFS API",
                            " * */",
                            "",
                            "DSTATUS ff_sd_initialize(uint8_t pdrv)",
                            "{",
                            "    char token;",
                            "    unsigned int resp;",
                            "    unsigned int start;",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "",
                            "    if (!(card->status & STA_NOINIT)) {",
                            "        return card->status;",
                            "    }",
                            "",
                            "    card->spi->beginTransaction(SPISettings(400000, MSBFIRST, SPI_MODE0));",
                            "",
                            "    if (sdTransaction(pdrv, GO_IDLE_STATE, 0, NULL) != 1) {",
                            "        goto unknown_card;",
                            "    }",
                            "",
                            "    token = sdTransaction(pdrv, CRC_ON_OFF, 1, NULL);",
                            "    if (token == 0x5) {",
                            "        //old card maybe",
                            "        card->supports_crc = false;",
                            "    } else if (token != 1) {",
                            "        goto unknown_card;",
                            "    }",
                            "",
                            "    if (sdTransaction(pdrv, SEND_IF_COND, 0x1AA, &resp) == 1) {",
                            "        if ((resp & 0xFFF) != 0x1AA) {",
                            "            goto unknown_card;",
                            "        }",
                            "",
                            "        if (sdTransaction(pdrv, READ_OCR, 0, &resp) != 1 || !(resp & (1 << 20))) {",
                            "            goto unknown_card;",
                            "        }",
                            "",
                            "        start = millis();",
                            "        do {",
                            "            token = sdTransaction(pdrv, APP_OP_COND, 0x40100000, NULL);",
                            "        } while (token == 1 && (millis() - start) < 1000);",
                            "",
                            "        if (token) {",
                            "            goto unknown_card;",
                            "        }",
                            "",
                            "        if (!sdTransaction(pdrv, READ_OCR, 0, &resp)) {",
                            "            if (resp & (1 << 30)) {",
                            "                card->type = CARD_SDHC;",
                            "            } else {",
                            "                card->type = CARD_SD;",
                            "            }",
                            "        } else {",
                            "            goto unknown_card;",
                            "        }",
                            "    } else {",
                            "        if (sdTransaction(pdrv, READ_OCR, 0, &resp) != 1 || !(resp & (1 << 20))) {",
                            "            goto unknown_card;",
                            "        }",
                            "",
                            "        start = millis();",
                            "        do {",
                            "            token = sdTransaction(pdrv, APP_OP_COND, 0x100000, NULL);",
                            "        } while (token == 0x01 && (millis() - start) < 1000);",
                            "",
                            "        if (!token) {",
                            "            card->type = CARD_SD;",
                            "        } else {",
                            "            start = millis();",
                            "            do {",
                            "                token = sdTransaction(pdrv, SEND_OP_COND, 0x100000, NULL);",
                            "            } while (token != 0x00 && (millis() - start) < 1000);",
                            "",
                            "            if (token == 0x00) {",
                            "                card->type = CARD_MMC;",
                            "            } else {",
                            "                goto unknown_card;",
                            "            }",
                            "        }",
                            "    }",
                            "",
                            "    if (card->type != CARD_MMC) {",
                            "        if (sdTransaction(pdrv, APP_CLR_CARD_DETECT, 0, NULL)) {",
                            "            goto unknown_card;",
                            "        }",
                            "    }",
                            "",
                            "    if (card->type != CARD_SDHC) {",
                            "        if (sdTransaction(pdrv, SET_BLOCKLEN, 512, NULL) != 0x00) {",
                            "            goto unknown_card;",
                            "        }",
                            "    }",
                            "",
                            "    card->sectors = sdGetSectorsCount(pdrv);",
                            "",
                            "    if (card->frequency > 25000000) {",
                            "        card->frequency = 25000000;",
                            "    }",
                            "",
                            "    card->spi->endTransaction();",
                            "",
                            "    card->status &= ~STA_NOINIT;",
                            "    return card->status;",
                            "",
                            "unknown_card:",
                            "    card->spi->endTransaction();",
                            "    card->type = CARD_UNKNOWN;",
                            "    return card->status;",
                            "}",
                            "",
                            "DSTATUS ff_sd_status(uint8_t pdrv)",
                            "{",
                            "    return s_cards[pdrv]->status;",
                            "}",
                            "",
                            "DRESULT ff_sd_read(uint8_t pdrv, uint8_t* buffer, DWORD sector, UINT count)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    if (card->status & STA_NOINIT) {",
                            "        return RES_NOTRDY;",
                            "    }",
                            "    DRESULT res = RES_OK;",
                            "",
                            "    card->spi->beginTransaction(SPISettings(card->frequency, MSBFIRST, SPI_MODE0));",
                            "",
                            "    if (count > 1) {",
                            "        res = sdReadSectors(pdrv, (char*)buffer, sector, count) ? RES_OK : RES_ERROR;",
                            "    } else {",
                            "        res = sdReadSector(pdrv, (char*)buffer, sector) ? RES_OK : RES_ERROR;",
                            "    }",
                            "",
                            "    card->spi->endTransaction();",
                            "    return res;",
                            "}",
                            "",
                            "DRESULT ff_sd_write(uint8_t pdrv, const uint8_t* buffer, DWORD sector, UINT count)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    if (card->status & STA_NOINIT) {",
                            "        return RES_NOTRDY;",
                            "    }",
                            "",
                            "    if (card->status & STA_PROTECT) {",
                            "        return RES_WRPRT;",
                            "    }",
                            "    DRESULT res = RES_OK;",
                            "",
                            "    card->spi->beginTransaction(SPISettings(card->frequency, MSBFIRST, SPI_MODE0));",
                            "",
                            "    if (count > 1) {",
                            "        res = sdWriteSectors(pdrv, (const char*)buffer, sector, count) ? RES_OK : RES_ERROR;",
                            "    }",
                            "    res = sdWriteSector(pdrv, (const char*)buffer, sector) ? RES_OK : RES_ERROR;",
                            "",
                            "    card->spi->endTransaction();",
                            "    return res;",
                            "}",
                            "",
                            "DRESULT ff_sd_ioctl(uint8_t pdrv, uint8_t cmd, void* buff)",
                            "{",
                            "    switch(cmd) {",
                            "    case CTRL_SYNC:",
                            "        if (sdSelectCard(pdrv)) {",
                            "            sdDeselectCard(pdrv);",
                            "            return RES_OK;",
                            "        }",
                            "        return RES_ERROR;",
                            "    case GET_SECTOR_COUNT:",
                            "        *((unsigned long*) buff) = s_cards[pdrv]->sectors;",
                            "        return RES_OK;",
                            "    case GET_SECTOR_SIZE:",
                            "        *((unsigned long*) buff) = 512;",
                            "        return RES_OK;",
                            "    case GET_BLOCK_SIZE:",
                            "        *((unsigned long*)buff) = 1;",
                            "        return RES_OK;",
                            "    }",
                            "    return RES_PARERR;",
                            "}",
                            "",
                            "",
                            "/*",
                            " * Public methods",
                            " * */",
                            "",
                            "uint8_t sdcard_uninit(uint8_t pdrv)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    if (pdrv >= _VOLUMES || card == NULL) {",
                            "        return 1;",
                            "    }",
                            "    ff_diskio_register(pdrv, NULL);",
                            "    s_cards[pdrv] = NULL;",
                            "    esp_err_t err = ESP_OK;",
                            "    if (card->base_path) {",
                            "        err = esp_vfs_fat_unregister_path(card->base_path);",
                            "    }",
                            "    free(card);",
                            "    return err;",
                            "}",
                            "",
                            "uint8_t sdcard_init(uint8_t cs, SPIClass * spi, int hz)",
                            "{",
                            "",
                            "    uint8_t pdrv = 0xFF;",
                            "    if (ff_diskio_get_drive(&pdrv) != ESP_OK || pdrv == 0xFF) {",
                            "        return pdrv;",
                            "    }",
                            "",
                            "    ardu_sdcard_t * card = (ardu_sdcard_t *)malloc(sizeof(ardu_sdcard_t));",
                            "    if (!card) {",
                            "        return 0xFF;",
                            "    }",
                            "",
                            "    card->base_path = NULL;",
                            "    card->frequency = hz;",
                            "    card->spi = spi;",
                            "    card->ssPin = cs;",
                            "",
                            "    card->supports_crc = true;",
                            "    card->type = CARD_NONE;",
                            "    card->status = STA_NOINIT;",
                            "",
                            "    pinMode(card->ssPin, OUTPUT);",
                            "    digitalWrite(card->ssPin, HIGH);",
                            "",
                            "    s_cards[pdrv] = card;",
                            "",
                            "    static const ff_diskio_impl_t sd_impl = {",
                            "        .init = &ff_sd_initialize,",
                            "        .status = &ff_sd_status,",
                            "        .read = &ff_sd_read,",
                            "        .write = &ff_sd_write,",
                            "        .ioctl = &ff_sd_ioctl",
                            "    };",
                            "    ff_diskio_register(pdrv, &sd_impl);",
                            "",
                            "    return pdrv;",
                            "}",
                            "",
                            "uint8_t sdcard_unmount(uint8_t pdrv)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    if (pdrv >= _VOLUMES || card == NULL) {",
                            "        return 1;",
                            "    }",
                            "    card->status |= STA_NOINIT;",
                            "    card->type = CARD_NONE;",
                            "",
                            "    char drv[3] = {(char)('0' + pdrv), ':', 0};",
                            "    f_mount(NULL, drv, 0);",
                            "    return 0;",
                            "}",
                            "",
                            "bool sdcard_mount(uint8_t pdrv, const char* path)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    if(pdrv >= _VOLUMES || card == NULL){",
                            "        return false;",
                            "    }",
                            "",
                            "    if(card->base_path){",
                            "        free(card->base_path);",
                            "    }",
                            "    card->base_path = strdup(path);",
                            "",
                            "    FATFS* fs;",
                            "    char drv[3] = {(char)('0' + pdrv), ':', 0};",
                            "    esp_err_t err = esp_vfs_fat_register(path, drv, 5, &fs);",
                            "    if (err == ESP_ERR_INVALID_STATE) {",
                            "        log_e(\"esp_vfs_fat_register failed 0x(%x): SD is registered.\", err);",
                            "        return false;",
                            "    } else if (err != ESP_OK) {",
                            "        log_e(\"esp_vfs_fat_register failed 0x(%x)\", err);",
                            "        return false;",
                            "    }",
                            "",
                            "    FRESULT res = f_mount(fs, drv, 1);",
                            "    if (res != FR_OK) {",
                            "        log_e(\"f_mount failed 0x(%x)\", res);",
                            "        esp_vfs_fat_unregister_path(path);",
                            "        return false;",
                            "    }",
                            "    card->sectors = sdGetSectorsCount(pdrv);",
                            "    return true;",
                            "}",
                            "",
                            "uint32_t sdcard_num_sectors(uint8_t pdrv)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    if(pdrv >= _VOLUMES || card == NULL){",
                            "        return 0;",
                            "    }",
                            "    return card->sectors;",
                            "}",
                            "",
                            "uint32_t sdcard_sector_size(uint8_t pdrv)",
                            "{",
                            "    if(pdrv >= _VOLUMES || s_cards[pdrv] == NULL){",
                            "        return 0;",
                            "    }",
                            "    return 512;",
                            "}",
                            "",
                            "sdcard_type_t sdcard_type(uint8_t pdrv)",
                            "{",
                            "    ardu_sdcard_t * card = s_cards[pdrv];",
                            "    if(pdrv >= _VOLUMES || card == NULL){",
                            "        return CARD_NONE;",
                            "    }",
                            "    return card->type;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "sd_diskio.h": [],
    "sd_diskio_crc.c": [],
    "SDMMC_Test.ino": [],
    "SD_MMC.cpp": [
        {
            "commit": "e625b3b08ed7a5bf2ae0d8cbf068ba534f91c23a",
            "timestamp": "2017-03-10T15:25:38+01:00",
            "author": "Me No Dev",
            "commit_message": "Add FS, SD and SD_MMC (#256)",
            "additions": 97,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "",
                            "#include \"vfs_api.h\"",
                            "",
                            "extern \"C\" {",
                            "#include <sys/unistd.h>",
                            "#include <sys/stat.h>",
                            "#include <dirent.h>",
                            "#include \"esp_vfs_fat.h\"",
                            "#include \"driver/sdmmc_host.h\"",
                            "#include \"driver/sdmmc_defs.h\"",
                            "#include \"sdmmc_cmd.h\"",
                            "}",
                            "#include \"SD_MMC.h\"",
                            "",
                            "using namespace fs;",
                            "/*",
                            "",
                            "*/",
                            "",
                            "SDMMCFS::SDMMCFS(FSImplPtr impl)",
                            "    : FS(impl), _card(NULL)",
                            "{}",
                            "",
                            "bool SDMMCFS::begin(const char * mountpoint)",
                            "{",
                            "    if(_card) {",
                            "        return true;",
                            "    }",
                            "    //mount",
                            "    sdmmc_slot_config_t slot_config = SDMMC_SLOT_CONFIG_DEFAULT();",
                            "    sdmmc_host_t host = SDMMC_HOST_DEFAULT();",
                            "    host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;",
                            "    //host.flags = SDMMC_HOST_FLAG_1BIT; //use 1-line SD mode",
                            "",
                            "    esp_vfs_fat_sdmmc_mount_config_t mount_config = {",
                            "        .format_if_mount_failed = false,",
                            "        .max_files = 5",
                            "    };",
                            "",
                            "    esp_err_t ret = esp_vfs_fat_sdmmc_mount(mountpoint, &host, &slot_config, &mount_config, &_card);",
                            "    if (ret != ESP_OK) {",
                            "        if (ret == ESP_FAIL) {",
                            "            log_e(\"Failed to mount filesystem. If you want the card to be formatted, set format_if_mount_failed = true.\");",
                            "        } else if (ret == ESP_ERR_INVALID_STATE) {",
                            "            _impl->mountpoint(mountpoint);",
                            "            log_w(\"SD Already mounted\");",
                            "            return true;",
                            "        } else {",
                            "            log_e(\"Failed to initialize the card (%d). Make sure SD card lines have pull-up resistors in place.\", ret);",
                            "        }",
                            "        _card = NULL;",
                            "        return false;",
                            "    }",
                            "    _impl->mountpoint(mountpoint);",
                            "    return true;",
                            "}",
                            "",
                            "void SDMMCFS::end()",
                            "{",
                            "    if(_card) {",
                            "        esp_vfs_fat_sdmmc_unmount();",
                            "        _impl->mountpoint(NULL);",
                            "        _card = NULL;",
                            "    }",
                            "}",
                            "",
                            "sdcard_type_t SDMMCFS::cardType()",
                            "{",
                            "    if(!_card) {",
                            "        return CARD_NONE;",
                            "    }",
                            "    return (_card->ocr & SD_OCR_SDHC_CAP)?CARD_SDHC:CARD_SD;",
                            "}",
                            "",
                            "uint64_t SDMMCFS::cardSize()",
                            "{",
                            "    if(!_card) {",
                            "        return 0;",
                            "    }",
                            "    return (uint64_t)_card->csd.capacity * _card->csd.sector_size;",
                            "}",
                            "",
                            "",
                            "SDMMCFS SD_MMC = SDMMCFS(FSImplPtr(new VFSImpl()));"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "SD_MMC.h": [],
    "BasicOTA.ino": [],
    "ArduinoOTA.cpp": [
        {
            "commit": "126674c3b65d414edd4cc60cff4619edcff6f53b",
            "timestamp": "2017-10-30T10:44:15+01:00",
            "author": "davruet",
            "commit_message": "Fixes for zero length packet bug, buffer overflow in parseInt(), added end() method (#757)\n\n* ArduinoOTA would stop receiving any packets if the port received a zero-length UDP packet, commonly sent by network scanners like nmap. Fixed to flush() after every call to parsePacket(), even if read length is 0.\r\n\r\nAdditionally, added length checking to fix a potential buffer overflow in parseInt().\r\n\r\nFinally, added an end() method that stops the OTA listener and releases resources.\r\n\r\n* Only end MDNS in end() if mdns mode is enabled.",
            "additions": 15,
            "deletions": 3,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            370
                        ],
                        "comments": [
                            "    _udp_ota.flush(); // always flush, even zero length packets must be flushed."
                        ],
                        "lines": []
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "370": "    _udp_ota.flush(); // always flush, even zero length packets must be flushed."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "2fda054bea45aa6d1be3ab4265406b0846247357",
            "timestamp": "2018-07-24T19:40:18+02:00",
            "author": "Sathishkumar T",
            "commit_message": "[OTA Timeout] Added ability set OTA timeout in the OTA client (#1669)",
            "additions": 9,
            "deletions": 3,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            12
                        ],
                        "comments": [
                            "// #define OTA_DEBUG Serial"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            23
                        ],
                        "comments": [],
                        "lines": [
                            ", _ota_timeout(1000)"
                        ]
                    },
                    {
                        "line_numbers": [
                            264
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            266
                        ],
                        "comments": [],
                        "lines": [
                            "        size_t waited = _ota_timeout;"
                        ]
                    },
                    {
                        "line_numbers": [
                            392,
                            393,
                            394,
                            395
                        ],
                        "comments": [],
                        "lines": [
                            "void ArduinoOTAClass::setTimeout(int timeoutInMillis) {",
                            "    _ota_timeout = timeoutInMillis;",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            398
                        ],
                        "comments": [],
                        "lines": [
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "12": "// #define OTA_DEBUG Serial"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "ArduinoOTA.h": [],
    "mDNS-SD_Extended.ino": [],
    "mDNS_Web_Server.ino": [],
    "ESPmDNS.cpp": [
        {
            "commit": "fa1716e73eb746088921ca2d3695a04f68beb1b6",
            "timestamp": "2017-03-11T07:15:44+01:00",
            "author": "Me No Dev",
            "commit_message": "Add Ota and mdns (#257)\n\n* Add Sketch Update Library\r\n\r\n* Add MDNS Library\r\n\r\n* Add Arduino OTA Library\r\n\r\n* add missing library file\r\n\r\n* Add library files for Update\r\n\r\n* Add missing headers\r\n\r\n* fix ota command\r\n\r\n* Add espota binary\r\n\r\n* remove bad example\r\n\r\n* PlatformIO does not auto forward declare methods like Arduino Builder",
            "additions": 187,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187
                        ],
                        "comments": [
                            "// Important RFC's for reference:",
                            "// - DNS request and response: http://www.ietf.org/rfc/rfc1035.txt",
                            "// - Multicast DNS: http://www.ietf.org/rfc/rfc6762.txt",
                            "// - MDNS-SD: https://tools.ietf.org/html/rfc6763"
                        ],
                        "lines": [
                            "",
                            "#ifndef LWIP_OPEN_SRC",
                            "#define LWIP_OPEN_SRC",
                            "#endif",
                            "",
                            "#include \"ESPmDNS.h\"",
                            "#include <functional>",
                            "#include \"esp_wifi.h\"",
                            "",
                            "MDNSResponder::MDNSResponder() : mdns(NULL), _if(TCPIP_ADAPTER_IF_STA) {}",
                            "MDNSResponder::~MDNSResponder() {",
                            "    end();",
                            "}",
                            "",
                            "bool MDNSResponder::begin(const char* hostName, tcpip_adapter_if_t tcpip_if, uint32_t ttl){",
                            "    _if = tcpip_if;",
                            "    if(!mdns && mdns_init(_if, &mdns)){",
                            "        log_e(\"Failed starting MDNS\");",
                            "        return false;",
                            "    }",
                            "    _hostname = hostName;",
                            "    if(mdns_set_hostname(mdns, hostName)) {",
                            "        log_e(\"Failed setting MDNS hostname\");",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "void MDNSResponder::end() {",
                            "    if(!mdns){",
                            "        return;",
                            "    }",
                            "    mdns_free(mdns);",
                            "    mdns = NULL;",
                            "}",
                            "",
                            "void MDNSResponder::setInstanceName(String name) {",
                            "    if (name.length() > 63) return;",
                            "    if(mdns_set_instance(mdns, name.c_str())){",
                            "        log_e(\"Failed setting MDNS instance\");",
                            "        return;",
                            "    }",
                            "}",
                            "",
                            "void MDNSResponder::enableArduino(uint16_t port, bool auth){",
                            "    const char * arduTxtData[4] = {",
                            "            \"board=\" ARDUINO_BOARD,",
                            "            \"tcp_check=no\",",
                            "            \"ssh_upload=no\",",
                            "            \"auth_upload=no\"",
                            "    };",
                            "    if(auth){",
                            "        arduTxtData[3] = \"auth_upload=yes\";",
                            "    }",
                            "",
                            "    if(mdns_service_add(mdns, \"_arduino\", \"_tcp\", port)) {",
                            "        log_e(\"Failed adding Arduino service\");",
                            "    } else if(mdns_service_txt_set(mdns, \"_arduino\", \"_tcp\", 4, arduTxtData)) {",
                            "        log_e(\"Failed setting Arduino service TXT\");",
                            "    }",
                            "}",
                            "",
                            "void MDNSResponder::disableArduino(){",
                            "    if(mdns_service_remove(mdns, \"_arduino\", \"_tcp\")) {",
                            "        log_w(\"Failed removing Arduino service\");",
                            "    }",
                            "}",
                            "",
                            "void MDNSResponder::enableWorkstation(){",
                            "    char winstance[21+_hostname.length()];",
                            "    uint8_t mac[6];",
                            "    esp_wifi_get_mac((wifi_interface_t)_if, mac);",
                            "    sprintf(winstance, \"%s [%02x:%02x:%02x:%02x:%02x:%02x]\", _hostname.c_str(), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "",
                            "    if(mdns_service_add(mdns, \"_workstation\", \"_tcp\", 9)) {",
                            "        log_e(\"Failed adding Workstation service\");",
                            "    } else if(mdns_service_instance_set(mdns, \"_workstation\", \"_tcp\", winstance)) {",
                            "        log_e(\"Failed setting Workstation service instance name\");",
                            "    }",
                            "}",
                            "",
                            "void MDNSResponder::disableWorkstation(){",
                            "    if(mdns_service_remove(mdns, \"_workstation\", \"_tcp\")) {",
                            "        log_w(\"Failed removing Workstation service\");",
                            "    }",
                            "}",
                            "",
                            "void MDNSResponder::addService(char *name, char *proto, uint16_t port){",
                            "    if(mdns_service_add(mdns, name, proto, port)) {",
                            "        log_e(\"Failed adding service %s.%s.\\n\", name, proto);",
                            "    }",
                            "}",
                            "",
                            "bool MDNSResponder::addServiceTxt(char *name, char *proto, char *key, char *value){",
                            "    //ToDo: implement it in IDF. This will set the TXT to one record currently",
                            "    String txt = String(key) + \"=\" + String(value);",
                            "    const char * txt_chr[1] = {txt.c_str()};",
                            "    if(mdns_service_txt_set(mdns, name, proto, 1, txt_chr)) {",
                            "        log_e(\"Failed setting service TXT\");",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "int MDNSResponder::queryService(char *service, char *proto) {",
                            "    mdns_result_free(mdns);",
                            "    if(proto){",
                            "        char srv[strlen(service)+2];",
                            "        char prt[strlen(proto)+2];",
                            "        sprintf(srv, \"_%s\", service);",
                            "        sprintf(prt, \"_%s\", proto);",
                            "        return mdns_query(mdns, srv, prt, 2000);",
                            "    }",
                            "    return mdns_query(mdns, service, NULL, 2000);",
                            "}",
                            "",
                            "IPAddress MDNSResponder::queryHost(char *host){",
                            "    mdns_result_free(mdns);",
                            "    if(!mdns_query(mdns, host, NULL, 2000)){",
                            "        return IPAddress();",
                            "    }",
                            "    return IP(0);",
                            "}",
                            "",
                            "String MDNSResponder::hostname(int idx) {",
                            "    const mdns_result_t * result = mdns_result_get(mdns, idx);",
                            "    if(!result){",
                            "        log_e(\"Result %d not found\", idx);",
                            "        return String();",
                            "    }",
                            "    return String(result->host);",
                            "}",
                            "",
                            "IPAddress MDNSResponder::IP(int idx) {",
                            "    const mdns_result_t * result = mdns_result_get(mdns, idx);",
                            "    if(!result){",
                            "        log_e(\"Result %d not found\", idx);",
                            "        return IPAddress();",
                            "    }",
                            "    return IPAddress(result->addr.addr);",
                            "}",
                            "",
                            "uint16_t MDNSResponder::port(int idx) {",
                            "    const mdns_result_t * result = mdns_result_get(mdns, idx);",
                            "    if(!result){",
                            "        log_e(\"Result %d not found\", idx);",
                            "        return 0;",
                            "    }",
                            "    return result->port;",
                            "}",
                            "",
                            "MDNSResponder MDNS;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "32": "// Important RFC's for reference:",
                "33": "// - DNS request and response: http://www.ietf.org/rfc/rfc1035.txt",
                "34": "// - Multicast DNS: http://www.ietf.org/rfc/rfc6762.txt",
                "35": "// - MDNS-SD: https://tools.ietf.org/html/rfc6763"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "4d3f6caa0d23b741f668f3a72c18a93227523bd8",
            "timestamp": "2018-12-16T17:10:56+01:00",
            "author": "Bascy",
            "commit_message": "Add quotes around macro value (Issue #2193) (#2197)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)",
            "additions": 9,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53
                        ],
                        "comments": [
                            "// Add quotes around defined value"
                        ],
                        "lines": [
                            "#ifdef __IN_ECLIPSE__",
                            "#define STR_EXPAND(tok) #tok",
                            "#define STR(tok) STR_EXPAND(tok)",
                            "#else",
                            "#define STR(tok) tok",
                            "#endif",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            93
                        ],
                        "comments": [],
                        "lines": [
                            "        {(char*)\"board\"         ,(char*)STR(ARDUINO_VARIANT)},"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "46": "// Add quotes around defined value"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "ESPmDNS.h": [],
    "Update.h": [],
    "Updater.cpp": [
        {
            "commit": "b58a3509b895d909cff287ad723aa4ec9f4d4be0",
            "timestamp": "2018-11-19T16:57:38+01:00",
            "author": "Jeroen88",
            "commit_message": "Feature/http update (#1979)\n\n* Added HTTPUpdate class for downloading sketches from a server\r\n\r\n* Added HTTPUpdate class for downloading sketches from a server\r\n\r\n* Added HTTPUpdate to CMakeLists.txt\r\n\r\n* Change ESP8266 class references to ESP32 for httpUpdate.ino example\r\n\r\n* Change ESP8266 class references to ESP32 for httpUpdate.ino example. setLedPin() commented out because not all boards support LED_BUITLIN\r\n\r\n* Added check to handle mixup of old and present api properly\r\n\r\n* Correct HTTPClient::setTimeout() to convert milliseconds to seconds. Correct WiFiClient::setTimeout() to call Stream::setTimeout() with seconds converted back to milliseconds. Remove inproper checks for _insecure.\r\n\r\n* Added small comment because it looked like the Travis build did not finish",
            "additions": 26,
            "deletions": 3,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            93,
                            94
                        ],
                        "comments": [
                            "      digitalWrite(_ledPin, !_ledOn); // off"
                        ],
                        "lines": [
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            113
                        ],
                        "comments": [],
                        "lines": [
                            "bool UpdateClass::begin(size_t size, int command, int ledPin, uint8_t ledOn) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            119,
                            120,
                            121
                        ],
                        "comments": [
                            "    _ledOn = !!ledOn; // 0(LOW) or 1(HIGH)"
                        ],
                        "lines": [
                            "    _ledPin = ledPin;",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            325,
                            326,
                            327,
                            328,
                            329
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "    if(_ledPin != -1) {",
                            "        pinMode(_ledPin, OUTPUT);",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339
                        ],
                        "comments": [
                            "            digitalWrite(_ledPin, _ledOn); // Switch LED on"
                        ],
                        "lines": [
                            "        if(_ledPin != -1) {",
                            "        }",
                            "        size_t bytesToRead = SPI_FLASH_SEC_SIZE - _bufferLen;",
                            "        if(bytesToRead > remaining()) {",
                            "            bytesToRead = remaining();",
                            "        }",
                            "",
                            "        toRead = data.readBytes(_buffer + _bufferLen,  bytesToRead);"
                        ]
                    },
                    {
                        "line_numbers": [
                            342
                        ],
                        "comments": [],
                        "lines": [
                            "            toRead = data.readBytes(_buffer + _bufferLen, bytesToRead);"
                        ]
                    },
                    {
                        "line_numbers": [
                            348,
                            349,
                            350
                        ],
                        "comments": [
                            "            digitalWrite(_ledPin, !_ledOn); // Switch LED off"
                        ],
                        "lines": [
                            "        if(_ledPin != -1) {",
                            "        }"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "93": "      digitalWrite(_ledPin, !_ledOn); // off",
                "120": "    _ledOn = !!ledOn; // 0(LOW) or 1(HIGH)",
                "332": "            digitalWrite(_ledPin, _ledOn); // Switch LED on",
                "349": "            digitalWrite(_ledPin, !_ledOn); // Switch LED off"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "espota.exe": [],
    "espota.py": [],
    "esp_efuse.h": [],
    "esp_flash_encrypt.h": [],
    "esp_flash_partitions.h": [],
    "esp_image_format.h": [],
    "esp_secure_boot.h": [],
    "GetChipID.ino": [],
    "Authorization.ino": [],
    "BasicHttpClient.ino": [],
    "ReuseConnection.ino": [],
    "StreamHttpClient.ino": [],
    "HTTPClient.cpp": [
        {
            "commit": "51a4432ca8e71be202358ceb068f3047bb8ad762",
            "timestamp": "2017-05-19T10:18:20+02:00",
            "author": "copercini",
            "commit_message": "HTTPClient Port (#347)\n\n* Fix possible infinite loop in the example\r\n\r\n* Remove workaround of sockets always return -76 \r\n\r\nRemove workaround of sockets always return -76 (because it's fixed on IDF now)\r\nRemove delay during handshake (improving stability)\r\n\r\n* Remove unusable mbedtls_net of context creation\r\n\r\n* Fix bad destructor\r\n\r\n* Compatibility with WiFiClient for HTTPClient\r\n\r\n* Initial port from ESP8266\r\n\r\nChanged SHA1 fingerprint by Root CA verification\r\nChanged log system\r\n\r\n* Remove deprecated function",
            "additions": 1116,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645,
                            646,
                            647,
                            648,
                            649,
                            650,
                            651,
                            652,
                            653,
                            654,
                            655,
                            656,
                            657,
                            658,
                            659,
                            660,
                            661,
                            662,
                            663,
                            664,
                            665,
                            666,
                            667,
                            668,
                            669,
                            670,
                            671,
                            672,
                            673,
                            674,
                            675,
                            676,
                            677,
                            678,
                            679,
                            680,
                            681,
                            682,
                            683,
                            684,
                            685,
                            686,
                            687,
                            688,
                            689,
                            690,
                            691,
                            692,
                            693,
                            694,
                            695,
                            696,
                            697,
                            698,
                            699,
                            700,
                            701,
                            702,
                            703,
                            704,
                            705,
                            706,
                            707,
                            708,
                            709,
                            710,
                            711,
                            712,
                            713,
                            714,
                            715,
                            716,
                            717,
                            718,
                            719,
                            720,
                            721,
                            722,
                            723,
                            724,
                            725,
                            726,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732,
                            733,
                            734,
                            735,
                            736,
                            737,
                            738,
                            739,
                            740,
                            741,
                            742,
                            743,
                            744,
                            745,
                            746,
                            747,
                            748,
                            749,
                            750,
                            751,
                            752,
                            753,
                            754,
                            755,
                            756,
                            757,
                            758,
                            759,
                            760,
                            761,
                            762,
                            763,
                            764,
                            765,
                            766,
                            767,
                            768,
                            769,
                            770,
                            771,
                            772,
                            773,
                            774,
                            775,
                            776,
                            777,
                            778,
                            779,
                            780,
                            781,
                            782,
                            783,
                            784,
                            785,
                            786,
                            787,
                            788,
                            789,
                            790,
                            791,
                            792,
                            793,
                            794,
                            795,
                            796,
                            797,
                            798,
                            799,
                            800,
                            801,
                            802,
                            803,
                            804,
                            805,
                            806,
                            807,
                            808,
                            809,
                            810,
                            811,
                            812,
                            813,
                            814,
                            815,
                            816,
                            817,
                            818,
                            819,
                            820,
                            821,
                            822,
                            823,
                            824,
                            825,
                            826,
                            827,
                            828,
                            829,
                            830,
                            831,
                            832,
                            833,
                            834,
                            835,
                            836,
                            837,
                            838,
                            839,
                            840,
                            841,
                            842,
                            843,
                            844,
                            845,
                            846,
                            847,
                            848,
                            849,
                            850,
                            851,
                            852,
                            853,
                            854,
                            855,
                            856,
                            857,
                            858,
                            859,
                            860,
                            861,
                            862,
                            863,
                            864,
                            865,
                            866,
                            867,
                            868,
                            869,
                            870,
                            871,
                            872,
                            873,
                            874,
                            875,
                            876,
                            877,
                            878,
                            879,
                            880,
                            881,
                            882,
                            883,
                            884,
                            885,
                            886,
                            887,
                            888,
                            889,
                            890,
                            891,
                            892,
                            893,
                            894,
                            895,
                            896,
                            897,
                            898,
                            899,
                            900,
                            901,
                            902,
                            903,
                            904,
                            905,
                            906,
                            907,
                            908,
                            909,
                            910,
                            911,
                            912,
                            913,
                            914,
                            915,
                            916,
                            917,
                            918,
                            919,
                            920,
                            921,
                            922,
                            923,
                            924,
                            925,
                            926,
                            927,
                            928,
                            929,
                            930,
                            931,
                            932,
                            933,
                            934,
                            935,
                            936,
                            937,
                            938,
                            939,
                            940,
                            941,
                            942,
                            943,
                            944,
                            945,
                            946,
                            947,
                            948,
                            949,
                            950,
                            951,
                            952,
                            953,
                            954,
                            955,
                            956,
                            957,
                            958,
                            959,
                            960,
                            961,
                            962,
                            963,
                            964,
                            965,
                            966,
                            967,
                            968,
                            969,
                            970,
                            971,
                            972,
                            973,
                            974,
                            975,
                            976,
                            977,
                            978,
                            979,
                            980,
                            981,
                            982,
                            983,
                            984,
                            985,
                            986,
                            987,
                            988,
                            989,
                            990,
                            991,
                            992,
                            993,
                            994,
                            995,
                            996,
                            997,
                            998,
                            999,
                            1000,
                            1001,
                            1002,
                            1003,
                            1004,
                            1005,
                            1006,
                            1007,
                            1008,
                            1009,
                            1010,
                            1011,
                            1012,
                            1013,
                            1014,
                            1015,
                            1016,
                            1017,
                            1018,
                            1019,
                            1020,
                            1021,
                            1022,
                            1023,
                            1024,
                            1025,
                            1026,
                            1027,
                            1028,
                            1029,
                            1030,
                            1031,
                            1032,
                            1033,
                            1034,
                            1035,
                            1036,
                            1037,
                            1038,
                            1039,
                            1040,
                            1041,
                            1042,
                            1043,
                            1044,
                            1045,
                            1046,
                            1047,
                            1048,
                            1049,
                            1050,
                            1051,
                            1052,
                            1053,
                            1054,
                            1055,
                            1056,
                            1057,
                            1058,
                            1059,
                            1060,
                            1061,
                            1062,
                            1063,
                            1064,
                            1065,
                            1066,
                            1067,
                            1068,
                            1069,
                            1070,
                            1071,
                            1072,
                            1073,
                            1074,
                            1075,
                            1076,
                            1077,
                            1078,
                            1079,
                            1080,
                            1081,
                            1082,
                            1083,
                            1084,
                            1085,
                            1086,
                            1087,
                            1088,
                            1089,
                            1090,
                            1091,
                            1092,
                            1093,
                            1094,
                            1095,
                            1096,
                            1097,
                            1098,
                            1099,
                            1100,
                            1101,
                            1102,
                            1103,
                            1104,
                            1105,
                            1106,
                            1107,
                            1108,
                            1109,
                            1110,
                            1111,
                            1112,
                            1113,
                            1114,
                            1115,
                            1116
                        ],
                        "comments": [
                            "    // check for : (http: or https:",
                            "    url.remove(0, (index + 3)); // remove http:// or https://",
                            "    url.remove(0, index); // remove host part",
                            "    // get Authorization",
                            "        // auth info",
                            "        host.remove(0, index + 1); // remove auth part including @",
                            "    // get port",
                            "        _host = host.substring(0, index); // hostname",
                            "        host.remove(0, (index + 1)); // remove hostname + :",
                            "        _port = host.toInt(); // get port",
                            "    // connect to server",
                            "    // send Header",
                            "    // send Payload if needed",
                            "    // handle Server Response (Header)",
                            "    // connect to server",
                            "    // send Header",
                            "    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE",
                            "    // create buffer for read",
                            "        // read all data from stream and send it to server",
                            "            // get available data size",
                            "                // read only the asked bytes",
                            "                // not read more the buffer can handle",
                            "                // read data",
                            "                // write it to Stream",
                            "                // are all Bytes a writen to stream ?",
                            "                    // check for write error",
                            "                    // some time for the stream",
                            "                    // retry to send the missed bytes",
                            "                        // failed again",
                            "                // check for write error",
                            "                // count bytes to read left",
                            "    // handle Server Response (Header)",
                            "    // get length of document (is -1 when Server sends no Content-Length header)",
                            "        // have we an error?",
                            "            chunkHeader.trim(); // remove \\r",
                            "            // read size of chunk",
                            "            // data left?",
                            "                    // error in writeToStreamDataBlock",
                            "                // if no length Header use global chunk size",
                            "                // check if we have write all data out",
                            "            // read trailing \\r\\n at the end of the chunk",
                            "        // try to reserve needed memmory",
                            "    // not allow set of Header handled by code",
                            "    // set Timeout for readBytesUntil and readStringUntil",
                            "            headerLine.trim(); // remove \\r",
                            "    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE",
                            "    // create buffer for read",
                            "        // read all data from server",
                            "            // get available data size",
                            "                // read only the asked bytes",
                            "                // not read more the buffer can handle",
                            "                // read data",
                            "                // write it to Stream",
                            "                // are all Bytes a writen to stream ?",
                            "                    // check for write error",
                            "                    // some time for the stream",
                            "                    // retry to send the missed bytes",
                            "                        // failed again",
                            "                // check for write error",
                            "                // count bytes to read left"
                        ],
                        "lines": [
                            "    int index = url.indexOf(':');",
                            "    if(index < 0) {",
                            "        log_d(\"[HTTP-Client][begin] failed to parse protocol\");",
                            "        return false;",
                            "    }",
                            "",
                            "    _protocol = url.substring(0, index);",
                            "",
                            "    index = url.indexOf('/');",
                            "    String host = url.substring(0, index);",
                            "",
                            "    index = host.indexOf('@');",
                            "    if(index >= 0) {",
                            "        String auth = host.substring(0, index);",
                            "        _base64Authorization = base64::encode(auth);",
                            "    }",
                            "",
                            "    index = host.indexOf(':');",
                            "    if(index >= 0) {",
                            "    } else {",
                            "        _host = host;",
                            "    }",
                            "    _uri = url;",
                            "    if (_protocol != expectedProtocol) {",
                            "        log_d(\"[HTTP-Client][begin] unexpected protocol: %s, expected %s\", _protocol.c_str(), expectedProtocol);",
                            "        return false;",
                            "    }",
                            "    log_d(\"[HTTP-Client][begin] host: %s port: %d url: %s\", _host.c_str(), _port, _uri.c_str());",
                            "    return true;",
                            "}",
                            "",
                            "bool HTTPClient::begin(String host, uint16_t port, String uri)",
                            "{",
                            "    clear();",
                            "    _host = host;",
                            "    _port = port;",
                            "    _uri = uri;",
                            "    _transportTraits = TransportTraitsPtr(new TransportTraits());",
                            "    log_d(\"[HTTP-Client][begin] host: %s port: %d uri: %s\", host.c_str(), port, uri.c_str());",
                            "    return true;",
                            "}",
                            "",
                            "bool HTTPClient::begin(String host, uint16_t port, String uri, const char* CAcert)",
                            "{",
                            "    clear();",
                            "    _host = host;",
                            "    _port = port;",
                            "    _uri = uri;",
                            "",
                            "    if (strlen(CAcert) == 0) {",
                            "        return false;",
                            "    }",
                            "    _transportTraits = TransportTraitsPtr(new TLSTraits(CAcert));",
                            "    //log_d(\"[HTTP-Client][begin] host: %s port: %d url: %s httpsFingerprint: %s\", host.c_str(), port, uri.c_str(), httpsFingerprint.c_str());",
                            "    return true;",
                            "}",
                            "",
                            "/**",
                            " * end",
                            " * called after the payload is handled",
                            " */",
                            "void HTTPClient::end(void)",
                            "{",
                            "    if(connected()) {",
                            "        if(_tcp->available() > 0) {",
                            "            log_d(\"[HTTP-Client][end] still data in buffer (%d), clean up.\", _tcp->available());",
                            "            while(_tcp->available() > 0) {",
                            "                _tcp->read();",
                            "            }",
                            "        }",
                            "        if(_reuse && _canReuse) {",
                            "            log_d(\"[HTTP-Client][end] tcp keep open for reuse\");",
                            "        } else {",
                            "            log_d(\"[HTTP-Client][end] tcp stop\");",
                            "            _tcp->stop();",
                            "        }",
                            "    } else {",
                            "        log_d(\"[HTTP-Client][end] tcp is closed\");",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * connected",
                            " * @return connected status",
                            " */",
                            "bool HTTPClient::connected()",
                            "{",
                            "    if(_tcp) {",
                            "        return (_tcp->connected() || (_tcp->available() > 0));",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * try to reuse the connection to the server",
                            " * keep-alive",
                            " * @param reuse bool",
                            " */",
                            "void HTTPClient::setReuse(bool reuse)",
                            "{",
                            "    _reuse = reuse;",
                            "}",
                            "",
                            "/**",
                            " * set User Agent",
                            " * @param userAgent const char *",
                            " */",
                            "void HTTPClient::setUserAgent(const String& userAgent)",
                            "{",
                            "    _userAgent = userAgent;",
                            "}",
                            "",
                            "/**",
                            " * set the Authorizatio for the http request",
                            " * @param user const char *",
                            " * @param password const char *",
                            " */",
                            "void HTTPClient::setAuthorization(const char * user, const char * password)",
                            "{",
                            "    if(user && password) {",
                            "        String auth = user;",
                            "        auth += \":\";",
                            "        auth += password;",
                            "        _base64Authorization = base64::encode(auth);",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * set the Authorizatio for the http request",
                            " * @param auth const char * base64",
                            " */",
                            "void HTTPClient::setAuthorization(const char * auth)",
                            "{",
                            "    if(auth) {",
                            "        _base64Authorization = auth;",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * set the timeout for the TCP connection",
                            " * @param timeout unsigned int",
                            " */",
                            "void HTTPClient::setTimeout(uint16_t timeout)",
                            "{",
                            "    _tcpTimeout = timeout;",
                            "    if(connected()) {",
                            "        _tcp->setTimeout(timeout);",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * use HTTP1.0",
                            " * @param timeout",
                            " */",
                            "void HTTPClient::useHTTP10(bool useHTTP10)",
                            "{",
                            "    _useHTTP10 = useHTTP10;",
                            "}",
                            "",
                            "/**",
                            " * send a GET request",
                            " * @return http code",
                            " */",
                            "int HTTPClient::GET()",
                            "{",
                            "    return sendRequest(\"GET\");",
                            "}",
                            "",
                            "/**",
                            " * sends a post request to the server",
                            " * @param payload uint8_t *",
                            " * @param size size_t",
                            " * @return http code",
                            " */",
                            "int HTTPClient::POST(uint8_t * payload, size_t size)",
                            "{",
                            "    return sendRequest(\"POST\", payload, size);",
                            "}",
                            "",
                            "int HTTPClient::POST(String payload)",
                            "{",
                            "    return POST((uint8_t *) payload.c_str(), payload.length());",
                            "}",
                            "",
                            "/**",
                            " * sends a put request to the server",
                            " * @param payload uint8_t *",
                            " * @param size size_t",
                            " * @return http code",
                            " */",
                            "int HTTPClient::PUT(uint8_t * payload, size_t size) {",
                            "    return sendRequest(\"PUT\", payload, size);",
                            "}",
                            "",
                            "int HTTPClient::PUT(String payload) {",
                            "    return PUT((uint8_t *) payload.c_str(), payload.length());",
                            "}",
                            "",
                            "/**",
                            " * sendRequest",
                            " * @param type const char *     \"GET\", \"POST\", ....",
                            " * @param payload String        data for the message body",
                            " * @return",
                            " */",
                            "int HTTPClient::sendRequest(const char * type, String payload)",
                            "{",
                            "    return sendRequest(type, (uint8_t *) payload.c_str(), payload.length());",
                            "}",
                            "",
                            "/**",
                            " * sendRequest",
                            " * @param type const char *     \"GET\", \"POST\", ....",
                            " * @param payload uint8_t *     data for the message body if null not send",
                            " * @param size size_t           size for the message body if 0 not send",
                            " * @return -1 if no info or > 0 when Content-Length is set by server",
                            " */",
                            "int HTTPClient::sendRequest(const char * type, uint8_t * payload, size_t size)",
                            "{",
                            "    if(!connect()) {",
                            "        return returnError(HTTPC_ERROR_CONNECTION_REFUSED);",
                            "    }",
                            "",
                            "    if(payload && size > 0) {",
                            "        addHeader(F(\"Content-Length\"), String(size));",
                            "    }",
                            "",
                            "    if(!sendHeader(type)) {",
                            "        return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);",
                            "    }",
                            "",
                            "    if(payload && size > 0) {",
                            "        if(_tcp->write(&payload[0], size) != size) {",
                            "            return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);",
                            "        }",
                            "    }",
                            "",
                            "    return returnError(handleHeaderResponse());",
                            "}",
                            "",
                            "/**",
                            " * sendRequest",
                            " * @param type const char *     \"GET\", \"POST\", ....",
                            " * @param stream Stream *       data stream for the message body",
                            " * @param size size_t           size for the message body if 0 not Content-Length is send",
                            " * @return -1 if no info or > 0 when Content-Length is set by server",
                            " */",
                            "int HTTPClient::sendRequest(const char * type, Stream * stream, size_t size)",
                            "{",
                            "",
                            "    if(!stream) {",
                            "        return returnError(HTTPC_ERROR_NO_STREAM);",
                            "    }",
                            "",
                            "    if(!connect()) {",
                            "        return returnError(HTTPC_ERROR_CONNECTION_REFUSED);",
                            "    }",
                            "",
                            "    if(size > 0) {",
                            "        addHeader(\"Content-Length\", String(size));",
                            "    }",
                            "",
                            "    if(!sendHeader(type)) {",
                            "        return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);",
                            "    }",
                            "",
                            "    int buff_size = HTTP_TCP_BUFFER_SIZE;",
                            "",
                            "    int len = size;",
                            "    int bytesWritten = 0;",
                            "",
                            "    if(len == 0) {",
                            "        len = -1;",
                            "    }",
                            "",
                            "    if((len > 0) && (len < HTTP_TCP_BUFFER_SIZE)) {",
                            "        buff_size = len;",
                            "    }",
                            "",
                            "    uint8_t * buff = (uint8_t *) malloc(buff_size);",
                            "",
                            "    if(buff) {",
                            "        while(connected() && (stream->available() > -1) && (len > 0 || len == -1)) {",
                            "",
                            "            int sizeAvailable = stream->available();",
                            "",
                            "            if(sizeAvailable) {",
                            "",
                            "                int readBytes = sizeAvailable;",
                            "",
                            "                if(len > 0 && readBytes > len) {",
                            "                    readBytes = len;",
                            "                }",
                            "",
                            "                if(readBytes > buff_size) {",
                            "                    readBytes = buff_size;",
                            "                }",
                            "",
                            "                int bytesRead = stream->readBytes(buff, readBytes);",
                            "",
                            "                int bytesWrite = _tcp->write((const uint8_t *) buff, bytesRead);",
                            "                bytesWritten += bytesWrite;",
                            "",
                            "                if(bytesWrite != bytesRead) {",
                            "                    log_d(\"[HTTP-Client][sendRequest] short write, asked for %d but got %d retry...\", bytesRead, bytesWrite);",
                            "",
                            "                    if(_tcp->getWriteError()) {",
                            "                        log_d(\"[HTTP-Client][sendRequest] stream write error %d\", _tcp->getWriteError());",
                            "",
                            "                        //reset write error for retry",
                            "                        _tcp->clearWriteError();",
                            "                    }",
                            "",
                            "                    delay(1);",
                            "",
                            "                    int leftBytes = (readBytes - bytesWrite);",
                            "",
                            "                    bytesWrite = _tcp->write((const uint8_t *) (buff + bytesWrite), leftBytes);",
                            "                    bytesWritten += bytesWrite;",
                            "",
                            "                    if(bytesWrite != leftBytes) {",
                            "                        log_d(\"[HTTP-Client][sendRequest] short write, asked for %d but got %d failed.\", leftBytes, bytesWrite);",
                            "                        free(buff);",
                            "                        return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);",
                            "                    }",
                            "                }",
                            "",
                            "                if(_tcp->getWriteError()) {",
                            "                    log_d(\"[HTTP-Client][sendRequest] stream write error %d\", _tcp->getWriteError());",
                            "                    free(buff);",
                            "                    return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);",
                            "                }",
                            "",
                            "                if(len > 0) {",
                            "                    len -= readBytes;",
                            "                }",
                            "",
                            "                delay(0);",
                            "            } else {",
                            "                delay(1);",
                            "            }",
                            "        }",
                            "",
                            "        free(buff);",
                            "",
                            "        if(size && (int) size != bytesWritten) {",
                            "            log_d(\"[HTTP-Client][sendRequest] Stream payload bytesWritten %d and size %d mismatch!.\", bytesWritten, size);",
                            "            log_d(\"[HTTP-Client][sendRequest] ERROR SEND PAYLOAD FAILED!\");",
                            "            return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);",
                            "        } else {",
                            "            log_d(\"[HTTP-Client][sendRequest] Stream payload written: %d\", bytesWritten);",
                            "        }",
                            "",
                            "    } else {",
                            "        log_d(\"[HTTP-Client][sendRequest] too less ram! need %d\", HTTP_TCP_BUFFER_SIZE);",
                            "        return returnError(HTTPC_ERROR_TOO_LESS_RAM);",
                            "    }",
                            "",
                            "    return returnError(handleHeaderResponse());",
                            "}",
                            "",
                            "/**",
                            " * size of message body / payload",
                            " * @return -1 if no info or > 0 when Content-Length is set by server",
                            " */",
                            "int HTTPClient::getSize(void)",
                            "{",
                            "    return _size;",
                            "}",
                            "",
                            "/**",
                            " * returns the stream of the tcp connection",
                            " * @return WiFiClient",
                            " */",
                            "WiFiClient& HTTPClient::getStream(void)",
                            "{",
                            "    if(connected()) {",
                            "        return *_tcp;",
                            "    }",
                            "",
                            "    log_d(\"[HTTP-Client] getStream: not connected\");",
                            "    static WiFiClient empty;",
                            "    return empty;",
                            "}",
                            "",
                            "/**",
                            " * returns the stream of the tcp connection",
                            " * @return WiFiClient *",
                            " */",
                            "WiFiClient* HTTPClient::getStreamPtr(void)",
                            "{",
                            "    if(connected()) {",
                            "        return _tcp.get();",
                            "    }",
                            "",
                            "    log_d(\"[HTTP-Client] getStreamPtr: not connected\");",
                            "    return nullptr;",
                            "}",
                            "",
                            "/**",
                            " * write all  message body / payload to Stream",
                            " * @param stream Stream *",
                            " * @return bytes written ( negative values are error codes )",
                            " */",
                            "int HTTPClient::writeToStream(Stream * stream)",
                            "{",
                            "",
                            "    if(!stream) {",
                            "        return returnError(HTTPC_ERROR_NO_STREAM);",
                            "    }",
                            "",
                            "    if(!connected()) {",
                            "        return returnError(HTTPC_ERROR_NOT_CONNECTED);",
                            "    }",
                            "",
                            "    int len = _size;",
                            "    int ret = 0;",
                            "",
                            "    if(_transferEncoding == HTTPC_TE_IDENTITY) {",
                            "        ret = writeToStreamDataBlock(stream, len);",
                            "",
                            "        if(ret < 0) {",
                            "            return returnError(ret);",
                            "        }",
                            "    } else if(_transferEncoding == HTTPC_TE_CHUNKED) {",
                            "        int size = 0;",
                            "        while(1) {",
                            "            if(!connected()) {",
                            "                return returnError(HTTPC_ERROR_CONNECTION_LOST);",
                            "            }",
                            "            String chunkHeader = _tcp->readStringUntil('\\n');",
                            "",
                            "            if(chunkHeader.length() <= 0) {",
                            "                return returnError(HTTPC_ERROR_READ_TIMEOUT);",
                            "            }",
                            "",
                            "",
                            "            len = (uint32_t) strtol((const char *) chunkHeader.c_str(), NULL, 16);",
                            "            size += len;",
                            "            log_d(\"[HTTP-Client] read chunk len: %d\", len);",
                            "",
                            "            if(len > 0) {",
                            "                int r = writeToStreamDataBlock(stream, len);",
                            "                if(r < 0) {",
                            "                    return returnError(r);",
                            "                }",
                            "                ret += r;",
                            "            } else {",
                            "",
                            "                if(_size <= 0) {",
                            "                    _size = size;",
                            "                }",
                            "",
                            "                if(ret != _size) {",
                            "                    return returnError(HTTPC_ERROR_STREAM_WRITE);",
                            "                }",
                            "                break;",
                            "            }",
                            "",
                            "            char buf[2];",
                            "            auto trailing_seq_len = _tcp->readBytes((uint8_t*)buf, 2);",
                            "            if (trailing_seq_len != 2 || buf[0] != '\\r' || buf[1] != '\\n') {",
                            "                return returnError(HTTPC_ERROR_READ_TIMEOUT);",
                            "            }",
                            "",
                            "            delay(0);",
                            "        }",
                            "    } else {",
                            "        return returnError(HTTPC_ERROR_ENCODING);",
                            "    }",
                            "",
                            "    end();",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * return all payload as String (may need lot of ram or trigger out of memory!)",
                            " * @return String",
                            " */",
                            "String HTTPClient::getString(void)",
                            "{",
                            "    StreamString sstring;",
                            "",
                            "    if(_size) {",
                            "        if(!sstring.reserve((_size + 1))) {",
                            "            log_d(\"[HTTP-Client][getString] not enough memory to reserve a string! need: %d\", (_size + 1));",
                            "            return \"\";",
                            "        }",
                            "    }",
                            "",
                            "    writeToStream(&sstring);",
                            "    return sstring;",
                            "}",
                            "",
                            "/**",
                            " * converts error code to String",
                            " * @param error int",
                            " * @return String",
                            " */",
                            "String HTTPClient::errorToString(int error)",
                            "{",
                            "    switch(error) {",
                            "    case HTTPC_ERROR_CONNECTION_REFUSED:",
                            "        return F(\"connection refused\");",
                            "    case HTTPC_ERROR_SEND_HEADER_FAILED:",
                            "        return F(\"send header failed\");",
                            "    case HTTPC_ERROR_SEND_PAYLOAD_FAILED:",
                            "        return F(\"send payload failed\");",
                            "    case HTTPC_ERROR_NOT_CONNECTED:",
                            "        return F(\"not connected\");",
                            "    case HTTPC_ERROR_CONNECTION_LOST:",
                            "        return F(\"connection lost\");",
                            "    case HTTPC_ERROR_NO_STREAM:",
                            "        return F(\"no stream\");",
                            "    case HTTPC_ERROR_NO_HTTP_SERVER:",
                            "        return F(\"no HTTP server\");",
                            "    case HTTPC_ERROR_TOO_LESS_RAM:",
                            "        return F(\"too less ram\");",
                            "    case HTTPC_ERROR_ENCODING:",
                            "        return F(\"Transfer-Encoding not supported\");",
                            "    case HTTPC_ERROR_STREAM_WRITE:",
                            "        return F(\"Stream write error\");",
                            "    case HTTPC_ERROR_READ_TIMEOUT:",
                            "        return F(\"read Timeout\");",
                            "    default:",
                            "        return String();",
                            "    }",
                            "}",
                            "",
                            "/**",
                            " * adds Header to the request",
                            " * @param name",
                            " * @param value",
                            " * @param first",
                            " */",
                            "void HTTPClient::addHeader(const String& name, const String& value, bool first, bool replace)",
                            "{",
                            "    if(!name.equalsIgnoreCase(F(\"Connection\")) &&",
                            "       !name.equalsIgnoreCase(F(\"User-Agent\")) &&",
                            "       !name.equalsIgnoreCase(F(\"Host\")) &&",
                            "       !(name.equalsIgnoreCase(F(\"Authorization\")) && _base64Authorization.length())){",
                            "",
                            "        String headerLine = name;",
                            "        headerLine += \": \";",
                            "",
                            "        if (replace) {",
                            "            int headerStart = _headers.indexOf(headerLine);",
                            "            if (headerStart != -1) {",
                            "                int headerEnd = _headers.indexOf('\\n', headerStart);",
                            "                _headers = _headers.substring(0, headerStart) + _headers.substring(headerEnd + 1);",
                            "            }",
                            "        }",
                            "",
                            "        headerLine += value;",
                            "        headerLine += \"\\r\\n\";",
                            "        if(first) {",
                            "            _headers = headerLine + _headers;",
                            "        } else {",
                            "            _headers += headerLine;",
                            "        }",
                            "    }",
                            "",
                            "}",
                            "",
                            "void HTTPClient::collectHeaders(const char* headerKeys[], const size_t headerKeysCount)",
                            "{",
                            "    _headerKeysCount = headerKeysCount;",
                            "    if(_currentHeaders) {",
                            "        delete[] _currentHeaders;",
                            "    }",
                            "    _currentHeaders = new RequestArgument[_headerKeysCount];",
                            "    for(size_t i = 0; i < _headerKeysCount; i++) {",
                            "        _currentHeaders[i].key = headerKeys[i];",
                            "    }",
                            "}",
                            "",
                            "String HTTPClient::header(const char* name)",
                            "{",
                            "    for(size_t i = 0; i < _headerKeysCount; ++i) {",
                            "        if(_currentHeaders[i].key == name) {",
                            "            return _currentHeaders[i].value;",
                            "        }",
                            "    }",
                            "    return String();",
                            "}",
                            "",
                            "String HTTPClient::header(size_t i)",
                            "{",
                            "    if(i < _headerKeysCount) {",
                            "        return _currentHeaders[i].value;",
                            "    }",
                            "    return String();",
                            "}",
                            "",
                            "String HTTPClient::headerName(size_t i)",
                            "{",
                            "    if(i < _headerKeysCount) {",
                            "        return _currentHeaders[i].key;",
                            "    }",
                            "    return String();",
                            "}",
                            "",
                            "int HTTPClient::headers()",
                            "{",
                            "    return _headerKeysCount;",
                            "}",
                            "",
                            "bool HTTPClient::hasHeader(const char* name)",
                            "{",
                            "    for(size_t i = 0; i < _headerKeysCount; ++i) {",
                            "        if((_currentHeaders[i].key == name) && (_currentHeaders[i].value.length() > 0)) {",
                            "            return true;",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "/**",
                            " * init TCP connection and handle ssl verify if needed",
                            " * @return true if connection is ok",
                            " */",
                            "bool HTTPClient::connect(void)",
                            "{",
                            "",
                            "    if(connected()) {",
                            "        log_d(\"[HTTP-Client] connect. already connected, try reuse!\");",
                            "        while(_tcp->available() > 0) {",
                            "            _tcp->read();",
                            "        }",
                            "        return true;",
                            "    }",
                            "",
                            "    if (!_transportTraits) {",
                            "        log_d(\"[HTTP-Client] connect: HTTPClient::begin was not called or returned error\");",
                            "        return false;",
                            "    }",
                            "",
                            "    _tcp = _transportTraits->create();",
                            "",
                            "",
                            "    if (!_transportTraits->verify(*_tcp, _host.c_str())) {",
                            "        log_d(\"[HTTP-Client] transport level verify failed\");",
                            "        _tcp->stop();",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!_tcp->connect(_host.c_str(), _port)) {",
                            "        log_d(\"[HTTP-Client] failed connect to %s:%u\", _host.c_str(), _port);",
                            "        return false;",
                            "    }",
                            "",
                            "    log_d(\"[HTTP-Client] connected to %s:%u\", _host.c_str(), _port);",
                            "",
                            "    _tcp->setTimeout(_tcpTimeout);",
                            "/*",
                            "#ifdef ESP8266",
                            "    _tcp->setNoDelay(true);",
                            "#endif",
                            " */",
                            " return connected();",
                            "}",
                            "",
                            "/**",
                            " * sends HTTP request header",
                            " * @param type (GET, POST, ...)",
                            " * @return status",
                            " */",
                            "bool HTTPClient::sendHeader(const char * type)",
                            "{",
                            "    if(!connected()) {",
                            "        return false;",
                            "    }",
                            "",
                            "    String header = String(type) + \" \" + _uri + F(\" HTTP/1.\");",
                            "",
                            "    if(_useHTTP10) {",
                            "        header += \"0\";",
                            "    } else {",
                            "        header += \"1\";",
                            "    }",
                            "",
                            "    header += String(F(\"\\r\\nHost: \")) + _host;",
                            "    if (_port != 80 && _port != 443)",
                            "    {",
                            "        header += ':';",
                            "        header += String(_port);",
                            "    }",
                            "    header += String(F(\"\\r\\nUser-Agent: \")) + _userAgent +",
                            "              F(\"\\r\\nConnection: \");",
                            "",
                            "    if(_reuse) {",
                            "        header += F(\"keep-alive\");",
                            "    } else {",
                            "        header += F(\"close\");",
                            "    }",
                            "    header += \"\\r\\n\";",
                            "",
                            "    if(!_useHTTP10) {",
                            "        header += F(\"Accept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\\r\\n\");",
                            "    }",
                            "",
                            "    if(_base64Authorization.length()) {",
                            "        _base64Authorization.replace(\"\\n\", \"\");",
                            "        header += F(\"Authorization: Basic \");",
                            "        header += _base64Authorization;",
                            "        header += \"\\r\\n\";",
                            "    }",
                            "",
                            "    header += _headers + \"\\r\\n\";",
                            "",
                            "    return (_tcp->write((const uint8_t *) header.c_str(), header.length()) == header.length());",
                            "}",
                            "",
                            "/**",
                            " * reads the response from the server",
                            " * @return int http code",
                            " */",
                            "int HTTPClient::handleHeaderResponse()",
                            "{",
                            "",
                            "    if(!connected()) {",
                            "        return HTTPC_ERROR_NOT_CONNECTED;",
                            "    }",
                            "",
                            "    String transferEncoding;",
                            "    _returnCode = -1;",
                            "    _size = -1;",
                            "    _transferEncoding = HTTPC_TE_IDENTITY;",
                            "    unsigned long lastDataTime = millis();",
                            "",
                            "    while(connected()) {",
                            "        size_t len = _tcp->available();",
                            "        if(len > 0) {",
                            "            String headerLine = _tcp->readStringUntil('\\n');",
                            "",
                            "            lastDataTime = millis();",
                            "",
                            "            log_d(\"[HTTP-Client][handleHeaderResponse] RX: '%s'\", headerLine.c_str());",
                            "",
                            "            if(headerLine.startsWith(\"HTTP/1.\")) {",
                            "                _returnCode = headerLine.substring(9, headerLine.indexOf(' ', 9)).toInt();",
                            "            } else if(headerLine.indexOf(':')) {",
                            "                String headerName = headerLine.substring(0, headerLine.indexOf(':'));",
                            "                String headerValue = headerLine.substring(headerLine.indexOf(':') + 1);",
                            "                headerValue.trim();",
                            "",
                            "                if(headerName.equalsIgnoreCase(\"Content-Length\")) {",
                            "                    _size = headerValue.toInt();",
                            "                }",
                            "",
                            "                if(headerName.equalsIgnoreCase(\"Connection\")) {",
                            "                    _canReuse = headerValue.equalsIgnoreCase(\"keep-alive\");",
                            "                }",
                            "",
                            "                if(headerName.equalsIgnoreCase(\"Transfer-Encoding\")) {",
                            "                    transferEncoding = headerValue;",
                            "                }",
                            "",
                            "                for(size_t i = 0; i < _headerKeysCount; i++) {",
                            "                    if(_currentHeaders[i].key.equalsIgnoreCase(headerName)) {",
                            "                        _currentHeaders[i].value = headerValue;",
                            "                        break;",
                            "                    }",
                            "                }",
                            "            }",
                            "",
                            "            if(headerLine == \"\") {",
                            "                log_d(\"[HTTP-Client][handleHeaderResponse] code: %d\", _returnCode);",
                            "",
                            "                if(_size > 0) {",
                            "                    log_d(\"[HTTP-Client][handleHeaderResponse] size: %d\", _size);",
                            "                }",
                            "",
                            "                if(transferEncoding.length() > 0) {",
                            "                    log_d(\"[HTTP-Client][handleHeaderResponse] Transfer-Encoding: %s\", transferEncoding.c_str());",
                            "                    if(transferEncoding.equalsIgnoreCase(\"chunked\")) {",
                            "                        _transferEncoding = HTTPC_TE_CHUNKED;",
                            "                    } else {",
                            "                        return HTTPC_ERROR_ENCODING;",
                            "                    }",
                            "                } else {",
                            "                    _transferEncoding = HTTPC_TE_IDENTITY;",
                            "                }",
                            "",
                            "                if(_returnCode) {",
                            "                    return _returnCode;",
                            "                } else {",
                            "                    log_d(\"[HTTP-Client][handleHeaderResponse] Remote host is not an HTTP Server!\");",
                            "                    return HTTPC_ERROR_NO_HTTP_SERVER;",
                            "                }",
                            "            }",
                            "",
                            "        } else {",
                            "            if((millis() - lastDataTime) > _tcpTimeout) {",
                            "                return HTTPC_ERROR_READ_TIMEOUT;",
                            "            }",
                            "            delay(0);",
                            "        }",
                            "    }",
                            "",
                            "    return HTTPC_ERROR_CONNECTION_LOST;",
                            "}",
                            "",
                            "/**",
                            " * write one Data Block to Stream",
                            " * @param stream Stream *",
                            " * @param size int",
                            " * @return < 0 = error >= 0 = size written",
                            " */",
                            "int HTTPClient::writeToStreamDataBlock(Stream * stream, int size)",
                            "{",
                            "    int buff_size = HTTP_TCP_BUFFER_SIZE;",
                            "    int len = size;",
                            "    int bytesWritten = 0;",
                            "",
                            "    if((len > 0) && (len < HTTP_TCP_BUFFER_SIZE)) {",
                            "        buff_size = len;",
                            "    }",
                            "",
                            "    uint8_t * buff = (uint8_t *) malloc(buff_size);",
                            "",
                            "    if(buff) {",
                            "        while(connected() && (len > 0 || len == -1)) {",
                            "",
                            "            size_t sizeAvailable = _tcp->available();",
                            "",
                            "            if(sizeAvailable) {",
                            "",
                            "                int readBytes = sizeAvailable;",
                            "",
                            "                if(len > 0 && readBytes > len) {",
                            "                    readBytes = len;",
                            "                }",
                            "",
                            "                if(readBytes > buff_size) {",
                            "                    readBytes = buff_size;",
                            "                }",
                            "",
                            "                int bytesRead = _tcp->readBytes(buff, readBytes);",
                            "",
                            "                int bytesWrite = stream->write(buff, bytesRead);",
                            "                bytesWritten += bytesWrite;",
                            "",
                            "                if(bytesWrite != bytesRead) {",
                            "                    log_d(\"[HTTP-Client][writeToStream] short write asked for %d but got %d retry...\", bytesRead, bytesWrite);",
                            "",
                            "                    if(stream->getWriteError()) {",
                            "                        log_d(\"[HTTP-Client][writeToStreamDataBlock] stream write error %d\", stream->getWriteError());",
                            "",
                            "                        //reset write error for retry",
                            "                        stream->clearWriteError();",
                            "                    }",
                            "",
                            "                    delay(1);",
                            "",
                            "                    int leftBytes = (readBytes - bytesWrite);",
                            "",
                            "                    bytesWrite = stream->write((buff + bytesWrite), leftBytes);",
                            "                    bytesWritten += bytesWrite;",
                            "",
                            "                    if(bytesWrite != leftBytes) {",
                            "                        log_d(\"[HTTP-Client][writeToStream] short write asked for %d but got %d failed.\", leftBytes, bytesWrite);",
                            "                        free(buff);",
                            "                        return HTTPC_ERROR_STREAM_WRITE;",
                            "                    }",
                            "                }",
                            "",
                            "                if(stream->getWriteError()) {",
                            "                    log_d(\"[HTTP-Client][writeToStreamDataBlock] stream write error %d\", stream->getWriteError());",
                            "                    free(buff);",
                            "                    return HTTPC_ERROR_STREAM_WRITE;",
                            "                }",
                            "",
                            "                if(len > 0) {",
                            "                    len -= readBytes;",
                            "                }",
                            "",
                            "                delay(0);",
                            "            } else {",
                            "                delay(1);",
                            "            }",
                            "        }",
                            "",
                            "        free(buff);",
                            "",
                            "        log_d(\"[HTTP-Client][writeToStreamDataBlock] connection closed or file end (written: %d).\", bytesWritten);",
                            "",
                            "        if((size > 0) && (size != bytesWritten)) {",
                            "            log_d(\"[HTTP-Client][writeToStreamDataBlock] bytesWritten %d and size %d mismatch!.\", bytesWritten, size);",
                            "            return HTTPC_ERROR_STREAM_WRITE;",
                            "        }",
                            "",
                            "    } else {",
                            "        log_d(\"[HTTP-Client][writeToStreamDataBlock] too less ram! need %d\", HTTP_TCP_BUFFER_SIZE);",
                            "        return HTTPC_ERROR_TOO_LESS_RAM;",
                            "    }",
                            "",
                            "    return bytesWritten;",
                            "}",
                            "",
                            "/**",
                            " * called to handle error return, may disconnect the connection if still exists",
                            " * @param error",
                            " * @return error",
                            " */",
                            "int HTTPClient::returnError(int error)",
                            "{",
                            "    if(error < 0) {",
                            "        log_d(\"[HTTP-Client][returnError] error(%d): %s\", error, errorToString(error).c_str());",
                            "        if(connected()) {",
                            "            log_d(\"[HTTP-Client][returnError] tcp stop\");",
                            "            _tcp->stop();",
                            "        }",
                            "    }",
                            "    return error;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "142": "    // check for : (http: or https:",
                "150": "    url.remove(0, (index + 3)); // remove http:// or https://",
                "154": "    url.remove(0, index); // remove host part",
                "156": "    // get Authorization",
                "159": "        // auth info",
                "161": "        host.remove(0, index + 1); // remove auth part including @",
                "165": "    // get port",
                "168": "        _host = host.substring(0, index); // hostname",
                "169": "        host.remove(0, (index + 1)); // remove hostname + :",
                "170": "        _port = host.toInt(); // get port",
                "370": "    // connect to server",
                "379": "    // send Header",
                "384": "    // send Payload if needed",
                "391": "    // handle Server Response (Header)",
                "409": "    // connect to server",
                "418": "    // send Header",
                "432": "    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE",
                "437": "    // create buffer for read",
                "441": "        // read all data from stream and send it to server",
                "444": "            // get available data size",
                "451": "                // read only the asked bytes",
                "456": "                // not read more the buffer can handle",
                "461": "                // read data",
                "464": "                // write it to Stream",
                "468": "                // are all Bytes a writen to stream ?",
                "472": "                    // check for write error",
                "480": "                    // some time for the stream",
                "485": "                    // retry to send the missed bytes",
                "490": "                        // failed again",
                "497": "                // check for write error",
                "504": "                // count bytes to read left",
                "530": "    // handle Server Response (Header)",
                "588": "    // get length of document (is -1 when Server sends no Content-Length header)",
                "595": "        // have we an error?",
                "611": "            chunkHeader.trim(); // remove \\r",
                "613": "            // read size of chunk",
                "618": "            // data left?",
                "622": "                    // error in writeToStreamDataBlock",
                "628": "                // if no length Header use global chunk size",
                "633": "                // check if we have write all data out",
                "640": "            // read trailing \\r\\n at the end of the chunk",
                "666": "        // try to reserve needed memmory",
                "720": "    // not allow set of Header handled by code",
                "837": "    // set Timeout for readBytesUntil and readStringUntil",
                "919": "            headerLine.trim(); // remove \\r",
                "1001": "    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE",
                "1006": "    // create buffer for read",
                "1010": "        // read all data from server",
                "1013": "            // get available data size",
                "1020": "                // read only the asked bytes",
                "1025": "                // not read more the buffer can handle",
                "1030": "                // read data",
                "1033": "                // write it to Stream",
                "1037": "                // are all Bytes a writen to stream ?",
                "1041": "                    // check for write error",
                "1049": "                    // some time for the stream",
                "1054": "                    // retry to send the missed bytes",
                "1059": "                        // failed again",
                "1066": "                // check for write error",
                "1073": "                // count bytes to read left"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d22c8807cf9186e242c7c64198d67e88939db9",
            "timestamp": "2018-11-19T16:57:23+01:00",
            "author": "Jeroen88",
            "commit_message": "Feature/http client (#1973)\n\n* Pass client parameter into two new begin() functions. Set other begin() functions deprecated. Updated library version to 1.2\r\n\r\n* Added working HTTPS example on a public url with a certificate\r\n\r\n* Remove two unnecessary tests in ::disconnect()\r\n\r\n* Add a scoping block to BasicHttpsClient.ino to assure HTTPClient is destroyed before WiFiClientSecure\r\n\r\n* Added check to handle mixup of old and present api properly\r\n\r\n* Correct HTTPClient::setTimeout() to convert milliseconds to seconds. Correct WiFiClient::setTimeout() to call Stream::setTimeout() with seconds converted back to milliseconds. Remove inproper checks for _insecure.\r\n\r\n* Added small comment because it looked like the Travis build did not finish",
            "additions": 183,
            "deletions": 49,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            87
                        ],
                        "comments": [
                            "#endif // HTTPCLIENT_1_1_COMPATIBLE"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            101,
                            102
                        ],
                        "comments": [],
                        "lines": [
                            "    if(_client) {",
                            "        _client->stop();"
                        ]
                    },
                    {
                        "line_numbers": [
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183
                        ],
                        "comments": [
                            "    // check for : (http: or https:)"
                        ],
                        "lines": [
                            "/**",
                            " * parsing the url for all needed parameters",
                            " * @param client Client&",
                            " * @param url String",
                            " * @param https bool",
                            " * @return success bool",
                            " */",
                            "bool HTTPClient::begin(WiFiClient &client, String url) {",
                            "#ifdef HTTPCLIENT_1_1_COMPATIBLE",
                            "    if(_tcpDeprecated) {",
                            "        log_d(\"mix up of new and deprecated api\");",
                            "        _canReuse = false;",
                            "        end();",
                            "    }",
                            "#endif",
                            "",
                            "    _client = &client;",
                            "",
                            "    int index = url.indexOf(':');",
                            "    if(index < 0) {",
                            "        log_d(\"failed to parse protocol\");",
                            "        return false;",
                            "    }",
                            "",
                            "    String protocol = url.substring(0, index);",
                            "    if(protocol != \"http\" && protocol != \"https\") {",
                            "        log_d(\"unknown protocol '%s'\", protocol.c_str());",
                            "        return false;",
                            "    }",
                            "",
                            "    _port = (protocol == \"https\" ? 443 : 80);",
                            "    return beginInternal(url, protocol.c_str());",
                            "}",
                            "",
                            "",
                            "/**",
                            " * directly supply all needed parameters",
                            " * @param client Client&",
                            " * @param host String",
                            " * @param port uint16_t",
                            " * @param uri String",
                            " * @param https bool",
                            " * @return success bool",
                            " */",
                            "bool HTTPClient::begin(WiFiClient &client, String host, uint16_t port, String uri, bool https)",
                            "{",
                            "#ifdef HTTPCLIENT_1_1_COMPATIBLE",
                            "    if(_tcpDeprecated) {",
                            "        log_d(\"mix up of new and deprecated api\");",
                            "        _canReuse = false;",
                            "        end();",
                            "    }",
                            "#endif",
                            "",
                            "    _client = &client;",
                            "",
                            "     clear();",
                            "    _host = host;",
                            "    _port = port;",
                            "    _uri = uri;",
                            "    _protocol = (https ? \"https\" : \"http\");",
                            "    return true;",
                            "}",
                            "",
                            "",
                            "#ifdef HTTPCLIENT_1_1_COMPATIBLE"
                        ]
                    },
                    {
                        "line_numbers": [
                            186,
                            187,
                            188,
                            189,
                            190,
                            191
                        ],
                        "comments": [],
                        "lines": [
                            "    if(_client && !_tcpDeprecated) {",
                            "        log_d(\"mix up of new and deprecated api\");",
                            "        _canReuse = false;",
                            "        end();",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            207,
                            208,
                            209,
                            210,
                            211
                        ],
                        "comments": [],
                        "lines": [
                            "    if(_client && !_tcpDeprecated) {",
                            "        log_d(\"mix up of new and deprecated api\");",
                            "        _canReuse = false;",
                            "        end();",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            269
                        ],
                        "comments": [],
                        "lines": [
                            "#ifdef HTTPCLIENT_1_1_COMPATIBLE"
                        ]
                    },
                    {
                        "line_numbers": [
                            272,
                            273,
                            274,
                            275,
                            276,
                            277
                        ],
                        "comments": [],
                        "lines": [
                            "    if(_client && !_tcpDeprecated) {",
                            "        log_d(\"mix up of new and deprecated api\");",
                            "        _canReuse = false;",
                            "        end();",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            289,
                            290,
                            291,
                            292,
                            293,
                            294
                        ],
                        "comments": [],
                        "lines": [
                            "    if(_client && !_tcpDeprecated) {",
                            "        log_d(\"mix up of new and deprecated api\");",
                            "        _canReuse = false;",
                            "        end();",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            310,
                            311,
                            312,
                            313,
                            314,
                            315
                        ],
                        "comments": [],
                        "lines": [
                            "    if(_client && !_tcpDeprecated) {",
                            "        log_d(\"mix up of new and deprecated api\");",
                            "        _canReuse = false;",
                            "        end();",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345
                        ],
                        "comments": [],
                        "lines": [
                            "{",
                            "    disconnect();",
                            "}",
                            "",
                            "",
                            "",
                            "/**",
                            " * disconnect",
                            " * close the TCP socket",
                            " */",
                            "void HTTPClient::disconnect()"
                        ]
                    },
                    {
                        "line_numbers": [
                            348,
                            349,
                            350,
                            351,
                            352
                        ],
                        "comments": [],
                        "lines": [
                            "        if(_client->available() > 0) {",
                            "            log_d(\"still data in buffer (%d), clean up.\\n\", _client->available());",
                            "            while(_client->available() > 0) {",
                            "                _client->read();",
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            354
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            356
                        ],
                        "comments": [],
                        "lines": [
                            "            log_d(\"tcp keep open for reuse\\n\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366
                        ],
                        "comments": [],
                        "lines": [
                            "            log_d(\"tcp stop\\n\");",
                            "            _client->stop();",
                            "            _client = nullptr;",
                            "#ifdef HTTPCLIENT_1_1_COMPATIBLE",
                            "            if(_tcpDeprecated) {",
                            "                _transportTraits.reset(nullptr);",
                            "                _tcpDeprecated.reset(nullptr);",
                            "            }",
                            "#endif"
                        ]
                    },
                    {
                        "line_numbers": [
                            369
                        ],
                        "comments": [],
                        "lines": [
                            "        log_d(\"tcp is closed\\n\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            373
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            380,
                            381
                        ],
                        "comments": [],
                        "lines": [
                            "    if(_client) {",
                            "        return ((_client->available() > 0) || _client->connected());"
                        ]
                    },
                    {
                        "line_numbers": [
                            438,
                            439
                        ],
                        "comments": [],
                        "lines": [
                            "    if(connected()) {",
                            "        _client->setTimeout((timeout + 500) / 1000);"
                        ]
                    },
                    {
                        "line_numbers": [
                            527
                        ],
                        "comments": [],
                        "lines": [
                            "        if(_client->write(&payload[0], size) != size) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            606
                        ],
                        "comments": [],
                        "lines": [
                            "                int bytesWrite = _client->write((const uint8_t *) buff, bytesRead);"
                        ]
                    },
                    {
                        "line_numbers": [
                            614,
                            615
                        ],
                        "comments": [],
                        "lines": [
                            "                    if(_client->getWriteError()) {",
                            "                        log_d(\"stream write error %d\", _client->getWriteError());"
                        ]
                    },
                    {
                        "line_numbers": [
                            618
                        ],
                        "comments": [],
                        "lines": [
                            "                        _client->clearWriteError();"
                        ]
                    },
                    {
                        "line_numbers": [
                            627
                        ],
                        "comments": [],
                        "lines": [
                            "                    bytesWrite = _client->write((const uint8_t *) (buff + bytesWrite), leftBytes);"
                        ]
                    },
                    {
                        "line_numbers": [
                            639,
                            640
                        ],
                        "comments": [],
                        "lines": [
                            "                if(_client->getWriteError()) {",
                            "                    log_d(\"stream write error %d\", _client->getWriteError());"
                        ]
                    },
                    {
                        "line_numbers": [
                            690,
                            691
                        ],
                        "comments": [],
                        "lines": [
                            "    if (connected()) {",
                            "        return *_client;"
                        ]
                    },
                    {
                        "line_numbers": [
                            706
                        ],
                        "comments": [],
                        "lines": [
                            "        return _client;"
                        ]
                    },
                    {
                        "line_numbers": [
                            746
                        ],
                        "comments": [],
                        "lines": [
                            "            String chunkHeader = _client->readStringUntil('\\n');"
                        ]
                    },
                    {
                        "line_numbers": [
                            783
                        ],
                        "comments": [],
                        "lines": [
                            "            auto trailing_seq_len = _client->readBytes((uint8_t*)buf, 2);"
                        ]
                    },
                    {
                        "line_numbers": [
                            951,
                            952
                        ],
                        "comments": [],
                        "lines": [
                            "        while(_client->available() > 0) {",
                            "            _client->read();"
                        ]
                    },
                    {
                        "line_numbers": [
                            957,
                            958,
                            959,
                            960,
                            961,
                            962,
                            963,
                            964
                        ],
                        "comments": [],
                        "lines": [
                            "#ifdef HTTPCLIENT_1_1_COMPATIBLE",
                            "     if(!_client) {",
                            "        _tcpDeprecated = _transportTraits->create();",
                            "        _client = _tcpDeprecated.get();",
                            "     }",
                            "#endif",
                            "",
                            "    if (!_client) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            970
                        ],
                        "comments": [],
                        "lines": [
                            "    _client->setTimeout((_tcpTimeout + 500) / 1000);"
                        ]
                    },
                    {
                        "line_numbers": [
                            972
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!_client->connect(_host.c_str(), _port)) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            979,
                            980,
                            981,
                            982,
                            983,
                            984,
                            985,
                            986,
                            987
                        ],
                        "comments": [],
                        "lines": [
                            "#ifdef HTTPCLIENT_1_1_COMPATIBLE",
                            "    if (_tcpDeprecated && !_transportTraits->verify(*_client, _host.c_str())) {",
                            "        log_d(\"transport level verify failed\");",
                            "        _client->stop();",
                            "        return false;",
                            "    }",
                            "#endif",
                            "",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            990
                        ],
                        "comments": [],
                        "lines": [
                            "    _client->setNoDelay(true);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1044
                        ],
                        "comments": [],
                        "lines": [
                            "    return (_client->write((const uint8_t *) header.c_str(), header.length()) == header.length());"
                        ]
                    },
                    {
                        "line_numbers": [
                            1065
                        ],
                        "comments": [],
                        "lines": [
                            "        size_t len = _client->available();"
                        ]
                    },
                    {
                        "line_numbers": [
                            1067
                        ],
                        "comments": [],
                        "lines": [
                            "            String headerLine = _client->readStringUntil('\\n');"
                        ]
                    },
                    {
                        "line_numbers": [
                            1163
                        ],
                        "comments": [],
                        "lines": [
                            "            size_t sizeAvailable = _client->available();"
                        ]
                    },
                    {
                        "line_numbers": [
                            1180
                        ],
                        "comments": [],
                        "lines": [
                            "                int bytesRead = _client->readBytes(buff, readBytes);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1261
                        ],
                        "comments": [],
                        "lines": [
                            "            _client->stop();"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            852,
                            853
                        ],
                        "comments": [
                            "    // set Timeout for readBytesUntil and readStringUntil"
                        ],
                        "lines": [
                            "    setTimeout(_tcpTimeout);"
                        ]
                    },
                    {
                        "line_numbers": [
                            856
                        ],
                        "comments": [],
                        "lines": [
                            "    _tcp->setNoDelay(true);"
                        ]
                    },
                    {
                        "line_numbers": [
                            910
                        ],
                        "comments": [],
                        "lines": [
                            "    return (_tcp->write((const uint8_t *) header.c_str(), header.length()) == header.length());"
                        ]
                    },
                    {
                        "line_numbers": [
                            931
                        ],
                        "comments": [],
                        "lines": [
                            "        size_t len = _tcp->available();"
                        ]
                    },
                    {
                        "line_numbers": [
                            933
                        ],
                        "comments": [],
                        "lines": [
                            "            String headerLine = _tcp->readStringUntil('\\n');"
                        ]
                    },
                    {
                        "line_numbers": [
                            1029
                        ],
                        "comments": [],
                        "lines": [
                            "            size_t sizeAvailable = _tcp->available();"
                        ]
                    },
                    {
                        "line_numbers": [
                            1046
                        ],
                        "comments": [],
                        "lines": [
                            "                int bytesRead = _tcp->readBytes(buff, readBytes);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1127
                        ],
                        "comments": [],
                        "lines": [
                            "            _tcp->stop();"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "87": "#endif // HTTPCLIENT_1_1_COMPATIBLE",
                "135": "    // check for : (http: or https:)",
                "220": "#endif // HTTPCLIENT_1_1_COMPATIBLE",
                "328": "#endif // HTTPCLIENT_1_1_COMPATIBLE",
                "969": "    // set Timeout for WiFiClient and for Stream::readBytesUntil() and Stream::readStringUntil()"
            },
            "comment_deleted_diff": {
                "852": "    // set Timeout for readBytesUntil and readStringUntil"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "7b811f9b3ad2200143f27b9a3cc5d8ba4131f041",
            "timestamp": "2018-11-19T16:59:14+01:00",
            "author": "FotoFieber",
            "commit_message": "leave possible endless loop (#1986)",
            "additions": 4,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1179,
                            1180,
                            1181
                        ],
                        "comments": [
                            "\t\t// stop if no more reading"
                        ],
                        "lines": [
                            "\t\tif (readBytes == 0)",
                            "\t\t\tbreak;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1179": "\t\t// stop if no more reading"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "0de0d3f79a71d5d5ab8a34d5cba90680e7d29036",
            "timestamp": "2018-12-18T19:21:36+01:00",
            "author": "atanisoft",
            "commit_message": "move call to setTimeout() to after the client connects. (#2214)\n\nThis is necessary to avoid this log entry from being generated due to invalid usage of setTimeout:\r\n[E][WiFiClient.cpp:236] setSocketOption(): 1006 : 9",
            "additions": 3,
            "deletions": 3,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            974,
                            975,
                            976
                        ],
                        "comments": [
                            "    // set Timeout for WiFiClient and for Stream::readBytesUntil() and Stream::readStringUntil()"
                        ],
                        "lines": [
                            "    _client->setTimeout((_tcpTimeout + 500) / 1000);",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            969,
                            970,
                            971
                        ],
                        "comments": [
                            "    // set Timeout for WiFiClient and for Stream::readBytesUntil() and Stream::readStringUntil()"
                        ],
                        "lines": [
                            "    _client->setTimeout((_tcpTimeout + 500) / 1000);",
                            ""
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "974": "    // set Timeout for WiFiClient and for Stream::readBytesUntil() and Stream::readStringUntil()"
            },
            "comment_deleted_diff": {
                "969": "    // set Timeout for WiFiClient and for Stream::readBytesUntil() and Stream::readStringUntil()"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "f4acac4c2bf83d76f49241489e24fc1d6bbb64e7",
            "timestamp": "2019-08-20T17:18:09+03:00",
            "author": "Jeroen88",
            "commit_message": "Bugfix/http client (#2867)\n\n* Fix persistance issue found, see ESP8266 issue #6152\r\n\r\n* Correcting the parsing of the header for HTTP1.0\r\n\r\n* Send 'Connection: Close' header in case of HTTP1.0\r\n\r\n* Let reuse connection depend on protocol used: HTTP1.0 or HTTP1.1\r\n\r\n* Fixed reuse, added null ptr checks, added check for _trainsportTraits in connect() in case _client was set null\r\n\r\n* Fix reuse connection issues, similar to ESP8266 PR #6176",
            "additions": 41,
            "deletions": 13,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            834,
                            835
                        ],
                        "comments": [
                            "//    end();"
                        ],
                        "lines": [
                            "    disconnect(true);"
                        ]
                    },
                    {
                        "line_numbers": [
                            990,
                            991,
                            992,
                            993,
                            994
                        ],
                        "comments": [],
                        "lines": [
                            "        if(_reuse) {",
                            "            log_d(\"already connected, reusing connection\");",
                            "        } else {",
                            "            log_d(\"already connected, try reuse!\");",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            1002
                        ],
                        "comments": [],
                        "lines": [
                            "     if(_transportTraits && !_client) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            1004,
                            1005,
                            1006,
                            1007
                        ],
                        "comments": [],
                        "lines": [
                            "        if(!_tcpDeprecated) {",
                            "            log_e(\"failed to create client\");",
                            "            return false;",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            1106,
                            1107,
                            1108
                        ],
                        "comments": [],
                        "lines": [
                            "    clear();",
                            "",
                            "    _canReuse = _reuse;"
                        ]
                    },
                    {
                        "line_numbers": [
                            1111
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            1126,
                            1127,
                            1128
                        ],
                        "comments": [],
                        "lines": [
                            "                if(_canReuse) {",
                            "                    _canReuse = (headerLine[sizeof \"HTTP/1.\" - 1] != '0');",
                            "                }"
                        ]
                    },
                    {
                        "line_numbers": [
                            1139,
                            1140,
                            1141,
                            1142
                        ],
                        "comments": [],
                        "lines": [
                            "                if(_canReuse && headerName.equalsIgnoreCase(\"Connection\")) {",
                            "                    if(headerValue.indexOf(\"close\") >= 0 && headerValue.indexOf(\"keep-alive\") < 0) {",
                            "                        _canReuse = false;",
                            "                    }"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "834": "//    end();"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "ee88c42c3b5e87a2fc09303f9e82dd8172e99990",
            "timestamp": "2020-10-01T14:41:54+03:00",
            "author": "Clickau",
            "commit_message": "Add support for following redirects in HTTPClient (#4240)",
            "additions": 145,
            "deletions": 17,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            555,
                            556,
                            557,
                            558,
                            559,
                            560
                        ],
                        "comments": [
                            "        // wipe out any existing headers from previous request"
                        ],
                        "lines": [
                            "        for(size_t i = 0; i < _headerKeysCount; i++) {",
                            "            if (_currentHeaders[i].value.length() > 0) {",
                            "                _currentHeaders[i].value.clear();",
                            "            }",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            562,
                            563,
                            564,
                            565,
                            566,
                            567
                        ],
                        "comments": [
                            "        // connect to server"
                        ],
                        "lines": [
                            "        log_d(\"request type: '%s' redirCount: %d\\n\", type, redirectCount);",
                            "",
                            "        if(!connect()) {",
                            "            return returnError(HTTPC_ERROR_CONNECTION_REFUSED);",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            569,
                            570,
                            571
                        ],
                        "comments": [],
                        "lines": [
                            "        if(payload && size > 0) {",
                            "            addHeader(F(\"Content-Length\"), String(size));",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645
                        ],
                        "comments": [
                            "        // send Payload if needed",
                            "        // Handle redirections as stated in RFC document:",
                            "        // https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html",
                            "        // Implementing HTTP_CODE_FOUND as redirection with GET method,",
                            "        // to follow most of existing user agent implementations.",
                            "                // redirecting using the same method",
                            "                        // allow to force redirections on other methods",
                            "                        // (the RFC require user to accept the redirection)",
                            "                        // allow GET and HEAD methods without force",
                            "                            // no redirection",
                            "                        // redirect using the same request method and payload, diffrent URL",
                            "                // redirecting with method dropped to GET or HEAD",
                            "                // note: it does not need `HTTPC_FORCE_FOLLOW_REDIRECTS` for any method",
                            "                        // no redirection",
                            "                    // redirect after changing method to GET/HEAD and dropping payload"
                        ],
                        "lines": [
                            "        if(!sendHeader(type)) {",
                            "            return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);",
                            "        }",
                            "",
                            "        if(payload && size > 0) {",
                            "            if(_client->write(&payload[0], size) != size) {",
                            "                return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);",
                            "            }",
                            "        }",
                            "",
                            "        code = handleHeaderResponse();",
                            "        Serial.printf(\"sendRequest code=%d\\n\", code);",
                            "",
                            "        //",
                            "        //",
                            "        redirect = false;",
                            "        if (",
                            "            _followRedirects != HTTPC_DISABLE_FOLLOW_REDIRECTS &&",
                            "            redirectCount < _redirectLimit &&",
                            "            _location.length() > 0",
                            "        ) {",
                            "            switch (code) {",
                            "                case HTTP_CODE_MOVED_PERMANENTLY:",
                            "                case HTTP_CODE_TEMPORARY_REDIRECT: {",
                            "                    if (",
                            "                        _followRedirects == HTTPC_FORCE_FOLLOW_REDIRECTS ||",
                            "                        !strcmp(type, \"GET\") ||",
                            "                        !strcmp(type, \"HEAD\")",
                            "                    ) {",
                            "                        redirectCount += 1;",
                            "                        log_d(\"following redirect (the same method): '%s' redirCount: %d\\n\", _location.c_str(), redirectCount);",
                            "                        if (!setURL(_location)) {",
                            "                            log_d(\"failed setting URL for redirection\\n\");",
                            "                            break;",
                            "                        }",
                            "                        redirect = true;",
                            "                    }",
                            "                    break;",
                            "                }",
                            "                case HTTP_CODE_FOUND:",
                            "                case HTTP_CODE_SEE_OTHER: {",
                            "                    redirectCount += 1;",
                            "                    log_d(\"following redirect (dropped to GET/HEAD): '%s' redirCount: %d\\n\", _location.c_str(), redirectCount);",
                            "                    if (!setURL(_location)) {",
                            "                        log_d(\"failed setting URL for redirection\\n\");",
                            "                        break;",
                            "                    }",
                            "                    type = \"GET\";",
                            "                    payload = nullptr;",
                            "                    size = 0;",
                            "                    redirect = true;",
                            "                    break;",
                            "                }",
                            "",
                            "                default:",
                            "                    break;",
                            "            }"
                        ]
                    },
                    {
                        "line_numbers": [
                            648
                        ],
                        "comments": [],
                        "lines": [
                            "    } while (redirect);"
                        ]
                    },
                    {
                        "line_numbers": [
                            650
                        ],
                        "comments": [],
                        "lines": [
                            "    return returnError(code);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1223,
                            1224,
                            1225,
                            1226
                        ],
                        "comments": [],
                        "lines": [
                            "                if (headerName.equalsIgnoreCase(\"Location\")) {",
                            "                    _location = headerValue;",
                            "                }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            1404,
                            1405,
                            1406,
                            1407,
                            1408,
                            1409,
                            1410,
                            1411,
                            1412,
                            1413,
                            1414,
                            1415,
                            1416,
                            1417,
                            1418,
                            1419,
                            1420,
                            1421,
                            1422,
                            1423,
                            1424,
                            1425,
                            1426,
                            1427,
                            1428,
                            1429,
                            1430,
                            1431,
                            1432,
                            1433,
                            1434,
                            1435,
                            1436,
                            1437,
                            1438,
                            1439,
                            1440,
                            1441,
                            1442,
                            1443,
                            1444,
                            1445,
                            1446,
                            1447,
                            1448,
                            1449,
                            1450
                        ],
                        "comments": [
                            "    // if the new location is only a path then only update the URI",
                            "    // check if the port is specified",
                            "    int indexPort = url.indexOf(':', 6); // find the first ':' excluding the one from the protocol",
                            "    int indexURI = url.indexOf('/', 7); // find where the URI starts to make sure the ':' is not part of it",
                            "        // the port is not specified",
                            "    // disconnect but preserve _client (clear _canReuse so disconnect will close the connection)"
                        ],
                        "lines": [
                            "",
                            "void HTTPClient::setFollowRedirects(followRedirects_t follow)",
                            "{",
                            "    _followRedirects = follow;",
                            "}",
                            "",
                            "void HTTPClient::setRedirectLimit(uint16_t limit)",
                            "{",
                            "    _redirectLimit = limit;",
                            "}",
                            "",
                            "/**",
                            " * set the URL to a new value. Handy for following redirects.",
                            " * @param url",
                            " */",
                            "bool HTTPClient::setURL(const String& url)",
                            "{",
                            "    if (url && url[0] == '/') {",
                            "        _uri = url;",
                            "        clear();",
                            "        return true;",
                            "    }",
                            "",
                            "    if (!url.startsWith(_protocol + ':')) {",
                            "        log_d(\"new URL not the same protocol, expected '%s', URL: '%s'\\n\", _protocol.c_str(), url.c_str());",
                            "        return false;",
                            "    }",
                            "",
                            "    if (indexPort == -1 || indexPort > indexURI) {",
                            "        _port = (_protocol == \"https\" ? 443 : 80);",
                            "    }",
                            "",
                            "    _canReuse = false;",
                            "    disconnect(true);",
                            "    return beginInternal(url, _protocol.c_str());",
                            "}",
                            "",
                            "const String &HTTPClient::getLocation(void)",
                            "{",
                            "    return _location;",
                            "}"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            551,
                            552,
                            553,
                            554
                        ],
                        "comments": [
                            "    // connect to server"
                        ],
                        "lines": [
                            "    if(!connect()) {",
                            "        return returnError(HTTPC_ERROR_CONNECTION_REFUSED);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            556,
                            557,
                            558
                        ],
                        "comments": [],
                        "lines": [
                            "    if(payload && size > 0) {",
                            "        addHeader(F(\"Content-Length\"), String(size));",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            561,
                            562,
                            563
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!sendHeader(type)) {",
                            "        return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            566,
                            567,
                            568
                        ],
                        "comments": [],
                        "lines": [
                            "    if(payload && size > 0) {",
                            "        if(_client->write(&payload[0], size) != size) {",
                            "            return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);"
                        ]
                    },
                    {
                        "line_numbers": [
                            570
                        ],
                        "comments": [],
                        "lines": [
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            573
                        ],
                        "comments": [],
                        "lines": [
                            "    return returnError(handleHeaderResponse());"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "555": "        // wipe out any existing headers from previous request",
                "564": "        // connect to server",
                "573": "        // send Header",
                "578": "        // send Payload if needed",
                "588": "        // Handle redirections as stated in RFC document:",
                "589": "        // https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html",
                "591": "        // Implementing HTTP_CODE_FOUND as redirection with GET method,",
                "592": "        // to follow most of existing user agent implementations.",
                "601": "                // redirecting using the same method",
                "605": "                        // allow to force redirections on other methods",
                "606": "                        // (the RFC require user to accept the redirection)",
                "608": "                        // allow GET and HEAD methods without force",
                "616": "                            // no redirection",
                "619": "                        // redirect using the same request method and payload, diffrent URL",
                "624": "                // redirecting with method dropped to GET or HEAD",
                "625": "                // note: it does not need `HTTPC_FORCE_FOLLOW_REDIRECTS` for any method",
                "632": "                        // no redirection",
                "635": "                    // redirect after changing method to GET/HEAD and dropping payload",
                "1421": "    // if the new location is only a path then only update the URI",
                "1433": "    // check if the port is specified",
                "1434": "    int indexPort = url.indexOf(':', 6); // find the first ':' excluding the one from the protocol",
                "1435": "    int indexURI = url.indexOf('/', 7); // find where the URI starts to make sure the ':' is not part of it",
                "1437": "        // the port is not specified",
                "1441": "    // disconnect but preserve _client (clear _canReuse so disconnect will close the connection)"
            },
            "comment_deleted_diff": {
                "551": "    // connect to server",
                "560": "    // send Header",
                "565": "    // send Payload if needed"
            },
            "comment_modified_diff": {}
        }
    ],
    "HTTPClient.h": [],
    "EEPROM.cpp": [
        {
            "commit": "706bf48708e6668077187ba3f5543d0f7b49e132",
            "timestamp": "2017-08-01T12:51:38+03:00",
            "author": "pbecchi",
            "commit_message": "EEPROM_library_ported_Partition_table_updated (#535)\n\n* EEPROM_library_ported_Partition_table_updated\r\n\r\n* Cleanup & formal corrections\r\n\r\n* Make formatting of file consistent.\r\n\r\nReadability change, Concern about the SubType being 0x99.\r\n\r\n* Code formatting cleanup\r\n\r\n* Code formatting cleanup\r\n\r\n* Code formatting cleanup\r\n\r\n* Remove commented out code\r\n\r\n* Restore dropped bracket\r\n\r\n* Update EEPROM.cpp\r\n\r\n* Format Corrections\r\n\r\n* deletedExample\r\n\r\n* Corrected example\r\n\r\n* Deleted interrupts/nointerrupts\r\n\r\n* Update EEPROM.cpp",
            "additions": 150,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150
                        ],
                        "comments": [
                            "\t: _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))",
                            "  // Optimise _dirty. Only flagged if data written is different."
                        ],
                        "lines": [
                            ", _data(0)",
                            ", _size(0)",
                            ", _dirty(false)",
                            "{",
                            "}",
                            "",
                            "bool EEPROMClass::begin(size_t size) {",
                            "  if (size <= 0) {",
                            "    return false;",
                            "  }",
                            "  if (size > SPI_FLASH_SEC_SIZE) {",
                            "    size = SPI_FLASH_SEC_SIZE;",
                            "  }",
                            "  _mypart = esp_partition_find_first(ESP_PARTITION_TYPE_DATA,ESP_PARTITION_SUBTYPE_ANY, EEPROM_FLASH_PARTITION_NAME);",
                            "  if (_mypart == NULL) {",
                            "    return false;",
                            "  }",
                            "  size = (size + 3) & (~3);",
                            "",
                            "  if (_data) {",
                            "    delete[] _data;",
                            "  }",
                            "",
                            "  _data = new uint8_t[size];",
                            "  _size = size;",
                            "  bool ret = false;",
                            "  if (esp_partition_read (_mypart,0, (void *) _data,_size)==ESP_OK) {",
                            "    ret=true;",
                            "  }",
                            "",
                            "  return ret;",
                            "}",
                            "",
                            "void EEPROMClass::end() {",
                            "  if (!_size) {",
                            "    return;",
                            "  }",
                            "",
                            "  commit();",
                            "  if (_data) {",
                            "    delete[] _data;",
                            "  }",
                            "  _data = 0;",
                            "  _size = 0;",
                            "}",
                            "",
                            "uint8_t EEPROMClass::read(int address) {",
                            "  if (address < 0 || (size_t)address >= _size) {",
                            "    return 0;",
                            "  }",
                            "  if (!_data) {",
                            "    return 0;",
                            "  }",
                            "",
                            "  return _data[address];",
                            "}",
                            "",
                            "void EEPROMClass::write(int address, uint8_t value) {",
                            "  if (address < 0 || (size_t)address >= _size)",
                            "    return;",
                            "  if(!_data)",
                            "    return;",
                            "",
                            "  uint8_t* pData = &_data[address];",
                            "  if (*pData != value)",
                            "  {",
                            "    *pData = value;",
                            "    _dirty = true;",
                            "  }",
                            "}",
                            "",
                            "bool EEPROMClass::commit() {",
                            "  bool ret = false;",
                            "  if (!_size)",
                            "    return false;",
                            "  if (!_dirty)",
                            "    return true;",
                            "  if (!_data)",
                            "    return false;",
                            "",
                            "",
                            "  if (esp_partition_erase_range(_mypart, 0, SPI_FLASH_SEC_SIZE) != ESP_OK)",
                            "  {",
                            "     log_e( \"partition erase err.\");",
                            "  }",
                            "  else",
                            "  {",
                            "     if (esp_partition_write(_mypart, 0, (void *)_data, _size) == ESP_ERR_INVALID_SIZE)",
                            "     {",
                            "\tlog_e( \"error in Write\");",
                            "     }",
                            "     else",
                            "     {",
                            "\t_dirty = false;",
                            "\tret = true;",
                            "     }",
                            "  }",
                            "",
                            "  return ret;",
                            "}",
                            "",
                            "uint8_t * EEPROMClass::getDataPtr() {",
                            "  _dirty = true;",
                            "  return &_data[0];",
                            "}",
                            "",
                            "#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_EEPROM)",
                            "EEPROMClass EEPROM;",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "40": "\t: _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))",
                "104": "  // Optimise _dirty. Only flagged if data written is different."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "3310e2e31d818efa095a750571d030cec6261f45",
            "timestamp": "2018-03-04T20:22:48+01:00",
            "author": "Ifediora Elochukwu C",
            "commit_message": "Add EEPROMClass and examples (#1034)\n\n* enchanced EEPROMClass\r\n\r\n* Added eeprom examles and modified partition\r\n\r\n* added eeprom class and extra examples\r\n\r\n* No changes\r\n\r\n* No changes\r\n\r\n* added eeprom class and examples\r\n\r\n* fixed typo\r\n\r\n* length() returns user-defined sector size\r\n\r\n* updated and annotated example",
            "additions": 328,
            "deletions": 28,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            54,
                            55,
                            56,
                            57,
                            58
                        ],
                        "comments": [
                            "  : _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))"
                        ],
                        "lines": [
                            "  , _data(0)",
                            "  , _size(0)",
                            "  , _dirty(false)",
                            "  , _name(\"eeprom\")"
                        ]
                    },
                    {
                        "line_numbers": [
                            62,
                            63,
                            64,
                            65
                        ],
                        "comments": [
                            "  // end();"
                        ],
                        "lines": [
                            "EEPROMClass::~EEPROMClass() {",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            74
                        ],
                        "comments": [],
                        "lines": [
                            "  _mypart = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, _name);"
                        ]
                    },
                    {
                        "line_numbers": [
                            85
                        ],
                        "comments": [],
                        "lines": [
                            "  _size = size;"
                        ]
                    },
                    {
                        "line_numbers": [
                            87,
                            88
                        ],
                        "comments": [],
                        "lines": [
                            "  if (esp_partition_read (_mypart, 0, (void *) _data, _size) == ESP_OK) {",
                            "    ret = true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            90
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            121
                        ],
                        "comments": [],
                        "lines": [
                            "  if (!_data)"
                        ]
                    },
                    {
                        "line_numbers": [
                            144,
                            145
                        ],
                        "comments": [],
                        "lines": [
                            "  {",
                            "    log_e( \"partition erase err.\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157
                        ],
                        "comments": [],
                        "lines": [
                            "    if (esp_partition_write(_mypart, 0, (void *)_data, _size) == ESP_ERR_INVALID_SIZE)",
                            "    {",
                            "      log_e( \"error in Write\");",
                            "    }",
                            "    else",
                            "    {",
                            "      _dirty = false;",
                            "      ret = true;",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447
                        ],
                        "comments": [],
                        "lines": [
                            "/*",
                            "   Get EEPROM total size in byte defined by the user",
                            "*/",
                            "uint16_t EEPROMClass::length ()",
                            "{",
                            "  return _user_defined_size;",
                            "}",
                            "",
                            "/*",
                            "   Read 'value' from 'address'",
                            "*/",
                            "uint8_t EEPROMClass::readByte (int address)",
                            "{",
                            "  uint8_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "int8_t EEPROMClass::readChar (int address)",
                            "{",
                            "  int8_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "uint8_t EEPROMClass::readUChar (int address)",
                            "{",
                            "  uint8_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "int16_t EEPROMClass::readShort (int address)",
                            "{",
                            "  int16_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "uint16_t EEPROMClass::readUShort (int address)",
                            "{",
                            "  uint16_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "int32_t EEPROMClass::readInt (int address)",
                            "{",
                            "  int32_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "uint32_t EEPROMClass::readUInt (int address)",
                            "{",
                            "  uint32_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "int32_t EEPROMClass::readLong (int address)",
                            "{",
                            "  int32_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "uint32_t EEPROMClass::readULong (int address)",
                            "{",
                            "  uint32_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "int64_t EEPROMClass::readLong64 (int address)",
                            "{",
                            "  int64_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "uint64_t EEPROMClass::readULong64 (int address)",
                            "{",
                            "  uint64_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "float_t EEPROMClass::readFloat (int address)",
                            "{",
                            "  float_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "double_t EEPROMClass::readDouble (int address)",
                            "{",
                            "  double_t value;",
                            "  return EEPROMClass::readAll (address, value);",
                            "}",
                            "",
                            "bool EEPROMClass::readBool (int address)",
                            "{",
                            "  int8_t value;",
                            "  return EEPROMClass::readAll (address, value) ? 1 : 0;",
                            "}",
                            "",
                            "size_t EEPROMClass::readString (int address, char* value, size_t maxLen)",
                            "{",
                            "  if (!value)",
                            "    return 0;",
                            "",
                            "  if (address < 0 || address + maxLen > _size)",
                            "    return 0;",
                            "",
                            "  uint16_t len;",
                            "  for (len = 0; len <= _size; len++)",
                            "    if (_data[address + len] == 0)",
                            "      break;",
                            "",
                            "  if (address + len > _size)",
                            "    return 0;",
                            "",
                            "  memcpy((uint8_t*) value, _data + address, len);",
                            "  return len;",
                            "}",
                            "",
                            "String EEPROMClass::readString (int address)",
                            "{",
                            "  if (address < 0 || address > _size)",
                            "    return String(0);",
                            "",
                            "  uint16_t len;",
                            "  for (len = 0; len <= _size; len++)",
                            "    if (_data[address + len] == 0)",
                            "      break;",
                            "",
                            "  if (address + len > _size)",
                            "    return String(0);",
                            "",
                            "  char value[len + 1];",
                            "  memcpy((uint8_t*) value, _data + address, len);",
                            "  value[len + 1] = 0;",
                            "  return String(value);",
                            "}",
                            "",
                            "size_t EEPROMClass::readBytes (int address, void* value, size_t maxLen)",
                            "{",
                            "  if (!value || !maxLen)",
                            "    return 0;",
                            "",
                            "  if (address < 0 || address + maxLen > _size)",
                            "    return 0;",
                            "",
                            "  memcpy((void*) value, _data + address, maxLen);",
                            "  return maxLen;",
                            "}",
                            "",
                            "template <class T> T EEPROMClass::readAll (int address, T &value)",
                            "{",
                            "  if (address < 0 || address + sizeof(T) > _size)",
                            "    return value;",
                            "",
                            "  memcpy((uint8_t*) &value, _data + address, sizeof(T));",
                            "  return value;",
                            "}",
                            "",
                            "/*",
                            "   Write 'value' to 'address'",
                            "*/",
                            "size_t EEPROMClass::writeByte (int address, uint8_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeChar (int address, int8_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeUChar (int address, uint8_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeShort (int address, int16_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeUShort (int address, uint16_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeInt (int address, int32_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeUInt (int address, uint32_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeLong (int address, int32_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeULong (int address, uint32_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeLong64 (int address, int64_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeULong64 (int address, uint64_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeFloat (int address, float_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeDouble (int address, double_t value)",
                            "{",
                            "  return EEPROMClass::writeAll (address, value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeBool (int address, bool value)",
                            "{",
                            "  int8_t Bool;",
                            "  value ? Bool = 1 : Bool = 0;",
                            "  return EEPROMClass::writeAll (address, Bool);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeString (int address, const char* value)",
                            "{",
                            "  if (!value)",
                            "    return 0;",
                            "",
                            "  if (address < 0 || address > _size)",
                            "    return 0;",
                            "",
                            "  uint16_t len;",
                            "  for (len = 0; len <= _size; len++)",
                            "    if (value[len] == 0)",
                            "      break;",
                            "",
                            "  if (address + len > _size)",
                            "    return 0;",
                            "",
                            "  memcpy(_data + address, (const uint8_t*) value, len + 1);",
                            "  _dirty = true;",
                            "  return strlen(value);",
                            "}",
                            "",
                            "size_t EEPROMClass::writeString (int address, String value)",
                            "{",
                            "  return EEPROMClass::writeString (address, value.c_str());",
                            "}",
                            "",
                            "size_t EEPROMClass::writeBytes (int address, const void* value, size_t len)",
                            "{",
                            "  if (!value || !len)",
                            "    return 0;",
                            "",
                            "  if (address < 0 || address + len > _size)",
                            "    return 0;",
                            "",
                            "  memcpy(_data + address, (const void*) value, len);",
                            "  _dirty = true;",
                            "  return len;",
                            "}",
                            "",
                            "template <class T> T EEPROMClass::writeAll (int address, const T &value)",
                            "{",
                            "  if (address < 0 || address + sizeof(T) > _size)",
                            "    return value;",
                            "",
                            "  memcpy(_data + address, (const uint8_t*) &value, sizeof(T));",
                            "  _dirty = true;",
                            "",
                            "  return sizeof (value);",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            40,
                            41,
                            42,
                            43
                        ],
                        "comments": [
                            "\t: _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))"
                        ],
                        "lines": [
                            ", _data(0)",
                            ", _size(0)",
                            ", _dirty(false)"
                        ]
                    },
                    {
                        "line_numbers": [
                            54
                        ],
                        "comments": [],
                        "lines": [
                            "  _mypart = esp_partition_find_first(ESP_PARTITION_TYPE_DATA,ESP_PARTITION_SUBTYPE_ANY, EEPROM_FLASH_PARTITION_NAME);"
                        ]
                    },
                    {
                        "line_numbers": [
                            65
                        ],
                        "comments": [],
                        "lines": [
                            "  _size = size;"
                        ]
                    },
                    {
                        "line_numbers": [
                            67,
                            68
                        ],
                        "comments": [],
                        "lines": [
                            "  if (esp_partition_read (_mypart,0, (void *) _data,_size)==ESP_OK) {",
                            "    ret=true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            70
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            101
                        ],
                        "comments": [],
                        "lines": [
                            "  if(!_data)"
                        ]
                    },
                    {
                        "line_numbers": [
                            124,
                            125
                        ],
                        "comments": [],
                        "lines": [
                            "  {",
                            "     log_e( \"partition erase err.\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137
                        ],
                        "comments": [],
                        "lines": [
                            "     if (esp_partition_write(_mypart, 0, (void *)_data, _size) == ESP_ERR_INVALID_SIZE)",
                            "     {",
                            "\tlog_e( \"error in Write\");",
                            "     }",
                            "     else",
                            "     {",
                            "\t_dirty = false;",
                            "\tret = true;",
                            "     }"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "54": "  : _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))",
                "63": "  // end();",
                "73": "  //  _mypart = esp_partition_find_first(ESP_PARTITION_TYPE_DATA,ESP_PARTITION_SUBTYPE_ANY, EEPROM_FLASH_PARTITION_NAME);"
            },
            "comment_deleted_diff": {
                "40": "\t: _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "619568db5bcc219091c653a5ced5e378b3a5643b",
            "timestamp": "2019-04-23T23:55:12+03:00",
            "author": "lbernstone",
            "commit_message": "Converted EEPROM library to use nvs instead of partition.   (#2678)\n\n* Converted EEPROM library to use nvs instead of partition.  Removed eeprom partition from all partition table CSV files.\r\n* Changed variable names, added some comments, formatting as per me-no-dev's requests\r\n* Checks for memory on malloc\r\n* Moved include nvs.h from header to code\r\n* Reworked the extra example to make it more clear how to actually use the library and persist data",
            "additions": 90,
            "deletions": 56,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            41,
                            42
                        ],
                        "comments": [
                            "// Only for compatiility, no sectors in nvs!"
                        ],
                        "lines": [
                            "  : _data(0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            45,
                            46,
                            47
                        ],
                        "comments": [],
                        "lines": [
                            "  , _handle(NULL)",
                            "  , _name(\"eeprom\")",
                            "  , _user_defined_size(0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            51,
                            52
                        ],
                        "comments": [],
                        "lines": [
                            "EEPROMClass::EEPROMClass(const char* name, uint32_t user_defined_size)",
                            "  : _data(0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            55,
                            56,
                            57
                        ],
                        "comments": [],
                        "lines": [
                            "  , _handle(NULL)",
                            "  , _name(name)",
                            "  , _user_defined_size(user_defined_size)"
                        ]
                    },
                    {
                        "line_numbers": [
                            66,
                            67
                        ],
                        "comments": [],
                        "lines": [
                            "  if (!size) {",
                            "      return false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            69,
                            70,
                            71,
                            72,
                            73
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "  esp_err_t res = nvs_open(_name, NVS_READWRITE, &_handle);",
                            "  if (res != ESP_OK) {",
                            "      log_e(\"Unable to open NVS namespace: %d\", res);",
                            "      return false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126
                        ],
                        "comments": [
                            "  if (size < key_size) { // truncate",
                            "  else if (size > key_size) { // expand or new",
                            "      // check for adequate free space",
                            "\t// hold data while key is deleted"
                        ],
                        "lines": [
                            "",
                            "  size_t key_size = 0;",
                            "  res = nvs_get_blob(_handle, _name, NULL, &key_size);",
                            "  if(res != ESP_OK && res != ESP_ERR_NVS_NOT_FOUND) {",
                            "      log_e(\"Unable to read NVS key: %d\", res);",
                            "      return false;",
                            "  }",
                            "      log_w(\"truncating EEPROM from %d to %d\", key_size, size);",
                            "      uint8_t* key_data = (uint8_t*) malloc(key_size);",
                            "      if(!key_data) {",
                            "         log_e(\"Not enough memory to truncate EEPROM!\");",
                            "         return false;",
                            "      }",
                            "      nvs_get_blob(_handle, _name, key_data, &key_size);",
                            "      nvs_set_blob(_handle, _name, key_data, size);",
                            "      nvs_commit(_handle);",
                            "      free(key_data);",
                            "  }",
                            "      size_t expand_size = size - key_size;",
                            "      uint8_t* expand_key = (uint8_t*) malloc(expand_size);",
                            "      if(!expand_key) {",
                            "         log_e(\"Not enough memory to expand EEPROM!\");",
                            "         return false;",
                            "      }",
                            "      if(nvs_set_blob(_handle, \"expand\", expand_key, expand_size)) {",
                            "        log_e(\"Not enough space to expand EEPROM from %d to %d\", key_size, size);",
                            "        free(expand_key);",
                            "        return false;",
                            "      }",
                            "      free(expand_key);",
                            "      nvs_erase_key(_handle, \"expand\");",
                            "      uint8_t* key_data = (uint8_t*) malloc(size);",
                            "      if(!key_data) {",
                            "         log_e(\"Not enough memory to expand EEPROM!\");",
                            "         return false;",
                            "      }",
                            "      memset(key_data, 0, size);",
                            "      if(key_size) {",
                            "        log_i(\"Expanding EEPROM from %d to %d\", key_size, size);",
                            "        nvs_get_blob(_handle, _name, key_data, &key_size);",
                            "        nvs_erase_key(_handle, _name);",
                            "      } else {",
                            "        log_i(\"New EEPROM of %d bytes\", size);",
                            "      }",
                            "      nvs_commit(_handle);",
                            "      nvs_set_blob(_handle, _name, key_data, size);",
                            "      free(key_data);",
                            "      nvs_commit(_handle);"
                        ]
                    },
                    {
                        "line_numbers": [
                            134,
                            135
                        ],
                        "comments": [],
                        "lines": [
                            "  nvs_get_blob(_handle, _name, _data, &_size);",
                            "  return true;"
                        ]
                    },
                    {
                        "line_numbers": [
                            179,
                            180
                        ],
                        "comments": [],
                        "lines": [
                            "  if (!_size) {",
                            "      return false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191
                        ],
                        "comments": [],
                        "lines": [
                            "  if (!_data) {",
                            "      return false;",
                            "  }",
                            "  if (!_dirty) {",
                            "      return true;",
                            "  }",
                            "",
                            "  if (ESP_OK != nvs_set_blob(_handle, _name, _data, _size)) {",
                            "      log_e( \"error in write\");",
                            "  } else {"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            54,
                            55
                        ],
                        "comments": [
                            "  : _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))"
                        ],
                        "lines": [
                            "  , _data(0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            58,
                            59,
                            60
                        ],
                        "comments": [],
                        "lines": [
                            "  , _mypart(NULL)",
                            "  , _name(\"eeprom\")",
                            "  , _user_defined_size(0)"
                        ]
                    },
                    {
                        "line_numbers": [
                            69,
                            70
                        ],
                        "comments": [],
                        "lines": [
                            "  if (size <= 0) {",
                            "    return false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            72,
                            73
                        ],
                        "comments": [],
                        "lines": [
                            "  if (size > SPI_FLASH_SEC_SIZE) {",
                            "    size = SPI_FLASH_SEC_SIZE;"
                        ]
                    },
                    {
                        "line_numbers": [
                            76,
                            77,
                            78
                        ],
                        "comments": [],
                        "lines": [
                            "  _mypart = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, _name);",
                            "  if (_mypart == NULL) {",
                            "    return false;"
                        ]
                    },
                    {
                        "line_numbers": [
                            80
                        ],
                        "comments": [],
                        "lines": [
                            "  size = (size + 3) & (~3);"
                        ]
                    },
                    {
                        "line_numbers": [
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93
                        ],
                        "comments": [],
                        "lines": [
                            "  _size = size;",
                            "  bool ret = false;",
                            "  if (esp_partition_read (_mypart, 0, (void *) _data, _size) == ESP_OK) {",
                            "    ret = true;",
                            "  }",
                            "",
                            "  return ret;"
                        ]
                    },
                    {
                        "line_numbers": [
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147
                        ],
                        "comments": [],
                        "lines": [
                            "  if (!_size)",
                            "    return false;",
                            "  if (!_dirty)",
                            "    return true;",
                            "  if (!_data)",
                            "    return false;",
                            "",
                            "",
                            "  if (esp_partition_erase_range(_mypart, 0, SPI_FLASH_SEC_SIZE) != ESP_OK)",
                            "  {",
                            "    log_e( \"partition erase err.\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156
                        ],
                        "comments": [],
                        "lines": [
                            "  else",
                            "  {",
                            "    if (esp_partition_write(_mypart, 0, (void *)_data, _size) == ESP_ERR_INVALID_SIZE)",
                            "    {",
                            "      log_e( \"error in Write\");",
                            "    }",
                            "    else",
                            "    {"
                        ]
                    },
                    {
                        "line_numbers": [
                            159
                        ],
                        "comments": [],
                        "lines": [
                            "    }"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "41": "// Only for compatiility, no sectors in nvs!",
                "82": "  if (size < key_size) { // truncate",
                "94": "  else if (size > key_size) { // expand or new",
                "101": "      // check for adequate free space",
                "117": "\t// hold data while key is deleted"
            },
            "comment_deleted_diff": {
                "54": "  : _sector(0)// (((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE))",
                "75": "  //  _mypart = esp_partition_find_first(ESP_PARTITION_TYPE_DATA,ESP_PARTITION_SUBTYPE_ANY, EEPROM_FLASH_PARTITION_NAME);"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "b3ba80d57036aa57469653d23cab7cc9029d2ff2",
            "timestamp": "2019-09-22T23:31:38+03:00",
            "author": "lbernstone",
            "commit_message": "nvs_handle is an int, was assigning NULL.  Also cleaned up end to ensure no memory leak. (#3246)",
            "additions": 7,
            "deletions": 4,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            63
                        ],
                        "comments": [
                            "  // end();"
                        ],
                        "lines": []
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "63": "  // end();"
            },
            "comment_modified_diff": {}
        }
    ],
    "EEPROM.h": [],
    "eeprom_write.ino": [],
    "ETH_LAN8720.ino": [],
    "ETH_TLK110.ino": [],
    "ETH.cpp": [
        {
            "commit": "3af1710a9211f70439e54c94820aec0b7ebbba8c",
            "timestamp": "2017-08-02T00:02:45+03:00",
            "author": "me-no-dev",
            "commit_message": "Add initial support for Ethernet and examples",
            "additions": 243,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243
                        ],
                        "comments": [
                            "        // Set DNS1-Server",
                            "        // Set DNS2-Server"
                        ],
                        "lines": [
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns1);",
                            "        dns_setserver(0, &d);",
                            "    }",
                            "",
                            "    if(dns2 != (uint32_t)0x00000000) {",
                            "        d.u_addr.ip4.addr = static_cast<uint32_t>(dns2);",
                            "        dns_setserver(1, &d);",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "*/",
                            "",
                            "IPAddress ETHClass::localIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    if(tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_ETH, &ip)){",
                            "        return IPAddress();",
                            "    }",
                            "    return IPAddress(ip.ip.addr);",
                            "}",
                            "",
                            "IPAddress ETHClass::subnetMask()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    if(tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_ETH, &ip)){",
                            "        return IPAddress();",
                            "    }",
                            "    return IPAddress(ip.netmask.addr);",
                            "}",
                            "",
                            "IPAddress ETHClass::gatewayIP()",
                            "{",
                            "    tcpip_adapter_ip_info_t ip;",
                            "    if(tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_ETH, &ip)){",
                            "        return IPAddress();",
                            "    }",
                            "    return IPAddress(ip.gw.addr);",
                            "}",
                            "",
                            "IPAddress ETHClass::dnsIP(uint8_t dns_no)",
                            "{",
                            "    ip_addr_t dns_ip = dns_getserver(dns_no);",
                            "    return IPAddress(dns_ip.u_addr.ip4.addr);",
                            "}",
                            "",
                            "const char * ETHClass::getHostname()",
                            "{",
                            "    const char * hostname;",
                            "    if(tcpip_adapter_get_hostname(TCPIP_ADAPTER_IF_ETH, &hostname)){",
                            "        return NULL;",
                            "    }",
                            "    return hostname;",
                            "}",
                            "",
                            "bool ETHClass::setHostname(const char * hostname)",
                            "{",
                            "    return tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_ETH, hostname) == 0;",
                            "}",
                            "",
                            "bool ETHClass::fullDuplex()",
                            "{",
                            "    return eth_config.phy_get_duplex_mode();",
                            "}",
                            "",
                            "bool ETHClass::linkUp()",
                            "{",
                            "    return eth_config.phy_check_link();",
                            "}",
                            "",
                            "uint8_t ETHClass::linkSpeed()",
                            "{",
                            "    return eth_config.phy_get_speed_mode()?100:10;",
                            "}",
                            "",
                            "bool ETHClass::enableIpV6()",
                            "{",
                            "    return tcpip_adapter_create_ip6_linklocal(TCPIP_ADAPTER_IF_ETH) == 0;",
                            "}",
                            "",
                            "IPv6Address ETHClass::localIPv6()",
                            "{",
                            "    static ip6_addr_t addr;",
                            "    if(tcpip_adapter_get_ip6_linklocal(TCPIP_ADAPTER_IF_ETH, &addr)){",
                            "        return IPv6Address();",
                            "    }",
                            "    return IPv6Address(addr.addr);",
                            "}",
                            "",
                            "uint8_t * macAddress(uint8_t* mac)",
                            "{",
                            "    if(!mac){",
                            "        return NULL;",
                            "    }",
                            "    esp_eth_get_mac(mac);",
                            "    return mac;",
                            "}",
                            "",
                            "String ETHClass::macAddress(void)",
                            "{",
                            "    uint8_t mac[6];",
                            "    char macStr[18] = { 0 };",
                            "    esp_eth_get_mac(mac);",
                            "    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);",
                            "    return String(macStr);",
                            "}",
                            "",
                            "ETHClass ETH;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "134": "        // Set DNS1-Server",
                "140": "        // Set DNS2-Server"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "ETH.h": [],
    "ExternalWakeUp.ino": [],
    "TimerWakeUp.ino": [],
    "TouchWakeUp.ino": [],
    "ResetReason.ino": [],
    "SPIFFS_Test.ino": [],
    "SPIFFS.cpp": [
        {
            "commit": "29a253ac9823fdb8189cfd72745a28143fe3c37d",
            "timestamp": "2017-09-12T11:09:59+03:00",
            "author": "Me No Dev",
            "commit_message": "Add initial SPIFFS library (#627)\n\n* Add initial SPIFFS library\r\n\r\n* Fix Deep Sleep Examples\r\n\r\n* Missed one example",
            "additions": 106,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "",
                            "#include \"vfs_api.h\"",
                            "",
                            "extern \"C\" {",
                            "#include <sys/unistd.h>",
                            "#include <sys/stat.h>",
                            "#include <dirent.h>",
                            "#include \"esp_spiffs.h\"",
                            "}",
                            "#include \"SPIFFS.h\"",
                            "",
                            "using namespace fs;",
                            "",
                            "SPIFFSFS::SPIFFSFS(FSImplPtr impl)",
                            "    : FS(impl)",
                            "{}",
                            "",
                            "bool SPIFFSFS::begin(bool formatOnFail, const char * basePath, uint8_t maxOpenFiles)",
                            "{",
                            "    if(esp_spiffs_mounted(NULL)){",
                            "        log_w(\"SPIFFS Already Mounted!\");",
                            "        return true;",
                            "    }",
                            "",
                            "    esp_vfs_spiffs_conf_t conf = {",
                            "      .base_path = basePath,",
                            "      .partition_label = NULL,",
                            "      .max_files = maxOpenFiles,",
                            "      .format_if_mount_failed = formatOnFail",
                            "    };",
                            "",
                            "    esp_err_t err = esp_vfs_spiffs_register(&conf);",
                            "    if(err){",
                            "        log_e(\"Mounting SPIFFS failed! Error: %d\", err);",
                            "        return false;",
                            "    }",
                            "    _impl->mountpoint(basePath);",
                            "    return true;",
                            "}",
                            "",
                            "void SPIFFSFS::end()",
                            "{",
                            "    if(esp_spiffs_mounted(NULL)){",
                            "        esp_err_t err = esp_vfs_spiffs_unregister(NULL);",
                            "        if(err){",
                            "            log_e(\"Unmounting SPIFFS failed! Error: %d\", err);",
                            "            return;",
                            "        }",
                            "        _impl->mountpoint(NULL);",
                            "    }",
                            "}",
                            "",
                            "bool SPIFFSFS::format()",
                            "{",
                            "    esp_err_t err = esp_spiffs_format(NULL);",
                            "    if(err){",
                            "        log_e(\"Formatting SPIFFS failed! Error: %d\", err);",
                            "        return false;",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "size_t SPIFFSFS::totalBytes()",
                            "{",
                            "    size_t total,used;",
                            "    if(esp_spiffs_info(NULL, &total, &used)){",
                            "        return 0;",
                            "    }",
                            "    return total;",
                            "}",
                            "",
                            "size_t SPIFFSFS::usedBytes()",
                            "{",
                            "    size_t total,used;",
                            "    if(esp_spiffs_info(NULL, &total, &used)){",
                            "        return 0;",
                            "    }",
                            "    return used;",
                            "}",
                            "",
                            "bool SPIFFSFS::exists(const char* path)",
                            "{",
                            "    File f = open(path, \"r\");",
                            "    return (f == true) && !f.isDirectory();",
                            "}",
                            "",
                            "bool SPIFFSFS::exists(const String& path)",
                            "{",
                            "    return exists(path.c_str());",
                            "}",
                            "",
                            "",
                            "SPIFFSFS SPIFFS = SPIFFSFS(FSImplPtr(new VFSImpl()));"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "SPIFFS.h": [],
    "dhcpserver_options.h": [],
    "BLE": [],
    "bootloader_qio.bin": [],
    "adc2_wifi_internal.h": [],
    "sdmmc_host.h": [],
    "sdspi_host.h": [],
    "spi_master.h": [],
    "timer.h": [],
    "esp_freertos_hooks.h": [],
    "esp_now.h": [],
    "esp_wifi_crypto_types.h": [],
    "ff.h": [],
    "ffconf.h": [],
    "integer.h": [],
    "esp_heap_caps.h": [],
    "esp_heap_caps_init.h": [],
    "esp_heap_trace.h": [],
    "ssl_methods.h": [],
    "ssl_types.h": [],
    "sens_reg.h": [],
    "ioctl.h": [],
    "libapp_trace.a": [],
    "libc_nano.a": [],
    "libconsole.a": [],
    "libesp_adc_cal.a": [],
    "libespnow.a": [],
    "libheap.a": [],
    "libidf_test.a": [],
    "libjsmn.a": [],
    "libpthread.a": [],
    "libsoc.a": [],
    "libspiffs.a": [],
    "libwear_levelling.a": [],
    "sdkconfig": [],
    "ETH_LAN8720_internal_clock.ino": [],
    "bootloader_dio_40m.bin": [],
    "bootloader_dio_80m.bin": [],
    "bootloader_dout_40m.bin": [],
    "bootloader_dout_80m.bin": [],
    "bootloader_qio_40m.bin": [],
    "bootloader_qio_80m.bin": [],
    "bootloader_qout_40m.bin": [],
    "bootloader_qout_80m.bin": [],
    "bt_utils.h": [],
    "bta_av_api.h": [],
    "bta_jv_api.h": [],
    "bta_jv_co.h": [],
    "btc_a2dp.h": [],
    "btc_a2dp_control.h": [],
    "btc_a2dp_sink.h": [],
    "btc_a2dp_source.h": [],
    "btc_av.h": [],
    "btc_av_api.h": [],
    "btc_av_co.h": [],
    "btc_avrc.h": [],
    "btc_spp.h": [],
    "btc_util.h": [],
    "esp_a2dp_api.h": [],
    "esp_avrc_api.h": [],
    "esp_gap_bt_api.h": [],
    "esp_spp_api.h": [],
    "port_int.h": [],
    "bootloader_clock.h": [],
    "esp_bt.h": [],
    "i2c.h": [],
    "esp_intr_alloc.h": [],
    "esp_timer.h": [],
    "esp_log_internal.h": [],
    "esp_debug.h": [],
    "mdns.h": [],
    "mdns_console.h": [],
    "rtc_i2c_reg.h": [],
    "soc_ulp.h": [],
    "spiffs_config.h": [],
    "ulp.h": [],
    "CaptivePortal.ino": [],
    "DNSServer.cpp": [
        {
            "commit": "694c3a453f8977dc61e2afa26a9e761557f09ac1",
            "timestamp": "2018-03-04T20:17:40+01:00",
            "author": "Laurent Louf",
            "commit_message": "DNS Server : bug fix and prettifying (#1011)\n\n* Retrieve some code from what has been done on the ESP8266. Clarify a bit the signification of several bytes in the response.\r\n\r\n* Add the type and class as members of the DNS class for an eventual future use.\r\n\r\n* Clarify the sense of a magic number present in DNS server.\r\n\r\n* A bit of aesthetics for the DNS server.\r\n\r\n* Add a structure for the DNS question, use it DNS server to store the question data and to create the DNS answer from scratch.",
            "additions": 69,
            "deletions": 17,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            59,
                            60,
                            61
                        ],
                        "comments": [
                            "    // Allocate buffer for the DNS query"
                        ],
                        "lines": [
                            "    if (_buffer != NULL)",
                            "      free(_buffer);"
                        ]
                    },
                    {
                        "line_numbers": [
                            63,
                            64,
                            65,
                            66,
                            67
                        ],
                        "comments": [
                            "    // Put the packet received in the buffer and get DNS header (beginning of message)",
                            "    // and the question"
                        ],
                        "lines": [
                            "    if (_buffer == NULL)",
                            "      return;",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89
                        ],
                        "comments": [
                            "      // The QName has a variable length, maximum 255 bytes and is comprised of multiple labels.",
                            "      // Each label contains a byte to describe its length and the label itself. The list of",
                            "      // labels terminates with a zero-valued byte. In \"github.com\", we have two labels \"github\" & \"com\"",
                            "      // Iterate through the labels and copy them as they come into a single buffer (for simplicity's sake)",
                            "      // Copy the QType and QClass"
                        ],
                        "lines": [
                            "    memcpy( _dnsHeader, _buffer, DNS_HEADER_SIZE ) ;",
                            "    if ( requestIncludesOnlyOneQuestion() )",
                            "    {",
                            "      _dnsQuestion->QNameLength = 0 ;",
                            "      while ( _buffer[ DNS_HEADER_SIZE + _dnsQuestion->QNameLength ] != 0 )",
                            "      {",
                            "        memcpy( (void*) &_dnsQuestion->QName[_dnsQuestion->QNameLength], (void*) &_buffer[DNS_HEADER_SIZE + _dnsQuestion->QNameLength], _buffer[DNS_HEADER_SIZE + _dnsQuestion->QNameLength] + 1 ) ;",
                            "        _dnsQuestion->QNameLength += _buffer[DNS_HEADER_SIZE + _dnsQuestion->QNameLength] + 1 ;",
                            "      }",
                            "      _dnsQuestion->QName[_dnsQuestion->QNameLength] = 0 ;",
                            "      _dnsQuestion->QNameLength++ ;",
                            "",
                            "      memcpy( &_dnsQuestion->QType, (void*) &_buffer[DNS_HEADER_SIZE + _dnsQuestion->QNameLength], sizeof(_dnsQuestion->QType) ) ;",
                            "      memcpy( &_dnsQuestion->QClass, (void*) &_buffer[DNS_HEADER_SIZE + _dnsQuestion->QNameLength + sizeof(_dnsQuestion->QType)], sizeof(_dnsQuestion->QClass) ) ;",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            117
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            122,
                            123,
                            124,
                            125,
                            126
                        ],
                        "comments": [
                            "  // Set the start of the domain just after the header (12 bytes). If equal to null character, return an empty domain"
                        ],
                        "lines": [
                            "  if (_buffer == NULL)",
                            "    return parsedDomainName;",
                            "",
                            "  unsigned char *start = _buffer + DNS_OFFSET_DOMAIN_NAME;"
                        ]
                    },
                    {
                        "line_numbers": [
                            131
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            157
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185
                        ],
                        "comments": [
                            "  // Change the type of message to a response and set the number of answers equal to",
                            "  // the number of questions in the header",
                            "  // Write the question",
                            "  // Write the answer",
                            "  // Use DNS name compression : instead of repeating the name in this RNAME occurence,",
                            "  // set the two MSB of the byte corresponding normally to the length to 1. The following",
                            "  // 14 bits must be used to specify the offset of the domain name in the message",
                            "  // (<255 here so the first byte has the 6 LSB at 0)",
                            "  // DNS type A : host address, DNS class IN for INternet, returning an IPv4 address",
                            "  _udp.write((unsigned char*) &_ttl, 4);        // DNS Time To Live",
                            "  _udp.write(_resolvedIP, sizeof(_resolvedIP)); // The IP address to return"
                        ],
                        "lines": [
                            "",
                            "  _dnsHeader->QR      = DNS_QR_RESPONSE;",
                            "  _dnsHeader->ANCount = _dnsHeader->QDCount;",
                            "  _udp.write( (unsigned char*) _dnsHeader, DNS_HEADER_SIZE ) ;",
                            "",
                            "  _udp.write(_dnsQuestion->QName, _dnsQuestion->QNameLength) ;",
                            "  _udp.write( (unsigned char*) &_dnsQuestion->QType, 2 ) ;",
                            "  _udp.write( (unsigned char*) &_dnsQuestion->QClass, 2 ) ;",
                            "",
                            "  _udp.write((uint8_t) 0xC0);",
                            "  _udp.write((uint8_t) DNS_OFFSET_DOMAIN_NAME);",
                            "",
                            "  uint16_t answerType = htons(DNS_TYPE_A), answerClass = htons(DNS_CLASS_IN), answerIPv4 = htons(DNS_RDLENGTH_IPV4)  ;",
                            "  _udp.write((unsigned char*) &answerType, 2 );",
                            "  _udp.write((unsigned char*) &answerClass, 2 );",
                            "  _udp.write((unsigned char*) &answerIPv4, 2 );"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "59": "    // Allocate buffer for the DNS query",
                "66": "    // Put the packet received in the buffer and get DNS header (beginning of message)",
                "67": "    // and the question",
                "72": "      // The QName has a variable length, maximum 255 bytes and is comprised of multiple labels.",
                "73": "      // Each label contains a byte to describe its length and the label itself. The list of",
                "74": "      // labels terminates with a zero-valued byte. In \"github.com\", we have two labels \"github\" & \"com\"",
                "75": "      // Iterate through the labels and copy them as they come into a single buffer (for simplicity's sake)",
                "85": "      // Copy the QType and QClass",
                "120": "  // Error checking : if the buffer containing the DNS request is a null pointer, return an empty domain",
                "125": "  // Set the start of the domain just after the header (12 bytes). If equal to null character, return an empty domain",
                "160": "  // Change the type of message to a response and set the number of answers equal to",
                "161": "  // the number of questions in the header",
                "166": "  // Write the question",
                "171": "  // Write the answer",
                "172": "  // Use DNS name compression : instead of repeating the name in this RNAME occurence,",
                "173": "  // set the two MSB of the byte corresponding normally to the length to 1. The following",
                "174": "  // 14 bits must be used to specify the offset of the domain name in the message",
                "175": "  // (<255 here so the first byte has the 6 LSB at 0)",
                "179": "  // DNS type A : host address, DNS class IN for INternet, returning an IPv4 address",
                "183": "  _udp.write((unsigned char*) &_ttl, 4);        // DNS Time To Live",
                "185": "  _udp.write(_resolvedIP, sizeof(_resolvedIP)); // The IP address to return"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "f76ec4f50b6e59770c0a51017375137209b4d590",
            "timestamp": "2020-10-03T02:59:55+03:00",
            "author": "Shawn A",
            "commit_message": "adds debugging to dnsserver (#1046)",
            "additions": 11,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            5,
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        "comments": [
                            "// #define DEBUG_ESP_DNS"
                        ],
                        "lines": [
                            "#ifdef DEBUG_ESP_PORT",
                            "#define DEBUG_OUTPUT DEBUG_ESP_PORT",
                            "#else",
                            "#define DEBUG_OUTPUT Serial",
                            "#endif"
                        ]
                    },
                    {
                        "line_numbers": [
                            193,
                            194,
                            195,
                            196,
                            197
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "  #ifdef DEBUG_ESP_DNS",
                            "    DEBUG_OUTPUT.printf(\"DNS responds: %s for %s\\n\",",
                            "            IPAddress(_resolvedIP).toString().c_str(), getDomainNameWithoutWwwPrefix().c_str() );",
                            "  #endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "5": "// #define DEBUG_ESP_DNS"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "DNSServer.h": [],
    "eeprom_class.ino": [],
    "eeprom_extra.ino": [],
    "Arguments.ino": [],
    "Blinker.ino": [],
    "Ticker.cpp": [],
    "Ticker.h": [],
    "SD_time.ino": [],
    "SDMMC_time.ino": [],
    "SPIFFS_time.ino": [],
    "README.md": [],
    "SerialToSerialBT.ino": [],
    "BluetoothSerial.cpp": [
        {
            "commit": "b4b9a79eead317d899fe4f199b4d536b99c25112",
            "timestamp": "2018-03-05T07:34:10+01:00",
            "author": "copercini",
            "commit_message": "Add BluetoothSerial library (#1144)\n\n* Add BluetoothSerial library\r\n\r\nA simple UART to Classical Bluetooth bridge for ESP32\r\n\r\n* Create README.md\r\n\r\n* Fix typos\r\n\r\n* Replace deprecated header and small fixes\r\n\r\n* Add coexistence with BLE\r\n\r\n* Add missing semicolon",
            "additions": 239,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239
                        ],
                        "comments": [
                            "// Copyright 2018 Evandro Luis Copercini",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "",
                            "#include \"sdkconfig.h\"",
                            "",
                            "#if defined(CONFIG_BT_ENABLED) && defined(CONFIG_BLUEDROID_ENABLED)",
                            "",
                            "#ifdef ARDUINO_ARCH_ESP32",
                            "#include \"esp32-hal-log.h\"",
                            "#endif",
                            "",
                            "#include \"BluetoothSerial.h\"",
                            "",
                            "#include \"esp_bt.h\"",
                            "#include \"esp_bt_main.h\"",
                            "#include \"esp_gap_bt_api.h\"",
                            "#include \"esp_bt_device.h\"",
                            "#include \"esp_spp_api.h\"",
                            "",
                            "#define SPP_SERVER_NAME \"ESP32_SPP_SERVER\"",
                            "",
                            "#define QUEUE_SIZE 256",
                            "uint32_t client;",
                            "xQueueHandle SerialQueueBT;",
                            "",
                            "static const esp_spp_mode_t esp_spp_mode = ESP_SPP_MODE_CB;",
                            "static const esp_spp_sec_t sec_mask = ESP_SPP_SEC_NONE;",
                            "static const esp_spp_role_t role_slave = ESP_SPP_ROLE_SLAVE;",
                            "",
                            "static void esp_spp_cb(esp_spp_cb_event_t event, esp_spp_cb_param_t *param)",
                            "{",
                            "    switch (event)",
                            "    {",
                            "    case ESP_SPP_INIT_EVT:",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_INIT_EVT\");",
                            "        esp_bt_gap_set_scan_mode(ESP_BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);",
                            "        esp_spp_start_srv(sec_mask, role_slave, 0, SPP_SERVER_NAME);",
                            "        break;",
                            "    case ESP_SPP_DISCOVERY_COMP_EVT:",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_DISCOVERY_COMP_EVT\");",
                            "        break;",
                            "    case ESP_SPP_OPEN_EVT:",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_OPEN_EVT\");",
                            "        break;",
                            "    case ESP_SPP_CLOSE_EVT:",
                            "        client = 0;",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_CLOSE_EVT\");",
                            "        break;",
                            "    case ESP_SPP_START_EVT:",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_START_EVT\");",
                            "        break;",
                            "    case ESP_SPP_CL_INIT_EVT:",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_CL_INIT_EVT\");",
                            "        break;",
                            "    case ESP_SPP_DATA_IND_EVT:",
                            "        ESP_LOGV(SPP_TAG, \"ESP_SPP_DATA_IND_EVT len=%d handle=%d\", param->data_ind.len, param->data_ind.handle);",
                            "        //esp_log_buffer_hex(\"\",param->data_ind.data,param->data_ind.len); //for low level debug",
                            "",
                            "        if (SerialQueueBT != 0){",
                            "            for (int i = 0; i < param->data_ind.len; i++)",
                            "                xQueueSend(SerialQueueBT, param->data_ind.data + i, (TickType_t)0);",
                            "        }",
                            "        else {",
                            "            ESP_LOGE(SPP_TAG, \"SerialQueueBT ERROR\");",
                            "        }",
                            "        break;",
                            "    case ESP_SPP_CONG_EVT:",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_CONG_EVT\");",
                            "        break;",
                            "    case ESP_SPP_WRITE_EVT:",
                            "        ESP_LOGV(SPP_TAG, \"ESP_SPP_WRITE_EVT\");",
                            "        break;",
                            "    case ESP_SPP_SRV_OPEN_EVT:",
                            "        client = param->open.handle;",
                            "        ESP_LOGI(SPP_TAG, \"ESP_SPP_SRV_OPEN_EVT\");",
                            "        break;",
                            "    default:",
                            "        break;",
                            "    }",
                            "}",
                            "",
                            "static bool _init_bt(const char *deviceName)",
                            "{",
                            "    if (!btStarted() && !btStart()){",
                            "        ESP_LOGE(SPP_TAG, \"%s initialize controller failed\\n\", __func__);",
                            "        return false;",
                            "    }",
                            "",
                            "    esp_bluedroid_status_t bt_state = esp_bluedroid_get_status();",
                            "    if (bt_state == ESP_BLUEDROID_STATUS_UNINITIALIZED){",
                            "        if (esp_bluedroid_init()) {",
                            "            ESP_LOGE(SPP_TAG, \"%s initialize bluedroid failed\\n\", __func__);",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    if (bt_state != ESP_BLUEDROID_STATUS_ENABLED){",
                            "        if (esp_bluedroid_enable()) {",
                            "            ESP_LOGE(SPP_TAG, \"%s enable bluedroid failed\\n\", __func__);",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    if (esp_spp_register_callback(esp_spp_cb) != ESP_OK){",
                            "        ESP_LOGE(SPP_TAG, \"%s spp register failed\\n\", __func__);",
                            "        return false;",
                            "    }",
                            "",
                            "    if (esp_spp_init(esp_spp_mode) != ESP_OK){",
                            "        ESP_LOGE(SPP_TAG, \"%s spp init failed\\n\", __func__);",
                            "        return false;",
                            "    }",
                            "",
                            "    SerialQueueBT = xQueueCreate(QUEUE_SIZE, sizeof(uint8_t)); //initialize the queue",
                            "    if (SerialQueueBT == NULL){",
                            "        ESP_LOGE(SPP_TAG, \"%s Queue creation error\\n\", __func__);",
                            "        return false;",
                            "    }",
                            "    esp_bt_dev_set_device_name(deviceName);",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "static bool _stop_bt()",
                            "{",
                            "    if (btStarted()){",
                            "        esp_bluedroid_disable();",
                            "        esp_bluedroid_deinit();",
                            "        btStop();",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "/*",
                            " * Serial Bluetooth Arduino",
                            " *",
                            " * */",
                            "",
                            "BluetoothSerial::BluetoothSerial()",
                            "{",
                            "    local_name = \"ESP32\"; //default bluetooth name",
                            "}",
                            "",
                            "BluetoothSerial::~BluetoothSerial(void)",
                            "{",
                            "    _stop_bt();",
                            "}",
                            "",
                            "bool BluetoothSerial::begin(String localName)",
                            "{",
                            "    if (localName.length()){",
                            "        local_name = localName;",
                            "    }",
                            "    return _init_bt(local_name.c_str());",
                            "}",
                            "",
                            "int BluetoothSerial::available(void)",
                            "{",
                            "    if (!client || SerialQueueBT == NULL){",
                            "        return 0;",
                            "    }",
                            "    return uxQueueMessagesWaiting(SerialQueueBT);",
                            "}",
                            "",
                            "int BluetoothSerial::peek(void)",
                            "{",
                            "    if (available()){",
                            "        if (!client || SerialQueueBT == NULL){",
                            "            return 0;",
                            "        }",
                            "",
                            "        uint8_t c;",
                            "        if (xQueuePeek(SerialQueueBT, &c, 0)){",
                            "            return c;",
                            "        }",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "int BluetoothSerial::read(void)",
                            "{",
                            "    if (available()){",
                            "        if (!client || SerialQueueBT == NULL){",
                            "            return 0;",
                            "        }",
                            "",
                            "        uint8_t c;",
                            "        if (xQueueReceive(SerialQueueBT, &c, 0)){",
                            "            return c;",
                            "        }",
                            "        return 0;",
                            "    }",
                            "}",
                            "",
                            "size_t BluetoothSerial::write(uint8_t c)",
                            "{",
                            "    if (client){",
                            "        uint8_t buffer[1];",
                            "        buffer[0] = c;",
                            "        esp_spp_write(client, 1, buffer);",
                            "        return 1;",
                            "    }",
                            "    return -1;",
                            "}",
                            "",
                            "size_t BluetoothSerial::write(const uint8_t *buffer, size_t size)",
                            "{",
                            "    if (client){",
                            "        esp_spp_write(client, size, (uint8_t *)buffer);",
                            "    }",
                            "    return size;",
                            "}",
                            "",
                            "void BluetoothSerial::flush()",
                            "{",
                            "    if (client){",
                            "        int qsize = available();",
                            "        uint8_t buffer[qsize];",
                            "        esp_spp_write(client, qsize, buffer);",
                            "    }",
                            "}",
                            "",
                            "void BluetoothSerial::end()",
                            "{",
                            "    _stop_bt();",
                            "}",
                            "",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2018 Evandro Luis Copercini",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "901a341949f23afe54bc6fc5c6617974ff9b36a9",
            "timestamp": "2018-07-07T11:25:10+02:00",
            "author": "Gottfried Haider",
            "commit_message": "BluetoothSerial: set COD to be compatible with macOS (#1304) (#1556)",
            "additions": 10,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148
                        ],
                        "comments": [
                            "    // the default BTA_DM_COD_LOUDSPEAKER does not work with the macOS BT stack"
                        ],
                        "lines": [
                            "    esp_bt_cod_t cod;",
                            "    cod.major = 0b00001;",
                            "    cod.minor = 0b000100;",
                            "    cod.service = 0b00000010110;",
                            "    if (esp_bt_gap_set_cod(cod, ESP_BT_INIT_COD) != ESP_OK) {",
                            "        log_e(\"%s set cod failed\\n\", __func__);",
                            "        return false;",
                            "    }",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "139": "    // the default BTA_DM_COD_LOUDSPEAKER does not work with the macOS BT stack"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "38c4c0610846b7193e908b474e2c8db06ae981ba",
            "timestamp": "2019-10-01T17:34:46+03:00",
            "author": "IonicEV",
            "commit_message": "Support for Master mode, Pin and SSP (#3219)\n\n* 20190916 - initial: support for Master mode, Pin and SSP\r\n\r\n* 20190916 - initial: Add example app for Master mode\r\n\r\n* 20190916 - initial: Force another build\r\n\r\n* 20190916 - connect would use resolved address as preference and remove now redundant _remote_address\r\n\r\n* 20190916 - rework set/reset/default pin logic\r\n\r\n* 20190916 - cleanup: remove static vars, add/use constants, fix typos\r\n\r\n* 20190916 - fix build issues and implement geoup events for status verification.\r\n\r\n* 20190916 - remove extra lines,misc\r\n\r\n* 20190916 - rework ESP_BT_GAP_DISC_RES_EVT, added SPP_DISCONNECTED bit for disconnect event. + timeout for disconnect()\r\n\r\n* 20190916 - Small log change to improve log sequencing\r\n\r\n* 20190916 - remove static from local vars\r\n\r\n* 20190916 - Limited scope and duration for the scan, log device address during scan in info mode as it is very difficult to find out sometimes. Fixed get_name_from_eir() not resetting the name when called.\r\n\r\n* 20190916 - break property for loop during scan when name matches.\r\n\r\n* 20190916 - misc\r\n\r\n* 20190916 - SPP_DISCONNECT state updates\r\n\r\n* 20190916 - formatting, remove some strange syntax from initiator code\r\n\r\n* 20190916 - Add comments to the example about connect(...) usage and timeouts\r\n\r\n* 20190916 - fix disconnect() without timeout\r\n\r\n* 20190916 - Add example comment to view BT address and name during connect(name)\r\n\r\n* 20190916 - wording in example comments\r\n\r\n* 20190916 - rework connect() and disconnect() methods to help with concurrency and more authoritative status returned back to caller. Automatic disconnect in connect() methods\r\n\r\n* 20190916 - optimize code\r\n\r\n* 20190916 - optimize code - more\r\n\r\n* 20190916 - add timeout for pin set\r\n\r\n* 20190916 - change scan mode to ESP_BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE\r\n\r\n* 20190916 - update example code slightly\r\n\r\n* 20190916 - increase READY_TIMEOUT to 10 secs\r\n\r\n* 20190916 - typo in example and move waitForConnect() to static area\r\n\r\n* 20190916 - update example comments\r\n\r\n* 20190916 - update example comments\r\n\r\n* 20190916 - update example comments\r\n\r\n* 20190916 - add new example to remove paired devices from ESP32\r\n\r\n* 20190916 - correct typo in example\r\n\r\n* 20190916 - update example comment, add remove_bond_device() method for convenience.\r\n\r\n* 20190916 - reword example comment.\r\n\r\n* 20190916 - rename remove_bond_device()\r\n\r\n* 20190916 - rename removePairedDevice() to unpairDevice()\r\n\r\n* 20190916 - code review changes\r\n\r\n* 20190916 - fix return value in setup() od example",
            "additions": 349,
            "deletions": 7,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129
                        ],
                        "comments": [
                            "            pin_type = ESP_BT_PIN_TYPE_VARIABLE; // pin_code would be ignored (default)"
                        ],
                        "lines": [
                            "        }",
                            "        return (esp_bt_gap_set_pin(pin_type, _pin_len, _pin_code) == ESP_OK);",
                            "    }",
                            "    return false;",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            227,
                            228,
                            229,
                            230
                        ],
                        "comments": [],
                        "lines": [
                            "        if (!_isMaster) {",
                            "            log_i(\"ESP_SPP_INIT_EVT: slave: start\");",
                            "            esp_spp_start_srv(ESP_SPP_SEC_NONE, ESP_SPP_ROLE_SLAVE, 0, _spp_server_name);",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            235
                        ],
                        "comments": [],
                        "lines": [
                            "        log_i(\"ESP_SPP_SRV_OPEN_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            242
                        ],
                        "comments": [],
                        "lines": [
                            "        xEventGroupClearBits(_spp_event_group, SPP_DISCONNECTED);"
                        ]
                    },
                    {
                        "line_numbers": [
                            247
                        ],
                        "comments": [],
                        "lines": [
                            "        log_i(\"ESP_SPP_CLOSE_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            252,
                            253
                        ],
                        "comments": [],
                        "lines": [
                            "            xEventGroupSetBits(_spp_event_group, SPP_DISCONNECTED);",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            291,
                            292,
                            293,
                            294
                        ],
                        "comments": [],
                        "lines": [
                            "        if (param->disc_comp.status == ESP_SPP_SUCCESS) {",
                            "            log_i(\"ESP_SPP_DISCOVERY_COMP_EVT: spp connect to remote\");",
                            "            esp_spp_connect(ESP_SPP_SEC_AUTHENTICATE, ESP_SPP_ROLE_MASTER, param->disc_comp.scn[0], _peer_bd_addr);",
                            "        }"
                        ]
                    },
                    {
                        "line_numbers": [
                            296
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306
                        ],
                        "comments": [],
                        "lines": [
                            "        if (!_spp_client){",
                            "                _spp_client = param->open.handle;",
                            "        } else {",
                            "            secondConnectionAttempt = true;",
                            "            esp_spp_disconnect(param->open.handle);",
                            "        }",
                            "        xEventGroupClearBits(_spp_event_group, SPP_DISCONNECTED);",
                            "        xEventGroupSetBits(_spp_event_group, SPP_CONNECTED);"
                        ]
                    },
                    {
                        "line_numbers": [
                            308
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            312
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            316
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431
                        ],
                        "comments": [
                            "                        peer_bdname_len--; // len includes 0 terminator",
                            "            // default pairing pins"
                        ],
                        "lines": [
                            "static void esp_bt_gap_cb(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param)",
                            "{",
                            "    switch(event){",
                            "        case ESP_BT_GAP_DISC_RES_EVT:",
                            "            log_i(\"ESP_BT_GAP_DISC_RES_EVT\");",
                            "            char bda_str[18];",
                            "            log_i(\"Scanned device: %s\", bda2str(param->disc_res.bda, bda_str, 18));",
                            "            for (int i = 0; i < param->disc_res.num_prop; i++) {",
                            "                uint8_t peer_bdname_len;",
                            "                char peer_bdname[ESP_BT_GAP_MAX_BDNAME_LEN + 1];",
                            "                switch(param->disc_res.prop[i].type) {",
                            "                    case ESP_BT_GAP_DEV_PROP_EIR:",
                            "                        if (get_name_from_eir((uint8_t*)param->disc_res.prop[i].val, peer_bdname, &peer_bdname_len)) {",
                            "                            log_i(\"ESP_BT_GAP_DISC_RES_EVT : EIR : %s : %d\", peer_bdname, peer_bdname_len);",
                            "                            if (strlen(_remote_name) == peer_bdname_len",
                            "                                && strncmp(peer_bdname, _remote_name, peer_bdname_len) == 0) {",
                            "                                log_v(\"ESP_BT_GAP_DISC_RES_EVT : SPP_START_DISCOVERY_EIR : %s\", peer_bdname, peer_bdname_len);",
                            "                                _isRemoteAddressSet = true;",
                            "                                memcpy(_peer_bd_addr, param->disc_res.bda, ESP_BD_ADDR_LEN);",
                            "                                esp_bt_gap_cancel_discovery();",
                            "                                esp_spp_start_discovery(_peer_bd_addr);",
                            "                            }",
                            "                        }",
                            "                        break;",
                            "",
                            "                    case ESP_BT_GAP_DEV_PROP_BDNAME:",
                            "                        peer_bdname_len = param->disc_res.prop[i].len;",
                            "                        memcpy(peer_bdname, param->disc_res.prop[i].val, peer_bdname_len);",
                            "                        log_v(\"ESP_BT_GAP_DISC_RES_EVT : BDNAME :  %s : %d\", peer_bdname, peer_bdname_len);",
                            "                        if (strlen(_remote_name) == peer_bdname_len",
                            "                            && strncmp(peer_bdname, _remote_name, peer_bdname_len) == 0) {",
                            "                            log_i(\"ESP_BT_GAP_DISC_RES_EVT : SPP_START_DISCOVERY_BDNAME : %s\", peer_bdname);",
                            "                            _isRemoteAddressSet = true;",
                            "                            memcpy(_peer_bd_addr, param->disc_res.bda, ESP_BD_ADDR_LEN);",
                            "                            esp_bt_gap_cancel_discovery();",
                            "                            esp_spp_start_discovery(_peer_bd_addr);",
                            "                        }",
                            "                        break;",
                            "",
                            "                    case ESP_BT_GAP_DEV_PROP_COD:",
                            "                        //log_i(\"ESP_BT_GAP_DEV_PROP_COD\");",
                            "                        break;",
                            "",
                            "                    case ESP_BT_GAP_DEV_PROP_RSSI:",
                            "                        //log_i(\"ESP_BT_GAP_DEV_PROP_RSSI\");",
                            "                        break;",
                            "",
                            "                    default:",
                            "                        break;",
                            "                }",
                            "                if (_isRemoteAddressSet)",
                            "                    break;",
                            "            }",
                            "            break;",
                            "        case ESP_BT_GAP_DISC_STATE_CHANGED_EVT:",
                            "            log_i(\"ESP_BT_GAP_DISC_STATE_CHANGED_EVT\");",
                            "            break;",
                            "",
                            "        case ESP_BT_GAP_RMT_SRVCS_EVT:",
                            "            log_i( \"ESP_BT_GAP_RMT_SRVCS_EVT\");",
                            "            break;",
                            "",
                            "        case ESP_BT_GAP_RMT_SRVC_REC_EVT:",
                            "            log_i(\"ESP_BT_GAP_RMT_SRVC_REC_EVT\");",
                            "            break;",
                            "",
                            "        case ESP_BT_GAP_AUTH_CMPL_EVT:",
                            "            if (param->auth_cmpl.stat == ESP_BT_STATUS_SUCCESS) {",
                            "                log_v(\"authentication success: %s\", param->auth_cmpl.device_name);",
                            "            } else {",
                            "                log_e(\"authentication failed, status:%d\", param->auth_cmpl.stat);",
                            "            }",
                            "            break;",
                            "",
                            "        case ESP_BT_GAP_PIN_REQ_EVT:",
                            "            log_i(\"ESP_BT_GAP_PIN_REQ_EVT min_16_digit:%d\", param->pin_req.min_16_digit);",
                            "            if (param->pin_req.min_16_digit) {",
                            "                log_i(\"Input pin code: 0000 0000 0000 0000\");",
                            "                esp_bt_pin_code_t pin_code;",
                            "                memset(pin_code, '0', ESP_BT_PIN_CODE_LEN);",
                            "                esp_bt_gap_pin_reply(param->pin_req.bda, true, 16, pin_code);",
                            "            } else {",
                            "                log_i(\"Input pin code: 1234\");",
                            "                esp_bt_pin_code_t pin_code;",
                            "                memcpy(pin_code, \"1234\", 4);",
                            "                esp_bt_gap_pin_reply(param->pin_req.bda, true, 4, pin_code);",
                            "            }",
                            "            break;",
                            "",
                            "        case ESP_BT_GAP_CFM_REQ_EVT:",
                            "            log_i(\"ESP_BT_GAP_CFM_REQ_EVT Please compare the numeric value: %d\", param->cfm_req.num_val);",
                            "            esp_bt_gap_ssp_confirm_reply(param->cfm_req.bda, true);",
                            "            break;",
                            "",
                            "        case ESP_BT_GAP_KEY_NOTIF_EVT:",
                            "            log_i(\"ESP_BT_GAP_KEY_NOTIF_EVT passkey:%d\", param->key_notif.passkey);",
                            "            break;",
                            "",
                            "        case ESP_BT_GAP_KEY_REQ_EVT:",
                            "            log_i(\"ESP_BT_GAP_KEY_REQ_EVT Please enter passkey!\");",
                            "            break;",
                            "",
                            "        default:",
                            "            break;",
                            "    }",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            442
                        ],
                        "comments": [],
                        "lines": [
                            "        xEventGroupSetBits(_spp_event_group, SPP_DISCONNECTED);"
                        ]
                    },
                    {
                        "line_numbers": [
                            495,
                            496,
                            497,
                            498,
                            499
                        ],
                        "comments": [],
                        "lines": [
                            "    if (_isMaster && esp_bt_gap_register_callback(esp_bt_gap_cb) != ESP_OK) {",
                            "        log_e(\"gap register failed\");",
                            "        return false;",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            510
                        ],
                        "comments": [],
                        "lines": [
                            "    log_i(\"device name set\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523
                        ],
                        "comments": [],
                        "lines": [
                            "    if (_isPinSet) {",
                            "        btSetPin();",
                            "    }",
                            "",
                            "    if (_enableSSP) {",
                            "        log_i(\"Simple Secure Pairing\");",
                            "        esp_bt_sp_param_t param_type = ESP_BT_SP_IOCAP_MODE;",
                            "        esp_bt_io_cap_t iocap = ESP_BT_IO_CAP_IO;",
                            "        esp_bt_gap_set_security_param(param_type, &iocap, sizeof(uint8_t));",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            575,
                            576,
                            577,
                            578,
                            579
                        ],
                        "comments": [],
                        "lines": [
                            "static bool waitForConnect(int timeout) {",
                            "    TickType_t xTicksToWait = timeout / portTICK_PERIOD_MS;",
                            "    return (xEventGroupWaitBits(_spp_event_group, SPP_CONNECTED, pdFALSE, pdTRUE, xTicksToWait) != 0);",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            595
                        ],
                        "comments": [],
                        "lines": [
                            "bool BluetoothSerial::begin(String localName, bool isMaster)"
                        ]
                    },
                    {
                        "line_numbers": [
                            597
                        ],
                        "comments": [],
                        "lines": [
                            "    _isMaster = isMaster;"
                        ]
                    },
                    {
                        "line_numbers": [
                            665,
                            666,
                            667,
                            668,
                            669,
                            670,
                            671,
                            672,
                            673,
                            674,
                            675,
                            676,
                            677,
                            678,
                            679,
                            680,
                            681,
                            682,
                            683,
                            684,
                            685,
                            686,
                            687,
                            688,
                            689,
                            690,
                            691,
                            692,
                            693,
                            694,
                            695,
                            696,
                            697,
                            698,
                            699,
                            700,
                            701,
                            702,
                            703,
                            704,
                            705,
                            706,
                            707,
                            708,
                            709,
                            710,
                            711,
                            712,
                            713,
                            714,
                            715,
                            716,
                            717,
                            718,
                            719,
                            720,
                            721,
                            722,
                            723,
                            724,
                            725,
                            726,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732,
                            733,
                            734,
                            735,
                            736,
                            737,
                            738,
                            739,
                            740,
                            741,
                            742,
                            743,
                            744,
                            745,
                            746,
                            747,
                            748,
                            749,
                            750,
                            751,
                            752,
                            753,
                            754,
                            755,
                            756,
                            757,
                            758,
                            759,
                            760,
                            761,
                            762,
                            763,
                            764,
                            765,
                            766,
                            767,
                            768,
                            769,
                            770,
                            771,
                            772,
                            773,
                            774,
                            775,
                            776,
                            777,
                            778,
                            779,
                            780,
                            781,
                            782,
                            783,
                            784,
                            785,
                            786,
                            787,
                            788,
                            789
                        ],
                        "comments": [
                            "        return true; // nothing to do",
                            "        _pin_len = 0; // resetting pin to none (default)",
                            "    // will first resolve name to address",
                            "        // use resolved or set address first",
                            "        // will resolve name to address first - it may take a while"
                        ],
                        "lines": [
                            "//Simple Secure Pairing",
                            "void BluetoothSerial::enableSSP() {",
                            "    _enableSSP = true;",
                            "}",
                            "/*",
                            "     * Set default parameters for Legacy Pairing",
                            "     * Use fixed pin code",
                            "*/",
                            "bool BluetoothSerial::setPin(const char *pin) {",
                            "    bool isEmpty =  !(pin  && *pin);",
                            "    if (isEmpty && !_isPinSet) {",
                            "    } else if (!isEmpty){",
                            "        _pin_len = strlen(pin);",
                            "        memcpy(_pin_code, pin, _pin_len);",
                            "    } else {",
                            "    }",
                            "    _pin_code[_pin_len] = 0;",
                            "    _isPinSet = true;",
                            "    if (isReady(false, READY_TIMEOUT)) {",
                            "        btSetPin();",
                            "    }",
                            "    return true;",
                            "}",
                            "",
                            "bool BluetoothSerial::connect(String remoteName)",
                            "{",
                            "    if (!isReady(true, READY_TIMEOUT)) return false;",
                            "    if (remoteName && remoteName.length() < 1) {",
                            "        log_e(\"No remote name is provided\");",
                            "        return false;",
                            "    }",
                            "    disconnect();",
                            "    _isRemoteAddressSet = false;",
                            "    strncpy(_remote_name, remoteName.c_str(), ESP_BT_GAP_MAX_BDNAME_LEN);",
                            "    _remote_name[ESP_BT_GAP_MAX_BDNAME_LEN] = 0;",
                            "    log_i(\"master : remoteName\");",
                            "    esp_bt_gap_set_scan_mode(ESP_BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);",
                            "    if (esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, INQ_LEN, INQ_NUM_RSPS) == ESP_OK) {",
                            "        return waitForConnect(SCAN_TIMEOUT);",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "bool BluetoothSerial::connect(uint8_t remoteAddress[])",
                            "{",
                            "    if (!isReady(true, READY_TIMEOUT)) return false;",
                            "    if (!remoteAddress) {",
                            "        log_e(\"No remote address is provided\");",
                            "        return false;",
                            "    }",
                            "    disconnect();",
                            "    _remote_name[0] = 0;",
                            "    _isRemoteAddressSet = true;",
                            "    memcpy(_peer_bd_addr, remoteAddress, ESP_BD_ADDR_LEN);",
                            "    log_i(\"master : remoteAddress\");",
                            "    if (esp_spp_start_discovery(_peer_bd_addr) == ESP_OK) {",
                            "        return waitForConnect(READY_TIMEOUT);",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "bool BluetoothSerial::connect()",
                            "{",
                            "    if (!isReady(true, READY_TIMEOUT)) return false;",
                            "    if (_isRemoteAddressSet){",
                            "        disconnect();",
                            "        log_i(\"master : remoteAddress\");",
                            "        if (esp_spp_start_discovery(_peer_bd_addr) == ESP_OK) {",
                            "            return waitForConnect(READY_TIMEOUT);",
                            "        }",
                            "        return false;",
                            "    } else if (_remote_name[0]) {",
                            "        disconnect();",
                            "        log_i(\"master : remoteName\");",
                            "        esp_bt_gap_set_scan_mode(ESP_BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);",
                            "        if (esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, INQ_LEN, INQ_NUM_RSPS) == ESP_OK) {",
                            "            return waitForConnect(SCAN_TIMEOUT);",
                            "        }",
                            "        return false;",
                            "    }",
                            "    log_e(\"Neither Remote name nor address was provided\");",
                            "    return false;",
                            "}",
                            "",
                            "bool BluetoothSerial::disconnect() {",
                            "    if (_spp_client) {",
                            "        flush();",
                            "        log_i(\"disconnecting\");",
                            "        if (esp_spp_disconnect(_spp_client) == ESP_OK) {",
                            "            TickType_t xTicksToWait = READY_TIMEOUT / portTICK_PERIOD_MS;",
                            "            return (xEventGroupWaitBits(_spp_event_group, SPP_DISCONNECTED, pdFALSE, pdTRUE, xTicksToWait) != 0);",
                            "        }",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "bool BluetoothSerial::unpairDevice(uint8_t remoteAddress[]) {",
                            "    if (isReady(false, READY_TIMEOUT)) {",
                            "        log_i(\"removing bonded device\");",
                            "        return (esp_bt_gap_remove_bond_device(remoteAddress) == ESP_OK);",
                            "    }",
                            "    return false;",
                            "}",
                            "",
                            "bool BluetoothSerial::connected(int timeout) {",
                            "    return waitForConnect(timeout);",
                            "}",
                            "",
                            "bool BluetoothSerial::isReady(bool checkMaster, int timeout) {",
                            "    if (checkMaster && !_isMaster) {",
                            "        log_e(\"Master mode is not active. Call begin(localName, true) to enable Master mode\");",
                            "        return false;",
                            "    }",
                            "    if (!btStarted()) {",
                            "        log_e(\"BT is not initialized. Call begin() first\");",
                            "        return false;",
                            "    }",
                            "    TickType_t xTicksToWait = timeout / portTICK_PERIOD_MS;",
                            "    return (xEventGroupWaitBits(_spp_event_group, SPP_RUNNING, pdFALSE, pdTRUE, xTicksToWait) != 0);",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "123": "            pin_type = ESP_BT_PIN_TYPE_VARIABLE; // pin_code would be ignored (default)",
                "351": "                        peer_bdname_len--; // len includes 0 terminator",
                "399": "            // default pairing pins",
                "676": "        return true; // nothing to do",
                "681": "        _pin_len = 0; // resetting pin to none (default)",
                "703": "    // will first resolve name to address",
                "734": "        // use resolved or set address first",
                "743": "        // will resolve name to address first - it may take a while"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BluetoothSerial.h": [],
    "Kconfig.projbuild": [],
    "Makefile.projbuild": [],
    "no_ota.csv": [],
    "a2d_api.h": [],
    "bta_ar_int.h": [],
    "bta_av_int.h": [],
    "bta_dm_int.h": [],
    "bta_hh_int.h": [],
    "bta_jv_int.h": [],
    "bta_sdp_int.h": [],
    "btc_gatt_common.h": [],
    "rfc_int.h": [],
    "esp_console.h": [],
    "sdmmc_defs.h": [],
    "sdmmc_types.h": [],
    "spi_slave.h": [],
    "esp_mesh.h": [],
    "esp_mesh_internal.h": [],
    "esp_sleep.h": [],
    "esp_wpa2.h": [],
    "esp_wps.h": [],
    "esp_adc_cal.h": [],
    "vfs_fat_internal.h": [],
    "esp_heap_task_info.h": [],
    "ssl_x509.h": [],
    "sens_struct.h": [],
    "soc_memory_layout.h": [],
    "libmesh.a": [],
    "esp8266-compat.h": [],
    "WiFiClientStaticIP.ino": [],
    "mcpwm.h": [],
    "diskio_spiflash.h": [],
    "x509_vfy.h": [],
    "wear_levelling.h": [],
    ".travis.yml": [],
    "CMakeLists.txt": [],
    "AsyncUDPClient.ino": [],
    "AsyncUDPMulticastServer.ino": [],
    "AsyncUDPServer.ino": [],
    "library.json": [],
    "AsyncUDP.cpp": [],
    "AsyncUDP.h": [],
    "ESP_NBNST.ino": [],
    "NetBIOS.cpp": [
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 131,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            131
                        ],
                        "comments": [
                            "// EOF"
                        ],
                        "lines": []
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "131": "// EOF"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "NetBIOS.h": [],
    "AdvancedWebServer.ino": [],
    "FSBrowser.ino": [],
    "edit.htm.gz": [],
    "favicon.ico": [],
    "graphs.js.gz": [],
    "index.htm": [],
    "HelloServer.ino": [],
    "HttpAdvancedAuth.ino": [],
    "HttpBasicAuth.ino": [],
    "SDWebServer.ino": [],
    "pins.png": [],
    "SimpleAuthentification.ino": [],
    "WebUpdate.ino": [],
    "Parsing.cpp": [
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 616,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616
                        ],
                        "comments": [
                            "  // Read the first line of HTTP request",
                            "  // First line of HTTP request looks like \"GET /path HTTP/1.1\"",
                            "  // Retrieve the \"/path\" part by finding the spaces",
                            "  // below is needed only when POST type request",
                            "        // No content - but we can still have arguments in the URL.",
                            "\t\t\t\tdecodedChar = encodedChar;  // normal ascii char"
                        ],
                        "lines": [
                            "  String req = client.readStringUntil('\\r');",
                            "  client.readStringUntil('\\n');",
                            "  //reset header value",
                            "  for (int i = 0; i < _headerKeysCount; ++i) {",
                            "    _currentHeaders[i].value =String();",
                            "   }",
                            "",
                            "  int addr_start = req.indexOf(' ');",
                            "  int addr_end = req.indexOf(' ', addr_start + 1);",
                            "  if (addr_start == -1 || addr_end == -1) {",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "    DEBUG_OUTPUT.print(\"Invalid request: \");",
                            "    DEBUG_OUTPUT.println(req);",
                            "#endif",
                            "    return false;",
                            "  }",
                            "",
                            "  String methodStr = req.substring(0, addr_start);",
                            "  String url = req.substring(addr_start + 1, addr_end);",
                            "  String versionEnd = req.substring(addr_end + 8);",
                            "  _currentVersion = atoi(versionEnd.c_str());",
                            "  String searchStr = \"\";",
                            "  int hasSearch = url.indexOf('?');",
                            "  if (hasSearch != -1){",
                            "    searchStr = url.substring(hasSearch + 1);",
                            "    url = url.substring(0, hasSearch);",
                            "  }",
                            "  _currentUri = url;",
                            "  _chunked = false;",
                            "",
                            "  HTTPMethod method = HTTP_GET;",
                            "  if (methodStr == F(\"POST\")) {",
                            "    method = HTTP_POST;",
                            "  } else if (methodStr == F(\"DELETE\")) {",
                            "    method = HTTP_DELETE;",
                            "  } else if (methodStr == F(\"OPTIONS\")) {",
                            "    method = HTTP_OPTIONS;",
                            "  } else if (methodStr == F(\"PUT\")) {",
                            "    method = HTTP_PUT;",
                            "  } else if (methodStr == F(\"PATCH\")) {",
                            "    method = HTTP_PATCH;",
                            "  }",
                            "  _currentMethod = method;",
                            "",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "  DEBUG_OUTPUT.print(\"method: \");",
                            "  DEBUG_OUTPUT.print(methodStr);",
                            "  DEBUG_OUTPUT.print(\" url: \");",
                            "  DEBUG_OUTPUT.print(url);",
                            "  DEBUG_OUTPUT.print(\" search: \");",
                            "  DEBUG_OUTPUT.println(searchStr);",
                            "#endif",
                            "",
                            "  //attach handler",
                            "  RequestHandler* handler;",
                            "  for (handler = _firstHandler; handler; handler = handler->next()) {",
                            "    if (handler->canHandle(_currentMethod, _currentUri))",
                            "      break;",
                            "  }",
                            "  _currentHandler = handler;",
                            "",
                            "  String formData;",
                            "  if (method == HTTP_POST || method == HTTP_PUT || method == HTTP_PATCH || method == HTTP_DELETE){",
                            "    String boundaryStr;",
                            "    String headerName;",
                            "    String headerValue;",
                            "    bool isForm = false;",
                            "    bool isEncoded = false;",
                            "    uint32_t contentLength = 0;",
                            "    //parse headers",
                            "    while(1){",
                            "      req = client.readStringUntil('\\r');",
                            "      client.readStringUntil('\\n');",
                            "      if (req == \"\") break;//no moar headers",
                            "      int headerDiv = req.indexOf(':');",
                            "      if (headerDiv == -1){",
                            "        break;",
                            "      }",
                            "      headerName = req.substring(0, headerDiv);",
                            "      headerValue = req.substring(headerDiv + 1);",
                            "      headerValue.trim();",
                            "       _collectHeader(headerName.c_str(),headerValue.c_str());",
                            "",
                            "      #ifdef DEBUG_ESP_HTTP_SERVER",
                            "      DEBUG_OUTPUT.print(\"headerName: \");",
                            "      DEBUG_OUTPUT.println(headerName);",
                            "      DEBUG_OUTPUT.print(\"headerValue: \");",
                            "      DEBUG_OUTPUT.println(headerValue);",
                            "      #endif",
                            "",
                            "      if (headerName.equalsIgnoreCase(FPSTR(Content_Type))){",
                            "        using namespace mime;",
                            "        if (headerValue.startsWith(FPSTR(mimeTable[txt].mimeType))){",
                            "          isForm = false;",
                            "        } else if (headerValue.startsWith(F(\"application/x-www-form-urlencoded\"))){",
                            "          isForm = false;",
                            "          isEncoded = true;",
                            "        } else if (headerValue.startsWith(F(\"multipart/\"))){",
                            "          boundaryStr = headerValue.substring(headerValue.indexOf('=') + 1);",
                            "          boundaryStr.replace(\"\\\"\",\"\");",
                            "          isForm = true;",
                            "        }",
                            "      } else if (headerName.equalsIgnoreCase(F(\"Content-Length\"))){",
                            "        contentLength = headerValue.toInt();",
                            "      } else if (headerName.equalsIgnoreCase(F(\"Host\"))){",
                            "        _hostHeader = headerValue;",
                            "      }",
                            "    }",
                            "",
                            "    if (!isForm){",
                            "      size_t plainLength;",
                            "      char* plainBuf = readBytesWithTimeout(client, contentLength, plainLength, HTTP_MAX_POST_WAIT);",
                            "      if (plainLength < contentLength) {",
                            "      \tfree(plainBuf);",
                            "      \treturn false;",
                            "      }",
                            "      if (contentLength > 0) {",
                            "        if(isEncoded){",
                            "          //url encoded form",
                            "          if (searchStr != \"\") searchStr += '&';",
                            "          searchStr += plainBuf;",
                            "        }",
                            "        _parseArguments(searchStr);",
                            "        if(!isEncoded){",
                            "          //plain post json or other data",
                            "          RequestArgument& arg = _currentArgs[_currentArgCount++];",
                            "          arg.key = F(\"plain\");",
                            "          arg.value = String(plainBuf);",
                            "        }",
                            "",
                            "  #ifdef DEBUG_ESP_HTTP_SERVER",
                            "        DEBUG_OUTPUT.print(\"Plain: \");",
                            "        DEBUG_OUTPUT.println(plainBuf);",
                            "  #endif",
                            "        free(plainBuf);",
                            "      } else {",
                            "        _parseArguments(searchStr);",
                            "      }",
                            "    }",
                            "",
                            "    if (isForm){",
                            "      _parseArguments(searchStr);",
                            "      if (!_parseForm(client, boundaryStr, contentLength)) {",
                            "        return false;",
                            "      }",
                            "    }",
                            "  } else {",
                            "    String headerName;",
                            "    String headerValue;",
                            "    //parse headers",
                            "    while(1){",
                            "      req = client.readStringUntil('\\r');",
                            "      client.readStringUntil('\\n');",
                            "      if (req == \"\") break;//no moar headers",
                            "      int headerDiv = req.indexOf(':');",
                            "      if (headerDiv == -1){",
                            "        break;",
                            "      }",
                            "      headerName = req.substring(0, headerDiv);",
                            "      headerValue = req.substring(headerDiv + 2);",
                            "      _collectHeader(headerName.c_str(),headerValue.c_str());",
                            "",
                            "\t  #ifdef DEBUG_ESP_HTTP_SERVER",
                            "\t  DEBUG_OUTPUT.print(\"headerName: \");",
                            "\t  DEBUG_OUTPUT.println(headerName);",
                            "\t  DEBUG_OUTPUT.print(\"headerValue: \");",
                            "\t  DEBUG_OUTPUT.println(headerValue);",
                            "\t  #endif",
                            "",
                            "\t  if (headerName.equalsIgnoreCase(\"Host\")){",
                            "        _hostHeader = headerValue;",
                            "      }",
                            "    }",
                            "    _parseArguments(searchStr);",
                            "  }",
                            "  client.flush();",
                            "",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "  DEBUG_OUTPUT.print(\"Request: \");",
                            "  DEBUG_OUTPUT.println(url);",
                            "  DEBUG_OUTPUT.print(\" Arguments: \");",
                            "  DEBUG_OUTPUT.println(searchStr);",
                            "#endif",
                            "",
                            "  return true;",
                            "}",
                            "",
                            "bool WebServer::_collectHeader(const char* headerName, const char* headerValue) {",
                            "  for (int i = 0; i < _headerKeysCount; i++) {",
                            "    if (_currentHeaders[i].key.equalsIgnoreCase(headerName)) {",
                            "            _currentHeaders[i].value=headerValue;",
                            "            return true;",
                            "        }",
                            "  }",
                            "  return false;",
                            "}",
                            "",
                            "void WebServer::_parseArguments(String data) {",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "  DEBUG_OUTPUT.print(\"args: \");",
                            "  DEBUG_OUTPUT.println(data);",
                            "#endif",
                            "  if (_currentArgs)",
                            "    delete[] _currentArgs;",
                            "  _currentArgs = 0;",
                            "  if (data.length() == 0) {",
                            "    _currentArgCount = 0;",
                            "    _currentArgs = new RequestArgument[1];",
                            "    return;",
                            "  }",
                            "  _currentArgCount = 1;",
                            "",
                            "  for (int i = 0; i < (int)data.length(); ) {",
                            "    i = data.indexOf('&', i);",
                            "    if (i == -1)",
                            "      break;",
                            "    ++i;",
                            "    ++_currentArgCount;",
                            "  }",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "  DEBUG_OUTPUT.print(\"args count: \");",
                            "  DEBUG_OUTPUT.println(_currentArgCount);",
                            "#endif",
                            "",
                            "  _currentArgs = new RequestArgument[_currentArgCount+1];",
                            "  int pos = 0;",
                            "  int iarg;",
                            "  for (iarg = 0; iarg < _currentArgCount;) {",
                            "    int equal_sign_index = data.indexOf('=', pos);",
                            "    int next_arg_index = data.indexOf('&', pos);",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "    DEBUG_OUTPUT.print(\"pos \");",
                            "    DEBUG_OUTPUT.print(pos);",
                            "    DEBUG_OUTPUT.print(\"=@ \");",
                            "    DEBUG_OUTPUT.print(equal_sign_index);",
                            "    DEBUG_OUTPUT.print(\" &@ \");",
                            "    DEBUG_OUTPUT.println(next_arg_index);",
                            "#endif",
                            "    if ((equal_sign_index == -1) || ((equal_sign_index > next_arg_index) && (next_arg_index != -1))) {",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "      DEBUG_OUTPUT.print(\"arg missing value: \");",
                            "      DEBUG_OUTPUT.println(iarg);",
                            "#endif",
                            "      if (next_arg_index == -1)",
                            "        break;",
                            "      pos = next_arg_index + 1;",
                            "      continue;",
                            "    }",
                            "    RequestArgument& arg = _currentArgs[iarg];",
                            "    arg.key = urlDecode(data.substring(pos, equal_sign_index));",
                            "    arg.value = urlDecode(data.substring(equal_sign_index + 1, next_arg_index));",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "    DEBUG_OUTPUT.print(\"arg \");",
                            "    DEBUG_OUTPUT.print(iarg);",
                            "    DEBUG_OUTPUT.print(\" key: \");",
                            "    DEBUG_OUTPUT.print(arg.key);",
                            "    DEBUG_OUTPUT.print(\" value: \");",
                            "    DEBUG_OUTPUT.println(arg.value);",
                            "#endif",
                            "    ++iarg;",
                            "    if (next_arg_index == -1)",
                            "      break;",
                            "    pos = next_arg_index + 1;",
                            "  }",
                            "  _currentArgCount = iarg;",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "  DEBUG_OUTPUT.print(\"args count: \");",
                            "  DEBUG_OUTPUT.println(_currentArgCount);",
                            "#endif",
                            "",
                            "}",
                            "",
                            "void WebServer::_uploadWriteByte(uint8_t b){",
                            "  if (_currentUpload->currentSize == HTTP_UPLOAD_BUFLEN){",
                            "    if(_currentHandler && _currentHandler->canUpload(_currentUri))",
                            "      _currentHandler->upload(*this, _currentUri, *_currentUpload);",
                            "    _currentUpload->totalSize += _currentUpload->currentSize;",
                            "    _currentUpload->currentSize = 0;",
                            "  }",
                            "  _currentUpload->buf[_currentUpload->currentSize++] = b;",
                            "}",
                            "",
                            "uint8_t WebServer::_uploadReadByte(WiFiClient& client){",
                            "  int res = client.read();",
                            "  if(res == -1){",
                            "    while(!client.available() && client.connected())",
                            "      yield();",
                            "    res = client.read();",
                            "  }",
                            "  return (uint8_t)res;",
                            "}",
                            "",
                            "bool WebServer::_parseForm(WiFiClient& client, String boundary, uint32_t len){",
                            "  (void) len;",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "  DEBUG_OUTPUT.print(\"Parse Form: Boundary: \");",
                            "  DEBUG_OUTPUT.print(boundary);",
                            "  DEBUG_OUTPUT.print(\" Length: \");",
                            "  DEBUG_OUTPUT.println(len);",
                            "#endif",
                            "  String line;",
                            "  int retry = 0;",
                            "  do {",
                            "    line = client.readStringUntil('\\r');",
                            "    ++retry;",
                            "  } while (line.length() == 0 && retry < 3);",
                            "",
                            "  client.readStringUntil('\\n');",
                            "  //start reading the form",
                            "  if (line == (\"--\"+boundary)){",
                            "    RequestArgument* postArgs = new RequestArgument[32];",
                            "    int postArgsLen = 0;",
                            "    while(1){",
                            "      String argName;",
                            "      String argValue;",
                            "      String argType;",
                            "      String argFilename;",
                            "      bool argIsFile = false;",
                            "",
                            "      line = client.readStringUntil('\\r');",
                            "      client.readStringUntil('\\n');",
                            "      if (line.length() > 19 && line.substring(0, 19).equalsIgnoreCase(F(\"Content-Disposition\"))){",
                            "        int nameStart = line.indexOf('=');",
                            "        if (nameStart != -1){",
                            "          argName = line.substring(nameStart+2);",
                            "          nameStart = argName.indexOf('=');",
                            "          if (nameStart == -1){",
                            "            argName = argName.substring(0, argName.length() - 1);",
                            "          } else {",
                            "            argFilename = argName.substring(nameStart+2, argName.length() - 1);",
                            "            argName = argName.substring(0, argName.indexOf('\"'));",
                            "            argIsFile = true;",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "            DEBUG_OUTPUT.print(\"PostArg FileName: \");",
                            "            DEBUG_OUTPUT.println(argFilename);",
                            "#endif",
                            "            //use GET to set the filename if uploading using blob",
                            "            if (argFilename == F(\"blob\") && hasArg(FPSTR(filename)))",
                            "              argFilename = arg(FPSTR(filename));",
                            "          }",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "          DEBUG_OUTPUT.print(\"PostArg Name: \");",
                            "          DEBUG_OUTPUT.println(argName);",
                            "#endif",
                            "          using namespace mime;",
                            "          argType = FPSTR(mimeTable[txt].mimeType);",
                            "          line = client.readStringUntil('\\r');",
                            "          client.readStringUntil('\\n');",
                            "          if (line.length() > 12 && line.substring(0, 12).equalsIgnoreCase(FPSTR(Content_Type))){",
                            "            argType = line.substring(line.indexOf(':')+2);",
                            "            //skip next line",
                            "            client.readStringUntil('\\r');",
                            "            client.readStringUntil('\\n');",
                            "          }",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "          DEBUG_OUTPUT.print(\"PostArg Type: \");",
                            "          DEBUG_OUTPUT.println(argType);",
                            "#endif",
                            "          if (!argIsFile){",
                            "            while(1){",
                            "              line = client.readStringUntil('\\r');",
                            "              client.readStringUntil('\\n');",
                            "              if (line.startsWith(\"--\"+boundary)) break;",
                            "              if (argValue.length() > 0) argValue += \"\\n\";",
                            "              argValue += line;",
                            "            }",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "            DEBUG_OUTPUT.print(\"PostArg Value: \");",
                            "            DEBUG_OUTPUT.println(argValue);",
                            "            DEBUG_OUTPUT.println();",
                            "#endif",
                            "",
                            "            RequestArgument& arg = postArgs[postArgsLen++];",
                            "            arg.key = argName;",
                            "            arg.value = argValue;",
                            "",
                            "            if (line == (\"--\"+boundary+\"--\")){",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "              DEBUG_OUTPUT.println(\"Done Parsing POST\");",
                            "#endif",
                            "              break;",
                            "            }",
                            "          } else {",
                            "            _currentUpload.reset(new HTTPUpload());",
                            "            _currentUpload->status = UPLOAD_FILE_START;",
                            "            _currentUpload->name = argName;",
                            "            _currentUpload->filename = argFilename;",
                            "            _currentUpload->type = argType;",
                            "            _currentUpload->totalSize = 0;",
                            "            _currentUpload->currentSize = 0;",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "            DEBUG_OUTPUT.print(\"Start File: \");",
                            "            DEBUG_OUTPUT.print(_currentUpload->filename);",
                            "            DEBUG_OUTPUT.print(\" Type: \");",
                            "            DEBUG_OUTPUT.println(_currentUpload->type);",
                            "#endif",
                            "            if(_currentHandler && _currentHandler->canUpload(_currentUri))",
                            "              _currentHandler->upload(*this, _currentUri, *_currentUpload);",
                            "            _currentUpload->status = UPLOAD_FILE_WRITE;",
                            "            uint8_t argByte = _uploadReadByte(client);",
                            "readfile:",
                            "            while(argByte != 0x0D){",
                            "              if (!client.connected()) return _parseFormUploadAborted();",
                            "              _uploadWriteByte(argByte);",
                            "              argByte = _uploadReadByte(client);",
                            "            }",
                            "",
                            "            argByte = _uploadReadByte(client);",
                            "            if (!client.connected()) return _parseFormUploadAborted();",
                            "            if (argByte == 0x0A){",
                            "              argByte = _uploadReadByte(client);",
                            "              if (!client.connected()) return _parseFormUploadAborted();",
                            "              if ((char)argByte != '-'){",
                            "                //continue reading the file",
                            "                _uploadWriteByte(0x0D);",
                            "                _uploadWriteByte(0x0A);",
                            "                goto readfile;",
                            "              } else {",
                            "                argByte = _uploadReadByte(client);",
                            "                if (!client.connected()) return _parseFormUploadAborted();",
                            "                if ((char)argByte != '-'){",
                            "                  //continue reading the file",
                            "                  _uploadWriteByte(0x0D);",
                            "                  _uploadWriteByte(0x0A);",
                            "                  _uploadWriteByte((uint8_t)('-'));",
                            "                  goto readfile;",
                            "                }",
                            "              }",
                            "",
                            "              uint8_t endBuf[boundary.length()];",
                            "              client.readBytes(endBuf, boundary.length());",
                            "",
                            "              if (strstr((const char*)endBuf, boundary.c_str()) != NULL){",
                            "                if(_currentHandler && _currentHandler->canUpload(_currentUri))",
                            "                  _currentHandler->upload(*this, _currentUri, *_currentUpload);",
                            "                _currentUpload->totalSize += _currentUpload->currentSize;",
                            "                _currentUpload->status = UPLOAD_FILE_END;",
                            "                if(_currentHandler && _currentHandler->canUpload(_currentUri))",
                            "                  _currentHandler->upload(*this, _currentUri, *_currentUpload);",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "                DEBUG_OUTPUT.print(\"End File: \");",
                            "                DEBUG_OUTPUT.print(_currentUpload->filename);",
                            "                DEBUG_OUTPUT.print(\" Type: \");",
                            "                DEBUG_OUTPUT.print(_currentUpload->type);",
                            "                DEBUG_OUTPUT.print(\" Size: \");",
                            "                DEBUG_OUTPUT.println(_currentUpload->totalSize);",
                            "#endif",
                            "                line = client.readStringUntil(0x0D);",
                            "                client.readStringUntil(0x0A);",
                            "                if (line == \"--\"){",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "                  DEBUG_OUTPUT.println(\"Done Parsing POST\");",
                            "#endif",
                            "                  break;",
                            "                }",
                            "                continue;",
                            "              } else {",
                            "                _uploadWriteByte(0x0D);",
                            "                _uploadWriteByte(0x0A);",
                            "                _uploadWriteByte((uint8_t)('-'));",
                            "                _uploadWriteByte((uint8_t)('-'));",
                            "                uint32_t i = 0;",
                            "                while(i < boundary.length()){",
                            "                  _uploadWriteByte(endBuf[i++]);",
                            "                }",
                            "                argByte = _uploadReadByte(client);",
                            "                goto readfile;",
                            "              }",
                            "            } else {",
                            "              _uploadWriteByte(0x0D);",
                            "              goto readfile;",
                            "            }",
                            "            break;",
                            "          }",
                            "        }",
                            "      }",
                            "    }",
                            "",
                            "    int iarg;",
                            "    int totalArgs = ((32 - postArgsLen) < _currentArgCount)?(32 - postArgsLen):_currentArgCount;",
                            "    for (iarg = 0; iarg < totalArgs; iarg++){",
                            "      RequestArgument& arg = postArgs[postArgsLen++];",
                            "      arg.key = _currentArgs[iarg].key;",
                            "      arg.value = _currentArgs[iarg].value;",
                            "    }",
                            "    if (_currentArgs) delete[] _currentArgs;",
                            "    _currentArgs = new RequestArgument[postArgsLen];",
                            "    for (iarg = 0; iarg < postArgsLen; iarg++){",
                            "      RequestArgument& arg = _currentArgs[iarg];",
                            "      arg.key = postArgs[iarg].key;",
                            "      arg.value = postArgs[iarg].value;",
                            "    }",
                            "    _currentArgCount = iarg;",
                            "    if (postArgs)",
                            "      delete[] postArgs;",
                            "    return true;",
                            "  }",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "  DEBUG_OUTPUT.print(\"Error: line: \");",
                            "  DEBUG_OUTPUT.println(line);",
                            "#endif",
                            "  return false;",
                            "}",
                            "",
                            "String WebServer::urlDecode(const String& text)",
                            "{",
                            "\tString decoded = \"\";",
                            "\tchar temp[] = \"0x00\";",
                            "\tunsigned int len = text.length();",
                            "\tunsigned int i = 0;",
                            "\twhile (i < len)",
                            "\t{",
                            "\t\tchar decodedChar;",
                            "\t\tchar encodedChar = text.charAt(i++);",
                            "\t\tif ((encodedChar == '%') && (i + 1 < len))",
                            "\t\t{",
                            "\t\t\ttemp[2] = text.charAt(i++);",
                            "\t\t\ttemp[3] = text.charAt(i++);",
                            "",
                            "\t\t\tdecodedChar = strtol(temp, NULL, 16);",
                            "\t\t}",
                            "\t\telse {",
                            "\t\t\tif (encodedChar == '+')",
                            "\t\t\t{",
                            "\t\t\t\tdecodedChar = ' ';",
                            "\t\t\t}",
                            "\t\t\telse {",
                            "\t\t\t}",
                            "\t\t}",
                            "\t\tdecoded += decodedChar;",
                            "\t}",
                            "\treturn decoded;",
                            "}",
                            "",
                            "bool WebServer::_parseFormUploadAborted(){",
                            "  _currentUpload->status = UPLOAD_FILE_ABORTED;",
                            "  if(_currentHandler && _currentHandler->canUpload(_currentUri))",
                            "    _currentHandler->upload(*this, _currentUri, *_currentUpload);",
                            "  return false;",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "71": "  // Read the first line of HTTP request",
                "79": "  // First line of HTTP request looks like \"GET /path HTTP/1.1\"",
                "80": "  // Retrieve the \"/path\" part by finding the spaces",
                "136": "  // below is needed only when POST type request",
                "211": "        // No content - but we can still have arguments in the URL.",
                "603": "\t\t\t\tdecodedChar = encodedChar;  // normal ascii char"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "25c0b52212798f64552c43111447a49cef3575fd",
            "timestamp": "2019-04-12T12:45:35+02:00",
            "author": "Victor Aprea",
            "commit_message": "Alternative Improve _uploadReadByte  (#2656)\n\n* add opportunity for more than one retry to _uploadReadByte\r\n\r\n* an alternative timeout-based method to making _uploadReadByte more resilient\r\n\r\n* move timing variables in the correct scope\r\n\r\n* implement and use client.getTimeout instead of hard-coded timeout in _uploadReadByte\r\n\r\n* add missing return\r\n\r\n* some refactoring to address respecting the timeout in a potentially deadlocked connection\r\n\r\n* fix spelling in comment\r\n\r\n* address review comments; move impl to cpp file for getTimeout, and remove local variable for currentMillis\r\n\r\n* remove redundant cast\r\n\r\n* need to check for timeout outside the inner while as well\r\n\r\n* update WebUpdate example to print something in unexpected callback condition\r\n\r\n* update log_e messages per review comments",
            "additions": 34,
            "deletions": 4,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339
                        ],
                        "comments": [
                            "    // keep trying until you either read a valid byte or timeout",
                            "      // loosely modeled after blinkWithoutDelay pattern",
                            "        return res; // exit on a valid read",
                            "      // NOTE: it is possible to get here and have all of the following",
                            "      //       assertions hold true",
                            "      //       -- client.available() > 0",
                            "      //       -- client.connected == true",
                            "      //       -- res == -1",
                            "      //       a simple retry strategy overcomes this which is to say the",
                            "      //       assertion is not permanent, but the reason that this works",
                            "      //       is elusive, and possibly indicative of a more subtle underlying",
                            "      //       issue",
                            "        return res; // exit on a timeout"
                        ],
                        "lines": [
                            "    unsigned long startMillis = millis();",
                            "    long timeoutIntervalMillis = client.getTimeout();",
                            "    boolean timedOut = false;",
                            "    for(;;) {",
                            "      while(!timedOut && !client.available() && client.connected()){",
                            "        delay(2);",
                            "        timedOut = millis() - startMillis >= timeoutIntervalMillis;",
                            "      }",
                            "",
                            "      res = client.read();",
                            "      if(res >= 0) {",
                            "      }",
                            "      //",
                            "      //",
                            "",
                            "      timedOut = millis() - startMillis >= timeoutIntervalMillis;",
                            "      if(timedOut) {",
                            "      }",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            341
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "308": "    // keep trying until you either read a valid byte or timeout",
                "313": "      // loosely modeled after blinkWithoutDelay pattern",
                "321": "        return res; // exit on a valid read",
                "323": "      // NOTE: it is possible to get here and have all of the following",
                "324": "      //       assertions hold true",
                "326": "      //       -- client.available() > 0",
                "327": "      //       -- client.connected == true",
                "328": "      //       -- res == -1",
                "330": "      //       a simple retry strategy overcomes this which is to say the",
                "331": "      //       assertion is not permanent, but the reason that this works",
                "332": "      //       is elusive, and possibly indicative of a more subtle underlying",
                "333": "      //       issue",
                "337": "        return res; // exit on a timeout"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "WebServer.cpp": [
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 676,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645,
                            646,
                            647,
                            648,
                            649,
                            650,
                            651,
                            652,
                            653,
                            654,
                            655,
                            656,
                            657,
                            658,
                            659,
                            660,
                            661,
                            662,
                            663,
                            664,
                            665,
                            666,
                            667,
                            668,
                            669,
                            670,
                            671,
                            672,
                            673,
                            674,
                            675,
                            676
                        ],
                        "comments": [
                            "      // extracting required parameters for RFC 2069 simpler Digest",
                            "      // parameters for the RFC 2617 newer Digest",
                            "  char buffer[33];  // buffer to hold 32 Hex Digit + /0",
                            "      // No-op to avoid C++ compiler warning",
                            "      // Wait for data from client to become available",
                            "      } else { // !_currentClient.available()",
                            "      // Wait for client to close the connection",
                            "    // Can we asume the following?",
                            "    //  _contentLength = CONTENT_LENGTH_UNKNOWN;"
                        ],
                        "lines": [
                            "      String _realm    = _extractParam(authReq, F(\"realm=\\\"\"));",
                            "      String _nonce    = _extractParam(authReq, F(\"nonce=\\\"\"));",
                            "      String _uri      = _extractParam(authReq, F(\"uri=\\\"\"));",
                            "      String _response = _extractParam(authReq, F(\"response=\\\"\"));",
                            "      String _opaque   = _extractParam(authReq, F(\"opaque=\\\"\"));",
                            "",
                            "      if((!_realm.length()) || (!_nonce.length()) || (!_uri.length()) || (!_response.length()) || (!_opaque.length())) {",
                            "        authReq = \"\";",
                            "        return false;",
                            "      }",
                            "      if((_opaque != _sopaque) || (_nonce != _snonce) || (_realm != _srealm)) {",
                            "        authReq = \"\";",
                            "        return false;",
                            "      }",
                            "      String _nc,_cnonce;",
                            "      if(authReq.indexOf(FPSTR(qop_auth)) != -1) {",
                            "        _nc = _extractParam(authReq, F(\"nc=\"), ',');",
                            "        _cnonce = _extractParam(authReq, F(\"cnonce=\\\"\"));",
                            "      }",
                            "      String _H1 = md5str(String(username) + ':' + _realm + ':' + String(password));",
                            "      #ifdef DEBUG_ESP_HTTP_SERVER",
                            "      DEBUG_OUTPUT.println(\"Hash of user:realm:pass=\" + _H1);",
                            "      #endif",
                            "      String _H2 = \"\";",
                            "      if(_currentMethod == HTTP_GET){",
                            "          _H2 = md5str(String(F(\"GET:\")) + _uri);",
                            "      }else if(_currentMethod == HTTP_POST){",
                            "          _H2 = md5str(String(F(\"POST:\")) + _uri);",
                            "      }else if(_currentMethod == HTTP_PUT){",
                            "          _H2 = md5str(String(F(\"PUT:\")) + _uri);",
                            "      }else if(_currentMethod == HTTP_DELETE){",
                            "          _H2 = md5str(String(F(\"DELETE:\")) + _uri);",
                            "      }else{",
                            "          _H2 = md5str(String(F(\"GET:\")) + _uri);",
                            "      }",
                            "      #ifdef DEBUG_ESP_HTTP_SERVER",
                            "      DEBUG_OUTPUT.println(\"Hash of GET:uri=\" + _H2);",
                            "      #endif",
                            "      String _responsecheck = \"\";",
                            "      if(authReq.indexOf(FPSTR(qop_auth)) != -1) {",
                            "          _responsecheck = md5str(_H1 + ':' + _nonce + ':' + _nc + ':' + _cnonce + F(\":auth:\") + _H2);",
                            "      } else {",
                            "          _responsecheck = md5str(_H1 + ':' + _nonce + ':' + _H2);",
                            "      }",
                            "      #ifdef DEBUG_ESP_HTTP_SERVER",
                            "      DEBUG_OUTPUT.println(\"The Proper response=\" +_responsecheck);",
                            "      #endif",
                            "      if(_response == _responsecheck){",
                            "        authReq = \"\";",
                            "        return true;",
                            "      }",
                            "    }",
                            "    authReq = \"\";",
                            "  }",
                            "  return false;",
                            "}",
                            "",
                            "String WebServer::_getRandomHexString() {",
                            "  int i;",
                            "  for(i = 0; i < 4; i++) {",
                            "    sprintf (buffer + (i*8), \"%08x\", esp_random());",
                            "  }",
                            "  return String(buffer);",
                            "}",
                            "",
                            "void WebServer::requestAuthentication(HTTPAuthMethod mode, const char* realm, const String& authFailMsg) {",
                            "  if(realm == NULL) {",
                            "    _srealm = String(F(\"Login Required\"));",
                            "  } else {",
                            "    _srealm = String(realm);",
                            "  }",
                            "  if(mode == BASIC_AUTH) {",
                            "    sendHeader(String(FPSTR(WWW_Authenticate)), String(F(\"Basic realm=\\\"\")) + _srealm + String(F(\"\\\"\")));",
                            "  } else {",
                            "    _snonce=_getRandomHexString();",
                            "    _sopaque=_getRandomHexString();",
                            "    sendHeader(String(FPSTR(WWW_Authenticate)), String(F(\"Digest realm=\\\"\")) +_srealm + String(F(\"\\\", qop=\\\"auth\\\", nonce=\\\"\")) + _snonce + String(F(\"\\\", opaque=\\\"\")) + _sopaque + String(F(\"\\\"\")));",
                            "  }",
                            "  using namespace mime;",
                            "  send(401, String(FPSTR(mimeTable[html].mimeType)), authFailMsg);",
                            "}",
                            "",
                            "void WebServer::on(const String &uri, WebServer::THandlerFunction handler) {",
                            "  on(uri, HTTP_ANY, handler);",
                            "}",
                            "",
                            "void WebServer::on(const String &uri, HTTPMethod method, WebServer::THandlerFunction fn) {",
                            "  on(uri, method, fn, _fileUploadHandler);",
                            "}",
                            "",
                            "void WebServer::on(const String &uri, HTTPMethod method, WebServer::THandlerFunction fn, WebServer::THandlerFunction ufn) {",
                            "  _addRequestHandler(new FunctionRequestHandler(fn, ufn, uri, method));",
                            "}",
                            "",
                            "void WebServer::addHandler(RequestHandler* handler) {",
                            "    _addRequestHandler(handler);",
                            "}",
                            "",
                            "void WebServer::_addRequestHandler(RequestHandler* handler) {",
                            "    if (!_lastHandler) {",
                            "      _firstHandler = handler;",
                            "      _lastHandler = handler;",
                            "    }",
                            "    else {",
                            "      _lastHandler->next(handler);",
                            "      _lastHandler = handler;",
                            "    }",
                            "}",
                            "",
                            "void WebServer::serveStatic(const char* uri, FS& fs, const char* path, const char* cache_header) {",
                            "    _addRequestHandler(new StaticRequestHandler(fs, path, uri, cache_header));",
                            "}",
                            "",
                            "void WebServer::handleClient() {",
                            "  if (_currentStatus == HC_NONE) {",
                            "    WiFiClient client = _server.available();",
                            "    if (!client) {",
                            "      return;",
                            "    }",
                            "",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "    DEBUG_OUTPUT.println(\"New client\");",
                            "#endif",
                            "",
                            "    _currentClient = client;",
                            "    _currentStatus = HC_WAIT_READ;",
                            "    _statusChange = millis();",
                            "  }",
                            "",
                            "  bool keepCurrentClient = false;",
                            "  bool callYield = false;",
                            "",
                            "  if (_currentClient.connected()) {",
                            "    switch (_currentStatus) {",
                            "    case HC_NONE:",
                            "      break;",
                            "    case HC_WAIT_READ:",
                            "      if (_currentClient.available()) {",
                            "        if (_parseRequest(_currentClient)) {",
                            "          _currentClient.setTimeout(HTTP_MAX_SEND_WAIT);",
                            "          _contentLength = CONTENT_LENGTH_NOT_SET;",
                            "          _handleRequest();",
                            "",
                            "          if (_currentClient.connected()) {",
                            "            _currentStatus = HC_WAIT_CLOSE;",
                            "            _statusChange = millis();",
                            "            keepCurrentClient = true;",
                            "          }",
                            "        }",
                            "        if (millis() - _statusChange <= HTTP_MAX_DATA_WAIT) {",
                            "          keepCurrentClient = true;",
                            "        }",
                            "        callYield = true;",
                            "      }",
                            "      break;",
                            "    case HC_WAIT_CLOSE:",
                            "      if (millis() - _statusChange <= HTTP_MAX_CLOSE_WAIT) {",
                            "        keepCurrentClient = true;",
                            "        callYield = true;",
                            "      }",
                            "    }",
                            "  }",
                            "",
                            "  if (!keepCurrentClient) {",
                            "    _currentClient = WiFiClient();",
                            "    _currentStatus = HC_NONE;",
                            "    _currentUpload.reset();",
                            "  }",
                            "",
                            "  if (callYield) {",
                            "    yield();",
                            "  }",
                            "}",
                            "",
                            "void WebServer::close() {",
                            "  _server.close();",
                            "  _currentStatus = HC_NONE;",
                            "  if(!_headerKeysCount)",
                            "    collectHeaders(0, 0);",
                            "}",
                            "",
                            "void WebServer::stop() {",
                            "  close();",
                            "}",
                            "",
                            "void WebServer::sendHeader(const String& name, const String& value, bool first) {",
                            "  String headerLine = name;",
                            "  headerLine += F(\": \");",
                            "  headerLine += value;",
                            "  headerLine += \"\\r\\n\";",
                            "",
                            "  if (first) {",
                            "    _responseHeaders = headerLine + _responseHeaders;",
                            "  }",
                            "  else {",
                            "    _responseHeaders += headerLine;",
                            "  }",
                            "}",
                            "",
                            "void WebServer::setContentLength(const size_t contentLength) {",
                            "    _contentLength = contentLength;",
                            "}",
                            "",
                            "void WebServer::_prepareHeader(String& response, int code, const char* content_type, size_t contentLength) {",
                            "    response = String(F(\"HTTP/1.\")) + String(_currentVersion) + ' ';",
                            "    response += String(code);",
                            "    response += ' ';",
                            "    response += _responseCodeToString(code);",
                            "    response += \"\\r\\n\";",
                            "",
                            "    using namespace mime;",
                            "    if (!content_type)",
                            "        content_type = mimeTable[html].mimeType;",
                            "",
                            "    sendHeader(String(F(\"Content-Type\")), String(FPSTR(content_type)), true);",
                            "    if (_contentLength == CONTENT_LENGTH_NOT_SET) {",
                            "        sendHeader(String(FPSTR(Content_Length)), String(contentLength));",
                            "    } else if (_contentLength != CONTENT_LENGTH_UNKNOWN) {",
                            "        sendHeader(String(FPSTR(Content_Length)), String(_contentLength));",
                            "    } else if(_contentLength == CONTENT_LENGTH_UNKNOWN && _currentVersion){ //HTTP/1.1 or above client",
                            "      //let's do chunked",
                            "      _chunked = true;",
                            "      sendHeader(String(F(\"Accept-Ranges\")),String(F(\"none\")));",
                            "      sendHeader(String(F(\"Transfer-Encoding\")),String(F(\"chunked\")));",
                            "    }",
                            "    sendHeader(String(F(\"Connection\")), String(F(\"close\")));",
                            "",
                            "    response += _responseHeaders;",
                            "    response += \"\\r\\n\";",
                            "    _responseHeaders = \"\";",
                            "}",
                            "",
                            "void WebServer::send(int code, const char* content_type, const String& content) {",
                            "    String header;",
                            "    //if(code == 200 && content.length() == 0 && _contentLength == CONTENT_LENGTH_NOT_SET)",
                            "    _prepareHeader(header, code, content_type, content.length());",
                            "    _currentClientWrite(header.c_str(), header.length());",
                            "    if(content.length())",
                            "      sendContent(content);",
                            "}",
                            "",
                            "void WebServer::send_P(int code, PGM_P content_type, PGM_P content) {",
                            "    size_t contentLength = 0;",
                            "",
                            "    if (content != NULL) {",
                            "        contentLength = strlen_P(content);",
                            "    }",
                            "",
                            "    String header;",
                            "    char type[64];",
                            "    memccpy_P((void*)type, (PGM_VOID_P)content_type, 0, sizeof(type));",
                            "    _prepareHeader(header, code, (const char* )type, contentLength);",
                            "    _currentClientWrite(header.c_str(), header.length());",
                            "    sendContent_P(content);",
                            "}",
                            "",
                            "void WebServer::send_P(int code, PGM_P content_type, PGM_P content, size_t contentLength) {",
                            "    String header;",
                            "    char type[64];",
                            "    memccpy_P((void*)type, (PGM_VOID_P)content_type, 0, sizeof(type));",
                            "    _prepareHeader(header, code, (const char* )type, contentLength);",
                            "    sendContent(header);",
                            "    sendContent_P(content, contentLength);",
                            "}",
                            "",
                            "void WebServer::send(int code, char* content_type, const String& content) {",
                            "  send(code, (const char*)content_type, content);",
                            "}",
                            "",
                            "void WebServer::send(int code, const String& content_type, const String& content) {",
                            "  send(code, (const char*)content_type.c_str(), content);",
                            "}",
                            "",
                            "void WebServer::sendContent(const String& content) {",
                            "  const char * footer = \"\\r\\n\";",
                            "  size_t len = content.length();",
                            "  if(_chunked) {",
                            "    char * chunkSize = (char *)malloc(11);",
                            "    if(chunkSize){",
                            "      sprintf(chunkSize, \"%x%s\", len, footer);",
                            "      _currentClientWrite(chunkSize, strlen(chunkSize));",
                            "      free(chunkSize);",
                            "    }",
                            "  }",
                            "  _currentClientWrite(content.c_str(), len);",
                            "  if(_chunked){",
                            "    _currentClient.write(footer, 2);",
                            "    if (len == 0) {",
                            "      _chunked = false;",
                            "    }",
                            "  }",
                            "}",
                            "",
                            "void WebServer::sendContent_P(PGM_P content) {",
                            "  sendContent_P(content, strlen_P(content));",
                            "}",
                            "",
                            "void WebServer::sendContent_P(PGM_P content, size_t size) {",
                            "  const char * footer = \"\\r\\n\";",
                            "  if(_chunked) {",
                            "    char * chunkSize = (char *)malloc(11);",
                            "    if(chunkSize){",
                            "      sprintf(chunkSize, \"%x%s\", size, footer);",
                            "      _currentClientWrite(chunkSize, strlen(chunkSize));",
                            "      free(chunkSize);",
                            "    }",
                            "  }",
                            "  _currentClientWrite_P(content, size);",
                            "  if(_chunked){",
                            "    _currentClient.write(footer, 2);",
                            "    if (size == 0) {",
                            "      _chunked = false;",
                            "    }",
                            "  }",
                            "}",
                            "",
                            "",
                            "void WebServer::_streamFileCore(const size_t fileSize, const String & fileName, const String & contentType)",
                            "{",
                            "  using namespace mime;",
                            "  setContentLength(fileSize);",
                            "  if (fileName.endsWith(String(FPSTR(mimeTable[gz].endsWith))) &&",
                            "      contentType != String(FPSTR(mimeTable[gz].mimeType)) &&",
                            "      contentType != String(FPSTR(mimeTable[none].mimeType))) {",
                            "    sendHeader(F(\"Content-Encoding\"), F(\"gzip\"));",
                            "  }",
                            "  send(200, contentType, \"\");",
                            "}",
                            "",
                            "",
                            "String WebServer::arg(String name) {",
                            "  for (int i = 0; i < _currentArgCount; ++i) {",
                            "    if ( _currentArgs[i].key == name )",
                            "      return _currentArgs[i].value;",
                            "  }",
                            "  return \"\";",
                            "}",
                            "",
                            "String WebServer::arg(int i) {",
                            "  if (i < _currentArgCount)",
                            "    return _currentArgs[i].value;",
                            "  return \"\";",
                            "}",
                            "",
                            "String WebServer::argName(int i) {",
                            "  if (i < _currentArgCount)",
                            "    return _currentArgs[i].key;",
                            "  return \"\";",
                            "}",
                            "",
                            "int WebServer::args() {",
                            "  return _currentArgCount;",
                            "}",
                            "",
                            "bool WebServer::hasArg(String  name) {",
                            "  for (int i = 0; i < _currentArgCount; ++i) {",
                            "    if (_currentArgs[i].key == name)",
                            "      return true;",
                            "  }",
                            "  return false;",
                            "}",
                            "",
                            "",
                            "String WebServer::header(String name) {",
                            "  for (int i = 0; i < _headerKeysCount; ++i) {",
                            "    if (_currentHeaders[i].key.equalsIgnoreCase(name))",
                            "      return _currentHeaders[i].value;",
                            "  }",
                            "  return \"\";",
                            "}",
                            "",
                            "void WebServer::collectHeaders(const char* headerKeys[], const size_t headerKeysCount) {",
                            "  _headerKeysCount = headerKeysCount + 1;",
                            "  if (_currentHeaders)",
                            "     delete[]_currentHeaders;",
                            "  _currentHeaders = new RequestArgument[_headerKeysCount];",
                            "  _currentHeaders[0].key = FPSTR(AUTHORIZATION_HEADER);",
                            "  for (int i = 1; i < _headerKeysCount; i++){",
                            "    _currentHeaders[i].key = headerKeys[i-1];",
                            "  }",
                            "}",
                            "",
                            "String WebServer::header(int i) {",
                            "  if (i < _headerKeysCount)",
                            "    return _currentHeaders[i].value;",
                            "  return \"\";",
                            "}",
                            "",
                            "String WebServer::headerName(int i) {",
                            "  if (i < _headerKeysCount)",
                            "    return _currentHeaders[i].key;",
                            "  return \"\";",
                            "}",
                            "",
                            "int WebServer::headers() {",
                            "  return _headerKeysCount;",
                            "}",
                            "",
                            "bool WebServer::hasHeader(String name) {",
                            "  for (int i = 0; i < _headerKeysCount; ++i) {",
                            "    if ((_currentHeaders[i].key.equalsIgnoreCase(name)) &&  (_currentHeaders[i].value.length() > 0))",
                            "      return true;",
                            "  }",
                            "  return false;",
                            "}",
                            "",
                            "String WebServer::hostHeader() {",
                            "  return _hostHeader;",
                            "}",
                            "",
                            "void WebServer::onFileUpload(THandlerFunction fn) {",
                            "  _fileUploadHandler = fn;",
                            "}",
                            "",
                            "void WebServer::onNotFound(THandlerFunction fn) {",
                            "  _notFoundHandler = fn;",
                            "}",
                            "",
                            "void WebServer::_handleRequest() {",
                            "  bool handled = false;",
                            "  if (!_currentHandler){",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "    DEBUG_OUTPUT.println(\"request handler not found\");",
                            "#endif",
                            "  }",
                            "  else {",
                            "    handled = _currentHandler->handle(*this, _currentMethod, _currentUri);",
                            "#ifdef DEBUG_ESP_HTTP_SERVER",
                            "    if (!handled) {",
                            "      DEBUG_OUTPUT.println(\"request handler failed to handle request\");",
                            "    }",
                            "#endif",
                            "  }",
                            "  if (!handled && _notFoundHandler) {",
                            "    _notFoundHandler();",
                            "    handled = true;",
                            "  }",
                            "  if (!handled) {",
                            "    using namespace mime;",
                            "    send(404, String(FPSTR(mimeTable[html].mimeType)), String(F(\"Not found: \")) + _currentUri);",
                            "    handled = true;",
                            "  }",
                            "  if (handled) {",
                            "    _finalizeResponse();",
                            "  }",
                            "  _currentUri = \"\";",
                            "}",
                            "",
                            "",
                            "void WebServer::_finalizeResponse() {",
                            "  if (_chunked) {",
                            "    sendContent(\"\");",
                            "  }",
                            "}",
                            "",
                            "String WebServer::_responseCodeToString(int code) {",
                            "  switch (code) {",
                            "    case 100: return F(\"Continue\");",
                            "    case 101: return F(\"Switching Protocols\");",
                            "    case 200: return F(\"OK\");",
                            "    case 201: return F(\"Created\");",
                            "    case 202: return F(\"Accepted\");",
                            "    case 203: return F(\"Non-Authoritative Information\");",
                            "    case 204: return F(\"No Content\");",
                            "    case 205: return F(\"Reset Content\");",
                            "    case 206: return F(\"Partial Content\");",
                            "    case 300: return F(\"Multiple Choices\");",
                            "    case 301: return F(\"Moved Permanently\");",
                            "    case 302: return F(\"Found\");",
                            "    case 303: return F(\"See Other\");",
                            "    case 304: return F(\"Not Modified\");",
                            "    case 305: return F(\"Use Proxy\");",
                            "    case 307: return F(\"Temporary Redirect\");",
                            "    case 400: return F(\"Bad Request\");",
                            "    case 401: return F(\"Unauthorized\");",
                            "    case 402: return F(\"Payment Required\");",
                            "    case 403: return F(\"Forbidden\");",
                            "    case 404: return F(\"Not Found\");",
                            "    case 405: return F(\"Method Not Allowed\");",
                            "    case 406: return F(\"Not Acceptable\");",
                            "    case 407: return F(\"Proxy Authentication Required\");",
                            "    case 408: return F(\"Request Time-out\");",
                            "    case 409: return F(\"Conflict\");",
                            "    case 410: return F(\"Gone\");",
                            "    case 411: return F(\"Length Required\");",
                            "    case 412: return F(\"Precondition Failed\");",
                            "    case 413: return F(\"Request Entity Too Large\");",
                            "    case 414: return F(\"Request-URI Too Large\");",
                            "    case 415: return F(\"Unsupported Media Type\");",
                            "    case 416: return F(\"Requested range not satisfiable\");",
                            "    case 417: return F(\"Expectation Failed\");",
                            "    case 500: return F(\"Internal Server Error\");",
                            "    case 501: return F(\"Not Implemented\");",
                            "    case 502: return F(\"Bad Gateway\");",
                            "    case 503: return F(\"Service Unavailable\");",
                            "    case 504: return F(\"Gateway Time-out\");",
                            "    case 505: return F(\"HTTP Version not supported\");",
                            "    default:  return F(\"\");",
                            "  }",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "168": "      // extracting required parameters for RFC 2069 simpler Digest",
                "183": "      // parameters for the RFC 2617 newer Digest",
                "228": "  char buffer[33];  // buffer to hold 32 Hex Digit + /0",
                "306": "      // No-op to avoid C++ compiler warning",
                "309": "      // Wait for data from client to become available",
                "322": "      } else { // !_currentClient.available()",
                "330": "      // Wait for client to close the connection",
                "409": "    // Can we asume the following?",
                "411": "    //  _contentLength = CONTENT_LENGTH_UNKNOWN;"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "02e51728c4f66d997dbe8c8948e377ccba36dd3e",
            "timestamp": "2019-07-09T19:27:24+03:00",
            "author": "Victor Aprea",
            "commit_message": "Fix Timeout Bug in WebServer (#2938)",
            "additions": 3,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            305,
                            306,
                            307
                        ],
                        "comments": [
                            "          // because HTTP_MAX_SEND_WAIT is expressed in milliseconds,",
                            "          // it must be divided by 1000"
                        ],
                        "lines": [
                            "          _currentClient.setTimeout(HTTP_MAX_SEND_WAIT / 1000);"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "305": "          // because HTTP_MAX_SEND_WAIT is expressed in milliseconds,",
                "306": "          // it must be divided by 1000"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "WebServer.h": [],
    "RequestHandler.h": [],
    "RequestHandlersImpl.h": [],
    "mimetable.cpp": [
        {
            "commit": "a59eafbc9dfa3ce818c110f996eebf68d755be24",
            "timestamp": "2018-06-27T09:01:06+02:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to aaf1239 (#1539)\n\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* Initial add of @stickbreaker i2c\r\n\r\n* Add log_n\r\n\r\n* fix warnings when log is off\r\n\r\n* i2c code clean up and reorganization\r\n\r\n* add flags to interrupt allocator\r\n\r\n* fix sdmmc config\r\n\r\n* Fix warnings in EEPROM\r\n\r\nfrom @Curclamas\r\n\r\n* remove leftover TAG in EEPROM\r\n\r\n* fix errors with latest IDF\r\n\r\n* fix debug optimization (#1365)\r\n\r\nincorrect optimization for debugging tick markers.\r\n\r\n* Fix some missing BT header\r\n\r\n* Change BTSerial log calls\r\n\r\n* Update BLE lib\r\n\r\n* Arduino-ESP32 release management scripted (#1515)\r\n\r\n* Calculate an absolute path for a custom partitions table (#1452)\r\n\r\n* * Arduino-ESP32 release management scripted\r\n(ready-to-merge)\r\n\r\n* * secure env for espressif/arduino-esp32\r\n\r\n* * build tests enabled\r\n* gitter webhook enabled\r\n\r\n* * gitter room link fixed\r\n* better comment\r\n\r\n* * filepaths fixed\r\n\r\n* BT Serial adjustments\r\n\r\n* * don't run sketch builds & tests for tagged builds\r\n\r\n* Return false from WiFi.hostByName() if hostname is not resolved\r\n\r\n* Free BT Memory when BT is not used\r\n\r\n* WIFI_MODE_NULL is not supported anymore\r\n\r\n* Select some key examples to build with PlatformIO to save some time\r\n\r\n* Update BLE lib\r\n\r\n* Fixed BLE lib\r\n\r\n* Major WiFi overhaul\r\n\r\n- auto reconnect on connection loss now works\r\n- moved to event groups\r\n- some code clean up and procedure optimizations\r\n- new methods to get a more elaborate system ststus\r\n\r\n* Add cmake tests to travis\r\n\r\n* Add initial AsyncUDP\r\n\r\n* Add NetBIOS lib and fix CMake includes\r\n\r\n* Add Initial WebServer\r\n\r\n* Fix WebServer and examples\r\n\r\n* travis not quiting on build fail\r\n\r\n* Try different travis build\r\n\r\n* Update IDF to aaf1239\r\n\r\n* Fix WPS Example\r\n\r\n* fix script permission and add some fail tests to sketch builder\r\n\r\n* Add missing space in WiFiClient::write(Stream &stream)",
            "additions": 35,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35
                        ],
                        "comments": [
                            "// Table of extension->MIME strings stored in PROGMEM, needs to be global due to GCC section typing rules"
                        ],
                        "lines": [
                            "const Entry mimeTable[maxType] =",
                            "{",
                            "    { \".html\", \"text/html\" },",
                            "    { \".htm\", \"text/html\" },",
                            "    { \".css\", \"text/css\" },",
                            "    { \".txt\", \"text/plain\" },",
                            "    { \".js\", \"application/javascript\" },",
                            "    { \".json\", \"application/json\" },",
                            "    { \".png\", \"image/png\" },",
                            "    { \".gif\", \"image/gif\" },",
                            "    { \".jpg\", \"image/jpeg\" },",
                            "    { \".ico\", \"image/x-icon\" },",
                            "    { \".svg\", \"image/svg+xml\" },",
                            "    { \".ttf\", \"application/x-font-ttf\" },",
                            "    { \".otf\", \"application/x-font-opentype\" },",
                            "    { \".woff\", \"application/font-woff\" },",
                            "    { \".woff2\", \"application/font-woff2\" },",
                            "    { \".eot\", \"application/vnd.ms-fontobject\" },",
                            "    { \".sfnt\", \"application/font-sfnt\" },",
                            "    { \".xml\", \"text/xml\" },",
                            "    { \".pdf\", \"application/pdf\" },",
                            "    { \".zip\", \"application/zip\" },",
                            "    { \".gz\", \"application/x-gzip\" },",
                            "    { \".appcache\", \"text/cache-manifest\" },",
                            "    { \"\", \"application/octet-stream\" }",
                            "};",
                            "",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "7": "// Table of extension->MIME strings stored in PROGMEM, needs to be global due to GCC section typing rules"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "mimetable.h": [],
    "WPS.ino": [],
    "merge_packages.py": [],
    "build-release.sh": [],
    "build-tests.sh": [],
    "build.sh": [],
    "deploy.sh": [],
    "esp_ota_ops.h": [],
    "a2d_int.h": [],
    "esp_gatt_common_api.h": [],
    "esp_hf_client_api.h": [],
    "esp_hf_defs.h": [],
    "avct_int.h": [],
    "avdt_int.h": [],
    "avrc_int.h": [],
    "bta_ar_api.h": [],
    "bta_av_ci.h": [],
    "bta_av_co.h": [],
    "bta_av_sbc.h": [],
    "bta_gatt_common.h": [],
    "bta_hf_client_api.h": [],
    "bta_hf_client_co.h": [],
    "bta_hfp_defs.h": [],
    "btc_alarm.h": [],
    "btc_ble_storage.h": [],
    "btc_common.h": [],
    "btc_config.h": [],
    "btc_dev.h": [],
    "btc_dm.h": [],
    "btc_profile_queue.h": [],
    "btc_sm.h": [],
    "btc_storage.h": [],
    "btc_hf_client.h": [],
    "esp_sec_api.h": [],
    "hci_audio.h": [],
    "hidh_int.h": [],
    "mutex.h": [],
    "semaphore.h": [],
    "sbc_encoder.h": [],
    "sbc_types.h": [],
    "srvc_battery_int.h": [],
    "srvc_dis_int.h": [],
    "a2d_sbc.h": [],
    "bootloader_common.h": [],
    "pcnt.h": [],
    "sdio_slave.h": [],
    "spi_common.h": [],
    "touch_pad.h": [],
    "uart_select.h": [],
    "esp_tls.h": [],
    "esp_dbg_stubs.h": [],
    "esp_dport_access.h": [],
    "esp_wifi_os_adapter.h": [],
    "esp_http_client.h": [],
    "diskio_rawflash.h": [],
    "diskio_wl.h": [],
    "vfs_lwip.h": [],
    "ethernetif.h": [],
    "cmac.h": [],
    "ecp_internal.h": [],
    "net_sockets.h": [],
    "platform_time.h": [],
    "rsa_internal.h": [],
    "esp_newlib.h": [],
    "select.h": [],
    "sdmmc_cmd.h": [],
    "smartconfig_ack.h": [],
    "dport_access.h": [],
    "emac_reg_v2.h": [],
    "gpio_periph.h": [],
    "gpio_pins.h": [],
    "hinf_reg.h": [],
    "hinf_struct.h": [],
    "host_reg.h": [],
    "host_struct.h": [],
    "periph_defs.h": [],
    "rtc_periph.h": [],
    "sdio_slave_periph.h": [],
    "sdio_slave_pins.h": [],
    "sdmmc_periph.h": [],
    "sdmmc_pins.h": [],
    "sdmmc_reg.h": [],
    "sdmmc_struct.h": [],
    "slc_reg.h": [],
    "slc_struct.h": [],
    "spi_periph.h": [],
    "spi_pins.h": [],
    "eap_methods.h": [],
    "eap_peap_common.h": [],
    "eap_tlv_common.h": [],
    "eap_ttls.h": [],
    "mschapv2.h": [],
    "uuid.h": [],
    "wps.h": [],
    "wps_attr_parse.h": [],
    "wps_defs.h": [],
    "wps_dev_attr.h": [],
    "wps_i.h": [],
    "libesp-tls.a": [],
    "libesp_http_client.a": [],
    "libsmartconfig_ack.a": [],
    "FFat_Test.ino": [],
    "FFat.cpp": [
        {
            "commit": "7206b2f39707ad600e8bdfd6d74e4957189932dd",
            "timestamp": "2018-09-17T23:06:04+02:00",
            "author": "lbernstone",
            "commit_message": "FAT on SPI Flash Library (#1809)\n\n* First commit of FFat library\r\n\r\n* Fixed reboot loops if no fat present. Added CMakeLists\r\n\r\n* Functionalize the partition checks\r\n\r\n* Cleanup, especially in format\r\n\r\n* Dont format if mounted.  More wording cleanup\r\n\r\n* 16M ffat should only be on 16M board\r\n\r\n* Fix some casting issues that trip up the compiler when building as ESP-IDF component",
            "additions": 144,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License.",
                            "// Attempt to mount to see if there is already data",
                            "// Wipe disk- quick just wipes the FAT. Full zeroes the whole disk",
                            "// Now do a mount with format_if_fail (which it will)"
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "",
                            "#include \"vfs_api.h\"",
                            "extern \"C\" {",
                            "#include \"esp_vfs_fat.h\"",
                            "#include \"diskio.h\"",
                            "#include \"diskio_wl.h\"",
                            "#include \"vfs_fat_internal.h\"",
                            "}",
                            "#include \"FFat.h\"",
                            "",
                            "using namespace fs;",
                            "",
                            "F_Fat::F_Fat(FSImplPtr impl)",
                            "    : FS(impl)",
                            "{}",
                            "",
                            "const esp_partition_t *check_ffat_partition(const char* label)",
                            "{",
                            "    const esp_partition_t* ck_part = esp_partition_find_first(",
                            "       ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, label);",
                            "    if (!ck_part) {",
                            "        log_e(\"No FAT partition found with label %s\", label);",
                            "        return NULL;",
                            "    }",
                            "    return ck_part;",
                            "}",
                            "",
                            "bool F_Fat::begin(bool formatOnFail, const char * basePath, uint8_t maxOpenFiles, const char * partitionLabel)",
                            "{",
                            "    if(_wl_handle){",
                            "        log_w(\"Already Mounted!\");",
                            "        return true;",
                            "    }",
                            "",
                            "    if (!check_ffat_partition(partitionLabel)) return false;",
                            "",
                            "    esp_vfs_fat_mount_config_t conf = {",
                            "      .format_if_mount_failed = formatOnFail,",
                            "      .max_files = maxOpenFiles",
                            "    };",
                            "    esp_err_t err = esp_vfs_fat_spiflash_mount(basePath, partitionLabel, &conf, &_wl_handle);",
                            "    if(err){",
                            "        log_e(\"Mounting FFat partition failed! Error: %d\", err);",
                            "        return false;",
                            "    }",
                            "    _impl->mountpoint(basePath);",
                            "    return true;",
                            "}",
                            "",
                            "void F_Fat::end()",
                            "{",
                            "    if(_wl_handle){",
                            "        esp_err_t err = esp_vfs_fat_spiflash_unmount(_impl->mountpoint(), _wl_handle);",
                            "        if(err){",
                            "            log_e(\"Unmounting FFat partition failed! Error: %d\", err);",
                            "            return;",
                            "        }",
                            "        _wl_handle = NULL;",
                            "        _impl->mountpoint(NULL);",
                            "    }",
                            "}",
                            "",
                            "bool F_Fat::format(bool full_wipe, char* partitionLabel)",
                            "{",
                            "    esp_err_t result;",
                            "    if(_wl_handle){",
                            "        log_w(\"Already Mounted!\");",
                            "        return false;",
                            "    }",
                            "    wl_handle_t temp_handle;",
                            "    const esp_partition_t *ffat_partition = check_ffat_partition(partitionLabel);",
                            "    if (!ffat_partition) return false;",
                            "    result = wl_mount(ffat_partition, &temp_handle);",
                            "",
                            "    if (result == ESP_OK) {",
                            "        uint32_t wipe_size = full_wipe ? wl_size(temp_handle) : 16384;",
                            "        wl_erase_range(temp_handle, 0, wipe_size);",
                            "        wl_unmount(temp_handle);",
                            "    }",
                            "    esp_vfs_fat_mount_config_t conf = {",
                            "      .format_if_mount_failed = true,",
                            "      .max_files = 1",
                            "    };",
                            "    result = esp_vfs_fat_spiflash_mount(\"/format_ffat\", partitionLabel, &conf, &temp_handle);",
                            "    esp_vfs_fat_spiflash_unmount(\"/format_ffat\", temp_handle);",
                            "    return result;",
                            "}",
                            "",
                            "size_t F_Fat::totalBytes()",
                            "{",
                            "    FATFS *fs;",
                            "    DWORD free_clust, tot_sect, sect_size;",
                            "",
                            "    BYTE pdrv = ff_diskio_get_pdrv_wl(_wl_handle);",
                            "    char drv[3] = {(char)(48+pdrv), ':', 0};",
                            "    FRESULT res = f_getfree(drv, &free_clust, &fs);",
                            "    tot_sect = (fs->n_fatent - 2) * fs->csize;",
                            "    sect_size = CONFIG_WL_SECTOR_SIZE;",
                            "    return tot_sect * sect_size;",
                            "}",
                            "",
                            "size_t F_Fat::freeBytes()",
                            "{",
                            "",
                            "    FATFS *fs;",
                            "    DWORD free_clust, free_sect, sect_size;",
                            "",
                            "    BYTE pdrv = ff_diskio_get_pdrv_wl(_wl_handle);",
                            "    char drv[3] = {(char)(48+pdrv), ':', 0};",
                            "    FRESULT res = f_getfree(drv, &free_clust, &fs);",
                            "    free_sect = free_clust * fs->csize;",
                            "    sect_size = CONFIG_WL_SECTOR_SIZE;",
                            "    return free_sect * sect_size;",
                            "}",
                            "",
                            "bool F_Fat::exists(const char* path)",
                            "{",
                            "    File f = open(path, \"r\");",
                            "    return (f == true) && !f.isDirectory();",
                            "}",
                            "",
                            "bool F_Fat::exists(const String& path)",
                            "{",
                            "    return exists(path.c_str());",
                            "}",
                            "",
                            "",
                            "F_Fat FFat = F_Fat(FSImplPtr(new VFSImpl()));"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License.",
                "84": "// Attempt to mount to see if there is already data",
                "90": "// Wipe disk- quick just wipes the FAT. Full zeroes the whole disk",
                "95": "// Now do a mount with format_if_fail (which it will)"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "FFat.h": [],
    "ffat.csv": [],
    "FunctionalInterrupt.cpp": [
        {
            "commit": "ea61563c690ea4c41cc8cfa808799f84bcfa0540",
            "timestamp": "2018-09-17T23:13:58+02:00",
            "author": "hreintke",
            "commit_message": "Functional interrupt (#1728)\n\n* Initial\r\n\r\n* Implementation\r\n\r\n* Add to CMakelist.txt\r\n\r\n* Add example\r\n\r\n* Add IRAM_ATTR",
            "additions": 44,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44
                        ],
                        "comments": [
                            "\t// use the local interrupt routine which takes the ArgStructure as argument"
                        ],
                        "lines": [
                            "\t__attachInterruptFunctionalArg (pin, (voidFuncPtrArg)interruptFunctional, new InterruptArgStructure{intRoutine}, mode, true);",
                            "}",
                            "",
                            "extern \"C\"",
                            "{",
                            "   void cleanupFunctional(void* arg)",
                            "   {",
                            "\t delete (InterruptArgStructure*)arg;",
                            "   }",
                            "}",
                            "",
                            "",
                            "",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "30": "\t// use the local interrupt routine which takes the ArgStructure as argument"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "FunctionalInterrupt.h": [],
    "FunctionalInterrupt.ino": [],
    "GPIOInterrupt.ino": [],
    "RMTLoopback.ino": [],
    "WatchdogTimer.ino": [],
    "bootloader_random.h": [],
    "can.h": [],
    "mqtt_client.h": [],
    "mqtt_config.h": [],
    "pm.h": [],
    "esp_clk.h": [],
    "esp_spiram.h": [],
    "esp_https_ota.h": [],
    "Makefile.am": [],
    "expat.vcxproj": [],
    "expat.vcxproj.filters": [],
    "expat_static.vcxproj": [],
    "expat_static.vcxproj.filters": [],
    "expatw.vcxproj": [],
    "expatw.vcxproj.filters": [],
    "expatw_static.vcxproj": [],
    "expatw_static.vcxproj.filters": [],
    "libexpat.def": [],
    "libexpatw.def": [],
    "loadlibrary.c": [],
    "siphash.h": [],
    "winconfig.h": [],
    "xmlparse.c": [],
    "xmlrole.c": [],
    "xmltok.c": [],
    "xmltok_impl.c": [],
    "xmltok_ns.c": [],
    "http_server.h": [],
    "FILES": [],
    "fs.h": [],
    "httpd.h": [],
    "httpd_opts.h": [],
    "lwiperf.h": [],
    "mdns_opts.h": [],
    "mdns_priv.h": [],
    "mqtt.h": [],
    "mqtt_opts.h": [],
    "netbiosns.h": [],
    "netbiosns_opts.h": [],
    "snmp_core.h": [],
    "snmp_mib2.h": [],
    "snmp_opts.h": [],
    "snmp_scalar.h": [],
    "snmp_table.h": [],
    "snmp_threadsync.h": [],
    "snmpv3.h": [],
    "tftp_opts.h": [],
    "tftp_server.h": [],
    "ip4_frag.h": [],
    "nd6_priv.h": [],
    "timeouts.h": [],
    "dhcp_state.h": [],
    "ppp_opts.h": [],
    "esp_ping.h": [],
    "ping.h": [],
    "aria.h": [],
    "chacha20.h": [],
    "chachapoly.h": [],
    "hkdf.h": [],
    "nist_kw.h": [],
    "platform_util.h": [],
    "poly1305.h": [],
    "if.h": [],
    "poll.h": [],
    "uio.h": [],
    "un.h": [],
    "can_struct.h": [],
    "rtc_wdt.h": [],
    "transport.h": [],
    "transport_ssl.h": [],
    "transport_tcp.h": [],
    "transport_utils.h": [],
    "esp32.rom.libgcc.ld": [],
    "libasio.a": [],
    "libesp_https_ota.a": [],
    "libesp_ringbuf.a": [],
    "libhttp_server.a": [],
    "libmqtt.a": [],
    "libtcp_transport.a": [],
    "BasicHttpsClient.ino": [],
    "httpUpdate.ino": [],
    "httpUpdateSPIFFS.ino": [],
    "httpUpdateSecure.ino": [],
    "HTTPUpdate.cpp": [
        {
            "commit": "b58a3509b895d909cff287ad723aa4ec9f4d4be0",
            "timestamp": "2018-11-19T16:57:38+01:00",
            "author": "Jeroen88",
            "commit_message": "Feature/http update (#1979)\n\n* Added HTTPUpdate class for downloading sketches from a server\r\n\r\n* Added HTTPUpdate class for downloading sketches from a server\r\n\r\n* Added HTTPUpdate to CMakeLists.txt\r\n\r\n* Change ESP8266 class references to ESP32 for httpUpdate.ino example\r\n\r\n* Change ESP8266 class references to ESP32 for httpUpdate.ino example. setLedPin() commented out because not all boards support LED_BUITLIN\r\n\r\n* Added check to handle mixup of old and present api properly\r\n\r\n* Correct HTTPClient::setTimeout() to convert milliseconds to seconds. Correct WiFiClient::setTimeout() to call Stream::setTimeout() with seconds converted back to milliseconds. Remove inproper checks for _insecure.\r\n\r\n* Added small comment because it looked like the Travis build did not finish",
            "additions": 356,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356
                        ],
                        "comments": [
                            "// To do extern \"C\" uint32_t _SPIFFS_start;",
                            "// To do extern \"C\" uint32_t _SPIFFS_end;",
                            "        return String(); // no error",
                            "    // error from Update class",
                            "        error.trim(); // remove line ending",
                            "    // error from http client",
                            "    // use HTTP/1.0 for update since the update handler not support any transfer Encoding",
                            "// To do    http.addHeader(F(\"x-ESP32-free-space\"), String(ESP.getFreeSketchSpace()));",
                            "// To do    http.addHeader(F(\"x-ESP32-sketch-size\"), String(ESP.getSketchSize()));",
                            "// To do    http.addHeader(F(\"x-ESP32-sketch-md5\"), String(ESP.getSketchMD5()));",
                            "// To do    http.addHeader(F(\"x-ESP32-chip-size\"), String(ESP.getFlashChipRealSize()));",
                            "    // track these headers",
                            "// To do    log_d(\" - free Space: %d\\n\", ESP.getFreeSketchSpace());",
                            "// To do    log_d(\" - current Sketch Size: %d\\n\", ESP.getSketchSize());",
                            "// To do                size_t spiffsSize = ((size_t) &_SPIFFS_end - (size_t) &_SPIFFS_start);",
                            "// To do                if(len > (int) spiffsSize) {",
                            "// To do                    log_e(\"spiffsSize to low (%d) needed: %d\\n\", spiffsSize, len);",
                            "// To do                    startUpdate = false;",
                            "// To do                }",
                            "// To do                if(len > (int) ESP.getFreeSketchSpace()) {",
                            "// To do                    log_e(\"FreeSketchSpace to low (%d) needed: %d\\n\", ESP.getFreeSketchSpace(), len);",
                            "// To do                    startUpdate = false;",
                            "// To do                }",
                            "// To do?                WiFiUDP::stopAll();",
                            "// To do?                WiFiClient::stopAllExcept(tcp);",
                            "                    // check for valid first magic byte",
                            "//                    if(buf[0] != 0xE9) {",
                            "                    // check if new bin fits to SPI flash",
                            "        error.trim(); // remove line ending",
                            "        error.trim(); // remove line ending",
                            "        error.trim(); // remove line ending"
                        ],
                        "lines": [
                            "",
                            "HTTPUpdate::HTTPUpdate(void)",
                            "        : _httpClientTimeout(8000), _ledPin(-1)",
                            "{",
                            "}",
                            "",
                            "HTTPUpdate::HTTPUpdate(int httpClientTimeout)",
                            "        : _httpClientTimeout(httpClientTimeout), _ledPin(-1)",
                            "{",
                            "}",
                            "",
                            "HTTPUpdate::~HTTPUpdate(void)",
                            "{",
                            "}",
                            "",
                            "HTTPUpdateResult HTTPUpdate::update(WiFiClient& client, const String& url, const String& currentVersion)",
                            "{",
                            "    HTTPClient http;",
                            "    http.begin(client, url);",
                            "    return handleUpdate(http, currentVersion, false);",
                            "}",
                            "",
                            "HTTPUpdateResult HTTPUpdate::updateSpiffs(WiFiClient& client, const String& url, const String& currentVersion)",
                            "{",
                            "    HTTPClient http;",
                            "    http.begin(client, url);",
                            "    return handleUpdate(http, currentVersion, true);",
                            "}",
                            "",
                            "HTTPUpdateResult HTTPUpdate::update(WiFiClient& client, const String& host, uint16_t port, const String& uri,",
                            "        const String& currentVersion)",
                            "{",
                            "    HTTPClient http;",
                            "    http.begin(client, host, port, uri);",
                            "    return handleUpdate(http, currentVersion, false);",
                            "}",
                            "",
                            "/**",
                            " * return error code as int",
                            " * @return int error code",
                            " */",
                            "int HTTPUpdate::getLastError(void)",
                            "{",
                            "    return _lastError;",
                            "}",
                            "",
                            "/**",
                            " * return error code as String",
                            " * @return String error",
                            " */",
                            "String HTTPUpdate::getLastErrorString(void)",
                            "{",
                            "",
                            "    if(_lastError == 0) {",
                            "    }",
                            "",
                            "    if(_lastError > 0) {",
                            "        StreamString error;",
                            "        Update.printError(error);",
                            "        return String(F(\"Update error: \")) + error;",
                            "    }",
                            "",
                            "    if(_lastError > -100) {",
                            "        return String(F(\"HTTP error: \")) + HTTPClient::errorToString(_lastError);",
                            "    }",
                            "",
                            "    switch(_lastError) {",
                            "    case HTTP_UE_TOO_LESS_SPACE:",
                            "        return F(\"Not Enough space\");",
                            "    case HTTP_UE_SERVER_NOT_REPORT_SIZE:",
                            "        return F(\"Server Did Not Report Size\");",
                            "    case HTTP_UE_SERVER_FILE_NOT_FOUND:",
                            "        return F(\"File Not Found (404)\");",
                            "    case HTTP_UE_SERVER_FORBIDDEN:",
                            "        return F(\"Forbidden (403)\");",
                            "    case HTTP_UE_SERVER_WRONG_HTTP_CODE:",
                            "        return F(\"Wrong HTTP Code\");",
                            "    case HTTP_UE_SERVER_FAULTY_MD5:",
                            "        return F(\"Wrong MD5\");",
                            "    case HTTP_UE_BIN_VERIFY_HEADER_FAILED:",
                            "        return F(\"Verify Bin Header Failed\");",
                            "    case HTTP_UE_BIN_FOR_WRONG_FLASH:",
                            "        return F(\"New Binary Does Not Fit Flash Size\");",
                            "    }",
                            "",
                            "    return String();",
                            "}",
                            "",
                            "",
                            "/**",
                            " *",
                            " * @param http HTTPClient *",
                            " * @param currentVersion const char *",
                            " * @return HTTPUpdateResult",
                            " */",
                            "HTTPUpdateResult HTTPUpdate::handleUpdate(HTTPClient& http, const String& currentVersion, bool spiffs)",
                            "{",
                            "",
                            "    HTTPUpdateResult ret = HTTP_UPDATE_FAILED;",
                            "",
                            "    http.useHTTP10(true);",
                            "    http.setTimeout(_httpClientTimeout);",
                            "    http.setUserAgent(F(\"ESP32-http-Update\"));",
                            "    http.addHeader(F(\"Cache-Control\"), F(\"no-cache\"));",
                            "    http.addHeader(F(\"x-ESP32-STA-MAC\"), WiFi.macAddress());",
                            "    http.addHeader(F(\"x-ESP32-AP-MAC\"), WiFi.softAPmacAddress());",
                            "    http.addHeader(F(\"x-ESP32-sdk-version\"), ESP.getSdkVersion());",
                            "",
                            "    if(spiffs) {",
                            "        http.addHeader(F(\"x-ESP32-mode\"), F(\"spiffs\"));",
                            "    } else {",
                            "        http.addHeader(F(\"x-ESP32-mode\"), F(\"sketch\"));",
                            "    }",
                            "",
                            "    if(currentVersion && currentVersion[0] != 0x00) {",
                            "        http.addHeader(F(\"x-ESP32-version\"), currentVersion);",
                            "    }",
                            "",
                            "    const char * headerkeys[] = { \"x-MD5\" };",
                            "    size_t headerkeyssize = sizeof(headerkeys) / sizeof(char*);",
                            "",
                            "    http.collectHeaders(headerkeys, headerkeyssize);",
                            "",
                            "",
                            "    int code = http.GET();",
                            "    int len = http.getSize();",
                            "",
                            "    if(code <= 0) {",
                            "        log_e(\"HTTP error: %s\\n\", http.errorToString(code).c_str());",
                            "        _lastError = code;",
                            "        http.end();",
                            "        return HTTP_UPDATE_FAILED;",
                            "    }",
                            "",
                            "",
                            "    log_d(\"Header read fin.\\n\");",
                            "    log_d(\"Server header:\\n\");",
                            "    log_d(\" - code: %d\\n\", code);",
                            "    log_d(\" - len: %d\\n\", len);",
                            "",
                            "    if(http.hasHeader(\"x-MD5\")) {",
                            "        log_d(\" - MD5: %s\\n\", http.header(\"x-MD5\").c_str());",
                            "    }",
                            "",
                            "    log_d(\"ESP32 info:\\n\");",
                            "",
                            "    if(currentVersion && currentVersion[0] != 0x00) {",
                            "        log_d(\" - current version: %s\\n\", currentVersion.c_str() );",
                            "    }",
                            "",
                            "    switch(code) {",
                            "    case HTTP_CODE_OK:  ///< OK (Start Update)",
                            "        if(len > 0) {",
                            "            bool startUpdate = true;",
                            "            if(spiffs) {",
                            "            } else {",
                            "            }",
                            "",
                            "            if(!startUpdate) {",
                            "                _lastError = HTTP_UE_TOO_LESS_SPACE;",
                            "                ret = HTTP_UPDATE_FAILED;",
                            "            } else {",
                            "",
                            "                WiFiClient * tcp = http.getStreamPtr();",
                            "",
                            "",
                            "                delay(100);",
                            "",
                            "                int command;",
                            "",
                            "                if(spiffs) {",
                            "                    command = U_SPIFFS;",
                            "                    log_d(\"runUpdate spiffs...\\n\");",
                            "                } else {",
                            "                    command = U_FLASH;",
                            "                    log_d(\"runUpdate flash...\\n\");",
                            "                }",
                            "",
                            "                if(!spiffs) {",
                            "/* To do",
                            "                    uint8_t buf[4];",
                            "                    if(tcp->peekBytes(&buf[0], 4) != 4) {",
                            "                        log_e(\"peekBytes magic header failed\\n\");",
                            "                        _lastError = HTTP_UE_BIN_VERIFY_HEADER_FAILED;",
                            "                        http.end();",
                            "                        return HTTP_UPDATE_FAILED;",
                            "                    }",
                            "*/",
                            "",
                            "                    if(tcp->peek() != 0xE9) {",
                            "                        log_e(\"Magic header does not start with 0xE9\\n\");",
                            "                        _lastError = HTTP_UE_BIN_VERIFY_HEADER_FAILED;",
                            "                        http.end();",
                            "                        return HTTP_UPDATE_FAILED;",
                            "",
                            "                    }",
                            "/* To do",
                            "                    uint32_t bin_flash_size = ESP.magicFlashChipSize((buf[3] & 0xf0) >> 4);",
                            "",
                            "                    if(bin_flash_size > ESP.getFlashChipRealSize()) {",
                            "                        log_e(\"New binary does not fit SPI Flash size\\n\");",
                            "                        _lastError = HTTP_UE_BIN_FOR_WRONG_FLASH;",
                            "                        http.end();",
                            "                        return HTTP_UPDATE_FAILED;",
                            "                    }",
                            "*/",
                            "                }",
                            "                if(runUpdate(*tcp, len, http.header(\"x-MD5\"), command)) {",
                            "                    ret = HTTP_UPDATE_OK;",
                            "                    log_d(\"Update ok\\n\");",
                            "                    http.end();",
                            "",
                            "                    if(_rebootOnUpdate && !spiffs) {",
                            "                        ESP.restart();",
                            "                    }",
                            "",
                            "                } else {",
                            "                    ret = HTTP_UPDATE_FAILED;",
                            "                    log_e(\"Update failed\\n\");",
                            "                }",
                            "            }",
                            "        } else {",
                            "            _lastError = HTTP_UE_SERVER_NOT_REPORT_SIZE;",
                            "            ret = HTTP_UPDATE_FAILED;",
                            "            log_e(\"Content-Length was 0 or wasn't set by Server?!\\n\");",
                            "        }",
                            "        break;",
                            "    case HTTP_CODE_NOT_MODIFIED:",
                            "        ///< Not Modified (No updates)",
                            "        ret = HTTP_UPDATE_NO_UPDATES;",
                            "        break;",
                            "    case HTTP_CODE_NOT_FOUND:",
                            "        _lastError = HTTP_UE_SERVER_FILE_NOT_FOUND;",
                            "        ret = HTTP_UPDATE_FAILED;",
                            "        break;",
                            "    case HTTP_CODE_FORBIDDEN:",
                            "        _lastError = HTTP_UE_SERVER_FORBIDDEN;",
                            "        ret = HTTP_UPDATE_FAILED;",
                            "        break;",
                            "    default:",
                            "        _lastError = HTTP_UE_SERVER_WRONG_HTTP_CODE;",
                            "        ret = HTTP_UPDATE_FAILED;",
                            "        log_e(\"HTTP Code is (%d)\\n\", code);",
                            "        break;",
                            "    }",
                            "",
                            "    http.end();",
                            "    return ret;",
                            "}",
                            "",
                            "/**",
                            " * write Update to flash",
                            " * @param in Stream&",
                            " * @param size uint32_t",
                            " * @param md5 String",
                            " * @return true if Update ok",
                            " */",
                            "bool HTTPUpdate::runUpdate(Stream& in, uint32_t size, String md5, int command)",
                            "{",
                            "",
                            "    StreamString error;",
                            "",
                            "    if(!Update.begin(size, command, _ledPin, _ledOn)) {",
                            "        _lastError = Update.getError();",
                            "        Update.printError(error);",
                            "        log_e(\"Update.begin failed! (%s)\\n\", error.c_str());",
                            "        return false;",
                            "    }",
                            "",
                            "    if(md5.length()) {",
                            "        if(!Update.setMD5(md5.c_str())) {",
                            "            _lastError = HTTP_UE_SERVER_FAULTY_MD5;",
                            "            log_e(\"Update.setMD5 failed! (%s)\\n\", md5.c_str());",
                            "            return false;",
                            "        }",
                            "    }",
                            "",
                            "    if(Update.writeStream(in) != size) {",
                            "        _lastError = Update.getError();",
                            "        Update.printError(error);",
                            "        log_e(\"Update.writeStream failed! (%s)\\n\", error.c_str());",
                            "        return false;",
                            "    }",
                            "",
                            "    if(!Update.end()) {",
                            "        _lastError = Update.getError();",
                            "        Update.printError(error);",
                            "        log_e(\"Update.end failed! (%s)\\n\", error.c_str());",
                            "        return false;",
                            "    }",
                            "",
                            "    return true;",
                            "}",
                            "",
                            "#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_HTTPUPDATE)",
                            "HTTPUpdate httpUpdate;",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "29": "// To do extern \"C\" uint32_t _SPIFFS_start;",
                "30": "// To do extern \"C\" uint32_t _SPIFFS_end;",
                "85": "        return String(); // no error",
                "88": "    // error from Update class",
                "92": "        error.trim(); // remove line ending",
                "96": "    // error from http client",
                "135": "    // use HTTP/1.0 for update since the update handler not support any transfer Encoding",
                "142": "// To do    http.addHeader(F(\"x-ESP32-free-space\"), String(ESP.getFreeSketchSpace()));",
                "143": "// To do    http.addHeader(F(\"x-ESP32-sketch-size\"), String(ESP.getSketchSize()));",
                "144": "// To do    http.addHeader(F(\"x-ESP32-sketch-md5\"), String(ESP.getSketchMD5()));",
                "145": "// To do    http.addHeader(F(\"x-ESP32-chip-size\"), String(ESP.getFlashChipRealSize()));",
                "161": "    // track these headers",
                "186": "// To do    log_d(\" - free Space: %d\\n\", ESP.getFreeSketchSpace());",
                "187": "// To do    log_d(\" - current Sketch Size: %d\\n\", ESP.getSketchSize());",
                "198": "// To do                size_t spiffsSize = ((size_t) &_SPIFFS_end - (size_t) &_SPIFFS_start);",
                "199": "// To do                if(len > (int) spiffsSize) {",
                "200": "// To do                    log_e(\"spiffsSize to low (%d) needed: %d\\n\", spiffsSize, len);",
                "201": "// To do                    startUpdate = false;",
                "202": "// To do                }",
                "204": "// To do                if(len > (int) ESP.getFreeSketchSpace()) {",
                "205": "// To do                    log_e(\"FreeSketchSpace to low (%d) needed: %d\\n\", ESP.getFreeSketchSpace(), len);",
                "206": "// To do                    startUpdate = false;",
                "207": "// To do                }",
                "217": "// To do?                WiFiUDP::stopAll();",
                "218": "// To do?                WiFiClient::stopAllExcept(tcp);",
                "243": "                    // check for valid first magic byte",
                "244": "//                    if(buf[0] != 0xE9) {",
                "255": "                    // check if new bin fits to SPI flash",
                "322": "        error.trim(); // remove line ending",
                "338": "        error.trim(); // remove line ending",
                "346": "        error.trim(); // remove line ending"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "7e9afe8c5ed7b5bf29624a5cd6e07d431c027b97",
            "timestamp": "2018-11-27T21:27:38+01:00",
            "author": "Jeroen88",
            "commit_message": "Add response headers with sketch and flash sizes, and a SHA256 (#2116)",
            "additions": 43,
            "deletions": 9,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            30,
                            31
                        ],
                        "comments": [
                            "#include <esp_ota_ops.h>                // get running partition"
                        ],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152
                        ],
                        "comments": [
                            "  const size_t HASH_LEN = 32; // SHA-256 digest length",
                            "// get sha256 digest for running partition"
                        ],
                        "lines": [
                            "String getSketchSHA256() {",
                            "",
                            "  uint8_t sha_256[HASH_LEN] = { 0 };",
                            "",
                            "  if(esp_partition_get_sha256(esp_ota_get_running_partition(), sha_256) == 0) {",
                            "    char buffer[2 * HASH_LEN + 1];",
                            "",
                            "    for(size_t index = 0; index < HASH_LEN; index++) {",
                            "      uint8_t nibble = (sha_256[index] & 0xf0) >> 4;",
                            "      buffer[2 * index] = nibble < 10 ? char(nibble + '0') : char(nibble - 10 + 'A');",
                            "",
                            "      nibble = sha_256[index] & 0x0f;",
                            "      buffer[2 * index + 1] = nibble < 10 ? char(nibble + '0') : char(nibble - 10 + 'A');",
                            "    }",
                            "",
                            "    buffer[2 * HASH_LEN] = '\\0';",
                            "",
                            "    return String(buffer);",
                            "  } else {",
                            "",
                            "    return String();",
                            "  }",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            171,
                            172
                        ],
                        "comments": [],
                        "lines": [
                            "    http.addHeader(F(\"x-ESP32-free-space\"), String(ESP.getFreeSketchSpace()));",
                            "    http.addHeader(F(\"x-ESP32-sketch-size\"), String(ESP.getSketchSize()));"
                        ]
                    },
                    {
                        "line_numbers": [
                            175,
                            176,
                            177,
                            178,
                            179
                        ],
                        "comments": [],
                        "lines": [
                            "    String sketchSHA256 = getSketchSHA256();",
                            "    if(sketchSHA256.length() != 0) {",
                            "      http.addHeader(F(\"x-ESP32-sketch-sha256\"), sketchSHA256);",
                            "    }",
                            "    http.addHeader(F(\"x-ESP32-chip-size\"), String(ESP.getFlashChipSize()));"
                        ]
                    },
                    {
                        "line_numbers": [
                            220,
                            221
                        ],
                        "comments": [],
                        "lines": [
                            "    log_d(\" - free Space: %d\\n\", ESP.getFreeSketchSpace());",
                            "    log_d(\" - current Sketch Size: %d\\n\", ESP.getSketchSize());"
                        ]
                    },
                    {
                        "line_numbers": [
                            238,
                            239,
                            240,
                            241
                        ],
                        "comments": [],
                        "lines": [
                            "                if(len > (int) ESP.getFreeSketchSpace()) {",
                            "                    log_e(\"FreeSketchSpace to low (%d) needed: %d\\n\", ESP.getFreeSketchSpace(), len);",
                            "                    startUpdate = false;",
                            "                }"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            142,
                            143
                        ],
                        "comments": [
                            "// To do    http.addHeader(F(\"x-ESP32-free-space\"), String(ESP.getFreeSketchSpace()));",
                            "// To do    http.addHeader(F(\"x-ESP32-sketch-size\"), String(ESP.getSketchSize()));"
                        ],
                        "lines": []
                    }
                ]
            },
            "comment_added_diff": {
                "30": "#include <esp_ota_ops.h>                // get running partition",
                "128": "  const size_t HASH_LEN = 32; // SHA-256 digest length",
                "132": "// get sha256 digest for running partition",
                "174": "    // Sketch MD5 is not supported by the core, but SHA256 is, so add a SHA256 instead"
            },
            "comment_deleted_diff": {
                "142": "// To do    http.addHeader(F(\"x-ESP32-free-space\"), String(ESP.getFreeSketchSpace()));",
                "143": "// To do    http.addHeader(F(\"x-ESP32-sketch-size\"), String(ESP.getSketchSize()));",
                "145": "// To do    http.addHeader(F(\"x-ESP32-chip-size\"), String(ESP.getFlashChipRealSize()));",
                "186": "// To do    log_d(\" - free Space: %d\\n\", ESP.getFreeSketchSpace());",
                "187": "// To do    log_d(\" - current Sketch Size: %d\\n\", ESP.getSketchSize());",
                "204": "// To do                if(len > (int) ESP.getFreeSketchSpace()) {",
                "205": "// To do                    log_e(\"FreeSketchSpace to low (%d) needed: %d\\n\", ESP.getFreeSketchSpace(), len);",
                "206": "// To do                    startUpdate = false;",
                "207": "// To do                }"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "cfe7e011583884afcf3d8938ed4bba68b67eecd3",
            "timestamp": "2018-11-28T11:45:25+01:00",
            "author": "Jeroen88",
            "commit_message": "Remove F() macro's (#2121)",
            "additions": 23,
            "deletions": 23,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            173
                        ],
                        "comments": [
                            "// To do    http.addHeader(\"x-ESP32-sketch-md5\", String(ESP.getSketchMD5()));"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            177
                        ],
                        "comments": [],
                        "lines": [
                            "      http.addHeader(\"x-ESP32-sketch-sha256\", sketchSHA256);"
                        ]
                    },
                    {
                        "line_numbers": [
                            179,
                            180
                        ],
                        "comments": [],
                        "lines": [
                            "    http.addHeader(\"x-ESP32-chip-size\", String(ESP.getFlashChipSize()));",
                            "    http.addHeader(\"x-ESP32-sdk-version\", ESP.getSdkVersion());"
                        ]
                    },
                    {
                        "line_numbers": [
                            183
                        ],
                        "comments": [],
                        "lines": [
                            "        http.addHeader(\"x-ESP32-mode\", \"spiffs\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            185
                        ],
                        "comments": [],
                        "lines": [
                            "        http.addHeader(\"x-ESP32-mode\", \"sketch\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            189
                        ],
                        "comments": [],
                        "lines": [
                            "        http.addHeader(\"x-ESP32-version\", currentVersion);"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            173
                        ],
                        "comments": [
                            "// To do    http.addHeader(F(\"x-ESP32-sketch-md5\"), String(ESP.getSketchMD5()));"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            177
                        ],
                        "comments": [],
                        "lines": [
                            "      http.addHeader(F(\"x-ESP32-sketch-sha256\"), sketchSHA256);"
                        ]
                    },
                    {
                        "line_numbers": [
                            179,
                            180
                        ],
                        "comments": [],
                        "lines": [
                            "    http.addHeader(F(\"x-ESP32-chip-size\"), String(ESP.getFlashChipSize()));",
                            "    http.addHeader(F(\"x-ESP32-sdk-version\"), ESP.getSdkVersion());"
                        ]
                    },
                    {
                        "line_numbers": [
                            183
                        ],
                        "comments": [],
                        "lines": [
                            "        http.addHeader(F(\"x-ESP32-mode\"), F(\"spiffs\"));"
                        ]
                    },
                    {
                        "line_numbers": [
                            185
                        ],
                        "comments": [],
                        "lines": [
                            "        http.addHeader(F(\"x-ESP32-mode\"), F(\"sketch\"));"
                        ]
                    },
                    {
                        "line_numbers": [
                            189
                        ],
                        "comments": [],
                        "lines": [
                            "        http.addHeader(F(\"x-ESP32-version\"), currentVersion);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "173": "// To do    http.addHeader(\"x-ESP32-sketch-md5\", String(ESP.getSketchMD5()));"
            },
            "comment_deleted_diff": {
                "173": "// To do    http.addHeader(F(\"x-ESP32-sketch-md5\"), String(ESP.getSketchMD5()));"
            },
            "comment_modified_diff": {
                "173": "// To do    http.addHeader(F(\"x-ESP32-sketch-md5\"), String(ESP.getSketchMD5()));"
            }
        },
        {
            "commit": "884e417a4943ae64897fc06db47915f24c00b59a",
            "timestamp": "2018-12-06T20:39:52+01:00",
            "author": "Jeroen88",
            "commit_message": "Fix HTTPUpdate flash size check and add SPIFFS size check (#2161)\n\n* Fix error in PR #2048: if ::available() is called before ::connect() _rxBuffer is not initialised\r\n\r\n* Fixed flash size check and added SPIFFS size check\r\n\r\n* Rewriting ESP.getFreeSketchSpace(), moving code from HTTPUpdate.cpp",
            "additions": 22,
            "deletions": 7,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            391,
                            392
                        ],
                        "comments": [
                            "// To do: the SHA256 could be checked if the server sends it"
                        ],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            241,
                            242,
                            243,
                            244,
                            245
                        ],
                        "comments": [
                            "// To do                size_t spiffsSize = ((size_t) &_SPIFFS_end - (size_t) &_SPIFFS_start);",
                            "// To do                if(len > (int) spiffsSize) {",
                            "// To do                    log_e(\"spiffsSize to low (%d) needed: %d\\n\", spiffsSize, len);",
                            "// To do                    startUpdate = false;",
                            "// To do                }"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            247,
                            248
                        ],
                        "comments": [],
                        "lines": [
                            "                if(len > (int) ESP.getFreeSketchSpace()) {",
                            "                    log_e(\"FreeSketchSpace to low (%d) needed: %d\\n\", ESP.getFreeSketchSpace(), len);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "391": "// To do: the SHA256 could be checked if the server sends it"
            },
            "comment_deleted_diff": {
                "241": "// To do                size_t spiffsSize = ((size_t) &_SPIFFS_end - (size_t) &_SPIFFS_start);",
                "242": "// To do                if(len > (int) spiffsSize) {",
                "243": "// To do                    log_e(\"spiffsSize to low (%d) needed: %d\\n\", spiffsSize, len);",
                "244": "// To do                    startUpdate = false;",
                "245": "// To do                }"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "1289f4be4b46d26ac244c71b338d3ca4a9664c67",
            "timestamp": "2018-12-11T02:06:58+01:00",
            "author": "Jeroen88",
            "commit_message": "Add MD5 computation to Esp and add request header with MD5 hash of the running sketch to HTTPUpdate (#2176)",
            "additions": 5,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            188
                        ],
                        "comments": [
                            "    // Add also a SHA256"
                        ],
                        "lines": []
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            184,
                            185
                        ],
                        "comments": [
                            "// To do    http.addHeader(\"x-ESP32-sketch-md5\", String(ESP.getSketchMD5()));",
                            "    // Sketch MD5 is not supported by the core, but SHA256 is, so add a SHA256 instead"
                        ],
                        "lines": []
                    }
                ]
            },
            "comment_added_diff": {
                "188": "    // Add also a SHA256"
            },
            "comment_deleted_diff": {
                "184": "// To do    http.addHeader(\"x-ESP32-sketch-md5\", String(ESP.getSketchMD5()));",
                "185": "    // Sketch MD5 is not supported by the core, but SHA256 is, so add a SHA256 instead"
            },
            "comment_modified_diff": {}
        }
    ],
    "HTTPUpdate.h": [],
    "PathArgServer.ino": [],
    "WiFiClientPSK.ino": [],
    "esp_camera.h": [],
    "esp_jpg_decode.h": [],
    "img_converters.h": [],
    "sensor.h": [],
    "esp_pthread.h": [],
    "apb_ctrl_struct.h": [],
    "mcpwm_struct.h": [],
    "rtc_cntl_struct.h": [],
    "rtc_io_struct.h": [],
    "syscon_struct.h": [],
    "libesp32-camera.a": [],
    "libesp_event.a": [],
    "libesp_http_server.a": [],
    "libesp_https_server.a": [],
    "libfreemodbus.a": [],
    "liblibsodium.a": [],
    "libprotobuf-c.a": [],
    "libprotocomm.a": [],
    "libunity.a": [],
    "libwifi_provisioning.a": [],
    "CameraWebServer.ino": [],
    "app_httpd.cpp": [
        {
            "commit": "1628f533a18a84bc540ce9d57f8c4eaa46f69878",
            "timestamp": "2018-12-20T00:41:48+01:00",
            "author": "me-no-dev",
            "commit_message": "Add Camera WebServer Example",
            "additions": 359,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359
                        ],
                        "comments": [
                            "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                            "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                            "// you may not use this file except in compliance with the License.",
                            "// You may obtain a copy of the License at",
                            "//     http://www.apache.org/licenses/LICENSE-2.0",
                            "// Unless required by applicable law or agreed to in writing, software",
                            "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                            "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                            "// See the License for the specific language governing permissions and",
                            "// limitations under the License."
                        ],
                        "lines": [
                            "//",
                            "//",
                            "//",
                            "#include \"esp_http_server.h\"",
                            "#include \"esp_timer.h\"",
                            "#include \"esp_camera.h\"",
                            "#include \"img_converters.h\"",
                            "#include \"camera_index.h\"",
                            "#include \"Arduino.h\"",
                            "",
                            "typedef struct {",
                            "        size_t size; //number of values used for filtering",
                            "        size_t index; //current value index",
                            "        size_t count; //value count",
                            "        int sum;",
                            "        int * values; //array to be filled with values",
                            "} ra_filter_t;",
                            "",
                            "typedef struct {",
                            "        httpd_req_t *req;",
                            "        size_t len;",
                            "} jpg_chunking_t;",
                            "",
                            "#define PART_BOUNDARY \"123456789000000000000987654321\"",
                            "static const char* _STREAM_CONTENT_TYPE = \"multipart/x-mixed-replace;boundary=\" PART_BOUNDARY;",
                            "static const char* _STREAM_BOUNDARY = \"\\r\\n--\" PART_BOUNDARY \"\\r\\n\";",
                            "static const char* _STREAM_PART = \"Content-Type: image/jpeg\\r\\nContent-Length: %u\\r\\n\\r\\n\";",
                            "",
                            "static ra_filter_t ra_filter;",
                            "httpd_handle_t stream_httpd = NULL;",
                            "httpd_handle_t camera_httpd = NULL;",
                            "",
                            "static ra_filter_t * ra_filter_init(ra_filter_t * filter, size_t sample_size){",
                            "    memset(filter, 0, sizeof(ra_filter_t));",
                            "",
                            "    filter->values = (int *)malloc(sample_size * sizeof(int));",
                            "    if(!filter->values){",
                            "        return NULL;",
                            "    }",
                            "    memset(filter->values, 0, sample_size * sizeof(int));",
                            "",
                            "    filter->size = sample_size;",
                            "    return filter;",
                            "}",
                            "",
                            "static int ra_filter_run(ra_filter_t * filter, int value){",
                            "    if(!filter->values){",
                            "        return value;",
                            "    }",
                            "    filter->sum -= filter->values[filter->index];",
                            "    filter->values[filter->index] = value;",
                            "    filter->sum += filter->values[filter->index];",
                            "    filter->index++;",
                            "    filter->index = filter->index % filter->size;",
                            "    if (filter->count < filter->size) {",
                            "        filter->count++;",
                            "    }",
                            "    return filter->sum / filter->count;",
                            "}",
                            "",
                            "static size_t jpg_encode_stream(void * arg, size_t index, const void* data, size_t len){",
                            "    jpg_chunking_t *j = (jpg_chunking_t *)arg;",
                            "    if(!index){",
                            "        j->len = 0;",
                            "    }",
                            "    if(httpd_resp_send_chunk(j->req, (const char *)data, len) != ESP_OK){",
                            "        return 0;",
                            "    }",
                            "    j->len += len;",
                            "    return len;",
                            "}",
                            "",
                            "static esp_err_t capture_handler(httpd_req_t *req){",
                            "    camera_fb_t * fb = NULL;",
                            "    esp_err_t res = ESP_OK;",
                            "    int64_t fr_start = esp_timer_get_time();",
                            "",
                            "    fb = esp_camera_fb_get();",
                            "    if (!fb) {",
                            "        Serial.printf(\"Camera capture failed\");",
                            "        httpd_resp_send_500(req);",
                            "        return ESP_FAIL;",
                            "    }",
                            "",
                            "    httpd_resp_set_type(req, \"image/jpeg\");",
                            "    httpd_resp_set_hdr(req, \"Content-Disposition\", \"inline; filename=capture.jpg\");",
                            "",
                            "    size_t fb_len = 0;",
                            "    if(fb->format == PIXFORMAT_JPEG){",
                            "        fb_len = fb->len;",
                            "        res = httpd_resp_send(req, (const char *)fb->buf, fb->len);",
                            "    } else {",
                            "        jpg_chunking_t jchunk = {req, 0};",
                            "        res = frame2jpg_cb(fb, 80, jpg_encode_stream, &jchunk)?ESP_OK:ESP_FAIL;",
                            "        httpd_resp_send_chunk(req, NULL, 0);",
                            "        fb_len = jchunk.len;",
                            "    }",
                            "    esp_camera_fb_return(fb);",
                            "    int64_t fr_end = esp_timer_get_time();",
                            "    Serial.printf(\"JPG: %uB %ums\", (uint32_t)(fb_len), (uint32_t)((fr_end - fr_start)/1000));",
                            "    return res;",
                            "}",
                            "",
                            "static esp_err_t stream_handler(httpd_req_t *req){",
                            "    camera_fb_t * fb = NULL;",
                            "    esp_err_t res = ESP_OK;",
                            "    size_t _jpg_buf_len = 0;",
                            "    uint8_t * _jpg_buf = NULL;",
                            "    char * part_buf[64];",
                            "",
                            "    static int64_t last_frame = 0;",
                            "    if(!last_frame) {",
                            "        last_frame = esp_timer_get_time();",
                            "    }",
                            "",
                            "    res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);",
                            "    if(res != ESP_OK){",
                            "        return res;",
                            "    }",
                            "",
                            "    while(true){",
                            "        fb = esp_camera_fb_get();",
                            "        if (!fb) {",
                            "            Serial.printf(\"Camera capture failed\");",
                            "            res = ESP_FAIL;",
                            "        } else {",
                            "            if(fb->format != PIXFORMAT_JPEG){",
                            "                bool jpeg_converted = frame2jpg(fb, 80, &_jpg_buf, &_jpg_buf_len);",
                            "                esp_camera_fb_return(fb);",
                            "                fb = NULL;",
                            "                if(!jpeg_converted){",
                            "                    Serial.printf(\"JPEG compression failed\");",
                            "                    res = ESP_FAIL;",
                            "                }",
                            "            } else {",
                            "                _jpg_buf_len = fb->len;",
                            "                _jpg_buf = fb->buf;",
                            "            }",
                            "        }",
                            "        if(res == ESP_OK){",
                            "            size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);",
                            "            res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);",
                            "        }",
                            "        if(res == ESP_OK){",
                            "            res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);",
                            "        }",
                            "        if(res == ESP_OK){",
                            "            res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));",
                            "        }",
                            "        if(fb){",
                            "            esp_camera_fb_return(fb);",
                            "            fb = NULL;",
                            "            _jpg_buf = NULL;",
                            "        } else if(_jpg_buf){",
                            "            free(_jpg_buf);",
                            "            _jpg_buf = NULL;",
                            "        }",
                            "        if(res != ESP_OK){",
                            "            break;",
                            "        }",
                            "        int64_t fr_end = esp_timer_get_time();",
                            "",
                            "        int64_t frame_time = fr_end - last_frame;",
                            "        last_frame = fr_end;",
                            "        frame_time /= 1000;",
                            "        uint32_t avg_frame_time = ra_filter_run(&ra_filter, frame_time);",
                            "        Serial.printf(\"MJPG: %uB %ums (%.1ffps), AVG: %ums (%.1ffps)\"",
                            "            ,(uint32_t)(_jpg_buf_len),",
                            "            (uint32_t)frame_time, 1000.0 / (uint32_t)frame_time,",
                            "            avg_frame_time, 1000.0 / avg_frame_time",
                            "        );",
                            "    }",
                            "",
                            "    last_frame = 0;",
                            "    return res;",
                            "}",
                            "",
                            "static esp_err_t cmd_handler(httpd_req_t *req){",
                            "    char*  buf;",
                            "    size_t buf_len;",
                            "    char variable[32] = {0,};",
                            "    char value[32] = {0,};",
                            "",
                            "    buf_len = httpd_req_get_url_query_len(req) + 1;",
                            "    if (buf_len > 1) {",
                            "        buf = (char*)malloc(buf_len);",
                            "        if(!buf){",
                            "            httpd_resp_send_500(req);",
                            "            return ESP_FAIL;",
                            "        }",
                            "        if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK) {",
                            "            if (httpd_query_key_value(buf, \"var\", variable, sizeof(variable)) == ESP_OK &&",
                            "                httpd_query_key_value(buf, \"val\", value, sizeof(value)) == ESP_OK) {",
                            "            } else {",
                            "                free(buf);",
                            "                httpd_resp_send_404(req);",
                            "                return ESP_FAIL;",
                            "            }",
                            "        } else {",
                            "            free(buf);",
                            "            httpd_resp_send_404(req);",
                            "            return ESP_FAIL;",
                            "        }",
                            "        free(buf);",
                            "    } else {",
                            "        httpd_resp_send_404(req);",
                            "        return ESP_FAIL;",
                            "    }",
                            "",
                            "    int val = atoi(value);",
                            "    sensor_t * s = esp_camera_sensor_get();",
                            "    int res = 0;",
                            "",
                            "    if(!strcmp(variable, \"framesize\")) {",
                            "        if(s->pixformat == PIXFORMAT_JPEG) res = s->set_framesize(s, (framesize_t)val);",
                            "    }",
                            "    else if(!strcmp(variable, \"quality\")) res = s->set_quality(s, val);",
                            "    else if(!strcmp(variable, \"contrast\")) res = s->set_contrast(s, val);",
                            "    else if(!strcmp(variable, \"brightness\")) res = s->set_brightness(s, val);",
                            "    else if(!strcmp(variable, \"saturation\")) res = s->set_saturation(s, val);",
                            "    else if(!strcmp(variable, \"gainceiling\")) res = s->set_gainceiling(s, (gainceiling_t)val);",
                            "    else if(!strcmp(variable, \"colorbar\")) res = s->set_colorbar(s, val);",
                            "    else if(!strcmp(variable, \"awb\")) res = s->set_whitebal(s, val);",
                            "    else if(!strcmp(variable, \"agc\")) res = s->set_gain_ctrl(s, val);",
                            "    else if(!strcmp(variable, \"aec\")) res = s->set_exposure_ctrl(s, val);",
                            "    else if(!strcmp(variable, \"hmirror\")) res = s->set_hmirror(s, val);",
                            "    else if(!strcmp(variable, \"vflip\")) res = s->set_vflip(s, val);",
                            "    else if(!strcmp(variable, \"awb_gain\")) res = s->set_awb_gain(s, val);",
                            "    else if(!strcmp(variable, \"agc_gain\")) res = s->set_agc_gain(s, val);",
                            "    else if(!strcmp(variable, \"aec_value\")) res = s->set_aec_value(s, val);",
                            "    else if(!strcmp(variable, \"aec2\")) res = s->set_aec2(s, val);",
                            "    else if(!strcmp(variable, \"dcw\")) res = s->set_dcw(s, val);",
                            "    else if(!strcmp(variable, \"bpc\")) res = s->set_bpc(s, val);",
                            "    else if(!strcmp(variable, \"wpc\")) res = s->set_wpc(s, val);",
                            "    else if(!strcmp(variable, \"raw_gma\")) res = s->set_raw_gma(s, val);",
                            "    else if(!strcmp(variable, \"lenc\")) res = s->set_lenc(s, val);",
                            "    else if(!strcmp(variable, \"special_effect\")) res = s->set_special_effect(s, val);",
                            "    else if(!strcmp(variable, \"wb_mode\")) res = s->set_wb_mode(s, val);",
                            "    else if(!strcmp(variable, \"ae_level\")) res = s->set_ae_level(s, val);",
                            "    else {",
                            "        res = -1;",
                            "    }",
                            "",
                            "    if(res){",
                            "        return httpd_resp_send_500(req);",
                            "    }",
                            "",
                            "    httpd_resp_set_hdr(req, \"Access-Control-Allow-Origin\", \"*\");",
                            "    return httpd_resp_send(req, NULL, 0);",
                            "}",
                            "",
                            "static esp_err_t status_handler(httpd_req_t *req){",
                            "    static char json_response[1024];",
                            "",
                            "    sensor_t * s = esp_camera_sensor_get();",
                            "    char * p = json_response;",
                            "    *p++ = '{';",
                            "",
                            "    p+=sprintf(p, \"\\\"framesize\\\":%u,\", s->status.framesize);",
                            "    p+=sprintf(p, \"\\\"quality\\\":%u,\", s->status.quality);",
                            "    p+=sprintf(p, \"\\\"brightness\\\":%d,\", s->status.brightness);",
                            "    p+=sprintf(p, \"\\\"contrast\\\":%d,\", s->status.contrast);",
                            "    p+=sprintf(p, \"\\\"saturation\\\":%d,\", s->status.saturation);",
                            "    p+=sprintf(p, \"\\\"special_effect\\\":%u,\", s->status.special_effect);",
                            "    p+=sprintf(p, \"\\\"wb_mode\\\":%u,\", s->status.wb_mode);",
                            "    p+=sprintf(p, \"\\\"awb\\\":%u,\", s->status.awb);",
                            "    p+=sprintf(p, \"\\\"awb_gain\\\":%u,\", s->status.awb_gain);",
                            "    p+=sprintf(p, \"\\\"aec\\\":%u,\", s->status.aec);",
                            "    p+=sprintf(p, \"\\\"aec2\\\":%u,\", s->status.aec2);",
                            "    p+=sprintf(p, \"\\\"ae_level\\\":%d,\", s->status.ae_level);",
                            "    p+=sprintf(p, \"\\\"aec_value\\\":%u,\", s->status.aec_value);",
                            "    p+=sprintf(p, \"\\\"agc\\\":%u,\", s->status.agc);",
                            "    p+=sprintf(p, \"\\\"agc_gain\\\":%u,\", s->status.agc_gain);",
                            "    p+=sprintf(p, \"\\\"gainceiling\\\":%u,\", s->status.gainceiling);",
                            "    p+=sprintf(p, \"\\\"bpc\\\":%u,\", s->status.bpc);",
                            "    p+=sprintf(p, \"\\\"wpc\\\":%u,\", s->status.wpc);",
                            "    p+=sprintf(p, \"\\\"raw_gma\\\":%u,\", s->status.raw_gma);",
                            "    p+=sprintf(p, \"\\\"lenc\\\":%u,\", s->status.lenc);",
                            "    p+=sprintf(p, \"\\\"hmirror\\\":%u,\", s->status.hmirror);",
                            "    p+=sprintf(p, \"\\\"dcw\\\":%u,\", s->status.dcw);",
                            "    p+=sprintf(p, \"\\\"colorbar\\\":%u\", s->status.colorbar);",
                            "    *p++ = '}';",
                            "    *p++ = 0;",
                            "    httpd_resp_set_type(req, \"application/json\");",
                            "    httpd_resp_set_hdr(req, \"Access-Control-Allow-Origin\", \"*\");",
                            "    return httpd_resp_send(req, json_response, strlen(json_response));",
                            "}",
                            "",
                            "static esp_err_t index_handler(httpd_req_t *req){",
                            "    httpd_resp_set_type(req, \"text/html\");",
                            "    httpd_resp_set_hdr(req, \"Content-Encoding\", \"gzip\");",
                            "    return httpd_resp_send(req, (const char *)index_html_gz, index_html_gz_len);",
                            "}",
                            "",
                            "void startCameraServer(){",
                            "    httpd_config_t config = HTTPD_DEFAULT_CONFIG();",
                            "",
                            "    httpd_uri_t index_uri = {",
                            "        .uri       = \"/\",",
                            "        .method    = HTTP_GET,",
                            "        .handler   = index_handler,",
                            "        .user_ctx  = NULL",
                            "    };",
                            "",
                            "    httpd_uri_t status_uri = {",
                            "        .uri       = \"/status\",",
                            "        .method    = HTTP_GET,",
                            "        .handler   = status_handler,",
                            "        .user_ctx  = NULL",
                            "    };",
                            "",
                            "    httpd_uri_t cmd_uri = {",
                            "        .uri       = \"/control\",",
                            "        .method    = HTTP_GET,",
                            "        .handler   = cmd_handler,",
                            "        .user_ctx  = NULL",
                            "    };",
                            "",
                            "    httpd_uri_t capture_uri = {",
                            "        .uri       = \"/capture\",",
                            "        .method    = HTTP_GET,",
                            "        .handler   = capture_handler,",
                            "        .user_ctx  = NULL",
                            "    };",
                            "",
                            "   httpd_uri_t stream_uri = {",
                            "        .uri       = \"/stream\",",
                            "        .method    = HTTP_GET,",
                            "        .handler   = stream_handler,",
                            "        .user_ctx  = NULL",
                            "    };",
                            "",
                            "",
                            "    ra_filter_init(&ra_filter, 20);",
                            "    Serial.printf(\"Starting web server on port: '%d'\", config.server_port);",
                            "    if (httpd_start(&camera_httpd, &config) == ESP_OK) {",
                            "        httpd_register_uri_handler(camera_httpd, &index_uri);",
                            "        httpd_register_uri_handler(camera_httpd, &cmd_uri);",
                            "        httpd_register_uri_handler(camera_httpd, &status_uri);",
                            "        httpd_register_uri_handler(camera_httpd, &capture_uri);",
                            "    }",
                            "",
                            "    config.server_port += 1;",
                            "    config.ctrl_port += 1;",
                            "    Serial.printf(\"Starting stream server on port: '%d'\", config.server_port);",
                            "    if (httpd_start(&stream_httpd, &config) == ESP_OK) {",
                            "        httpd_register_uri_handler(stream_httpd, &stream_uri);",
                            "    }",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "1": "// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD",
                "3": "// Licensed under the Apache License, Version 2.0 (the \"License\");",
                "4": "// you may not use this file except in compliance with the License.",
                "5": "// You may obtain a copy of the License at",
                "7": "//     http://www.apache.org/licenses/LICENSE-2.0",
                "9": "// Unless required by applicable law or agreed to in writing, software",
                "10": "// distributed under the License is distributed on an \"AS IS\" BASIS,",
                "11": "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "12": "// See the License for the specific language governing permissions and",
                "13": "// limitations under the License."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "fa61b3bffedc0c5b65de69c1a550c7c07d437faa",
            "timestamp": "2019-01-09T19:31:46+01:00",
            "author": "Me No Dev",
            "commit_message": "Update IDF to e931fe9 and add esp-face (#2291)\n\n* Update IDF to e931fe9 and add esp-face\r\n\r\n* Fix PIO builds fail because of sketch size\r\n\r\n* Fix example build failing for Arduino",
            "additions": 318,
            "deletions": 27,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206
                        ],
                        "comments": [
                            "        // rectangle box",
                            "        // landmark"
                        ],
                        "lines": [
                            "        x = (int)boxes->box[i].box_p[0];",
                            "        y = (int)boxes->box[i].box_p[1];",
                            "        w = (int)boxes->box[i].box_p[2] - x + 1;",
                            "        h = (int)boxes->box[i].box_p[3] - y + 1;",
                            "        fb_gfx_drawFastHLine(&fb, x, y, w, color);",
                            "        fb_gfx_drawFastHLine(&fb, x, y+h-1, w, color);",
                            "        fb_gfx_drawFastVLine(&fb, x, y, h, color);",
                            "        fb_gfx_drawFastVLine(&fb, x+w-1, y, h, color);",
                            "#if 0",
                            "        int x0, y0, j;",
                            "        for (j = 0; j < 10; j+=2) {",
                            "            x0 = (int)boxes->landmark[i].landmark_p[j];",
                            "            y0 = (int)boxes->landmark[i].landmark_p[j+1];",
                            "            fb_gfx_fillRect(&fb, x0, y0, 3, 3, color);",
                            "        }",
                            "#endif",
                            "    }",
                            "}",
                            "",
                            "static int run_face_recognition(dl_matrix3du_t *image_matrix, box_array_t *net_boxes){",
                            "    dl_matrix3du_t *aligned_face = NULL;",
                            "    int matched_id = 0;",
                            "",
                            "    aligned_face = dl_matrix3du_alloc(1, FACE_WIDTH, FACE_HEIGHT, 3);",
                            "    if(!aligned_face){",
                            "        Serial.println(\"Could not allocate face recognition buffer\");",
                            "        return matched_id;",
                            "    }",
                            "    if (align_face(net_boxes, image_matrix, aligned_face) == ESP_OK){",
                            "        if (is_enrolling == 1){",
                            "            int8_t left_sample_face = enroll_face(&id_list, aligned_face);",
                            "",
                            "            if(left_sample_face == (ENROLL_CONFIRM_TIMES - 1)){",
                            "                Serial.printf(\"Enrolling Face ID: %d\\n\", id_list.tail);",
                            "            }",
                            "            Serial.printf(\"Enrolling Face ID: %d sample %d\\n\", id_list.tail, ENROLL_CONFIRM_TIMES - left_sample_face);",
                            "            rgb_printf(image_matrix, FACE_COLOR_CYAN, \"ID[%u] Sample[%u]\", id_list.tail, ENROLL_CONFIRM_TIMES - left_sample_face);",
                            "            if (left_sample_face == 0){",
                            "                is_enrolling = 0;",
                            "                Serial.printf(\"Enrolled Face ID: %d\\n\", id_list.tail);",
                            "            }",
                            "        } else {",
                            "            matched_id = recognize_face(&id_list, aligned_face);",
                            "            if (matched_id >= 0) {",
                            "                Serial.printf(\"Match Face ID: %u\\n\", matched_id);",
                            "                rgb_printf(image_matrix, FACE_COLOR_GREEN, \"Hello Subject %u\", matched_id);",
                            "            } else {",
                            "                Serial.println(\"No Match Found\");",
                            "                rgb_print(image_matrix, FACE_COLOR_RED, \"Intruder Alert!\");",
                            "                matched_id = -1;",
                            "            }",
                            "        }",
                            "    } else {",
                            "        Serial.println(\"Face Not Aligned\");",
                            "        //rgb_print(image_matrix, FACE_COLOR_YELLOW, \"Human Detected\");",
                            "    }",
                            "",
                            "    dl_matrix3du_free(aligned_face);",
                            "    return matched_id;",
                            "}",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            226
                        ],
                        "comments": [],
                        "lines": [
                            "        Serial.println(\"Camera capture failed\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261
                        ],
                        "comments": [],
                        "lines": [
                            "    size_t out_len, out_width, out_height;",
                            "    uint8_t * out_buf;",
                            "    bool s;",
                            "    bool detected = false;",
                            "    int face_id = 0;",
                            "    if(!detection_enabled || fb->width > 400){",
                            "        size_t fb_len = 0;",
                            "        if(fb->format == PIXFORMAT_JPEG){",
                            "            fb_len = fb->len;",
                            "            res = httpd_resp_send(req, (const char *)fb->buf, fb->len);",
                            "        } else {",
                            "            jpg_chunking_t jchunk = {req, 0};",
                            "            res = frame2jpg_cb(fb, 80, jpg_encode_stream, &jchunk)?ESP_OK:ESP_FAIL;",
                            "            httpd_resp_send_chunk(req, NULL, 0);",
                            "            fb_len = jchunk.len;",
                            "        }",
                            "        esp_camera_fb_return(fb);",
                            "        int64_t fr_end = esp_timer_get_time();",
                            "        Serial.printf(\"JPG: %uB %ums\\n\", (uint32_t)(fb_len), (uint32_t)((fr_end - fr_start)/1000));",
                            "        return res;",
                            "    }",
                            "",
                            "    dl_matrix3du_t *image_matrix = dl_matrix3du_alloc(1, fb->width, fb->height, 3);",
                            "    if (!image_matrix) {",
                            "        esp_camera_fb_return(fb);",
                            "        Serial.println(\"dl_matrix3du_alloc failed\");",
                            "        httpd_resp_send_500(req);",
                            "        return ESP_FAIL;"
                        ]
                    },
                    {
                        "line_numbers": [
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "    out_buf = image_matrix->item;",
                            "    out_len = fb->width * fb->height * 3;",
                            "    out_width = fb->width;",
                            "    out_height = fb->height;",
                            "",
                            "    s = fmt2rgb888(fb->buf, fb->len, fb->format, out_buf);"
                        ]
                    },
                    {
                        "line_numbers": [
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298
                        ],
                        "comments": [],
                        "lines": [
                            "    if(!s){",
                            "        dl_matrix3du_free(image_matrix);",
                            "        Serial.println(\"to rgb888 failed\");",
                            "        httpd_resp_send_500(req);",
                            "        return ESP_FAIL;",
                            "    }",
                            "",
                            "    box_array_t *net_boxes = face_detect(image_matrix, &mtmn_config);",
                            "",
                            "    if (net_boxes){",
                            "        detected = true;",
                            "        if(recognition_enabled){",
                            "            face_id = run_face_recognition(image_matrix, net_boxes);",
                            "        }",
                            "        draw_face_boxes(image_matrix, net_boxes, face_id);",
                            "        free(net_boxes->box);",
                            "        free(net_boxes->landmark);",
                            "        free(net_boxes);",
                            "    }",
                            "",
                            "    jpg_chunking_t jchunk = {req, 0};",
                            "    s = fmt2jpg_cb(out_buf, out_len, out_width, out_height, PIXFORMAT_RGB888, 90, jpg_encode_stream, &jchunk);",
                            "    dl_matrix3du_free(image_matrix);",
                            "    if(!s){",
                            "        Serial.println(\"JPEG compression failed\");",
                            "        return ESP_FAIL;",
                            "    }",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            300
                        ],
                        "comments": [],
                        "lines": [
                            "    Serial.printf(\"FACE: %uB %ums %s%d\\n\", (uint32_t)(jchunk.len), (uint32_t)((fr_end - fr_start)/1000), detected?\"DETECTED \":\"\", face_id);"
                        ]
                    },
                    {
                        "line_numbers": [
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317
                        ],
                        "comments": [],
                        "lines": [
                            "    dl_matrix3du_t *image_matrix = NULL;",
                            "    bool detected = false;",
                            "    int face_id = 0;",
                            "    int64_t fr_start = 0;",
                            "    int64_t fr_ready = 0;",
                            "    int64_t fr_face = 0;",
                            "    int64_t fr_recognize = 0;",
                            "    int64_t fr_encode = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            330,
                            331
                        ],
                        "comments": [],
                        "lines": [
                            "        detected = false;",
                            "        face_id = 0;"
                        ]
                    },
                    {
                        "line_numbers": [
                            334
                        ],
                        "comments": [],
                        "lines": [
                            "            Serial.println(\"Camera capture failed\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353
                        ],
                        "comments": [],
                        "lines": [
                            "            fr_start = esp_timer_get_time();",
                            "            fr_ready = fr_start;",
                            "            fr_face = fr_start;",
                            "            fr_encode = fr_start;",
                            "            fr_recognize = fr_start;",
                            "            if(!detection_enabled || fb->width > 400){",
                            "                if(fb->format != PIXFORMAT_JPEG){",
                            "                    bool jpeg_converted = frame2jpg(fb, 80, &_jpg_buf, &_jpg_buf_len);",
                            "                    esp_camera_fb_return(fb);",
                            "                    fb = NULL;",
                            "                    if(!jpeg_converted){",
                            "                        Serial.println(\"JPEG compression failed\");",
                            "                        res = ESP_FAIL;",
                            "                    }",
                            "                } else {",
                            "                    _jpg_buf_len = fb->len;",
                            "                    _jpg_buf = fb->buf;"
                        ]
                    },
                    {
                        "line_numbers": [
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "                image_matrix = dl_matrix3du_alloc(1, fb->width, fb->height, 3);",
                            "",
                            "                if (!image_matrix) {",
                            "                    Serial.println(\"dl_matrix3du_alloc failed\");",
                            "                    res = ESP_FAIL;",
                            "                } else {",
                            "                    if(!fmt2rgb888(fb->buf, fb->len, fb->format, image_matrix->item)){",
                            "                        Serial.println(\"fmt2rgb888 failed\");",
                            "                        res = ESP_FAIL;",
                            "                    } else {",
                            "                        fr_ready = esp_timer_get_time();",
                            "                        box_array_t *net_boxes = NULL;",
                            "                        if(detection_enabled){",
                            "                            net_boxes = face_detect(image_matrix, &mtmn_config);",
                            "                        }",
                            "                        fr_face = esp_timer_get_time();",
                            "                        fr_recognize = fr_face;",
                            "                        if (net_boxes || fb->format != PIXFORMAT_JPEG){",
                            "                            if(net_boxes){",
                            "                                detected = true;",
                            "                                if(recognition_enabled){",
                            "                                    face_id = run_face_recognition(image_matrix, net_boxes);",
                            "                                }",
                            "                                fr_recognize = esp_timer_get_time();",
                            "                                draw_face_boxes(image_matrix, net_boxes, face_id);",
                            "                                free(net_boxes->box);",
                            "                                free(net_boxes->landmark);",
                            "                                free(net_boxes);",
                            "                            }",
                            "                            if(!fmt2jpg(image_matrix->item, fb->width*fb->height*3, fb->width, fb->height, PIXFORMAT_RGB888, 90, &_jpg_buf, &_jpg_buf_len)){",
                            "                                Serial.println(\"fmt2jpg failed\");",
                            "                                res = ESP_FAIL;",
                            "                            }",
                            "                            esp_camera_fb_return(fb);",
                            "                            fb = NULL;",
                            "                        } else {",
                            "                            _jpg_buf = fb->buf;",
                            "                            _jpg_buf_len = fb->len;",
                            "                        }",
                            "                        fr_encode = esp_timer_get_time();",
                            "                    }",
                            "                    dl_matrix3du_free(image_matrix);",
                            "                }"
                        ]
                    },
                    {
                        "line_numbers": [
                            425,
                            426,
                            427,
                            428,
                            429,
                            430
                        ],
                        "comments": [],
                        "lines": [
                            "        int64_t ready_time = (fr_ready - fr_start)/1000;",
                            "        int64_t face_time = (fr_face - fr_ready)/1000;",
                            "        int64_t recognize_time = (fr_recognize - fr_face)/1000;",
                            "        int64_t encode_time = (fr_encode - fr_recognize)/1000;",
                            "        int64_t process_time = (fr_encode - fr_start)/1000;",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            435,
                            436
                        ],
                        "comments": [],
                        "lines": [
                            "        Serial.printf(\"MJPG: %uB %ums (%.1ffps), AVG: %ums (%.1ffps), %u+%u+%u+%u=%u %s%d\\n\",",
                            "            (uint32_t)(_jpg_buf_len),"
                        ]
                    },
                    {
                        "line_numbers": [
                            438,
                            439,
                            440
                        ],
                        "comments": [],
                        "lines": [
                            "            avg_frame_time, 1000.0 / avg_frame_time,",
                            "            (uint32_t)ready_time, (uint32_t)face_time, (uint32_t)recognize_time, (uint32_t)encode_time, (uint32_t)process_time,",
                            "            (detected)?\"DETECTED \":\"\", face_id"
                        ]
                    },
                    {
                        "line_numbers": [
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522
                        ],
                        "comments": [],
                        "lines": [
                            "    else if(!strcmp(variable, \"face_detect\")) {",
                            "        detection_enabled = val;",
                            "        if(!detection_enabled) {",
                            "            recognition_enabled = 0;",
                            "        }",
                            "    }",
                            "    else if(!strcmp(variable, \"face_enroll\")) is_enrolling = val;",
                            "    else if(!strcmp(variable, \"face_recognize\")) {",
                            "        recognition_enabled = val;",
                            "        if(recognition_enabled){",
                            "            detection_enabled = val;",
                            "        }",
                            "    }"
                        ]
                    },
                    {
                        "line_numbers": [
                            562
                        ],
                        "comments": [],
                        "lines": [
                            "    p+=sprintf(p, \"\\\"vflip\\\":%u,\", s->status.vflip);"
                        ]
                    },
                    {
                        "line_numbers": [
                            565,
                            566,
                            567,
                            568
                        ],
                        "comments": [],
                        "lines": [
                            "    p+=sprintf(p, \"\\\"colorbar\\\":%u,\", s->status.colorbar);",
                            "    p+=sprintf(p, \"\\\"face_detect\\\":%u,\", detection_enabled);",
                            "    p+=sprintf(p, \"\\\"face_enroll\\\":%u,\", is_enrolling);",
                            "    p+=sprintf(p, \"\\\"face_recognize\\\":%u\", recognition_enabled);"
                        ]
                    },
                    {
                        "line_numbers": [
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636
                        ],
                        "comments": [],
                        "lines": [
                            "",
                            "    mtmn_config.min_face = 80;",
                            "    mtmn_config.pyramid = 0.7;",
                            "    mtmn_config.p_threshold.score = 0.6;",
                            "    mtmn_config.p_threshold.nms = 0.7;",
                            "    mtmn_config.r_threshold.score = 0.7;",
                            "    mtmn_config.r_threshold.nms = 0.7;",
                            "    mtmn_config.r_threshold.candidate_number = 4;",
                            "    mtmn_config.o_threshold.score = 0.7;",
                            "    mtmn_config.o_threshold.nms = 0.4;",
                            "    mtmn_config.o_threshold.candidate_number = 1;",
                            "",
                            "    face_id_init(&id_list, FACE_ID_SAVE_NUMBER, ENROLL_CONFIRM_TIMES);",
                            "",
                            "    Serial.printf(\"Starting web server on port: '%d'\\n\", config.server_port);"
                        ]
                    },
                    {
                        "line_numbers": [
                            646
                        ],
                        "comments": [],
                        "lines": [
                            "    Serial.printf(\"Starting stream server on port: '%d'\\n\", config.server_port);"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "144": "        // rectangle box",
                "154": "        // landmark"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "camera_index.h": [],
    "tcpip_adapter_internal.h": [],
    "esp32.extram.bss.ld": [],
    "build.py": [],
    "huge_app.csv": [],
    "dl_lib.h": [],
    "dl_lib_coefgetter_if.h": [],
    "dl_lib_matrix.h": [],
    "dl_lib_matrix3d.h": [],
    "dl_lib_matrix3dq.h": [],
    "dl_lib_matrixq.h": [],
    "fd_forward.h": [],
    "fr_flash.h": [],
    "fr_forward.h": [],
    "frmn.h": [],
    "image_util.h": [],
    "mtmn.h": [],
    "esp_https_server.h": [],
    "fb_gfx.h": [],
    "libdl_lib.a": [],
    "libface_detection.a": [],
    "libface_recognition.a": [],
    "libfb_gfx.a": [],
    "libfd_coefficients.a": [],
    "libfr_coefficients.a": [],
    "libfrmn.a": [],
    "libimage_util.a": [],
    "liblib.a": [],
    "libmtmn.a": [],
    "Prefs2Struct.ino": [],
    ".gitmodules": [],
    "BLE_client.ino": [],
    "BLE_iBeacon.ino": [],
    "BLE_notify.ino": [],
    "BLE_scan.ino": [],
    "BLE_server.ino": [],
    "BLE_server_multiconnect.ino": [],
    "BLE_uart.ino": [],
    "BLE_write.ino": [],
    "BLE2902.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 62,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62
                        ],
                        "comments": [
                            "} // BLE2902",
                            "} // getNotifications",
                            "} // getIndications",
                            "} // setIndications",
                            "} // setNotifications"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Get the notifications value.",
                            " * @return The notifications value.  True if notifications are enabled and false if not.",
                            " */",
                            "bool BLE2902::getNotifications() {",
                            "\treturn (getValue()[0] & (1 << 0)) != 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the indications value.",
                            " * @return The indications value.  True if indications are enabled and false if not.",
                            " */",
                            "bool BLE2902::getIndications() {",
                            "\treturn (getValue()[0] & (1 << 1)) != 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the indications flag.",
                            " * @param [in] flag The indications flag.",
                            " */",
                            "void BLE2902::setIndications(bool flag) {",
                            "\tuint8_t *pValue = getValue();",
                            "\tif (flag) pValue[0] |= 1 << 1;",
                            "\telse pValue[0] &= ~(1 << 1);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the notifications flag.",
                            " * @param [in] flag The notifications flag.",
                            " */",
                            "void BLE2902::setNotifications(bool flag) {",
                            "\tuint8_t *pValue = getValue();",
                            "\tif (flag) pValue[0] |= 1 << 0;",
                            "\telse pValue[0] &= ~(1 << 0);",
                            "",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "20": "} // BLE2902",
                "29": "} // getNotifications",
                "38": "} // getIndications",
                "49": "} // setIndications",
                "60": "} // setNotifications"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLE2902.h": [],
    "BLE2904.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 74,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74
                        ],
                        "comments": [
                            "\tm_data.m_namespace   = 1;  // 1 = Bluetooth SIG Assigned Numbers",
                            "} // BLE2902",
                            "} // setExponent",
                            "} // setFormat",
                            "} // setNamespace",
                            "} // setUnit"
                        ],
                        "lines": [
                            "\tm_data.m_unit        = 0;",
                            "\tm_data.m_description = 0;",
                            "\tsetValue((uint8_t*) &m_data, sizeof(m_data));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the description.",
                            " */",
                            "void BLE2904::setDescription(uint16_t description) {",
                            "\tm_data.m_description = description;",
                            "\tsetValue((uint8_t*) &m_data, sizeof(m_data));",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the exponent.",
                            " */",
                            "void BLE2904::setExponent(int8_t exponent) {",
                            "\tm_data.m_exponent = exponent;",
                            "\tsetValue((uint8_t*) &m_data, sizeof(m_data));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the format.",
                            " */",
                            "void BLE2904::setFormat(uint8_t format) {",
                            "\tm_data.m_format = format;",
                            "\tsetValue((uint8_t*) &m_data, sizeof(m_data));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the namespace.",
                            " */",
                            "void BLE2904::setNamespace(uint8_t namespace_value) {",
                            "\tm_data.m_namespace = namespace_value;",
                            "\tsetValue((uint8_t*) &m_data, sizeof(m_data));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the units for this value.  It should be one of the encoded values defined here:",
                            " * https://www.bluetooth.com/specifications/assigned-numbers/units",
                            " * @param [in] unit The type of units of this characteristic as defined by assigned numbers.",
                            " */",
                            "void BLE2904::setUnit(uint16_t unit) {",
                            "\tm_data.m_unit = unit;",
                            "\tsetValue((uint8_t*) &m_data, sizeof(m_data));",
                            "",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "21": "\tm_data.m_namespace   = 1;  // 1 = Bluetooth SIG Assigned Numbers",
                "25": "} // BLE2902",
                "43": "} // setExponent",
                "52": "} // setFormat",
                "61": "} // setNamespace",
                "72": "} // setUnit"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLE2904.h": [],
    "BLEAddress.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 95,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95
                        ],
                        "comments": [
                            "} // BLEAddress",
                            "} // BLEAddress",
                            "} // equals",
                            "} // getNative",
                            "} // toString"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Create an address from a hex string",
                            " *",
                            " * A hex string is of the format:",
                            " * ```",
                            " * 00:00:00:00:00:00",
                            " * ```",
                            " * which is 17 characters in length.",
                            " *",
                            " * @param [in] stringAddress The hex representation of the address.",
                            " */",
                            "BLEAddress::BLEAddress(std::string stringAddress) {",
                            "\tif (stringAddress.length() != 17) return;",
                            "",
                            "\tint data[6];",
                            "\tsscanf(stringAddress.c_str(), \"%x:%x:%x:%x:%x:%x\", &data[0], &data[1], &data[2], &data[3], &data[4], &data[5]);",
                            "\tm_address[0] = (uint8_t) data[0];",
                            "\tm_address[1] = (uint8_t) data[1];",
                            "\tm_address[2] = (uint8_t) data[2];",
                            "\tm_address[3] = (uint8_t) data[3];",
                            "\tm_address[4] = (uint8_t) data[4];",
                            "\tm_address[5] = (uint8_t) data[5];",
                            "",
                            "",
                            "/**",
                            " * @brief Determine if this address equals another.",
                            " * @param [in] otherAddress The other address to compare against.",
                            " * @return True if the addresses are equal.",
                            " */",
                            "bool BLEAddress::equals(BLEAddress otherAddress) {",
                            "\treturn memcmp(otherAddress.getNative(), m_address, 6) == 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Return the native representation of the address.",
                            " * @return The native representation of the address.",
                            " */",
                            "esp_bd_addr_t *BLEAddress::getNative() {",
                            "\treturn &m_address;",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a BLE address to a string.",
                            " *",
                            " * A string representation of an address is in the format:",
                            " *",
                            " * ```",
                            " * xx:xx:xx:xx:xx:xx",
                            " * ```",
                            " *",
                            " * @return The string representation of the address.",
                            " */",
                            "std::string BLEAddress::toString() {",
                            "\tstd::stringstream stream;",
                            "\tstream << std::setfill('0') << std::setw(2) << std::hex << (int) ((uint8_t*) (m_address))[0] << ':';",
                            "\tstream << std::setfill('0') << std::setw(2) << std::hex << (int) ((uint8_t*) (m_address))[1] << ':';",
                            "\tstream << std::setfill('0') << std::setw(2) << std::hex << (int) ((uint8_t*) (m_address))[2] << ':';",
                            "\tstream << std::setfill('0') << std::setw(2) << std::hex << (int) ((uint8_t*) (m_address))[3] << ':';",
                            "\tstream << std::setfill('0') << std::setw(2) << std::hex << (int) ((uint8_t*) (m_address))[4] << ':';",
                            "\tstream << std::setfill('0') << std::setw(2) << std::hex << (int) ((uint8_t*) (m_address))[5];",
                            "\treturn stream.str();",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "27": "} // BLEAddress",
                "52": "} // BLEAddress",
                "62": "} // equals",
                "71": "} // getNative",
                "94": "} // toString"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEAddress.h": [],
    "BLEAdvertisedDevice.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 529,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529
                        ],
                        "comments": [
                            "} // BLEAdvertisedDevice",
                            "} // getAddress",
                            "} // getAppearance",
                            "} // getManufacturerData",
                            "} // getName",
                            "} // getRSSI",
                            "} // getScan",
                            "} // getServiceDataUUID",
                            "} // getServiceUUID",
                            "} // getTXPower",
                            "} // haveAppearance",
                            "} // haveManufacturerData",
                            "} // haveName",
                            "} // haveRSSI",
                            "} // haveServiceData",
                            "} // haveServiceUUID",
                            "} // haveTXPower",
                            "\t\tlength = *payload;          // Retrieve the length of the record.",
                            "\t\tpayload++;                  // Skip to type",
                            "\t\tsizeConsumed += 1 + length; // increase the size consumed.",
                            "\t\tif (length != 0) { // A length of 0 indicates that we have reached the end.",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_NAME_CMPL: {   // Adv Data Type: 0x09",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_NAME_CMPL",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_TX_PWR: {      // Adv Data Type: 0x0A",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_TX_PWR",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_APPEARANCE: { // Adv Data Type: 0x19",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_APPEARANCE",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_FLAG: {        // Adv Data Type: 0x01",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_FLAG",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_16SRV_PART: {   // Adv Data Type: 0x02",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_16SRV_PART",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_32SRV_PART: {   // Adv Data Type: 0x04",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_32SRV_PART",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_128SRV_CMPL: { // Adv Data Type: 0x07",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_128SRV_CMPL",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_128SRV_PART: { // Adv Data Type: 0x06",
                            "\t\t\t\t} // ESP_BLE_AD_TYPE_128SRV_PART",
                            "\t\t\t\t// See CSS Part A 1.4 Manufacturer Specific Data",
                            "\t\t\t\t} // ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_SERVICE_DATA: {  // Adv Data Type: 0x16 (Service Data) - 2 byte UUID",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_32SERVICE_DATA: {  // Adv Data Type: 0x20 (Service Data) - 4 byte UUID",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_128SERVICE_DATA: {  // Adv Data Type: 0x21 (Service Data) - 16 byte UUID",
                            "\t\t\t} // switch",
                            "\t\t} // Length <> 0",
                            "\t} // !finished",
                            "} // parseAdvertisement",
                            "} // setAddress",
                            "} // setAdFlag",
                            "} // setAppearance",
                            "} // setManufacturerData",
                            "} // setName",
                            "} // setRSSI",
                            "} // setScan",
                            "} // setServiceUUID",
                            "} // setServiceUUID",
                            "\tm_haveServiceData = true;         // Set the flag that indicates we have service data.",
                            "\tm_serviceData     = serviceData;  // Save the service data that we received.",
                            "\tm_haveServiceData = true;         // Set the flag that indicates we have service data.",
                            "} // setServiceDataUUID",
                            "} // setTXPower",
                            "} // toString"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Get the address.",
                            " *",
                            " * Every %BLE device exposes an address that is used to identify it and subsequently connect to it.",
                            " * Call this function to obtain the address of the advertised device.",
                            " *",
                            " * @return The address of the advertised device.",
                            " */",
                            "BLEAddress BLEAdvertisedDevice::getAddress() {",
                            "\treturn m_address;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the appearance.",
                            " *",
                            " * A %BLE device can declare its own appearance.  The appearance is how it would like to be shown to an end user",
                            " * typcially in the form of an icon.",
                            " *",
                            " * @return The appearance of the advertised device.",
                            " */",
                            "uint16_t BLEAdvertisedDevice::getAppearance() {",
                            "\treturn m_appearance;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the manufacturer data.",
                            " * @return The manufacturer data of the advertised device.",
                            " */",
                            "std::string BLEAdvertisedDevice::getManufacturerData() {",
                            "\treturn m_manufacturerData;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the name.",
                            " * @return The name of the advertised device.",
                            " */",
                            "std::string BLEAdvertisedDevice::getName() {",
                            "\treturn m_name;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the RSSI.",
                            " * @return The RSSI of the advertised device.",
                            " */",
                            "int BLEAdvertisedDevice::getRSSI() {",
                            "\treturn m_rssi;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the scan object that created this advertisement.",
                            " * @return The scan object.",
                            " */",
                            "BLEScan* BLEAdvertisedDevice::getScan() {",
                            "\treturn m_pScan;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the service data.",
                            " * @return The ServiceData of the advertised device.",
                            " */",
                            "std::string BLEAdvertisedDevice::getServiceData() {",
                            "\treturn m_serviceData;",
                            "} //getServiceData",
                            "",
                            "",
                            "/**",
                            " * @brief Get the service data UUID.",
                            " * @return The service data UUID.",
                            " */",
                            "BLEUUID BLEAdvertisedDevice::getServiceDataUUID() {",
                            "\treturn m_serviceDataUUID;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the Service UUID.",
                            " * @return The Service UUID of the advertised device.",
                            " */",
                            "BLEUUID BLEAdvertisedDevice::getServiceUUID() {  //TODO Remove it eventually, is no longer useful",
                            "\treturn m_serviceUUIDs[0];",
                            "",
                            "/**",
                            " * @brief Check advertised serviced for existence required UUID",
                            " * @return Return true if service is advertised",
                            " */",
                            "bool BLEAdvertisedDevice::isAdvertisingService(BLEUUID uuid){",
                            "\tfor (int i = 0; i < m_serviceUUIDs.size(); i++) {",
                            "\t\tif (m_serviceUUIDs[i].equals(uuid)) return true;",
                            "\t}",
                            "\treturn false;",
                            "}",
                            "",
                            "/**",
                            " * @brief Get the TX Power.",
                            " * @return The TX Power of the advertised device.",
                            " */",
                            "int8_t BLEAdvertisedDevice::getTXPower() {",
                            "\treturn m_txPower;",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Does this advertisement have an appearance value?",
                            " * @return True if there is an appearance value present.",
                            " */",
                            "bool BLEAdvertisedDevice::haveAppearance() {",
                            "\treturn m_haveAppearance;",
                            "",
                            "",
                            "/**",
                            " * @brief Does this advertisement have manufacturer data?",
                            " * @return True if there is manufacturer data present.",
                            " */",
                            "bool BLEAdvertisedDevice::haveManufacturerData() {",
                            "\treturn m_haveManufacturerData;",
                            "",
                            "",
                            "/**",
                            " * @brief Does this advertisement have a name value?",
                            " * @return True if there is a name value present.",
                            " */",
                            "bool BLEAdvertisedDevice::haveName() {",
                            "\treturn m_haveName;",
                            "",
                            "",
                            "/**",
                            " * @brief Does this advertisement have a signal strength value?",
                            " * @return True if there is a signal strength value present.",
                            " */",
                            "bool BLEAdvertisedDevice::haveRSSI() {",
                            "\treturn m_haveRSSI;",
                            "",
                            "",
                            "/**",
                            " * @brief Does this advertisement have a service data value?",
                            " * @return True if there is a service data value present.",
                            " */",
                            "bool BLEAdvertisedDevice::haveServiceData() {",
                            "\treturn m_haveServiceData;",
                            "",
                            "",
                            "/**",
                            " * @brief Does this advertisement have a service UUID value?",
                            " * @return True if there is a service UUID value present.",
                            " */",
                            "bool BLEAdvertisedDevice::haveServiceUUID() {",
                            "\treturn m_haveServiceUUID;",
                            "",
                            "",
                            "/**",
                            " * @brief Does this advertisement have a transmission power value?",
                            " * @return True if there is a transmission power value present.",
                            " */",
                            "bool BLEAdvertisedDevice::haveTXPower() {",
                            "\treturn m_haveTXPower;",
                            "",
                            "",
                            "/**",
                            " * @brief Parse the advertising pay load.",
                            " *",
                            " * The pay load is a buffer of bytes that is either 31 bytes long or terminated by",
                            " * a 0 length value.  Each entry in the buffer has the format:",
                            " * [length][type][data...]",
                            " *",
                            " * The length does not include itself but does include everything after it until the next record.  A record",
                            " * with a length value of 0 indicates a terminator.",
                            " *",
                            " * https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile",
                            " */",
                            "void BLEAdvertisedDevice::parseAdvertisement(uint8_t* payload, size_t total_len) {",
                            "\tuint8_t length;",
                            "\tuint8_t ad_type;",
                            "\tuint8_t sizeConsumed = 0;",
                            "\tbool finished = false;",
                            "\tm_payload = payload;",
                            "\tm_payloadLength = total_len;",
                            "",
                            "\twhile(!finished) {",
                            "",
                            "\t\t\tad_type = *payload;",
                            "\t\t\tpayload++;",
                            "\t\t\tlength--;",
                            "",
                            "\t\t\tchar* pHex = BLEUtils::buildHexData(nullptr, payload, length);",
                            "\t\t\tESP_LOGD(LOG_TAG, \"Type: 0x%.2x (%s), length: %d, data: %s\",",
                            "\t\t\t\t\tad_type, BLEUtils::advTypeToString(ad_type), length, pHex);",
                            "\t\t\tfree(pHex);",
                            "",
                            "\t\t\tswitch(ad_type) {",
                            "\t\t\t\t\tsetName(std::string(reinterpret_cast<char*>(payload), length));",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\t\tsetTXPower(*payload);",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\t\tsetAppearance(*reinterpret_cast<uint16_t*>(payload));",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\t\tsetAdFlag(*payload);",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_16SRV_CMPL:",
                            "\t\t\t\t\tfor (int var = 0; var < length/2; ++var) {",
                            "\t\t\t\t\t\tsetServiceUUID(BLEUUID(*reinterpret_cast<uint16_t*>(payload + var * 2)));",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\tcase ESP_BLE_AD_TYPE_32SRV_CMPL:",
                            "\t\t\t\t\tfor (int var = 0; var < length/4; ++var) {",
                            "\t\t\t\t\t\tsetServiceUUID(BLEUUID(*reinterpret_cast<uint32_t*>(payload + var * 4)));",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\t\tsetServiceUUID(BLEUUID(payload, 16, false));",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\t\tsetServiceUUID(BLEUUID(payload, 16, false));",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\tcase ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE: {",
                            "\t\t\t\t\tsetManufacturerData(std::string(reinterpret_cast<char*>(payload), length));",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\t\tif (length < 2) {",
                            "\t\t\t\t\t\tESP_LOGE(LOG_TAG, \"Length too small for ESP_BLE_AD_TYPE_SERVICE_DATA\");",
                            "\t\t\t\t\t\tbreak;",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tuint16_t uuid = *(uint16_t*)payload;",
                            "\t\t\t\t\tsetServiceDataUUID(BLEUUID(uuid));",
                            "\t\t\t\t\tif (length > 2) {",
                            "\t\t\t\t\t\tsetServiceData(std::string(reinterpret_cast<char*>(payload + 2), length - 2));",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t} //ESP_BLE_AD_TYPE_SERVICE_DATA",
                            "",
                            "\t\t\t\t\tif (length < 4) {",
                            "\t\t\t\t\t\tESP_LOGE(LOG_TAG, \"Length too small for ESP_BLE_AD_TYPE_32SERVICE_DATA\");",
                            "\t\t\t\t\t\tbreak;",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tuint32_t uuid = *(uint32_t*) payload;",
                            "\t\t\t\t\tsetServiceDataUUID(BLEUUID(uuid));",
                            "\t\t\t\t\tif (length > 4) {",
                            "\t\t\t\t\t\tsetServiceData(std::string(reinterpret_cast<char*>(payload + 4), length - 4));",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t} //ESP_BLE_AD_TYPE_32SERVICE_DATA",
                            "",
                            "\t\t\t\t\tif (length < 16) {",
                            "\t\t\t\t\t\tESP_LOGE(LOG_TAG, \"Length too small for ESP_BLE_AD_TYPE_128SERVICE_DATA\");",
                            "\t\t\t\t\t\tbreak;",
                            "\t\t\t\t\t}",
                            "",
                            "\t\t\t\t\tsetServiceDataUUID(BLEUUID(payload, (size_t)16, false));",
                            "\t\t\t\t\tif (length > 16) {",
                            "\t\t\t\t\t\tsetServiceData(std::string(reinterpret_cast<char*>(payload + 16), length - 16));",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t} //ESP_BLE_AD_TYPE_32SERVICE_DATA",
                            "",
                            "\t\t\t\tdefault: {",
                            "\t\t\t\t\tESP_LOGD(LOG_TAG, \"Unhandled type: adType: %d - 0x%.2x\", ad_type, ad_type);",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t}",
                            "\t\t\tpayload += length;",
                            "",
                            "",
                            "\t\tif (sizeConsumed >= total_len)",
                            "\t\t\tfinished = true;",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Set the address of the advertised device.",
                            " * @param [in] address The address of the advertised device.",
                            " */",
                            "void BLEAdvertisedDevice::setAddress(BLEAddress address) {",
                            "\tm_address = address;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the adFlag for this device.",
                            " * @param [in] The discovered adFlag.",
                            " */",
                            "void BLEAdvertisedDevice::setAdFlag(uint8_t adFlag) {",
                            "\tm_adFlag = adFlag;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the appearance for this device.",
                            " * @param [in] The discovered appearance.",
                            " */",
                            "void BLEAdvertisedDevice::setAppearance(uint16_t appearance) {",
                            "\tm_appearance     = appearance;",
                            "\tm_haveAppearance = true;",
                            "\tESP_LOGD(LOG_TAG, \"- appearance: %d\", m_appearance);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the manufacturer data for this device.",
                            " * @param [in] The discovered manufacturer data.",
                            " */",
                            "void BLEAdvertisedDevice::setManufacturerData(std::string manufacturerData) {",
                            "\tm_manufacturerData     = manufacturerData;",
                            "\tm_haveManufacturerData = true;",
                            "\tchar* pHex = BLEUtils::buildHexData(nullptr, (uint8_t*) m_manufacturerData.data(), (uint8_t) m_manufacturerData.length());",
                            "\tESP_LOGD(LOG_TAG, \"- manufacturer data: %s\", pHex);",
                            "\tfree(pHex);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the name for this device.",
                            " * @param [in] name The discovered name.",
                            " */",
                            "void BLEAdvertisedDevice::setName(std::string name) {",
                            "\tm_name     = name;",
                            "\tm_haveName = true;",
                            "\tESP_LOGD(LOG_TAG, \"- setName(): name: %s\", m_name.c_str());",
                            "",
                            "",
                            "/**",
                            " * @brief Set the RSSI for this device.",
                            " * @param [in] rssi The discovered RSSI.",
                            " */",
                            "void BLEAdvertisedDevice::setRSSI(int rssi) {",
                            "\tm_rssi     = rssi;",
                            "\tm_haveRSSI = true;",
                            "\tESP_LOGD(LOG_TAG, \"- setRSSI(): rssi: %d\", m_rssi);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Scan that created this advertised device.",
                            " * @param pScan The Scan that created this advertised device.",
                            " */",
                            "void BLEAdvertisedDevice::setScan(BLEScan* pScan) {",
                            "\tm_pScan = pScan;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Service UUID for this device.",
                            " * @param [in] serviceUUID The discovered serviceUUID",
                            " */",
                            "void BLEAdvertisedDevice::setServiceUUID(const char* serviceUUID) {",
                            "\treturn setServiceUUID(BLEUUID(serviceUUID));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Service UUID for this device.",
                            " * @param [in] serviceUUID The discovered serviceUUID",
                            " */",
                            "void BLEAdvertisedDevice::setServiceUUID(BLEUUID serviceUUID) {",
                            "\tm_serviceUUIDs.push_back(serviceUUID);",
                            "\tm_haveServiceUUID = true;",
                            "\tESP_LOGD(LOG_TAG, \"- addServiceUUID(): serviceUUID: %s\", serviceUUID.toString().c_str());",
                            "",
                            "",
                            "/**",
                            " * @brief Set the ServiceData value.",
                            " * @param [in] data ServiceData value.",
                            " */",
                            "void BLEAdvertisedDevice::setServiceData(std::string serviceData) {",
                            "} //setServiceData",
                            "",
                            "",
                            "/**",
                            " * @brief Set the ServiceDataUUID value.",
                            " * @param [in] data ServiceDataUUID value.",
                            " */",
                            "void BLEAdvertisedDevice::setServiceDataUUID(BLEUUID uuid) {",
                            "\tm_serviceDataUUID = uuid;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the power level for this device.",
                            " * @param [in] txPower The discovered power level.",
                            " */",
                            "void BLEAdvertisedDevice::setTXPower(int8_t txPower) {",
                            "\tm_txPower     = txPower;",
                            "\tm_haveTXPower = true;",
                            "\tESP_LOGD(LOG_TAG, \"- txPower: %d\", m_txPower);",
                            "",
                            "",
                            "/**",
                            " * @brief Create a string representation of this device.",
                            " * @return A string representation of this device.",
                            " */",
                            "std::string BLEAdvertisedDevice::toString() {",
                            "\tstd::stringstream ss;",
                            "\tss << \"Name: \" << getName() << \", Address: \" << getAddress().toString();",
                            "\tif (haveAppearance()) {",
                            "\t\tss << \", appearance: \" << getAppearance();",
                            "\t}",
                            "\tif (haveManufacturerData()) {",
                            "\t\tchar *pHex = BLEUtils::buildHexData(nullptr, (uint8_t*)getManufacturerData().data(), getManufacturerData().length());",
                            "\t\tss << \", manufacturer data: \" << pHex;",
                            "\t\tfree(pHex);",
                            "\t}",
                            "\tif (haveServiceUUID()) {",
                            "\t\tss << \", serviceUUID: \" << getServiceUUID().toString();",
                            "\t}",
                            "\tif (haveTXPower()) {",
                            "\t\tss << \", txPower: \" << (int)getTXPower();",
                            "\t}",
                            "\treturn ss.str();",
                            "",
                            "uint8_t* BLEAdvertisedDevice::getPayload() {",
                            "\treturn m_payload;",
                            "}",
                            "",
                            "esp_ble_addr_type_t BLEAdvertisedDevice::getAddressType() {",
                            "\treturn m_addressType;",
                            "}",
                            "",
                            "void BLEAdvertisedDevice::setAddressType(esp_ble_addr_type_t type) {",
                            "\tm_addressType = type;",
                            "}",
                            "",
                            "size_t BLEAdvertisedDevice::getPayloadLength() {",
                            "\treturn m_payloadLength;",
                            "}",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "46": "} // BLEAdvertisedDevice",
                "59": "} // getAddress",
                "72": "} // getAppearance",
                "81": "} // getManufacturerData",
                "90": "} // getName",
                "99": "} // getRSSI",
                "108": "} // getScan",
                "126": "} // getServiceDataUUID",
                "135": "} // getServiceUUID",
                "154": "} // getTXPower",
                "164": "} // haveAppearance",
                "173": "} // haveManufacturerData",
                "182": "} // haveName",
                "191": "} // haveRSSI",
                "200": "} // haveServiceData",
                "209": "} // haveServiceUUID",
                "218": "} // haveTXPower",
                "242": "\t\tlength = *payload;          // Retrieve the length of the record.",
                "243": "\t\tpayload++;                  // Skip to type",
                "244": "\t\tsizeConsumed += 1 + length; // increase the size consumed.",
                "246": "\t\tif (length != 0) { // A length of 0 indicates that we have reached the end.",
                "257": "\t\t\t\tcase ESP_BLE_AD_TYPE_NAME_CMPL: {   // Adv Data Type: 0x09",
                "260": "\t\t\t\t} // ESP_BLE_AD_TYPE_NAME_CMPL",
                "262": "\t\t\t\tcase ESP_BLE_AD_TYPE_TX_PWR: {      // Adv Data Type: 0x0A",
                "265": "\t\t\t\t} // ESP_BLE_AD_TYPE_TX_PWR",
                "267": "\t\t\t\tcase ESP_BLE_AD_TYPE_APPEARANCE: { // Adv Data Type: 0x19",
                "270": "\t\t\t\t} // ESP_BLE_AD_TYPE_APPEARANCE",
                "272": "\t\t\t\tcase ESP_BLE_AD_TYPE_FLAG: {        // Adv Data Type: 0x01",
                "275": "\t\t\t\t} // ESP_BLE_AD_TYPE_FLAG",
                "278": "\t\t\t\tcase ESP_BLE_AD_TYPE_16SRV_PART: {   // Adv Data Type: 0x02",
                "283": "\t\t\t\t} // ESP_BLE_AD_TYPE_16SRV_PART",
                "286": "\t\t\t\tcase ESP_BLE_AD_TYPE_32SRV_PART: {   // Adv Data Type: 0x04",
                "291": "\t\t\t\t} // ESP_BLE_AD_TYPE_32SRV_PART",
                "293": "\t\t\t\tcase ESP_BLE_AD_TYPE_128SRV_CMPL: { // Adv Data Type: 0x07",
                "296": "\t\t\t\t} // ESP_BLE_AD_TYPE_128SRV_CMPL",
                "298": "\t\t\t\tcase ESP_BLE_AD_TYPE_128SRV_PART: { // Adv Data Type: 0x06",
                "301": "\t\t\t\t} // ESP_BLE_AD_TYPE_128SRV_PART",
                "303": "\t\t\t\t// See CSS Part A 1.4 Manufacturer Specific Data",
                "307": "\t\t\t\t} // ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE",
                "309": "\t\t\t\tcase ESP_BLE_AD_TYPE_SERVICE_DATA: {  // Adv Data Type: 0x16 (Service Data) - 2 byte UUID",
                "322": "\t\t\t\tcase ESP_BLE_AD_TYPE_32SERVICE_DATA: {  // Adv Data Type: 0x20 (Service Data) - 4 byte UUID",
                "335": "\t\t\t\tcase ESP_BLE_AD_TYPE_128SERVICE_DATA: {  // Adv Data Type: 0x21 (Service Data) - 16 byte UUID",
                "352": "\t\t\t} // switch",
                "354": "\t\t} // Length <> 0",
                "360": "\t} // !finished",
                "361": "} // parseAdvertisement",
                "370": "} // setAddress",
                "379": "} // setAdFlag",
                "390": "} // setAppearance",
                "403": "} // setManufacturerData",
                "414": "} // setName",
                "425": "} // setRSSI",
                "434": "} // setScan",
                "443": "} // setServiceUUID",
                "454": "} // setServiceUUID",
                "462": "\tm_haveServiceData = true;         // Set the flag that indicates we have service data.",
                "463": "\tm_serviceData     = serviceData;  // Save the service data that we received.",
                "472": "\tm_haveServiceData = true;         // Set the flag that indicates we have service data.",
                "474": "} // setServiceDataUUID",
                "485": "} // setTXPower",
                "510": "} // toString"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "85ef51ffbc74d3fa31b873a3375c89cfdcecb7d8",
            "timestamp": "2020-01-20T15:30:29+02:00",
            "author": "Evgenii Grekov",
            "commit_message": "BLE: reception support multiple service data (#3502)\n\n* BLE: reception support multiple service data\r\n\r\n* fix prev commit, i not inicialized",
            "additions": 44,
            "deletions": 7,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            147
                        ],
                        "comments": [
                            "} // getServiceDataUUID"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            153
                        ],
                        "comments": [],
                        "lines": [
                            "BLEUUID BLEAdvertisedDevice::getServiceUUID() {"
                        ]
                    },
                    {
                        "line_numbers": [
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164
                        ],
                        "comments": [
                            "} // getServiceUUID"
                        ],
                        "lines": [
                            "/**",
                            " * @brief Get the Service UUID.",
                            " * @return The Service UUID of the advertised device.",
                            " */",
                            "BLEUUID BLEAdvertisedDevice::getServiceUUID(int i) {",
                            "\treturn m_serviceUUIDs[i];",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            501,
                            502
                        ],
                        "comments": [],
                        "lines": [
                            "\tm_serviceDataUUIDs.push_back(uuid);",
                            "\tlog_d(\"- addServiceDataUUID(): serviceDataUUID: %s\", uuid.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            536,
                            537,
                            538
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tfor (int i=0; i < m_serviceUUIDs.size(); i++) {",
                            "\t\t    res += \", serviceUUID: \" + getServiceUUID(i).toString();",
                            "\t\t}"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            457
                        ],
                        "comments": [
                            "\tm_serviceData     = serviceData;  // Save the service data that we received."
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            467
                        ],
                        "comments": [],
                        "lines": [
                            "\tm_serviceDataUUID = uuid;"
                        ]
                    },
                    {
                        "line_numbers": [
                            501
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tres += \", serviceUUID: \" + getServiceUUID().toString();"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "147": "} // getServiceDataUUID",
                "163": "} // getServiceUUID",
                "491": "\tm_serviceData.push_back(serviceData); // Save the service data that we received."
            },
            "comment_deleted_diff": {
                "457": "\tm_serviceData     = serviceData;  // Save the service data that we received."
            },
            "comment_modified_diff": {}
        }
    ],
    "BLEAdvertisedDevice.h": [],
    "BLEAdvertising.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 505,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505
                        ],
                        "comments": [
                            "\tm_customAdvData               = false;   // No custom advertising data",
                            "\tm_customScanResponseData      = false;   // No custom scan response data",
                            "} // BLEAdvertising",
                            "} // addServiceUUID",
                            "} // addServiceUUID",
                            "} // setAppearance",
                            "} // setMinInterval",
                            "} // setMaxInterval",
                            "} // setScanFilter",
                            "\tm_customAdvData = true;   // Set the flag that indicates we are using custom advertising data.",
                            "} // setAdvertisementData",
                            "\tm_customScanResponseData = true;   // Set the flag that indicates we are using custom scan response data.",
                            "} // setScanResponseData",
                            "\t// We have a vector of service UUIDs that we wish to advertise.  In order to use the",
                            "\t// ESP-IDF framework, these must be supplied in a contiguous array of their 128bit (16 byte)",
                            "\t// representations.  If we have 1 or more services to advertise then we allocate enough",
                            "\t// storage to host them and then copy them in one at a time into the contiguous storage.",
                            "\t\t// Set the configuration for advertising.",
                            "\t// If we had services to advertise then we previously allocated some storage for them.",
                            "\t// Here we release that storage.",
                            "\t// Start advertising.",
                            "} // start",
                            "} // stop",
                            "} // addData",
                            "\tcdata[1] = ESP_BLE_AD_TYPE_APPEARANCE; // 0x19",
                            "} // setAppearance",
                            "\t\t\t// [Len] [0x02] [LL] [HH]",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_16SRV_CMPL;  // 0x03",
                            "\t\t\t// [Len] [0x04] [LL] [LL] [HH] [HH]",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_32SRV_CMPL;  // 0x05",
                            "\t\t\t// [Len] [0x04] [0] [1] ... [15]",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_128SRV_CMPL;  // 0x07",
                            "} // setCompleteServices",
                            "\tcdata[1] = ESP_BLE_AD_TYPE_FLAG;  // 0x01",
                            "} // setFlag",
                            "\tcdata[1] = ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE;  // 0xff",
                            "} // setManufacturerData",
                            "\tcdata[1] = ESP_BLE_AD_TYPE_NAME_CMPL;  // 0x09",
                            "} // setName",
                            "\t\t\t// [Len] [0x02] [LL] [HH]",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_16SRV_PART;  // 0x02",
                            "\t\t\t// [Len] [0x04] [LL] [LL] [HH] [HH]",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_32SRV_PART; // 0x04",
                            "\t\t\t// [Len] [0x04] [0] [1] ... [15]",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_128SRV_PART;  // 0x06",
                            "} // setPartialServices",
                            "\t\t\t// [Len] [0x16] [UUID16] data",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_SERVICE_DATA;  // 0x16",
                            "\t\t\t// [Len] [0x20] [UUID32] data",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_32SERVICE_DATA; // 0x20",
                            "\t\t\t// [Len] [0x21] [UUID128] data",
                            "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_128SERVICE_DATA;  // 0x21",
                            "} // setServiceData",
                            "\tcdata[1] = ESP_BLE_AD_TYPE_NAME_SHORT;  // 0x08",
                            "} // setShortName",
                            "} // getPayload",
                            "\t\t\t// m_semaphoreSetAdv.give();",
                            "\t\t\t// m_semaphoreSetAdv.give();",
                            "\t\t\t// m_semaphoreSetAdv.give();"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Add a service uuid to exposed list of services.",
                            " * @param [in] serviceUUID The UUID of the service to expose.",
                            " */",
                            "void BLEAdvertising::addServiceUUID(BLEUUID serviceUUID) {",
                            "\tm_serviceUUIDs.push_back(serviceUUID);",
                            "",
                            "",
                            "/**",
                            " * @brief Add a service uuid to exposed list of services.",
                            " * @param [in] serviceUUID The string representation of the service to expose.",
                            " */",
                            "void BLEAdvertising::addServiceUUID(const char* serviceUUID) {",
                            "\taddServiceUUID(BLEUUID(serviceUUID));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the device appearance in the advertising data.",
                            " * The appearance attribute is of type 0x19.  The codes for distinct appearances can be found here:",
                            " * https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.gap.appearance.xml.",
                            " * @param [in] appearance The appearance of the device in the advertising data.",
                            " * @return N/A.",
                            " */",
                            "void BLEAdvertising::setAppearance(uint16_t appearance) {",
                            "\tm_advData.appearance = appearance;",
                            "",
                            "void BLEAdvertising::setMinInterval(uint16_t mininterval) {",
                            "\tm_advParams.adv_int_min = mininterval;",
                            "",
                            "void BLEAdvertising::setMaxInterval(uint16_t maxinterval) {",
                            "\tm_advParams.adv_int_max = maxinterval;",
                            "",
                            "void BLEAdvertising::setMinPreferred(uint16_t mininterval) {",
                            "\tm_advData.min_interval = mininterval;",
                            "} //",
                            "",
                            "void BLEAdvertising::setMaxPreferred(uint16_t maxinterval) {",
                            "\tm_advData.max_interval = maxinterval;",
                            "} //",
                            "",
                            "void BLEAdvertising::setScanResponse(bool set) {",
                            "\tm_scanResp = set;",
                            "}",
                            "",
                            "/**",
                            " * @brief Set the filtering for the scan filter.",
                            " * @param [in] scanRequestWhitelistOnly If true, only allow scan requests from those on the white list.",
                            " * @param [in] connectWhitelistOnly If true, only allow connections from those on the white list.",
                            " */",
                            "void BLEAdvertising::setScanFilter(bool scanRequestWhitelistOnly, bool connectWhitelistOnly) {",
                            "\tESP_LOGD(LOG_TAG, \">> setScanFilter: scanRequestWhitelistOnly: %d, connectWhitelistOnly: %d\", scanRequestWhitelistOnly, connectWhitelistOnly);",
                            "\tif (!scanRequestWhitelistOnly && !connectWhitelistOnly) {",
                            "\t\tm_advParams.adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY;",
                            "\t\tESP_LOGD(LOG_TAG, \"<< setScanFilter\");",
                            "\t\treturn;",
                            "\t}",
                            "\tif (scanRequestWhitelistOnly && !connectWhitelistOnly) {",
                            "\t\tm_advParams.adv_filter_policy = ADV_FILTER_ALLOW_SCAN_WLST_CON_ANY;",
                            "\t\tESP_LOGD(LOG_TAG, \"<< setScanFilter\");",
                            "\t\treturn;",
                            "\t}",
                            "\tif (!scanRequestWhitelistOnly && connectWhitelistOnly) {",
                            "\t\tm_advParams.adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_WLST;",
                            "\t\tESP_LOGD(LOG_TAG, \"<< setScanFilter\");",
                            "\t\treturn;",
                            "\t}",
                            "\tif (scanRequestWhitelistOnly && connectWhitelistOnly) {",
                            "\t\tm_advParams.adv_filter_policy = ADV_FILTER_ALLOW_SCAN_WLST_CON_WLST;",
                            "\t\tESP_LOGD(LOG_TAG, \"<< setScanFilter\");",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the advertisement data that is to be published in a regular advertisement.",
                            " * @param [in] advertisementData The data to be advertised.",
                            " */",
                            "void BLEAdvertising::setAdvertisementData(BLEAdvertisementData& advertisementData) {",
                            "\tESP_LOGD(LOG_TAG, \">> setAdvertisementData\");",
                            "\tesp_err_t errRc = ::esp_ble_gap_config_adv_data_raw(",
                            "\t\t(uint8_t*)advertisementData.getPayload().data(),",
                            "\t\tadvertisementData.getPayload().length());",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_config_adv_data_raw: %d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< setAdvertisementData\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the advertisement data that is to be published in a scan response.",
                            " * @param [in] advertisementData The data to be advertised.",
                            " */",
                            "void BLEAdvertising::setScanResponseData(BLEAdvertisementData& advertisementData) {",
                            "\tESP_LOGD(LOG_TAG, \">> setScanResponseData\");",
                            "\tesp_err_t errRc = ::esp_ble_gap_config_scan_rsp_data_raw(",
                            "\t\t(uint8_t*)advertisementData.getPayload().data(),",
                            "\t\tadvertisementData.getPayload().length());",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_config_scan_rsp_data_raw: %d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< setScanResponseData\");",
                            "",
                            "/**",
                            " * @brief Start advertising.",
                            " * Start advertising.",
                            " * @return N/A.",
                            " */",
                            "void BLEAdvertising::start() {",
                            "\tESP_LOGD(LOG_TAG, \">> start: customAdvData: %d, customScanResponseData: %d\", m_customAdvData, m_customScanResponseData);",
                            "",
                            "\tint numServices = m_serviceUUIDs.size();",
                            "\tif (numServices > 0) {",
                            "\t\tm_advData.service_uuid_len = 16 * numServices;",
                            "\t\tm_advData.p_service_uuid = new uint8_t[m_advData.service_uuid_len];",
                            "\t\tuint8_t* p = m_advData.p_service_uuid;",
                            "\t\tfor (int i = 0; i < numServices; i++) {",
                            "\t\t\tESP_LOGD(LOG_TAG, \"- advertising service: %s\", m_serviceUUIDs[i].toString().c_str());",
                            "\t\t\tBLEUUID serviceUUID128 = m_serviceUUIDs[i].to128();",
                            "\t\t\tmemcpy(p, serviceUUID128.getNative()->uuid.uuid128, 16);",
                            "\t\t\tp += 16;",
                            "\t\t}",
                            "\t} else {",
                            "\t\tm_advData.service_uuid_len = 0;",
                            "\t\tESP_LOGD(LOG_TAG, \"- no services advertised\");",
                            "\t}",
                            "",
                            "\tesp_err_t errRc;",
                            "",
                            "\tif (!m_customAdvData) {",
                            "\t\tm_advData.set_scan_rsp = false;",
                            "\t\tm_advData.include_name = !m_scanResp;",
                            "\t\tm_advData.include_txpower = !m_scanResp;",
                            "\t\terrRc = ::esp_ble_gap_config_adv_data(&m_advData);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gap_config_adv_data: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "\t}",
                            "",
                            "\tif (!m_customScanResponseData && m_scanResp) {",
                            "\t\tm_advData.set_scan_rsp = true;",
                            "\t\tm_advData.include_name = m_scanResp;",
                            "\t\tm_advData.include_txpower = m_scanResp;",
                            "\t\terrRc = ::esp_ble_gap_config_adv_data(&m_advData);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gap_config_adv_data (Scan response): rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "\t}",
                            "",
                            "\tif (m_advData.service_uuid_len > 0) {",
                            "\t\tdelete[] m_advData.p_service_uuid;",
                            "\t\tm_advData.p_service_uuid = nullptr;",
                            "\t}",
                            "",
                            "\terrRc = ::esp_ble_gap_start_advertising(&m_advParams);",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gap_start_advertising: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< start\");",
                            "",
                            "",
                            "/**",
                            " * @brief Stop advertising.",
                            " * Stop advertising.",
                            " * @return N/A.",
                            " */",
                            "void BLEAdvertising::stop() {",
                            "\tESP_LOGD(LOG_TAG, \">> stop\");",
                            "\tesp_err_t errRc = ::esp_ble_gap_stop_advertising();",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_stop_advertising: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< stop\");",
                            "",
                            "/**",
                            " * @brief Add data to the payload to be advertised.",
                            " * @param [in] data The data to be added to the payload.",
                            " */",
                            "void BLEAdvertisementData::addData(std::string data) {",
                            "\tif ((m_payload.length() + data.length()) > ESP_BLE_ADV_DATA_LEN_MAX) {",
                            "\t\treturn;",
                            "\t}",
                            "\tm_payload.append(data);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the appearance.",
                            " * @param [in] appearance The appearance code value.",
                            " *",
                            " * See also:",
                            " * https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.gap.appearance.xml",
                            " */",
                            "void BLEAdvertisementData::setAppearance(uint16_t appearance) {",
                            "\tchar cdata[2];",
                            "\tcdata[0] = 3;",
                            "\taddData(std::string(cdata, 2) + std::string((char*) &appearance, 2));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the complete services.",
                            " * @param [in] uuid The single service to advertise.",
                            " */",
                            "void BLEAdvertisementData::setCompleteServices(BLEUUID uuid) {",
                            "\tchar cdata[2];",
                            "\tswitch (uuid.bitSize()) {",
                            "\t\tcase 16: {",
                            "\t\t\tcdata[0] = 3;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char*) &uuid.getNative()->uuid.uuid16, 2));",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase 32: {",
                            "\t\t\tcdata[0] = 5;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char*) &uuid.getNative()->uuid.uuid32, 4));",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase 128: {",
                            "\t\t\tcdata[0] = 17;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char*) uuid.getNative()->uuid.uuid128, 16));",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tdefault:",
                            "\t\t\treturn;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the advertisement flags.",
                            " * @param [in] The flags to be set in the advertisement.",
                            " *",
                            " * * ESP_BLE_ADV_FLAG_LIMIT_DISC",
                            " * * ESP_BLE_ADV_FLAG_GEN_DISC",
                            " * * ESP_BLE_ADV_FLAG_BREDR_NOT_SPT",
                            " * * ESP_BLE_ADV_FLAG_DMT_CONTROLLER_SPT",
                            " * * ESP_BLE_ADV_FLAG_DMT_HOST_SPT",
                            " * * ESP_BLE_ADV_FLAG_NON_LIMIT_DISC",
                            " */",
                            "void BLEAdvertisementData::setFlags(uint8_t flag) {",
                            "\tchar cdata[3];",
                            "\tcdata[0] = 2;",
                            "\tcdata[2] = flag;",
                            "\taddData(std::string(cdata, 3));",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Set manufacturer specific data.",
                            " * @param [in] data Manufacturer data.",
                            " */",
                            "void BLEAdvertisementData::setManufacturerData(std::string data) {",
                            "\tESP_LOGD(\"BLEAdvertisementData\", \">> setManufacturerData\");",
                            "\tchar cdata[2];",
                            "\tcdata[0] = data.length() + 1;",
                            "\taddData(std::string(cdata, 2) + data);",
                            "\tESP_LOGD(\"BLEAdvertisementData\", \"<< setManufacturerData\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the name.",
                            " * @param [in] The complete name of the device.",
                            " */",
                            "void BLEAdvertisementData::setName(std::string name) {",
                            "\tESP_LOGD(\"BLEAdvertisementData\", \">> setName: %s\", name.c_str());",
                            "\tchar cdata[2];",
                            "\tcdata[0] = name.length() + 1;",
                            "\taddData(std::string(cdata, 2) + name);",
                            "\tESP_LOGD(\"BLEAdvertisementData\", \"<< setName\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the partial services.",
                            " * @param [in] uuid The single service to advertise.",
                            " */",
                            "void BLEAdvertisementData::setPartialServices(BLEUUID uuid) {",
                            "\tchar cdata[2];",
                            "\tswitch (uuid.bitSize()) {",
                            "\t\tcase 16: {",
                            "\t\t\tcdata[0] = 3;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char *) &uuid.getNative()->uuid.uuid16, 2));",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase 32: {",
                            "\t\t\tcdata[0] = 5;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char *) &uuid.getNative()->uuid.uuid32, 4));",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase 128: {",
                            "\t\t\tcdata[0] = 17;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char *) &uuid.getNative()->uuid.uuid128, 16));",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tdefault:",
                            "\t\t\treturn;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the service data (UUID + data)",
                            " * @param [in] uuid The UUID to set with the service data.  Size of UUID will be used.",
                            " * @param [in] data The data to be associated with the service data advert.",
                            " */",
                            "void BLEAdvertisementData::setServiceData(BLEUUID uuid, std::string data) {",
                            "\tchar cdata[2];",
                            "\tswitch (uuid.bitSize()) {",
                            "\t\tcase 16: {",
                            "\t\t\tcdata[0] = data.length() + 3;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char*) &uuid.getNative()->uuid.uuid16, 2) + data);",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase 32: {",
                            "\t\t\tcdata[0] = data.length() + 5;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char*) &uuid.getNative()->uuid.uuid32, 4) + data);",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase 128: {",
                            "\t\t\tcdata[0] = data.length() + 17;",
                            "\t\t\taddData(std::string(cdata, 2) + std::string((char*) &uuid.getNative()->uuid.uuid128, 16) + data);",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tdefault:",
                            "\t\t\treturn;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the short name.",
                            " * @param [in] The short name of the device.",
                            " */",
                            "void BLEAdvertisementData::setShortName(std::string name) {",
                            "\tESP_LOGD(\"BLEAdvertisementData\", \">> setShortName: %s\", name.c_str());",
                            "\tchar cdata[2];",
                            "\tcdata[0] = name.length() + 1;",
                            "\taddData(std::string(cdata, 2) + name);",
                            "\tESP_LOGD(\"BLEAdvertisementData\", \"<< setShortName\");",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve the payload that is to be advertised.",
                            " * @return The payload that is to be advertised.",
                            " */",
                            "std::string BLEAdvertisementData::getPayload() {",
                            "\treturn m_payload;",
                            "",
                            "void BLEAdvertising::handleGAPEvent(",
                            "\t\tesp_gap_ble_cb_event_t  event,",
                            "\t\tesp_ble_gap_cb_param_t* param)  {",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"handleGAPEvent [event no: %d]\", (int)event);",
                            "",
                            "\tswitch(event) {",
                            "\t\tcase ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "\t\tcase ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "\t\tcase ESP_GAP_BLE_ADV_START_COMPLETE_EVT: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "\t\tcase ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGI(LOG_TAG, \"STOP advertising\");",
                            "\t\t\tstart();",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "\t}",
                            "}",
                            "",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "63": "\tm_customAdvData               = false;   // No custom advertising data",
                "64": "\tm_customScanResponseData      = false;   // No custom scan response data",
                "65": "} // BLEAdvertising",
                "74": "} // addServiceUUID",
                "83": "} // addServiceUUID",
                "95": "} // setAppearance",
                "99": "} // setMinInterval",
                "103": "} // setMaxInterval",
                "144": "} // setScanFilter",
                "159": "\tm_customAdvData = true;   // Set the flag that indicates we are using custom advertising data.",
                "161": "} // setAdvertisementData",
                "176": "\tm_customScanResponseData = true;   // Set the flag that indicates we are using custom scan response data.",
                "178": "} // setScanResponseData",
                "188": "\t// We have a vector of service UUIDs that we wish to advertise.  In order to use the",
                "189": "\t// ESP-IDF framework, these must be supplied in a contiguous array of their 128bit (16 byte)",
                "190": "\t// representations.  If we have 1 or more services to advertise then we allocate enough",
                "191": "\t// storage to host them and then copy them in one at a time into the contiguous storage.",
                "211": "\t\t// Set the configuration for advertising.",
                "233": "\t// If we had services to advertise then we previously allocated some storage for them.",
                "234": "\t// Here we release that storage.",
                "240": "\t// Start advertising.",
                "247": "} // start",
                "263": "} // stop",
                "274": "} // addData",
                "287": "\tcdata[1] = ESP_BLE_AD_TYPE_APPEARANCE; // 0x19",
                "289": "} // setAppearance",
                "300": "\t\t\t// [Len] [0x02] [LL] [HH]",
                "302": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_16SRV_CMPL;  // 0x03",
                "308": "\t\t\t// [Len] [0x04] [LL] [LL] [HH] [HH]",
                "310": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_32SRV_CMPL;  // 0x05",
                "316": "\t\t\t// [Len] [0x04] [0] [1] ... [15]",
                "318": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_128SRV_CMPL;  // 0x07",
                "326": "} // setCompleteServices",
                "343": "\tcdata[1] = ESP_BLE_AD_TYPE_FLAG;  // 0x01",
                "346": "} // setFlag",
                "358": "\tcdata[1] = ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE;  // 0xff",
                "361": "} // setManufacturerData",
                "372": "\tcdata[1] = ESP_BLE_AD_TYPE_NAME_CMPL;  // 0x09",
                "375": "} // setName",
                "386": "\t\t\t// [Len] [0x02] [LL] [HH]",
                "388": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_16SRV_PART;  // 0x02",
                "394": "\t\t\t// [Len] [0x04] [LL] [LL] [HH] [HH]",
                "396": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_32SRV_PART; // 0x04",
                "402": "\t\t\t// [Len] [0x04] [0] [1] ... [15]",
                "404": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_128SRV_PART;  // 0x06",
                "412": "} // setPartialServices",
                "424": "\t\t\t// [Len] [0x16] [UUID16] data",
                "426": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_SERVICE_DATA;  // 0x16",
                "432": "\t\t\t// [Len] [0x20] [UUID32] data",
                "434": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_32SERVICE_DATA; // 0x20",
                "440": "\t\t\t// [Len] [0x21] [UUID128] data",
                "442": "\t\t\tcdata[1] = ESP_BLE_AD_TYPE_128SERVICE_DATA;  // 0x21",
                "450": "} // setServiceData",
                "461": "\tcdata[1] = ESP_BLE_AD_TYPE_NAME_SHORT;  // 0x08",
                "464": "} // setShortName",
                "473": "} // getPayload",
                "483": "\t\t\t// m_semaphoreSetAdv.give();",
                "487": "\t\t\t// m_semaphoreSetAdv.give();",
                "491": "\t\t\t// m_semaphoreSetAdv.give();"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "bea7bd1852bae767864dbb582ea4d4123bc968c1",
            "timestamp": "2019-05-11T11:02:26+03:00",
            "author": "Adam",
            "commit_message": "Implemented ability to change BLE address (#2690)\n\nImplemented the ability to change the ESP32s BLE device address as\r\naccording the the BLE specification. This address is used when\r\nadvertising the ESP32 over BLE.",
            "additions": 21,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            275,
                            276
                        ],
                        "comments": [
                            "} // setPrivateAddress"
                        ],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "275": "} // setPrivateAddress"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "915d45de7d41899f1721fedc8d71d239b84708a0",
            "timestamp": "2020-01-20T15:42:38+02:00",
            "author": "syonbori",
            "commit_message": "Defined BLE setAdvertisementType (#3535)\n\nCurrently we have no way to set BLE Advertisement Type.\r\nWe have an initial value of ADV_TYPE_IND and the member is private.\r\n\r\niBeacon should advertise with ADV_TYPE_NONCONN_IND.\r\nesp-idf's example code specifies this value.\r\n\r\nhttps://github.com/espressif/esp-idf/blob/93a8603c545fb8e54741d6685146e2f3b874378d/examples/bluetooth/bluedroid/ble/ble_ibeacon/main/ibeacon_demo.c#L57",
            "additions": 4,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            90,
                            91
                        ],
                        "comments": [
                            "} // setAdvertisementType"
                        ],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "90": "} // setAdvertisementType"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEAdvertising.h": [],
    "BLEBeacon.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 89,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89
                        ],
                        "comments": [
                            "} // BLEBeacon",
                            "} // getData",
                            "} // setData",
                            "} // setMajor",
                            "} // setManufacturerId",
                            "} // setMinior",
                            "} // setProximityUUID",
                            "} // setSignalPower"
                        ],
                        "lines": [
                            "",
                            "std::string BLEBeacon::getData() {",
                            "\treturn std::string((char*) &m_beaconData, sizeof(m_beaconData));",
                            "",
                            "uint16_t BLEBeacon::getMajor() {",
                            "\treturn m_beaconData.major;",
                            "}",
                            "",
                            "uint16_t BLEBeacon::getManufacturerId() {",
                            "\treturn m_beaconData.manufacturerId;",
                            "}",
                            "",
                            "uint16_t BLEBeacon::getMinor() {",
                            "\treturn m_beaconData.minor;",
                            "}",
                            "",
                            "BLEUUID BLEBeacon::getProximityUUID() {",
                            "\treturn BLEUUID(m_beaconData.proximityUUID, 16, false);",
                            "}",
                            "",
                            "int8_t BLEBeacon::getSignalPower() {",
                            "\treturn m_beaconData.signalPower;",
                            "}",
                            "",
                            "/**",
                            " * Set the raw data for the beacon record.",
                            " */",
                            "void BLEBeacon::setData(std::string data) {",
                            "\tif (data.length() != sizeof(m_beaconData)) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Unable to set the data ... length passed in was %d and expected %d\", data.length(), sizeof(m_beaconData));",
                            "\t\treturn;",
                            "\t}",
                            "\tmemcpy(&m_beaconData, data.data(), sizeof(m_beaconData));",
                            "",
                            "void BLEBeacon::setMajor(uint16_t major) {",
                            "\tm_beaconData.major = ENDIAN_CHANGE_U16(major);",
                            "",
                            "void BLEBeacon::setManufacturerId(uint16_t manufacturerId) {",
                            "\tm_beaconData.manufacturerId = ENDIAN_CHANGE_U16(manufacturerId);",
                            "",
                            "void BLEBeacon::setMinor(uint16_t minor) {",
                            "\tm_beaconData.minor = ENDIAN_CHANGE_U16(minor);",
                            "",
                            "void BLEBeacon::setProximityUUID(BLEUUID uuid) {",
                            "\tuuid = uuid.to128();",
                            "\tmemcpy(m_beaconData.proximityUUID, uuid.getNative()->uuid.uuid128, 16);",
                            "",
                            "void BLEBeacon::setSignalPower(int8_t signalPower) {",
                            "\tm_beaconData.signalPower = signalPower;",
                            "",
                            "",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "30": "} // BLEBeacon",
                "34": "} // getData",
                "65": "} // setData",
                "69": "} // setMajor",
                "73": "} // setManufacturerId",
                "77": "} // setMinior",
                "82": "} // setProximityUUID",
                "86": "} // setSignalPower"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEBeacon.h": [],
    "BLECharacteristic.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 760,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645,
                            646,
                            647,
                            648,
                            649,
                            650,
                            651,
                            652,
                            653,
                            654,
                            655,
                            656,
                            657,
                            658,
                            659,
                            660,
                            661,
                            662,
                            663,
                            664,
                            665,
                            666,
                            667,
                            668,
                            669,
                            670,
                            671,
                            672,
                            673,
                            674,
                            675,
                            676,
                            677,
                            678,
                            679,
                            680,
                            681,
                            682,
                            683,
                            684,
                            685,
                            686,
                            687,
                            688,
                            689,
                            690,
                            691,
                            692,
                            693,
                            694,
                            695,
                            696,
                            697,
                            698,
                            699,
                            700,
                            701,
                            702,
                            703,
                            704,
                            705,
                            706,
                            707,
                            708,
                            709,
                            710,
                            711,
                            712,
                            713,
                            714,
                            715,
                            716,
                            717,
                            718,
                            719,
                            720,
                            721,
                            722,
                            723,
                            724,
                            725,
                            726,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732,
                            733,
                            734,
                            735,
                            736,
                            737,
                            738,
                            739,
                            740,
                            741,
                            742,
                            743,
                            744,
                            745,
                            746,
                            747,
                            748,
                            749,
                            750,
                            751,
                            752,
                            753,
                            754,
                            755,
                            756,
                            757,
                            758,
                            759,
                            760
                        ],
                        "comments": [
                            "} // BLECharacteristic",
                            "\t//free(m_value.attr_value); // Release the storage for the value.",
                            "} // ~BLECharacteristic",
                            "} // addDescriptor",
                            "\tm_pService = pService; // Save the service to which this characteristic belongs.",
                            "\t\t&control); // Whether to auto respond or not.",
                            "\t} // End while",
                            "} // executeCreate",
                            "} // getDescriptorByUUID",
                            "} // getDescriptorByUUID",
                            "} // getHandle",
                            "} // getProperties",
                            "} // getService",
                            "} // getUUID",
                            "} // getValue",
                            "} // getData",
                            "\t// Events handled:",
                            "\t// ESP_GATTS_ADD_CHAR_EVT",
                            "\t// ESP_GATTS_CONF_EVT",
                            "\t// ESP_GATTS_CONNECT_EVT",
                            "\t// ESP_GATTS_DISCONNECT_EVT",
                            "\t// ESP_GATTS_EXEC_WRITE_EVT",
                            "\t// ESP_GATTS_READ_EVT",
                            "\t// ESP_GATTS_WRITE_EVT",
                            "\t\t// ESP_GATTS_EXEC_WRITE_EVT",
                            "\t\t// When we receive this event it is an indication that a previous write long needs to be committed.",
                            "\t\t// exec_write:",
                            "\t\t// - uint16_t conn_id",
                            "\t\t// - uint32_t trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint8_t exec_write_flag - Either ESP_GATT_PREP_WRITE_EXEC or ESP_GATT_PREP_WRITE_CANCEL",
                            "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                            "// ???",
                            "\t\t} // ESP_GATTS_EXEC_WRITE_EVT",
                            "\t\t// ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.",
                            "\t\t// add_char:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t attr_handle",
                            "\t\t// - uint16_t service_handle",
                            "\t\t// - esp_bt_uuid_t char_uuid",
                            "\t\t\t\t// we have created characteristic, now we can create descriptors",
                            "\t\t\t\t// BLEDescriptor* pDescriptor = m_descriptorMap.getFirst();",
                            "\t\t\t\t// while (pDescriptor != nullptr) {",
                            "\t\t\t\t// \tpDescriptor->executeCreate(this);",
                            "\t\t\t\t// \tpDescriptor = m_descriptorMap.getNext();",
                            "\t\t\t\t// } // End while",
                            "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                            "\t\t// ESP_GATTS_WRITE_EVT - A request to write the value of a characteristic has arrived.",
                            "\t\t// write:",
                            "\t\t// - uint16_t      conn_id",
                            "\t\t// - uint16_t      trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint16_t      handle",
                            "\t\t// - uint16_t      offset",
                            "\t\t// - bool          need_rsp",
                            "\t\t// - bool          is_prep",
                            "\t\t// - uint16_t      len",
                            "\t\t// - uint8_t      *value",
                            "// We check if this write request is for us by comparing the handles in the event.  If it is for us",
                            "// we save the new value.  Next we look at the need_rsp flag which indicates whether or not we need",
                            "// to send a response.  If we do, then we formulate a response and send it.",
                            "\t\t\t\t} // Response needed",
                            "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                            "\t\t\t} // Match on handles.",
                            "\t\t} // ESP_GATTS_WRITE_EVT",
                            "\t\t// ESP_GATTS_READ_EVT - A request to read the value of a characteristic has arrived.",
                            "\t\t// read:",
                            "\t\t// - uint16_t      conn_id",
                            "\t\t// - uint32_t      trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint16_t      handle",
                            "\t\t// - uint16_t      offset",
                            "\t\t// - bool          is_long",
                            "\t\t// - bool          need_rsp",
                            "// Here's an interesting thing.  The read request has the option of saying whether we need a response",
                            "// or not.  What would it \"mean\" to receive a read request and NOT send a response back?  That feels like",
                            "// a very strange read.",
                            "// We have to handle the case where the data we wish to send back to the client is greater than the maximum",
                            "// packet size of 22 bytes.  In this case, we become responsible for chunking the data into units of 22 bytes.",
                            "// The apparent algorithm is as follows:",
                            "// If the is_long flag is set then this is a follow on from an original read and we will already have sent at least 22 bytes.",
                            "// If the is_long flag is not set then we need to check how much data we are going to send.  If we are sending LESS than",
                            "// 22 bytes, then we \"just\" send it and thats the end of the story.",
                            "// If we are sending 22 bytes exactly, we just send it BUT we will get a follow on request.",
                            "// If we are sending more than 22 bytes, we send the first 22 bytes and we will get a follow on request.",
                            "// Because of follow on request processing, we need to maintain an offset of how much data we have already sent",
                            "// so that when a follow on request arrives, we know where to start in the data to send the next sequence.",
                            "// Note that the indication that the client will send a follow on request is that we sent exactly 22 bytes as a response.",
                            "// If our payload is divisible by 22 then the last response will be a response of 0 bytes in length.",
                            "// The following code has deliberately not been factored to make it fewer statements because this would cloud the",
                            "// the logic flow comprehension.",
                            "\t\t\t\t// get mtu for peer device that we are sending read request to",
                            "\t\t\t\t\t\t\t// This is the last in the chain",
                            "\t\t\t\t\t\t\t// There will be more to come.",
                            "\t\t\t\t\t} else { // read.is_long == false",
                            "\t\t\t\t\t\t\t// Too big for a single shot entry.",
                            "\t\t\t\t\t\t\t// Will fit in a single packet with no callbacks required.",
                            "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                            "\t\t\t\t\t\t\tm_pCallbacks->onRead(this);   // Invoke the read callback.",
                            "\t\t\t\t} // Response needed",
                            "\t\t\t} // Handle matches this characteristic.",
                            "\t\t} // ESP_GATTS_READ_EVT",
                            "\t\t// ESP_GATTS_CONF_EVT",
                            "\t\t// conf:",
                            "\t\t// - esp_gatt_status_t status  \u2013 The status code.",
                            "\t\t// - uint16_t          conn_id \u2013 The connection used.",
                            "\t\t\t// ESP_LOGD(LOG_TAG, \"m_handle = %d, conf->handle = %d\", m_handle, param->conf.handle);",
                            "\t\t\tif(param->conf.conn_id == getService()->getServer()->getConnId()) // && param->conf.handle == m_handle) // bug in esp-idf and not implemented in arduino yet",
                            "\t\t} // default",
                            "\t} // switch event",
                            "\t// Give each of the descriptors associated with this characteristic the opportunity to handle the",
                            "\t// event.",
                            "} // handleGATTServerEvent",
                            "} // indicate",
                            "\t// Test to see if we have a 0x2902 descriptor.  If we do, then check to see if notification is enabled",
                            "\t// and, if not, prevent the notification.",
                            "\t\t\t\tgetHandle(), length, (uint8_t*)m_value.getValue().data(), !is_notification); // The need_confirm = false makes this a notify.",
                            "} // Notify",
                            "} // setBroadcastProperty",
                            "} // setCallbacks",
                            "} // setHandle",
                            "} // setIndicateProperty",
                            "} // setNotifyProperty",
                            "} // setReadProperty",
                            "} // setValue",
                            "} // setValue",
                            "} // setValue",
                            "} // setValue",
                            "} // setValue",
                            "} // setValue",
                            "} // setValue",
                            "} // setWriteNoResponseProperty",
                            "} // setWriteProperty",
                            "} // toString",
                            "} // onRead",
                            "} // onWrite"
                        ],
                        "lines": [
                            "",
                            "/**",
                            " * @brief Destructor.",
                            " */",
                            "BLECharacteristic::~BLECharacteristic() {",
                            "",
                            "",
                            "/**",
                            " * @brief Associate a descriptor with this characteristic.",
                            " * @param [in] pDescriptor",
                            " * @return N/A.",
                            " */",
                            "void BLECharacteristic::addDescriptor(BLEDescriptor* pDescriptor) {",
                            "\tESP_LOGD(LOG_TAG, \">> addDescriptor(): Adding %s to %s\", pDescriptor->toString().c_str(), toString().c_str());",
                            "\tm_descriptorMap.setByUUID(pDescriptor->getUUID(), pDescriptor);",
                            "\tESP_LOGD(LOG_TAG, \"<< addDescriptor()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Register a new characteristic with the ESP runtime.",
                            " * @param [in] pService The service with which to associate this characteristic.",
                            " */",
                            "void BLECharacteristic::executeCreate(BLEService* pService) {",
                            "\tESP_LOGD(LOG_TAG, \">> executeCreate()\");",
                            "",
                            "\tif (m_handle != NULL_HANDLE) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Characteristic already has a handle.\");",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"Registering characteristic (esp_ble_gatts_add_char): uuid: %s, service: %s\",",
                            "\t\tgetUUID().toString().c_str(),",
                            "\t\tm_pService->toString().c_str());",
                            "",
                            "\tesp_attr_control_t control;",
                            "\tcontrol.auto_rsp = ESP_GATT_RSP_BY_APP;",
                            "",
                            "\tm_semaphoreCreateEvt.take(\"executeCreate\");",
                            "\tesp_err_t errRc = ::esp_ble_gatts_add_char(",
                            "\t\tm_pService->getHandle(),",
                            "\t\tgetUUID().getNative(),",
                            "\t\tstatic_cast<esp_gatt_perm_t>(m_permissions),",
                            "\t\tgetProperties(),",
                            "\t\tnullptr,",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_add_char: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "\tm_semaphoreCreateEvt.wait(\"executeCreate\");",
                            "",
                            "\tBLEDescriptor* pDescriptor = m_descriptorMap.getFirst();",
                            "\twhile (pDescriptor != nullptr) {",
                            "\t\tpDescriptor->executeCreate(this);",
                            "\t\tpDescriptor = m_descriptorMap.getNext();",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< executeCreate\");",
                            "",
                            "",
                            "/**",
                            " * @brief Return the BLE Descriptor for the given UUID if associated with this characteristic.",
                            " * @param [in] descriptorUUID The UUID of the descriptor that we wish to retrieve.",
                            " * @return The BLE Descriptor.  If no such descriptor is associated with the characteristic, nullptr is returned.",
                            " */",
                            "BLEDescriptor* BLECharacteristic::getDescriptorByUUID(const char* descriptorUUID) {",
                            "\treturn m_descriptorMap.getByUUID(BLEUUID(descriptorUUID));",
                            "",
                            "",
                            "/**",
                            " * @brief Return the BLE Descriptor for the given UUID if associated with this characteristic.",
                            " * @param [in] descriptorUUID The UUID of the descriptor that we wish to retrieve.",
                            " * @return The BLE Descriptor.  If no such descriptor is associated with the characteristic, nullptr is returned.",
                            " */",
                            "BLEDescriptor* BLECharacteristic::getDescriptorByUUID(BLEUUID descriptorUUID) {",
                            "\treturn m_descriptorMap.getByUUID(descriptorUUID);",
                            "",
                            "",
                            "/**",
                            " * @brief Get the handle of the characteristic.",
                            " * @return The handle of the characteristic.",
                            " */",
                            "uint16_t BLECharacteristic::getHandle() {",
                            "\treturn m_handle;",
                            "",
                            "void BLECharacteristic::setAccessPermissions(esp_gatt_perm_t perm) {",
                            "\tm_permissions = perm;",
                            "}",
                            "",
                            "esp_gatt_char_prop_t BLECharacteristic::getProperties() {",
                            "\treturn m_properties;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the service associated with this characteristic.",
                            " */",
                            "BLEService* BLECharacteristic::getService() {",
                            "\treturn m_pService;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the UUID of the characteristic.",
                            " * @return The UUID of the characteristic.",
                            " */",
                            "BLEUUID BLECharacteristic::getUUID() {",
                            "\treturn m_bleUUID;",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve the current value of the characteristic.",
                            " * @return A pointer to storage containing the current characteristic value.",
                            " */",
                            "std::string BLECharacteristic::getValue() {",
                            "\treturn m_value.getValue();",
                            "",
                            "/**",
                            " * @brief Retrieve the current raw data of the characteristic.",
                            " * @return A pointer to storage containing the current characteristic data.",
                            " */",
                            "uint8_t* BLECharacteristic::getData() {",
                            "\treturn m_value.getData();",
                            "",
                            "",
                            "/**",
                            " * Handle a GATT server event.",
                            " */",
                            "void BLECharacteristic::handleGATTServerEvent(",
                            "\t\tesp_gatts_cb_event_t      event,",
                            "\t\tesp_gatt_if_t             gatts_if,",
                            "\t\tesp_ble_gatts_cb_param_t* param) {",
                            "\tESP_LOGD(LOG_TAG, \">> handleGATTServerEvent: %s\", BLEUtils::gattServerEventTypeToString(event).c_str());",
                            "",
                            "\tswitch(event) {",
                            "\t//",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_EXEC_WRITE_EVT: {",
                            "\t\t\tif (param->exec_write.exec_write_flag == ESP_GATT_PREP_WRITE_EXEC) {",
                            "\t\t\t\tm_value.commit();",
                            "\t\t\t\tif (m_pCallbacks != nullptr) {",
                            "\t\t\t\t}",
                            "\t\t\t} else {",
                            "\t\t\t\tm_value.cancel();",
                            "\t\t\t}",
                            "\t\t\tesp_err_t errRc = ::esp_ble_gatts_send_response(",
                            "\t\t\t\t\tgatts_if,",
                            "\t\t\t\t\tparam->write.conn_id,",
                            "\t\t\t\t\tparam->write.trans_id, ESP_GATT_OK, nullptr);",
                            "\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_send_response: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\tcase ESP_GATTS_ADD_CHAR_EVT: {",
                            "\t\t\tif (getHandle() == param->add_char.attr_handle) {",
                            "\t\t\t\tm_semaphoreCreateEvt.give();",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_WRITE_EVT: {",
                            "\t\t\tif (param->write.handle == m_handle) {",
                            "\t\t\t\tif (param->write.is_prep) {",
                            "\t\t\t\t\tm_value.addPart(param->write.value, param->write.len);",
                            "\t\t\t\t} else {",
                            "\t\t\t\t\tsetValue(param->write.value, param->write.len);",
                            "\t\t\t\t}",
                            "",
                            "\t\t\t\tESP_LOGD(LOG_TAG, \" - Response to write event: New value: handle: %.2x, uuid: %s\",",
                            "\t\t\t\t\t\tgetHandle(), getUUID().toString().c_str());",
                            "",
                            "\t\t\t\tchar* pHexData = BLEUtils::buildHexData(nullptr, param->write.value, param->write.len);",
                            "\t\t\t\tESP_LOGD(LOG_TAG, \" - Data: length: %d, data: %s\", param->write.len, pHexData);",
                            "\t\t\t\tfree(pHexData);",
                            "",
                            "\t\t\t\tif (param->write.need_rsp) {",
                            "\t\t\t\t\tesp_gatt_rsp_t rsp;",
                            "",
                            "\t\t\t\t\trsp.attr_value.len      = param->write.len;",
                            "\t\t\t\t\trsp.attr_value.handle   = m_handle;",
                            "\t\t\t\t\trsp.attr_value.offset   = param->write.offset;",
                            "\t\t\t\t\trsp.attr_value.auth_req = ESP_GATT_AUTH_REQ_NONE;",
                            "\t\t\t\t\tmemcpy(rsp.attr_value.value, param->write.value, param->write.len);",
                            "",
                            "\t\t\t\t\tesp_err_t errRc = ::esp_ble_gatts_send_response(",
                            "\t\t\t\t\t\t\tgatts_if,",
                            "\t\t\t\t\t\t\tparam->write.conn_id,",
                            "\t\t\t\t\t\t\tparam->write.trans_id, ESP_GATT_OK, &rsp);",
                            "\t\t\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_send_response: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t\t\t}",
                            "",
                            "\t\t\t\tif (m_pCallbacks != nullptr && param->write.is_prep != true) {",
                            "\t\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_READ_EVT: {",
                            "\t\t\tif (param->read.handle == m_handle) {",
                            "",
                            "",
                            "",
                            "//",
                            "//",
                            "//",
                            "//",
                            "",
                            "\t\t\t\tuint16_t maxOffset =  getService()->getServer()->getPeerMTU(param->read.conn_id) - 1;",
                            "\t\t\t\tESP_LOGD(LOG_TAG, \"mtu value: %d\", maxOffset);",
                            "\t\t\t\tif (param->read.need_rsp) {",
                            "\t\t\t\t\tESP_LOGD(LOG_TAG, \"Sending a response (esp_ble_gatts_send_response)\");",
                            "\t\t\t\t\tesp_gatt_rsp_t rsp;",
                            "",
                            "\t\t\t\t\tif (param->read.is_long) {",
                            "\t\t\t\t\t\tstd::string value = m_value.getValue();",
                            "",
                            "\t\t\t\t\t\tif (value.length() - m_value.getReadOffset() < maxOffset) {",
                            "\t\t\t\t\t\t\trsp.attr_value.len    = value.length() - m_value.getReadOffset();",
                            "\t\t\t\t\t\t\trsp.attr_value.offset = m_value.getReadOffset();",
                            "\t\t\t\t\t\t\tmemcpy(rsp.attr_value.value, value.data() + rsp.attr_value.offset, rsp.attr_value.len);",
                            "\t\t\t\t\t\t\tm_value.setReadOffset(0);",
                            "\t\t\t\t\t\t} else {",
                            "\t\t\t\t\t\t\trsp.attr_value.len    = maxOffset;",
                            "\t\t\t\t\t\t\trsp.attr_value.offset = m_value.getReadOffset();",
                            "\t\t\t\t\t\t\tmemcpy(rsp.attr_value.value, value.data() + rsp.attr_value.offset, rsp.attr_value.len);",
                            "\t\t\t\t\t\t\tm_value.setReadOffset(rsp.attr_value.offset + maxOffset);",
                            "\t\t\t\t\t\t}",
                            "",
                            "\t\t\t\t\t\tstd::string value = m_value.getValue();",
                            "",
                            "\t\t\t\t\t\tif (value.length() + 1 > maxOffset) {",
                            "\t\t\t\t\t\t\tm_value.setReadOffset(maxOffset);",
                            "\t\t\t\t\t\t\trsp.attr_value.len    = maxOffset;",
                            "\t\t\t\t\t\t\trsp.attr_value.offset = 0;",
                            "\t\t\t\t\t\t\tmemcpy(rsp.attr_value.value, value.data(), rsp.attr_value.len);",
                            "\t\t\t\t\t\t} else {",
                            "\t\t\t\t\t\t\trsp.attr_value.len    = value.length();",
                            "\t\t\t\t\t\t\trsp.attr_value.offset = 0;",
                            "\t\t\t\t\t\t\tmemcpy(rsp.attr_value.value, value.data(), rsp.attr_value.len);",
                            "\t\t\t\t\t\t}",
                            "",
                            "\t\t\t\t\t\t}",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\trsp.attr_value.handle   = param->read.handle;",
                            "\t\t\t\t\trsp.attr_value.auth_req = ESP_GATT_AUTH_REQ_NONE;",
                            "",
                            "\t\t\t\t\tchar *pHexData = BLEUtils::buildHexData(nullptr, rsp.attr_value.value, rsp.attr_value.len);",
                            "\t\t\t\t\tESP_LOGD(LOG_TAG, \" - Data: length=%d, data=%s, offset=%d\", rsp.attr_value.len, pHexData, rsp.attr_value.offset);",
                            "\t\t\t\t\tfree(pHexData);",
                            "",
                            "\t\t\t\t\tesp_err_t errRc = ::esp_ble_gatts_send_response(",
                            "\t\t\t\t\t\t\tgatts_if, param->read.conn_id,",
                            "\t\t\t\t\t\t\tparam->read.trans_id,",
                            "\t\t\t\t\t\t\tESP_GATT_OK,",
                            "\t\t\t\t\t\t\t&rsp);",
                            "\t\t\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_send_response: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_CONF_EVT: {",
                            "\t\t\t\tm_semaphoreConfEvt.give(param->conf.status);",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase ESP_GATTS_CONNECT_EVT: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase ESP_GATTS_DISCONNECT_EVT: {",
                            "\t\t\tm_semaphoreConfEvt.give();",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tdefault: {",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "",
                            "\tm_descriptorMap.handleGATTServerEvent(event, gatts_if, param);",
                            "\tESP_LOGD(LOG_TAG, \"<< handleGATTServerEvent\");",
                            "",
                            "",
                            "/**",
                            " * @brief Send an indication.",
                            " * An indication is a transmission of up to the first 20 bytes of the characteristic value.  An indication",
                            " * will block waiting a positive confirmation from the client.",
                            " * @return N/A",
                            " */",
                            "void BLECharacteristic::indicate() {",
                            "",
                            "\tESP_LOGD(LOG_TAG, \">> indicate: length: %d\", m_value.getValue().length());",
                            "\tnotify(false);",
                            "\tESP_LOGD(LOG_TAG, \"<< indicate\");",
                            "",
                            "",
                            "/**",
                            " * @brief Send a notify.",
                            " * A notification is a transmission of up to the first 20 bytes of the characteristic value.  An notification",
                            " * will not block; it is a fire and forget.",
                            " * @return N/A.",
                            " */",
                            "void BLECharacteristic::notify(bool is_notification) {",
                            "\tESP_LOGD(LOG_TAG, \">> notify: length: %d\", m_value.getValue().length());",
                            "",
                            "\tassert(getService() != nullptr);",
                            "\tassert(getService()->getServer() != nullptr);",
                            "",
                            "\tGeneralUtils::hexDump((uint8_t*)m_value.getValue().data(), m_value.getValue().length());",
                            "",
                            "\tif (getService()->getServer()->getConnectedCount() == 0) {",
                            "\t\tESP_LOGD(LOG_TAG, \"<< notify: No connected clients.\");",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "",
                            "\tBLE2902 *p2902 = (BLE2902*)getDescriptorByUUID((uint16_t)0x2902);",
                            "\tif(is_notification) {",
                            "\t\tif (p2902 != nullptr && !p2902->getNotifications()) {",
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< notifications disabled; ignoring\");",
                            "\t\t\treturn;",
                            "\t\t}",
                            "\t}",
                            "\telse{",
                            "\t\tif (p2902 != nullptr && !p2902->getIndications()) {",
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< indications disabled; ignoring\");",
                            "\t\t\treturn;",
                            "\t\t}",
                            "\t}",
                            "\tfor (auto &myPair : getService()->getServer()->getPeerDevices(false)) {",
                            "\t\tuint16_t _mtu = (myPair.second.mtu);",
                            "\t\tif (m_value.getValue().length() > _mtu - 3) {",
                            "\t\t\tESP_LOGW(LOG_TAG, \"- Truncating to %d bytes (maximum notify size)\", _mtu - 3);",
                            "\t\t}",
                            "",
                            "\t\tsize_t length = m_value.getValue().length();",
                            "\t\tif(!is_notification)",
                            "\t\t\tm_semaphoreConfEvt.take(\"indicate\");",
                            "\t\tesp_err_t errRc = ::esp_ble_gatts_send_indicate(",
                            "\t\t\t\tgetService()->getServer()->getGattsIf(),",
                            "\t\t\t\tmyPair.first,",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_send_ %s: rc=%d %s\",is_notification?\"notify\":\"indicate\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\tm_semaphoreConfEvt.give();",
                            "\t\t\treturn;",
                            "\t\t}",
                            "\t\tif(!is_notification)",
                            "\t\t\tm_semaphoreConfEvt.wait(\"indicate\");",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< notify\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the permission to broadcast.",
                            " * A characteristics has properties associated with it which define what it is capable of doing.",
                            " * One of these is the broadcast flag.",
                            " * @param [in] value The flag value of the property.",
                            " * @return N/A",
                            " */",
                            "void BLECharacteristic::setBroadcastProperty(bool value) {",
                            "\t//ESP_LOGD(LOG_TAG, \"setBroadcastProperty(%d)\", value);",
                            "\tif (value) {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_BROADCAST);",
                            "\t} else {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_BROADCAST);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the callback handlers for this characteristic.",
                            " * @param [in] pCallbacks An instance of a callbacks structure used to define any callbacks for the characteristic.",
                            " */",
                            "void BLECharacteristic::setCallbacks(BLECharacteristicCallbacks* pCallbacks) {",
                            "\tESP_LOGD(LOG_TAG, \">> setCallbacks: 0x%x\", (uint32_t)pCallbacks);",
                            "\tm_pCallbacks = pCallbacks;",
                            "\tESP_LOGD(LOG_TAG, \"<< setCallbacks\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the BLE handle associated with this characteristic.",
                            " * A user program will request that a characteristic be created against a service.  When the characteristic has been",
                            " * registered, the service will be given a \"handle\" that it knows the characteristic as.  This handle is unique to the",
                            " * server/service but it is told to the service, not the characteristic associated with the service.  This internally",
                            " * exposed function can be invoked by the service against this model of the characteristic to allow the characteristic",
                            " * to learn its own handle.  Once the characteristic knows its own handle, it will be able to see incoming GATT events",
                            " * that will be propagated down to it which contain a handle value and now know that the event is destined for it.",
                            " * @param [in] handle The handle associated with this characteristic.",
                            " */",
                            "void BLECharacteristic::setHandle(uint16_t handle) {",
                            "\tESP_LOGD(LOG_TAG, \">> setHandle: handle=0x%.2x, characteristic uuid=%s\", handle, getUUID().toString().c_str());",
                            "\tm_handle = handle;",
                            "\tESP_LOGD(LOG_TAG, \"<< setHandle\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Indicate property value.",
                            " * @param [in] value Set to true if we are to allow indicate messages.",
                            " */",
                            "void BLECharacteristic::setIndicateProperty(bool value) {",
                            "\t//ESP_LOGD(LOG_TAG, \"setIndicateProperty(%d)\", value);",
                            "\tif (value) {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_INDICATE);",
                            "\t} else {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_INDICATE);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Notify property value.",
                            " * @param [in] value Set to true if we are to allow notification messages.",
                            " */",
                            "void BLECharacteristic::setNotifyProperty(bool value) {",
                            "\t//ESP_LOGD(LOG_TAG, \"setNotifyProperty(%d)\", value);",
                            "\tif (value) {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_NOTIFY);",
                            "\t} else {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_NOTIFY);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Read property value.",
                            " * @param [in] value Set to true if we are to allow reads.",
                            " */",
                            "void BLECharacteristic::setReadProperty(bool value) {",
                            "\t//ESP_LOGD(LOG_TAG, \"setReadProperty(%d)\", value);",
                            "\tif (value) {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_READ);",
                            "\t} else {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_READ);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the value of the characteristic.",
                            " * @param [in] data The data to set for the characteristic.",
                            " * @param [in] length The length of the data in bytes.",
                            " */",
                            "void BLECharacteristic::setValue(uint8_t* data, size_t length) {",
                            "\tchar* pHex = BLEUtils::buildHexData(nullptr, data, length);",
                            "\tESP_LOGD(LOG_TAG, \">> setValue: length=%d, data=%s, characteristic UUID=%s\", length, pHex, getUUID().toString().c_str());",
                            "\tfree(pHex);",
                            "\tif (length > ESP_GATT_MAX_ATTR_LEN) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Size %d too large, must be no bigger than %d\", length, ESP_GATT_MAX_ATTR_LEN);",
                            "\t\treturn;",
                            "\t}",
                            "\tm_value.setValue(data, length);",
                            "\tESP_LOGD(LOG_TAG, \"<< setValue\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the value of the characteristic from string data.",
                            " * We set the value of the characteristic from the bytes contained in the",
                            " * string.",
                            " * @param [in] Set the value of the characteristic.",
                            " * @return N/A.",
                            " */",
                            "void BLECharacteristic::setValue(std::string value) {",
                            "\tsetValue((uint8_t*)(value.data()), value.length());",
                            "",
                            "void BLECharacteristic::setValue(uint16_t& data16) {",
                            "\tuint8_t temp[2];",
                            "\ttemp[0] = data16;",
                            "\ttemp[1] = data16 >> 8;",
                            "\tsetValue(temp, 2);",
                            "",
                            "void BLECharacteristic::setValue(uint32_t& data32) {",
                            "\tuint8_t temp[4];",
                            "\ttemp[0] = data32;",
                            "\ttemp[1] = data32 >> 8;",
                            "\ttemp[2] = data32 >> 16;",
                            "\ttemp[3] = data32 >> 24;",
                            "\tsetValue(temp, 4);",
                            "",
                            "void BLECharacteristic::setValue(int& data32) {",
                            "\tuint8_t temp[4];",
                            "\ttemp[0] = data32;",
                            "\ttemp[1] = data32 >> 8;",
                            "\ttemp[2] = data32 >> 16;",
                            "\ttemp[3] = data32 >> 24;",
                            "\tsetValue(temp, 4);",
                            "",
                            "void BLECharacteristic::setValue(float& data32) {",
                            "\tuint8_t temp[4];",
                            "\t*((float*)temp) = data32;",
                            "\tsetValue(temp, 4);",
                            "",
                            "void BLECharacteristic::setValue(double& data64) {",
                            "\tuint8_t temp[8];",
                            "\t*((double*)temp) = data64;",
                            "\tsetValue(temp, 8);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Write No Response property value.",
                            " * @param [in] value Set to true if we are to allow writes with no response.",
                            " */",
                            "void BLECharacteristic::setWriteNoResponseProperty(bool value) {",
                            "\t//ESP_LOGD(LOG_TAG, \"setWriteNoResponseProperty(%d)\", value);",
                            "\tif (value) {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_WRITE_NR);",
                            "\t} else {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_WRITE_NR);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the Write property value.",
                            " * @param [in] value Set to true if we are to allow writes.",
                            " */",
                            "void BLECharacteristic::setWriteProperty(bool value) {",
                            "\t//ESP_LOGD(LOG_TAG, \"setWriteProperty(%d)\", value);",
                            "\tif (value) {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_WRITE);",
                            "\t} else {",
                            "\t\tm_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_WRITE);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of the characteristic.",
                            " * @return A string representation of the characteristic.",
                            " */",
                            "std::string BLECharacteristic::toString() {",
                            "\tstd::stringstream stringstream;",
                            "\tstringstream << std::hex << std::setfill('0');",
                            "\tstringstream << \"UUID: \" << m_bleUUID.toString() + \", handle: 0x\" << std::setw(2) << m_handle;",
                            "\tstringstream << \" \" <<",
                            "\t\t((m_properties & ESP_GATT_CHAR_PROP_BIT_READ) ? \"Read \" : \"\") <<",
                            "\t\t((m_properties & ESP_GATT_CHAR_PROP_BIT_WRITE) ? \"Write \" : \"\") <<",
                            "\t\t((m_properties & ESP_GATT_CHAR_PROP_BIT_WRITE_NR) ? \"WriteNoResponse \" : \"\") <<",
                            "\t\t((m_properties & ESP_GATT_CHAR_PROP_BIT_BROADCAST) ? \"Broadcast \" : \"\") <<",
                            "\t\t((m_properties & ESP_GATT_CHAR_PROP_BIT_NOTIFY) ? \"Notify \" : \"\") <<",
                            "\t\t((m_properties & ESP_GATT_CHAR_PROP_BIT_INDICATE) ? \"Indicate \" : \"\");",
                            "\treturn stringstream.str();",
                            "",
                            "",
                            "BLECharacteristicCallbacks::~BLECharacteristicCallbacks() {}",
                            "",
                            "",
                            "/**",
                            " * @brief Callback function to support a read request.",
                            " * @param [in] pCharacteristic The characteristic that is the source of the event.",
                            " */",
                            "void BLECharacteristicCallbacks::onRead(BLECharacteristic* pCharacteristic) {",
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \">> onRead: default\");",
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \"<< onRead\");",
                            "",
                            "",
                            "/**",
                            " * @brief Callback function to support a write request.",
                            " * @param [in] pCharacteristic The characteristic that is the source of the event.",
                            " */",
                            "void BLECharacteristicCallbacks::onWrite(BLECharacteristic* pCharacteristic) {",
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \">> onWrite: default\");",
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \"<< onWrite\");",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "57": "} // BLECharacteristic",
                "63": "\t//free(m_value.attr_value); // Release the storage for the value.",
                "64": "} // ~BLECharacteristic",
                "76": "} // addDescriptor",
                "91": "\tm_pService = pService; // Save the service to which this characteristic belongs.",
                "107": "\t\t&control); // Whether to auto respond or not.",
                "119": "\t} // End while",
                "122": "} // executeCreate",
                "132": "} // getDescriptorByUUID",
                "142": "} // getDescriptorByUUID",
                "151": "} // getHandle",
                "159": "} // getProperties",
                "167": "} // getService",
                "176": "} // getUUID",
                "185": "} // getValue",
                "193": "} // getData",
                "206": "\t// Events handled:",
                "208": "\t// ESP_GATTS_ADD_CHAR_EVT",
                "209": "\t// ESP_GATTS_CONF_EVT",
                "210": "\t// ESP_GATTS_CONNECT_EVT",
                "211": "\t// ESP_GATTS_DISCONNECT_EVT",
                "212": "\t// ESP_GATTS_EXEC_WRITE_EVT",
                "213": "\t// ESP_GATTS_READ_EVT",
                "214": "\t// ESP_GATTS_WRITE_EVT",
                "217": "\t\t// ESP_GATTS_EXEC_WRITE_EVT",
                "218": "\t\t// When we receive this event it is an indication that a previous write long needs to be committed.",
                "220": "\t\t// exec_write:",
                "221": "\t\t// - uint16_t conn_id",
                "222": "\t\t// - uint32_t trans_id",
                "223": "\t\t// - esp_bd_addr_t bda",
                "224": "\t\t// - uint8_t exec_write_flag - Either ESP_GATT_PREP_WRITE_EXEC or ESP_GATT_PREP_WRITE_CANCEL",
                "230": "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                "235": "// ???",
                "244": "\t\t} // ESP_GATTS_EXEC_WRITE_EVT",
                "247": "\t\t// ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.",
                "248": "\t\t// add_char:",
                "249": "\t\t// - esp_gatt_status_t status",
                "250": "\t\t// - uint16_t attr_handle",
                "251": "\t\t// - uint16_t service_handle",
                "252": "\t\t// - esp_bt_uuid_t char_uuid",
                "255": "\t\t\t\t// we have created characteristic, now we can create descriptors",
                "256": "\t\t\t\t// BLEDescriptor* pDescriptor = m_descriptorMap.getFirst();",
                "257": "\t\t\t\t// while (pDescriptor != nullptr) {",
                "258": "\t\t\t\t// \tpDescriptor->executeCreate(this);",
                "259": "\t\t\t\t// \tpDescriptor = m_descriptorMap.getNext();",
                "260": "\t\t\t\t// } // End while",
                "264": "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                "267": "\t\t// ESP_GATTS_WRITE_EVT - A request to write the value of a characteristic has arrived.",
                "269": "\t\t// write:",
                "270": "\t\t// - uint16_t      conn_id",
                "271": "\t\t// - uint16_t      trans_id",
                "272": "\t\t// - esp_bd_addr_t bda",
                "273": "\t\t// - uint16_t      handle",
                "274": "\t\t// - uint16_t      offset",
                "275": "\t\t// - bool          need_rsp",
                "276": "\t\t// - bool          is_prep",
                "277": "\t\t// - uint16_t      len",
                "278": "\t\t// - uint8_t      *value",
                "281": "// We check if this write request is for us by comparing the handles in the event.  If it is for us",
                "282": "// we save the new value.  Next we look at the need_rsp flag which indicates whether or not we need",
                "283": "// to send a response.  If we do, then we formulate a response and send it.",
                "314": "\t\t\t\t} // Response needed",
                "317": "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                "319": "\t\t\t} // Match on handles.",
                "321": "\t\t} // ESP_GATTS_WRITE_EVT",
                "324": "\t\t// ESP_GATTS_READ_EVT - A request to read the value of a characteristic has arrived.",
                "326": "\t\t// read:",
                "327": "\t\t// - uint16_t      conn_id",
                "328": "\t\t// - uint32_t      trans_id",
                "329": "\t\t// - esp_bd_addr_t bda",
                "330": "\t\t// - uint16_t      handle",
                "331": "\t\t// - uint16_t      offset",
                "332": "\t\t// - bool          is_long",
                "333": "\t\t// - bool          need_rsp",
                "340": "// Here's an interesting thing.  The read request has the option of saying whether we need a response",
                "341": "// or not.  What would it \"mean\" to receive a read request and NOT send a response back?  That feels like",
                "342": "// a very strange read.",
                "344": "// We have to handle the case where the data we wish to send back to the client is greater than the maximum",
                "345": "// packet size of 22 bytes.  In this case, we become responsible for chunking the data into units of 22 bytes.",
                "346": "// The apparent algorithm is as follows:",
                "348": "// If the is_long flag is set then this is a follow on from an original read and we will already have sent at least 22 bytes.",
                "349": "// If the is_long flag is not set then we need to check how much data we are going to send.  If we are sending LESS than",
                "350": "// 22 bytes, then we \"just\" send it and thats the end of the story.",
                "351": "// If we are sending 22 bytes exactly, we just send it BUT we will get a follow on request.",
                "352": "// If we are sending more than 22 bytes, we send the first 22 bytes and we will get a follow on request.",
                "353": "// Because of follow on request processing, we need to maintain an offset of how much data we have already sent",
                "354": "// so that when a follow on request arrives, we know where to start in the data to send the next sequence.",
                "355": "// Note that the indication that the client will send a follow on request is that we sent exactly 22 bytes as a response.",
                "356": "// If our payload is divisible by 22 then the last response will be a response of 0 bytes in length.",
                "358": "// The following code has deliberately not been factored to make it fewer statements because this would cloud the",
                "359": "// the logic flow comprehension.",
                "362": "\t\t\t\t// get mtu for peer device that we are sending read request to",
                "373": "\t\t\t\t\t\t\t// This is the last in the chain",
                "379": "\t\t\t\t\t\t\t// There will be more to come.",
                "385": "\t\t\t\t\t} else { // read.is_long == false",
                "390": "\t\t\t\t\t\t\t// Too big for a single shot entry.",
                "396": "\t\t\t\t\t\t\t// Will fit in a single packet with no callbacks required.",
                "402": "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                "403": "\t\t\t\t\t\t\tm_pCallbacks->onRead(this);   // Invoke the read callback.",
                "421": "\t\t\t\t} // Response needed",
                "422": "\t\t\t} // Handle matches this characteristic.",
                "424": "\t\t} // ESP_GATTS_READ_EVT",
                "427": "\t\t// ESP_GATTS_CONF_EVT",
                "429": "\t\t// conf:",
                "430": "\t\t// - esp_gatt_status_t status  \u2013 The status code.",
                "431": "\t\t// - uint16_t          conn_id \u2013 The connection used.",
                "434": "\t\t\t// ESP_LOGD(LOG_TAG, \"m_handle = %d, conf->handle = %d\", m_handle, param->conf.handle);",
                "435": "\t\t\tif(param->conf.conn_id == getService()->getServer()->getConnId()) // && param->conf.handle == m_handle) // bug in esp-idf and not implemented in arduino yet",
                "451": "\t\t} // default",
                "453": "\t} // switch event",
                "455": "\t// Give each of the descriptors associated with this characteristic the opportunity to handle the",
                "456": "\t// event.",
                "460": "} // handleGATTServerEvent",
                "474": "} // indicate",
                "496": "\t// Test to see if we have a 0x2902 descriptor.  If we do, then check to see if notification is enabled",
                "497": "\t// and, if not, prevent the notification.",
                "524": "\t\t\t\tgetHandle(), length, (uint8_t*)m_value.getValue().data(), !is_notification); // The need_confirm = false makes this a notify.",
                "534": "} // Notify",
                "551": "} // setBroadcastProperty",
                "562": "} // setCallbacks",
                "579": "} // setHandle",
                "593": "} // setIndicateProperty",
                "607": "} // setNotifyProperty",
                "621": "} // setReadProperty",
                "639": "} // setValue",
                "651": "} // setValue",
                "658": "} // setValue",
                "667": "} // setValue",
                "676": "} // setValue",
                "682": "} // setValue",
                "688": "} // setValue",
                "702": "} // setWriteNoResponseProperty",
                "716": "} // setWriteProperty",
                "735": "} // toString",
                "748": "} // onRead",
                "758": "} // onWrite"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d7ea7b80a7badbe30e6fb6f33f71375e0b133c",
            "timestamp": "2019-04-15T17:26:35+02:00",
            "author": "Bascy",
            "commit_message": "Refactored use of LOG_X(LOG_TAG, ...) to log_x(...) (#2672)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)\r\n\r\n* Change logging from Error to Verbose when not found and default available\r\n\r\n* Move Enter and Exit logging to Verbose Level\r\n\r\n* Refactored LOG_X() into log_x()",
            "additions": 44,
            "deletions": 50,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            428
                        ],
                        "comments": [
                            "\t\t\t// log_d(\"m_handle = %d, conf->handle = %d\", m_handle, param->conf.handle);"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            453
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< handleGATTServerEvent\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            465
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> indicate: length: %d\", m_value.getValue().length());"
                        ]
                    },
                    {
                        "line_numbers": [
                            467
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< indicate\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            478
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> notify: length: %d\", m_value.getValue().length());"
                        ]
                    },
                    {
                        "line_numbers": [
                            486
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_v(\"<< notify: No connected clients.\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            496
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_v(\"<< notifications disabled; ignoring\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            502
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_v(\"<< indications disabled; ignoring\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            509
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_w(\"- Truncating to %d bytes (maximum notify size)\", _mtu - 3);"
                        ]
                    },
                    {
                        "line_numbers": [
                            520
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"<< esp_ble_gatts_send_ %s: rc=%d %s\",is_notification?\"notify\":\"indicate\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            527
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< notify\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            539
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_d(\"setBroadcastProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            553
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> setCallbacks: 0x%x\", (uint32_t)pCallbacks);"
                        ]
                    },
                    {
                        "line_numbers": [
                            555
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< setCallbacks\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            570
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> setHandle: handle=0x%.2x, characteristic uuid=%s\", handle, getUUID().toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            572
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< setHandle\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            581
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_d(\"setIndicateProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            595
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_d(\"setNotifyProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            609
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_d(\"setReadProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            625
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> setValue: length=%d, data=%s, characteristic UUID=%s\", length, pHex, getUUID().toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            628
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"Size %d too large, must be no bigger than %d\", length, ESP_GATT_MAX_ATTR_LEN);"
                        ]
                    },
                    {
                        "line_numbers": [
                            632
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< setValue\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            690
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_d(\"setWriteNoResponseProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            704
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_d(\"setWriteProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            740,
                            741
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_d(\"BLECharacteristicCallbacks\", \">> onRead: default\");",
                            "\tlog_d(\"BLECharacteristicCallbacks\", \"<< onRead\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            750,
                            751
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_d(\"BLECharacteristicCallbacks\", \">> onWrite: default\");",
                            "\tlog_d(\"BLECharacteristicCallbacks\", \"<< onWrite\");"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            434
                        ],
                        "comments": [
                            "\t\t\t// ESP_LOGD(LOG_TAG, \"m_handle = %d, conf->handle = %d\", m_handle, param->conf.handle);"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            459
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< handleGATTServerEvent\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            471
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> indicate: length: %d\", m_value.getValue().length());"
                        ]
                    },
                    {
                        "line_numbers": [
                            473
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< indicate\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            484
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> notify: length: %d\", m_value.getValue().length());"
                        ]
                    },
                    {
                        "line_numbers": [
                            492
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGD(LOG_TAG, \"<< notify: No connected clients.\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            502
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< notifications disabled; ignoring\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            508
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< indications disabled; ignoring\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            515
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGW(LOG_TAG, \"- Truncating to %d bytes (maximum notify size)\", _mtu - 3);"
                        ]
                    },
                    {
                        "line_numbers": [
                            526
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_send_ %s: rc=%d %s\",is_notification?\"notify\":\"indicate\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            533
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< notify\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            545
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \"setBroadcastProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            559
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setCallbacks: 0x%x\", (uint32_t)pCallbacks);"
                        ]
                    },
                    {
                        "line_numbers": [
                            561
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< setCallbacks\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            576
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setHandle: handle=0x%.2x, characteristic uuid=%s\", handle, getUUID().toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            578
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< setHandle\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            587
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \"setIndicateProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            601
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \"setNotifyProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            615
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \"setReadProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            631
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setValue: length=%d, data=%s, characteristic UUID=%s\", length, pHex, getUUID().toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            634
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"Size %d too large, must be no bigger than %d\", length, ESP_GATT_MAX_ATTR_LEN);"
                        ]
                    },
                    {
                        "line_numbers": [
                            638
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< setValue\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            696
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \"setWriteNoResponseProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            710
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \"setWriteProperty(%d)\", value);"
                        ]
                    },
                    {
                        "line_numbers": [
                            746,
                            747
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \">> onRead: default\");",
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \"<< onRead\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            756,
                            757
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \">> onWrite: default\");",
                            "\tESP_LOGD(\"BLECharacteristicCallbacks\", \"<< onWrite\");"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "428": "\t\t\t// log_d(\"m_handle = %d, conf->handle = %d\", m_handle, param->conf.handle);"
            },
            "comment_deleted_diff": {
                "434": "\t\t\t// ESP_LOGD(LOG_TAG, \"m_handle = %d, conf->handle = %d\", m_handle, param->conf.handle);"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "05de017bd557a20f21a2519e7f977f3d42f99f6e",
            "timestamp": "2019-07-09T19:35:07+03:00",
            "author": "Roman Savrulin",
            "commit_message": "BLE Library onRead Callback fix and Client disconnect feature (#2913)\n\n* BLEServer::disconnect()\r\n\r\n* Invoke Read callback first, to make data update possible before read",
            "additions": 4,
            "deletions": 4,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            381,
                            382,
                            383,
                            384
                        ],
                        "comments": [
                            "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                            "\t\t\t\t\t\t\tm_pCallbacks->onRead(this);   // Invoke the read callback."
                        ],
                        "lines": [
                            "\t\t\t\t\t\t}",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            396,
                            397,
                            398
                        ],
                        "comments": [
                            "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                            "\t\t\t\t\t\t\tm_pCallbacks->onRead(this);   // Invoke the read callback."
                        ],
                        "lines": [
                            "\t\t\t\t\t\t}"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "381": "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                "382": "\t\t\t\t\t\t\tm_pCallbacks->onRead(this);   // Invoke the read callback."
            },
            "comment_deleted_diff": {
                "396": "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                "397": "\t\t\t\t\t\t\tm_pCallbacks->onRead(this);   // Invoke the read callback."
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "5137fc5c80e8cd1d9f07879d0bc1ecf5a52e8ce4",
            "timestamp": "2019-08-20T17:15:30+03:00",
            "author": "Roman Savrulin",
            "commit_message": "Ble notification/indication status and timeout (#2998)\n\n* add timed wait\r\n\r\n* Added Notification/Indication data and status callbacks\r\n\r\n* imply null-object pattern for BLE callback",
            "additions": 56,
            "deletions": 12,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            224
                        ],
                        "comments": [
                            "\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler."
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            309
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tif (param->write.is_prep != true) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            382
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\t\t\tm_pCallbacks->onRead(this);"
                        ]
                    },
                    {
                        "line_numbers": [
                            483
                        ],
                        "comments": [],
                        "lines": [
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            488
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_NO_CLIENT, 0);"
                        ]
                    },
                    {
                        "line_numbers": [
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542
                        ],
                        "comments": [
                            "\t\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_TIMEOUT, 0);   // Invoke the notify callback.",
                            "\t\t\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_INDICATE, code);   // Invoke the notify callback.",
                            "\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_NOTIFY, 0);   // Invoke the notify callback."
                        ],
                        "lines": [
                            "\t\t\tif(!m_semaphoreConfEvt.timedWait(\"indicate\", indicationTimeout)){",
                            "\t\t\t} else {",
                            "\t\t\t\tauto code = (esp_gatt_status_t) m_semaphoreConfEvt.value();",
                            "\t\t\t\tif(code == ESP_GATT_OK) {",
                            "\t\t\t\t} else {",
                            "\t\t\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_FAILURE, code);",
                            "\t\t\t\t}",
                            "\t\t\t}",
                            "\t\t} else {",
                            "\t\t}"
                        ]
                    },
                    {
                        "line_numbers": [
                            571,
                            572,
                            573,
                            574,
                            575
                        ],
                        "comments": [],
                        "lines": [
                            "\tif (pCallbacks != nullptr){",
                            "\t\tm_pCallbacks = pCallbacks;",
                            "\t} else {",
                            "\t\tm_pCallbacks = &defaultCallback;",
                            "\t}"
                        ]
                    },
                    {
                        "line_numbers": [
                            778,
                            779,
                            780,
                            781,
                            782,
                            783,
                            784,
                            785,
                            786,
                            787,
                            788,
                            789,
                            790,
                            791,
                            792,
                            793,
                            794,
                            795,
                            796,
                            797,
                            798,
                            799,
                            800
                        ],
                        "comments": [
                            "} // onNotify",
                            "} // onStatus"
                        ],
                        "lines": [
                            "",
                            "/**",
                            " * @brief Callback function to support a Notify request.",
                            " * @param [in] pCharacteristic The characteristic that is the source of the event.",
                            " */",
                            "void BLECharacteristicCallbacks::onNotify(BLECharacteristic* pCharacteristic) {",
                            "\tlog_d(\"BLECharacteristicCallbacks\", \">> onNotify: default\");",
                            "\tlog_d(\"BLECharacteristicCallbacks\", \"<< onNotify\");",
                            "",
                            "",
                            "/**",
                            " * @brief Callback function to support a Notify/Indicate Status report.",
                            " * @param [in] pCharacteristic The characteristic that is the source of the event.",
                            " * @param [in] s Status of the notification/indication",
                            " * @param [in] code Additional code of underlying errors",
                            " */",
                            "void BLECharacteristicCallbacks::onStatus(BLECharacteristic* pCharacteristic, Status s, uint32_t code) {",
                            "\tlog_d(\"BLECharacteristicCallbacks\", \">> onStatus: default\");",
                            "\tlog_d(\"BLECharacteristicCallbacks\", \"<< onStatus\");",
                            "",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            224,
                            225
                        ],
                        "comments": [
                            "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler."
                        ],
                        "lines": [
                            "\t\t\t\t}"
                        ]
                    },
                    {
                        "line_numbers": [
                            310
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tif (m_pCallbacks != nullptr && param->write.is_prep != true) {"
                        ]
                    },
                    {
                        "line_numbers": [
                            383
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\t\t\t}"
                        ]
                    },
                    {
                        "line_numbers": [
                            513
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tif(!is_notification)"
                        ]
                    },
                    {
                        "line_numbers": [
                            524,
                            525
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tif(!is_notification)",
                            "\t\t\tm_semaphoreConfEvt.wait(\"indicate\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            554
                        ],
                        "comments": [],
                        "lines": [
                            "\tm_pCallbacks = pCallbacks;"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "224": "\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                "380": "\t\t\t\t\t\t// If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                "381": "\t\t\t\t\t\t// Invoke the read callback.",
                "482": "\tm_pCallbacks->onNotify(this);   // Invoke the notify callback.",
                "499": "\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_NOTIFY_DISABLED, 0);   // Invoke the notify callback.",
                "506": "\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_DISABLED, 0);   // Invoke the notify callback.",
                "517": "\t\tif(!is_notification) // is indication",
                "526": "\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_GATT, errRc);   // Invoke the notify callback.",
                "529": "\t\tif(!is_notification){ // is indication",
                "531": "\t\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_TIMEOUT, 0);   // Invoke the notify callback.",
                "535": "\t\t\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_INDICATE, code);   // Invoke the notify callback.",
                "541": "\t\t\tm_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_NOTIFY, 0);   // Invoke the notify callback.",
                "786": "} // onNotify",
                "798": "} // onStatus"
            },
            "comment_deleted_diff": {
                "224": "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                "381": "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback",
                "382": "\t\t\t\t\t\t\tm_pCallbacks->onRead(this);   // Invoke the read callback."
            },
            "comment_modified_diff": {
                "224": "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                "381": "\t\t\t\t\t\tif (m_pCallbacks != nullptr) {  // If is.long is false then this is the first (or only) request to read data, so invoke the callback"
            }
        },
        {
            "commit": "2fd3d042b2deda7685f31f8a92eba9f93c7bd0f0",
            "timestamp": "2020-09-30T15:27:35+03:00",
            "author": "Kevin Hester",
            "commit_message": "Fix #4046 Details below: (#4086)\n\nInformed by the discussion in the bug and the code in 'that other branch'\r\nthe fix was clear.  Just set a flag if we start handling a write, and\r\nuse that flag to guard the long write complete call.",
            "additions": 17,
            "deletions": 13,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237
                        ],
                        "comments": [
                            "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                            "\t// ???"
                        ],
                        "lines": [
                            "\t\t\t\t} else {",
                            "\t\t\t\t\tm_value.cancel();",
                            "\t\t\t\t}",
                            "\t\t\t\tesp_err_t errRc = ::esp_ble_gatts_send_response(",
                            "\t\t\t\t\t\tgatts_if,",
                            "\t\t\t\t\t\tparam->write.conn_id,",
                            "\t\t\t\t\t\tparam->write.trans_id, ESP_GATT_OK, nullptr);",
                            "\t\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\t\tlog_e(\"esp_ble_gatts_send_response: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t\t}"
                        ]
                    },
                    {
                        "line_numbers": [
                            283
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\t\tm_writeEvt = true;"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234
                        ],
                        "comments": [
                            "\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                            "// ???"
                        ],
                        "lines": [
                            "\t\t\t} else {",
                            "\t\t\t\tm_value.cancel();",
                            "\t\t\t}",
                            "\t\t\tesp_err_t errRc = ::esp_ble_gatts_send_response(",
                            "\t\t\t\t\tgatts_if,",
                            "\t\t\t\t\tparam->write.conn_id,",
                            "\t\t\t\t\tparam->write.trans_id, ESP_GATT_OK, nullptr);",
                            "\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\tlog_e(\"esp_ble_gatts_send_response: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "226": "\t\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                "230": "\t// ???"
            },
            "comment_deleted_diff": {
                "224": "\t\t\t\tm_pCallbacks->onWrite(this); // Invoke the onWrite callback handler.",
                "228": "// ???"
            },
            "comment_modified_diff": {}
        }
    ],
    "BLECharacteristic.h": [],
    "BLECharacteristicMap.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 133,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133
                        ],
                        "comments": [
                            "} // getByHandle",
                            "} // getByUUID",
                            "} // getFirst",
                            "} // getNext",
                            "\t// Invoke the handler for every Service we have.",
                            "} // handleGATTServerEvent",
                            "} // setByHandle",
                            "} // setByUUID",
                            "} // toString"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Return the characteristic by UUID.",
                            " * @param [in] UUID The UUID to look up the characteristic.",
                            " * @return The characteristic.",
                            " */",
                            "BLECharacteristic* BLECharacteristicMap::getByUUID(const char* uuid) {",
                            "    return getByUUID(BLEUUID(uuid));",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Return the characteristic by UUID.",
                            " * @param [in] UUID The UUID to look up the characteristic.",
                            " * @return The characteristic.",
                            " */",
                            "BLECharacteristic* BLECharacteristicMap::getByUUID(BLEUUID uuid) {",
                            "\tfor (auto &myPair : m_uuidMap) {",
                            "\t\tif (myPair.first->getUUID().equals(uuid)) {",
                            "\t\t\treturn myPair.first;",
                            "\t\t}",
                            "\t}",
                            "\t//return m_uuidMap.at(uuid.toString());",
                            "\treturn nullptr;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the first characteristic in the map.",
                            " * @return The first characteristic in the map.",
                            " */",
                            "BLECharacteristic* BLECharacteristicMap::getFirst() {",
                            "\tm_iterator = m_uuidMap.begin();",
                            "\tif (m_iterator == m_uuidMap.end()) return nullptr;",
                            "\tBLECharacteristic* pRet = m_iterator->first;",
                            "\tm_iterator++;",
                            "\treturn pRet;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the next characteristic in the map.",
                            " * @return The next characteristic in the map.",
                            " */",
                            "BLECharacteristic* BLECharacteristicMap::getNext() {",
                            "\tif (m_iterator == m_uuidMap.end()) return nullptr;",
                            "\tBLECharacteristic* pRet = m_iterator->first;",
                            "\tm_iterator++;",
                            "\treturn pRet;",
                            "",
                            "",
                            "/**",
                            " * @brief Pass the GATT server event onwards to each of the characteristics found in the mapping",
                            " * @param [in] event",
                            " * @param [in] gatts_if",
                            " * @param [in] param",
                            " */",
                            "void BLECharacteristicMap::handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t* param) {",
                            "\tfor (auto& myPair : m_uuidMap) {",
                            "\t\tmyPair.first->handleGATTServerEvent(event, gatts_if, param);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the characteristic by handle.",
                            " * @param [in] handle The handle of the characteristic.",
                            " * @param [in] characteristic The characteristic to cache.",
                            " * @return N/A.",
                            " */",
                            "void BLECharacteristicMap::setByHandle(uint16_t handle, BLECharacteristic* characteristic) {",
                            "\tm_handleMap.insert(std::pair<uint16_t, BLECharacteristic*>(handle, characteristic));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the characteristic by UUID.",
                            " * @param [in] uuid The uuid of the characteristic.",
                            " * @param [in] characteristic The characteristic to cache.",
                            " * @return N/A.",
                            " */",
                            "void BLECharacteristicMap::setByUUID(BLECharacteristic* pCharacteristic, BLEUUID uuid) {",
                            "\tm_uuidMap.insert(std::pair<BLECharacteristic*, std::string>(pCharacteristic, uuid.toString()));",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of the characteristic map.",
                            " * @return A string representation of the characteristic map.",
                            " */",
                            "std::string BLECharacteristicMap::toString() {",
                            "\tstd::stringstream stringStream;",
                            "\tstringStream << std::hex << std::setfill('0');",
                            "\tint count = 0;",
                            "\tfor (auto &myPair: m_uuidMap) {",
                            "\t\tif (count > 0) {",
                            "\t\t\tstringStream << \"\\n\";",
                            "\t\t}",
                            "\t\tcount++;",
                            "\t\tstringStream << \"handle: 0x\" << std::setw(2) << myPair.first->getHandle() << \", uuid: \" + myPair.first->getUUID().toString();",
                            "\t}",
                            "\treturn stringStream.str();",
                            "",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "24": "} // getByHandle",
                "50": "} // getByUUID",
                "63": "} // getFirst",
                "75": "} // getNext",
                "85": "\t// Invoke the handler for every Service we have.",
                "89": "} // handleGATTServerEvent",
                "100": "} // setByHandle",
                "111": "} // setByUUID",
                "130": "} // toString"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEClient.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 536,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536
                        ],
                        "comments": [
                            "\tm_isConnected      = false;  // Initially, we are flagged as not connected.",
                            "} // BLEClient",
                            "\t// We may have allocated service references associated with this client.  Before we are finished",
                            "\t// with the client, we must release resources.",
                            "} // ~BLEClient",
                            "\t// Delete all the services.",
                            "} // clearServices",
                            "// We need the connection handle that we get from registering the application.  We register the app",
                            "// and then block on its completion.  When the event has arrived, we will have the handle.",
                            "\t// clearServices(); // we dont need to delete services since every client is unique?",
                            "\t// Perform the open connection request against the target BLE Server.",
                            "\t\t*getPeerAddress().getNative(), // address",
                            "\t\ttype,          // Note: This was added on 2018-04-03 when the latest ESP-IDF was detected to have changed the signature.",
                            "\t\t1                              // direct connection <-- maybe needs to be changed in case of direct indirect connection???",
                            "\tuint32_t rc = m_semaphoreOpenEvt.wait(\"connect\");   // Wait for the connection to complete.",
                            "} // connect",
                            "} // disconnect",
                            "\t// Execute handler code based on the type of event received.",
                            "\t\t\t\t// esp_ble_gattc_app_unregister(m_appId);",
                            "\t\t\t\t// BLEDevice::removePeerDevice(m_gattc_if, true);",
                            "\t\t// ESP_GATTC_DISCONNECT_EVT",
                            "\t\t// disconnect:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "\t\t// - esp_bd_addr_t     remote_bda",
                            "\t\t\t\t// If we receive a disconnect event, set the class flag that indicates that we are",
                            "\t\t\t\t// no longer connected.",
                            "\t\t} // ESP_GATTC_DISCONNECT_EVT",
                            "\t\t// ESP_GATTC_OPEN_EVT",
                            "\t\t// open:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "\t\t// - esp_bd_addr_t     remote_bda",
                            "\t\t\t\tm_isConnected = true;   // Flag us as connected.",
                            "\t\t} // ESP_GATTC_OPEN_EVT",
                            "\t\t// ESP_GATTC_REG_EVT",
                            "\t\t// reg:",
                            "\t\t// esp_gatt_status_t status",
                            "\t\t// uint16_t          app_id",
                            "\t\t} // ESP_GATTC_REG_EVT",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "\t\t} // ESP_GATTC_CONNECT_EVT",
                            "\t\t// ESP_GATTC_SEARCH_CMPL_EVT",
                            "\t\t// search_cmpl:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "// commented out just for now to keep backward compatibility",
                            "\t\t\t// if(p_data->search_cmpl.searched_service_source == ESP_GATT_SERVICE_FROM_REMOTE_DEVICE) {",
                            "\t\t\t// \tESP_LOGI(LOG_TAG, \"Get service information from remote device\");",
                            "\t\t\t// } else if (p_data->search_cmpl.searched_service_source == ESP_GATT_SERVICE_FROM_NVS_FLASH) {",
                            "\t\t\t// \tESP_LOGI(LOG_TAG, \"Get service information from flash\");",
                            "\t\t\t// } else {",
                            "\t\t\t// \tESP_LOGI(LOG_TAG, \"unknown service source\");",
                            "\t\t\t// }",
                            "\t\t} // ESP_GATTC_SEARCH_CMPL_EVT",
                            "\t\t// ESP_GATTC_SEARCH_RES_EVT",
                            "\t\t// search_res:",
                            "\t\t// - uint16_t      conn_id",
                            "\t\t// - uint16_t      start_handle",
                            "\t\t// - uint16_t      end_handle",
                            "\t\t// - esp_gatt_id_t srvc_id",
                            "\t\t} // ESP_GATTC_SEARCH_RES_EVT",
                            "\t} // Switch",
                            "\t// Pass the request on to all services.",
                            "} // gattClientEventHandler",
                            "} // getConnId",
                            "} // getGattcIf",
                            "} // getAddress",
                            "\t// We make the API call to read the RSSI value which is an asynchronous operation.  We expect to receive",
                            "\t// an ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT to indicate completion.",
                            "} // getRssi",
                            "} // getService",
                            "// Design",
                            "// ------",
                            "// We wish to retrieve the service given its UUID.  It is possible that we have not yet asked the",
                            "// device what services it has in which case we have nothing to match against.  If we have not",
                            "// asked the device about its services, then we do that now.  Once we get the results we can then",
                            "// examine the services map to see if it has the service we are looking for.",
                            "\t} // End of each of the services.",
                            "} // getService",
                            "// TODO implement retrieving services from cache",
                            "\tclearServices(); // Clear any services that may exist.",
                            "\t\tNULL            // Filter UUID",
                            "\t// If sucessfull, remember that we now have services.",
                            "} // getServices",
                            "} // getValue",
                            "\t\t// ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                            "\t\t// read_rssi_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t// - int8_t rssi",
                            "\t\t// - esp_bd_addr_t remote_addr",
                            "\t\t} // ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                            "} // handleGAPEvent",
                            "} // isConnected",
                            "} // setClientCallbacks",
                            "} // setValue",
                            "\t  // myPair.second is the value",
                            "} // toString",
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Destructor.",
                            " */",
                            "BLEClient::~BLEClient() {",
                            "\tfor (auto &myPair : m_servicesMap) {",
                            "\t   delete myPair.second;",
                            "\t}",
                            "\tm_servicesMap.clear();",
                            "",
                            "",
                            "/**",
                            " * @brief Clear any existing services.",
                            " *",
                            " */",
                            "void BLEClient::clearServices() {",
                            "\tESP_LOGD(LOG_TAG, \">> clearServices\");",
                            "\tfor (auto &myPair : m_servicesMap) {",
                            "\t   delete myPair.second;",
                            "\t}",
                            "\tm_servicesMap.clear();",
                            "\tm_haveServices = false;",
                            "\tESP_LOGD(LOG_TAG, \"<< clearServices\");",
                            "",
                            "/**",
                            " * Add overloaded function to ease connect to peer device with not public address",
                            " */",
                            "bool BLEClient::connect(BLEAdvertisedDevice* device) {",
                            "\tBLEAddress address =  device->getAddress();",
                            "\tesp_ble_addr_type_t type = device->getAddressType();",
                            "\treturn connect(address, type);",
                            "}",
                            "",
                            "/**",
                            " * @brief Connect to the partner (BLE Server).",
                            " * @param [in] address The address of the partner.",
                            " * @return True on success.",
                            " */",
                            "bool BLEClient::connect(BLEAddress address, esp_ble_addr_type_t type) {",
                            "\tESP_LOGD(LOG_TAG, \">> connect(%s)\", address.toString().c_str());",
                            "",
                            "\tm_appId = BLEDevice::m_appId++;",
                            "\tBLEDevice::addPeerDevice(this, true, m_appId);",
                            "\tm_semaphoreRegEvt.take(\"connect\");",
                            "",
                            "\tesp_err_t errRc = ::esp_ble_gattc_app_register(m_appId);",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_app_register: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn false;",
                            "\t}",
                            "",
                            "\tm_semaphoreRegEvt.wait(\"connect\");",
                            "",
                            "\tm_peerAddress = address;",
                            "",
                            "\tm_semaphoreOpenEvt.take(\"connect\");",
                            "\terrRc = ::esp_ble_gattc_open(",
                            "\t\tm_gattc_if,",
                            "\t);",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_open: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn false;",
                            "\t}",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< connect(), rc=%d\", rc==ESP_GATT_OK);",
                            "\treturn rc == ESP_GATT_OK;",
                            "",
                            "",
                            "/**",
                            " * @brief Disconnect from the peer.",
                            " * @return N/A.",
                            " */",
                            "void BLEClient::disconnect() {",
                            "\tESP_LOGD(LOG_TAG, \">> disconnect()\");",
                            "\tesp_err_t errRc = ::esp_ble_gattc_close(getGattcIf(), getConnId());",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_close: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< disconnect()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Handle GATT Client events",
                            " */",
                            "void BLEClient::gattClientEventHandler(",
                            "\tesp_gattc_cb_event_t      event,",
                            "\tesp_gatt_if_t             gattc_if,",
                            "\tesp_ble_gattc_cb_param_t* evtParam) {",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"gattClientEventHandler [esp_gatt_if: %d] ... %s\",",
                            "\t\tgattc_if, BLEUtils::gattClientEventTypeToString(event).c_str());",
                            "",
                            "\tswitch(event) {",
                            "",
                            "\t\tcase ESP_GATTC_SRVC_CHG_EVT:",
                            "\t\t\tESP_LOGI(LOG_TAG, \"SERVICE CHANGED\");",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTC_CLOSE_EVT: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_DISCONNECT_EVT: {",
                            "\t\t\t\tm_isConnected = false;",
                            "\t\t\t\tif (m_pClientCallbacks != nullptr) {",
                            "\t\t\t\t\tm_pClientCallbacks->onDisconnect(this);",
                            "\t\t\t\t}",
                            "\t\t\t\tBLEDevice::removePeerDevice(m_appId, true);",
                            "\t\t\t\tesp_ble_gattc_app_unregister(m_gattc_if);",
                            "\t\t\t\tm_semaphoreRssiCmplEvt.give();",
                            "\t\t\t\tm_semaphoreSearchCmplEvt.give(1);",
                            "\t\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_OPEN_EVT: {",
                            "\t\t\tm_conn_id = evtParam->open.conn_id;",
                            "\t\t\tif (m_pClientCallbacks != nullptr) {",
                            "\t\t\t\tm_pClientCallbacks->onConnect(this);",
                            "\t\t\t}",
                            "\t\t\tif (evtParam->open.status == ESP_GATT_OK) {",
                            "\t\t\t}",
                            "\t\t\tm_semaphoreOpenEvt.give(evtParam->open.status);",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_REG_EVT: {",
                            "\t\t\tm_gattc_if = gattc_if;",
                            "\t\t\tm_semaphoreRegEvt.give();",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTC_CFG_MTU_EVT:",
                            "\t\t\tif(evtParam->cfg_mtu.status != ESP_GATT_OK) {",
                            "\t\t\t\tESP_LOGE(LOG_TAG,\"Config mtu failed\");",
                            "\t\t\t}",
                            "\t\t\tm_mtu = evtParam->cfg_mtu.mtu;",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTC_CONNECT_EVT: {",
                            "\t\t\tBLEDevice::updatePeerDevice(this, true, m_gattc_if);",
                            "\t\t\tesp_err_t errRc = esp_ble_gattc_send_mtu_req(gattc_if, evtParam->connect.conn_id);",
                            "\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_send_mtu_req: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t}",
                            "\t\t\tif(BLEDevice::m_securityLevel){",
                            "\t\t\t\tesp_ble_set_encryption(evtParam->connect.remote_bda, BLEDevice::m_securityLevel);",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_SEARCH_CMPL_EVT: {",
                            "\t\t\tesp_ble_gattc_cb_param_t* p_data = (esp_ble_gattc_cb_param_t*)evtParam;",
                            "\t\t\tif (p_data->search_cmpl.status != ESP_GATT_OK){",
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"search service failed, error status = %x\", p_data->search_cmpl.status);",
                            "\t\t\t\tbreak;",
                            "\t\t\t}",
                            "#ifndef ARDUINO_ARCH_ESP32",
                            "#endif",
                            "\t\t\tm_semaphoreSearchCmplEvt.give(0);",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_SEARCH_RES_EVT: {",
                            "\t\t\tBLEUUID uuid = BLEUUID(evtParam->search_res.srvc_id);",
                            "\t\t\tBLERemoteService* pRemoteService = new BLERemoteService(",
                            "\t\t\t\tevtParam->search_res.srvc_id,",
                            "\t\t\t\tthis,",
                            "\t\t\t\tevtParam->search_res.start_handle,",
                            "\t\t\t\tevtParam->search_res.end_handle",
                            "\t\t\t);",
                            "\t\t\tm_servicesMap.insert(std::pair<std::string, BLERemoteService*>(uuid.toString(), pRemoteService));",
                            "\t\t\tm_servicesMapByInstID.insert(std::pair<BLERemoteService *, uint16_t>(pRemoteService, evtParam->search_res.srvc_id.inst_id));",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\tdefault: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\tfor (auto &myPair : m_servicesMap) {",
                            "\t   myPair.second->gattClientEventHandler(event, gattc_if, evtParam);",
                            "\t}",
                            "",
                            "",
                            "",
                            "uint16_t BLEClient::getConnId() {",
                            "\treturn m_conn_id;",
                            "",
                            "",
                            "",
                            "esp_gatt_if_t BLEClient::getGattcIf() {",
                            "\treturn m_gattc_if;",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve the address of the peer.",
                            " *",
                            " * Returns the Bluetooth device address of the %BLE peer to which this client is connected.",
                            " */",
                            "BLEAddress BLEClient::getPeerAddress() {",
                            "\treturn m_peerAddress;",
                            "",
                            "",
                            "/**",
                            " * @brief Ask the BLE server for the RSSI value.",
                            " * @return The RSSI value.",
                            " */",
                            "int BLEClient::getRssi() {",
                            "\tESP_LOGD(LOG_TAG, \">> getRssi()\");",
                            "\tif (!isConnected()) {",
                            "\t\tESP_LOGD(LOG_TAG, \"<< getRssi(): Not connected\");",
                            "\t\treturn 0;",
                            "\t}",
                            "\t//",
                            "\tm_semaphoreRssiCmplEvt.take(\"getRssi\");",
                            "\tesp_err_t rc = ::esp_ble_gap_read_rssi(*getPeerAddress().getNative());",
                            "\tif (rc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< getRssi: esp_ble_gap_read_rssi: rc=%d %s\", rc, GeneralUtils::errorToString(rc));",
                            "\t\treturn 0;",
                            "\t}",
                            "\tint rssiValue = m_semaphoreRssiCmplEvt.wait(\"getRssi\");",
                            "\tESP_LOGD(LOG_TAG, \"<< getRssi(): %d\", rssiValue);",
                            "\treturn rssiValue;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the service BLE Remote Service instance corresponding to the uuid.",
                            " * @param [in] uuid The UUID of the service being sought.",
                            " * @return A reference to the Service or nullptr if don't know about it.",
                            " */",
                            "BLERemoteService* BLEClient::getService(const char* uuid) {",
                            "    return getService(BLEUUID(uuid));",
                            "",
                            "",
                            "/**",
                            " * @brief Get the service object corresponding to the uuid.",
                            " * @param [in] uuid The UUID of the service being sought.",
                            " * @return A reference to the Service or nullptr if don't know about it.",
                            " * @throws BLEUuidNotFound",
                            " */",
                            "BLERemoteService* BLEClient::getService(BLEUUID uuid) {",
                            "\tESP_LOGD(LOG_TAG, \">> getService: uuid: %s\", uuid.toString().c_str());",
                            "\tif (!m_haveServices) {",
                            "\t\tgetServices();",
                            "\t}",
                            "\tstd::string uuidStr = uuid.toString();",
                            "\tfor (auto &myPair : m_servicesMap) {",
                            "\t\tif (myPair.first == uuidStr) {",
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< getService: found the service with uuid: %s\", uuid.toString().c_str());",
                            "\t\t\treturn myPair.second;",
                            "\t\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< getService: not found\");",
                            "\treturn nullptr;",
                            "",
                            "",
                            "/**",
                            " * @brief Ask the remote %BLE server for its services.",
                            " * A %BLE Server exposes a set of services for its partners.  Here we ask the server for its set of",
                            " * services and wait until we have received them all.",
                            " * @return N/A",
                            " */",
                            "std::map<std::string, BLERemoteService*>* BLEClient::getServices() {",
                            "/*",
                            " * Design",
                            " * ------",
                            " * We invoke esp_ble_gattc_search_service.  This will request a list of the service exposed by the",
                            " * peer BLE partner to be returned as events.  Each event will be an an instance of ESP_GATTC_SEARCH_RES_EVT",
                            " * and will culminate with an ESP_GATTC_SEARCH_CMPL_EVT when all have been received.",
                            " */",
                            "\tESP_LOGD(LOG_TAG, \">> getServices\");",
                            "",
                            "\tesp_err_t errRc = esp_ble_gattc_search_service(",
                            "\t\tgetGattcIf(),",
                            "\t\tgetConnId(),",
                            "\t);",
                            "",
                            "\tm_semaphoreSearchCmplEvt.take(\"getServices\");",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_search_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn &m_servicesMap;",
                            "\t}",
                            "\tm_haveServices = (m_semaphoreSearchCmplEvt.wait(\"getServices\") == 0);",
                            "\tESP_LOGD(LOG_TAG, \"<< getServices\");",
                            "\treturn &m_servicesMap;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the value of a specific characteristic associated with a specific service.",
                            " * @param [in] serviceUUID The service that owns the characteristic.",
                            " * @param [in] characteristicUUID The characteristic whose value we wish to read.",
                            " * @throws BLEUuidNotFound",
                            " */",
                            "std::string BLEClient::getValue(BLEUUID serviceUUID, BLEUUID characteristicUUID) {",
                            "\tESP_LOGD(LOG_TAG, \">> getValue: serviceUUID: %s, characteristicUUID: %s\", serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());",
                            "\tstd::string ret = getService(serviceUUID)->getCharacteristic(characteristicUUID)->readValue();",
                            "\tESP_LOGD(LOG_TAG, \"<<getValue\");",
                            "\treturn ret;",
                            "",
                            "",
                            "/**",
                            " * @brief Handle a received GAP event.",
                            " *",
                            " * @param [in] event",
                            " * @param [in] param",
                            " */",
                            "void BLEClient::handleGAPEvent(",
                            "\t\tesp_gap_ble_cb_event_t  event,",
                            "\t\tesp_ble_gap_cb_param_t* param) {",
                            "\tESP_LOGD(LOG_TAG, \"BLEClient ... handling GAP event!\");",
                            "\tswitch (event) {",
                            "\t\t//",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT: {",
                            "\t\t\tm_semaphoreRssiCmplEvt.give((uint32_t) param->read_rssi_cmpl.rssi);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Are we connected to a partner?",
                            " * @return True if we are connected and false if we are not connected.",
                            " */",
                            "bool BLEClient::isConnected() {",
                            "\treturn m_isConnected;",
                            "",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Set the callbacks that will be invoked.",
                            " */",
                            "void BLEClient::setClientCallbacks(BLEClientCallbacks* pClientCallbacks) {",
                            "\tm_pClientCallbacks = pClientCallbacks;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the value of a specific characteristic associated with a specific service.",
                            " * @param [in] serviceUUID The service that owns the characteristic.",
                            " * @param [in] characteristicUUID The characteristic whose value we wish to write.",
                            " * @throws BLEUuidNotFound",
                            " */",
                            "void BLEClient::setValue(BLEUUID serviceUUID, BLEUUID characteristicUUID, std::string value) {",
                            "\tESP_LOGD(LOG_TAG, \">> setValue: serviceUUID: %s, characteristicUUID: %s\", serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());",
                            "\tgetService(serviceUUID)->getCharacteristic(characteristicUUID)->writeValue(value);",
                            "\tESP_LOGD(LOG_TAG, \"<< setValue\");",
                            "",
                            "uint16_t BLEClient::getMTU() {",
                            "\treturn m_mtu;",
                            "}",
                            "",
                            "/**",
                            " * @brief Return a string representation of this client.",
                            " * @return A string representation of this client.",
                            " */",
                            "std::string BLEClient::toString() {",
                            "\tstd::ostringstream ss;",
                            "\tss << \"peer address: \" << m_peerAddress.toString();",
                            "\tss << \"\\nServices:\\n\";",
                            "\tfor (auto &myPair : m_servicesMap) {",
                            "\t\tss << myPair.second->toString() << \"\\n\";",
                            "\t}",
                            "\treturn ss.str();",
                            "",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "56": "\tm_isConnected      = false;  // Initially, we are flagged as not connected.",
                "57": "} // BLEClient",
                "64": "\t// We may have allocated service references associated with this client.  Before we are finished",
                "65": "\t// with the client, we must release resources.",
                "70": "} // ~BLEClient",
                "79": "\t// Delete all the services.",
                "86": "} // clearServices",
                "105": "// We need the connection handle that we get from registering the application.  We register the app",
                "106": "// and then block on its completion.  When the event has arrived, we will have the handle.",
                "111": "\t// clearServices(); // we dont need to delete services since every client is unique?",
                "122": "\t// Perform the open connection request against the target BLE Server.",
                "126": "\t\t*getPeerAddress().getNative(), // address",
                "127": "\t\ttype,          // Note: This was added on 2018-04-03 when the latest ESP-IDF was detected to have changed the signature.",
                "128": "\t\t1                              // direct connection <-- maybe needs to be changed in case of direct indirect connection???",
                "135": "\tuint32_t rc = m_semaphoreOpenEvt.wait(\"connect\");   // Wait for the connection to complete.",
                "138": "} // connect",
                "153": "} // disconnect",
                "167": "\t// Execute handler code based on the type of event received.",
                "175": "\t\t\t\t// esp_ble_gattc_app_unregister(m_appId);",
                "176": "\t\t\t\t// BLEDevice::removePeerDevice(m_gattc_if, true);",
                "181": "\t\t// ESP_GATTC_DISCONNECT_EVT",
                "183": "\t\t// disconnect:",
                "184": "\t\t// - esp_gatt_status_t status",
                "185": "\t\t// - uint16_t          conn_id",
                "186": "\t\t// - esp_bd_addr_t     remote_bda",
                "188": "\t\t\t\t// If we receive a disconnect event, set the class flag that indicates that we are",
                "189": "\t\t\t\t// no longer connected.",
                "199": "\t\t} // ESP_GATTC_DISCONNECT_EVT",
                "202": "\t\t// ESP_GATTC_OPEN_EVT",
                "204": "\t\t// open:",
                "205": "\t\t// - esp_gatt_status_t status",
                "206": "\t\t// - uint16_t          conn_id",
                "207": "\t\t// - esp_bd_addr_t     remote_bda",
                "215": "\t\t\t\tm_isConnected = true;   // Flag us as connected.",
                "219": "\t\t} // ESP_GATTC_OPEN_EVT",
                "223": "\t\t// ESP_GATTC_REG_EVT",
                "225": "\t\t// reg:",
                "226": "\t\t// esp_gatt_status_t status",
                "227": "\t\t// uint16_t          app_id",
                "233": "\t\t} // ESP_GATTC_REG_EVT",
                "248": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "252": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "254": "\t\t} // ESP_GATTC_CONNECT_EVT",
                "257": "\t\t// ESP_GATTC_SEARCH_CMPL_EVT",
                "259": "\t\t// search_cmpl:",
                "260": "\t\t// - esp_gatt_status_t status",
                "261": "\t\t// - uint16_t          conn_id",
                "270": "// commented out just for now to keep backward compatibility",
                "271": "\t\t\t// if(p_data->search_cmpl.searched_service_source == ESP_GATT_SERVICE_FROM_REMOTE_DEVICE) {",
                "272": "\t\t\t// \tESP_LOGI(LOG_TAG, \"Get service information from remote device\");",
                "273": "\t\t\t// } else if (p_data->search_cmpl.searched_service_source == ESP_GATT_SERVICE_FROM_NVS_FLASH) {",
                "274": "\t\t\t// \tESP_LOGI(LOG_TAG, \"Get service information from flash\");",
                "275": "\t\t\t// } else {",
                "276": "\t\t\t// \tESP_LOGI(LOG_TAG, \"unknown service source\");",
                "277": "\t\t\t// }",
                "281": "\t\t} // ESP_GATTC_SEARCH_CMPL_EVT",
                "285": "\t\t// ESP_GATTC_SEARCH_RES_EVT",
                "287": "\t\t// search_res:",
                "288": "\t\t// - uint16_t      conn_id",
                "289": "\t\t// - uint16_t      start_handle",
                "290": "\t\t// - uint16_t      end_handle",
                "291": "\t\t// - esp_gatt_id_t srvc_id",
                "304": "\t\t} // ESP_GATTC_SEARCH_RES_EVT",
                "310": "\t} // Switch",
                "312": "\t// Pass the request on to all services.",
                "317": "} // gattClientEventHandler",
                "322": "} // getConnId",
                "328": "} // getGattcIf",
                "338": "} // getAddress",
                "351": "\t// We make the API call to read the RSSI value which is an asynchronous operation.  We expect to receive",
                "352": "\t// an ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT to indicate completion.",
                "363": "} // getRssi",
                "373": "} // getService",
                "384": "// Design",
                "385": "// ------",
                "386": "// We wish to retrieve the service given its UUID.  It is possible that we have not yet asked the",
                "387": "// device what services it has in which case we have nothing to match against.  If we have not",
                "388": "// asked the device about its services, then we do that now.  Once we get the results we can then",
                "389": "// examine the services map to see if it has the service we are looking for.",
                "399": "\t} // End of each of the services.",
                "402": "} // getService",
                "420": "// TODO implement retrieving services from cache",
                "421": "\tclearServices(); // Clear any services that may exist.",
                "426": "\t\tNULL            // Filter UUID",
                "434": "\t// If sucessfull, remember that we now have services.",
                "438": "} // getServices",
                "452": "} // getValue",
                "467": "\t\t// ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                "469": "\t\t// read_rssi_cmpl",
                "470": "\t\t// - esp_bt_status_t status",
                "471": "\t\t// - int8_t rssi",
                "472": "\t\t// - esp_bd_addr_t remote_addr",
                "477": "\t\t} // ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                "482": "} // handleGAPEvent",
                "491": "} // isConnected",
                "501": "} // setClientCallbacks",
                "514": "} // setValue",
                "530": "\t  // myPair.second is the value",
                "533": "} // toString",
                "536": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d7ea7b80a7badbe30e6fb6f33f71375e0b133c",
            "timestamp": "2019-04-15T17:26:35+02:00",
            "author": "Bascy",
            "commit_message": "Refactored use of LOG_X(LOG_TAG, ...) to log_x(...) (#2672)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)\r\n\r\n* Change logging from Error to Verbose when not found and default available\r\n\r\n* Move Enter and Exit logging to Verbose Level\r\n\r\n* Refactored LOG_X() into log_x()",
            "additions": 32,
            "deletions": 39,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            265
                        ],
                        "comments": [
                            "\t\t\t// \tlog_i(\"Get service information from remote device\");"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            339
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> getRssi()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            341
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_v(\"<< getRssi(): Not connected\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            350
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"<< getRssi: esp_ble_gap_read_rssi: rc=%d %s\", rc, GeneralUtils::errorToString(rc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            354
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< getRssi(): %d\", rssiValue);"
                        ]
                    },
                    {
                        "line_numbers": [
                            376
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> getService: uuid: %s\", uuid.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            389
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_v(\"<< getService: found the service with uuid: %s\", uuid.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            393
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< getService: not found\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            412
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> getServices\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            424
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"esp_ble_gattc_search_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            429
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< getServices\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            441
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> getValue: serviceUUID: %s, characteristicUUID: %s\", serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            443
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<<getValue\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            457
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_d(\"BLEClient ... handling GAP event!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            504
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> setValue: serviceUUID: %s, characteristicUUID: %s\", serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            506
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< setValue\");"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            272
                        ],
                        "comments": [
                            "\t\t\t// \tESP_LOGI(LOG_TAG, \"Get service information from remote device\");"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            346
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> getRssi()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            348
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGD(LOG_TAG, \"<< getRssi(): Not connected\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            357
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"<< getRssi: esp_ble_gap_read_rssi: rc=%d %s\", rc, GeneralUtils::errorToString(rc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            361
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< getRssi(): %d\", rssiValue);"
                        ]
                    },
                    {
                        "line_numbers": [
                            383
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> getService: uuid: %s\", uuid.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            396
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< getService: found the service with uuid: %s\", uuid.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            400
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< getService: not found\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            419
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> getServices\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            431
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_search_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            436
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< getServices\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            448
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> getValue: serviceUUID: %s, characteristicUUID: %s\", serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            450
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<<getValue\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            464
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"BLEClient ... handling GAP event!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            511
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setValue: serviceUUID: %s, characteristicUUID: %s\", serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            513
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< setValue\");"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "265": "\t\t\t// \tlog_i(\"Get service information from remote device\");",
                "267": "\t\t\t// \tlog_i(\"Get service information from flash\");",
                "269": "\t\t\t// \tlog_i(\"unknown service source\");"
            },
            "comment_deleted_diff": {
                "272": "\t\t\t// \tESP_LOGI(LOG_TAG, \"Get service information from remote device\");",
                "274": "\t\t\t// \tESP_LOGI(LOG_TAG, \"Get service information from flash\");",
                "276": "\t\t\t// \tESP_LOGI(LOG_TAG, \"unknown service source\");"
            },
            "comment_modified_diff": {}
        }
    ],
    "BLEClient.h": [],
    "BLEDescriptor.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 296,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296
                        ],
                        "comments": [
                            "\tm_value.attr_len     = 0;                                         // Initial length is 0.",
                            "\tm_value.attr_max_len = max_len;                     // Maximum length of the data.",
                            "\tm_handle             = NULL_HANDLE;                               // Handle is initially unknown.",
                            "\tm_pCharacteristic    = nullptr;                                   // No initial characteristic.",
                            "\tm_pCallback          = nullptr;                                   // No initial callback.",
                            "\tm_value.attr_value   = (uint8_t*) malloc(max_len);  // Allocate storage for the value.",
                            "} // BLEDescriptor",
                            "\tfree(m_value.attr_value);   // Release the storage we created in the constructor.",
                            "} // ~BLEDescriptor",
                            "\tm_pCharacteristic = pCharacteristic; // Save the characteristic associated with this service.",
                            "} // executeCreate",
                            "} // getHandle",
                            "} // getLength",
                            "} // getUUID",
                            "} // getValue",
                            "\t\t// ESP_GATTS_ADD_CHAR_DESCR_EVT",
                            "\t\t// add_char_descr:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          attr_handle",
                            "\t\t// - uint16_t          service_handle",
                            "\t\t// - esp_bt_uuid_t     char_uuid",
                            "\t\t} // ESP_GATTS_ADD_CHAR_DESCR_EVT",
                            "\t\t// ESP_GATTS_WRITE_EVT - A request to write the value of a descriptor has arrived.",
                            "\t\t// write:",
                            "\t\t// - uint16_t conn_id",
                            "\t\t// - uint16_t trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint16_t handle",
                            "\t\t// - uint16_t offset",
                            "\t\t// - bool need_rsp",
                            "\t\t// - bool is_prep",
                            "\t\t// - uint16_t len",
                            "\t\t// - uint8_t *value",
                            "\t\t\t\tsetValue(param->write.value, param->write.len);   // Set the value of the descriptor.",
                            "\t\t\t\tif (m_pCallback != nullptr) {   // We have completed the write, if there is a user supplied callback handler, invoke it now.",
                            "\t\t\t\t\tm_pCallback->onWrite(this);   // Invoke the onWrite callback handler.",
                            "\t\t\t}  // End of ... this is our handle.",
                            "\t\t} // ESP_GATTS_WRITE_EVT",
                            "\t\t// ESP_GATTS_READ_EVT - A request to read the value of a descriptor has arrived.",
                            "\t\t// read:",
                            "\t\t// - uint16_t conn_id",
                            "\t\t// - uint32_t trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint16_t handle",
                            "\t\t// - uint16_t offset",
                            "\t\t// - bool is_long",
                            "\t\t// - bool need_rsp",
                            "\t\t\tif (param->read.handle == m_handle) {  // If this event is for this descriptor ... process it",
                            "\t\t\t\tif (m_pCallback != nullptr) {   // If we have a user supplied callback, invoke it now.",
                            "\t\t\t\t\tm_pCallback->onRead(this);    // Invoke the onRead callback method in the callback handler.",
                            "\t\t\t} // End of this is our handle",
                            "\t\t} // ESP_GATTS_READ_EVT",
                            "\t} // switch event",
                            "} // handleGATTServerEvent",
                            "} // setCallbacks",
                            "} // setHandle",
                            "} // setValue",
                            "} // setValue",
                            "} // toString",
                            "} // onRead",
                            "} // onWrite"
                        ],
                        "lines": [
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief BLEDescriptor destructor.",
                            " */",
                            "BLEDescriptor::~BLEDescriptor() {",
                            "",
                            "",
                            "/**",
                            " * @brief Execute the creation of the descriptor with the BLE runtime in ESP.",
                            " * @param [in] pCharacteristic The characteristic to which to register this descriptor.",
                            " */",
                            "void BLEDescriptor::executeCreate(BLECharacteristic* pCharacteristic) {",
                            "\tESP_LOGD(LOG_TAG, \">> executeCreate(): %s\", toString().c_str());",
                            "",
                            "\tif (m_handle != NULL_HANDLE) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Descriptor already has a handle.\");",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "",
                            "\tesp_attr_control_t control;",
                            "\tcontrol.auto_rsp = ESP_GATT_AUTO_RSP;",
                            "\tm_semaphoreCreateEvt.take(\"executeCreate\");",
                            "\tesp_err_t errRc = ::esp_ble_gatts_add_char_descr(",
                            "\t\t\tpCharacteristic->getService()->getHandle(),",
                            "\t\t\tgetUUID().getNative(),",
                            "\t\t\t(esp_gatt_perm_t)m_permissions,",
                            "\t\t\t&m_value,",
                            "\t\t\t&control);",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_add_char_descr: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "\tm_semaphoreCreateEvt.wait(\"executeCreate\");",
                            "\tESP_LOGD(LOG_TAG, \"<< executeCreate\");",
                            "",
                            "",
                            "/**",
                            " * @brief Get the BLE handle for this descriptor.",
                            " * @return The handle for this descriptor.",
                            " */",
                            "uint16_t BLEDescriptor::getHandle() {",
                            "\treturn m_handle;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the length of the value of this descriptor.",
                            " * @return The length (in bytes) of the value of this descriptor.",
                            " */",
                            "size_t BLEDescriptor::getLength() {",
                            "\treturn m_value.attr_len;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the UUID of the descriptor.",
                            " */",
                            "BLEUUID BLEDescriptor::getUUID() {",
                            "\treturn m_bleUUID;",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Get the value of this descriptor.",
                            " * @return A pointer to the value of this descriptor.",
                            " */",
                            "uint8_t* BLEDescriptor::getValue() {",
                            "\treturn m_value.attr_value;",
                            "",
                            "",
                            "/**",
                            " * @brief Handle GATT server events for the descripttor.",
                            " * @param [in] event",
                            " * @param [in] gatts_if",
                            " * @param [in] param",
                            " */",
                            "void BLEDescriptor::handleGATTServerEvent(",
                            "\t\tesp_gatts_cb_event_t      event,",
                            "\t\tesp_gatt_if_t             gatts_if,",
                            "\t\tesp_ble_gatts_cb_param_t* param) {",
                            "\tswitch (event) {",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_ADD_CHAR_DESCR_EVT: {",
                            "\t\t\tif (m_pCharacteristic != nullptr &&",
                            "\t\t\t\t\tm_bleUUID.equals(BLEUUID(param->add_char_descr.descr_uuid)) &&",
                            "\t\t\t\t\tm_pCharacteristic->getService()->getHandle() == param->add_char_descr.service_handle &&",
                            "\t\t\t\t\tm_pCharacteristic == m_pCharacteristic->getService()->getLastCreatedCharacteristic()) {",
                            "\t\t\t\tsetHandle(param->add_char_descr.attr_handle);",
                            "\t\t\t\tm_semaphoreCreateEvt.give();",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_WRITE_EVT: {",
                            "\t\t\tif (param->write.handle == m_handle) {",
                            "",
                            "\t\t\t\t}",
                            "",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_READ_EVT: {",
                            "",
                            "\t\t\t\t}",
                            "",
                            "\t\t\tbreak;",
                            "",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the callback handlers for this descriptor.",
                            " * @param [in] pCallbacks An instance of a callback structure used to define any callbacks for the descriptor.",
                            " */",
                            "void BLEDescriptor::setCallbacks(BLEDescriptorCallbacks* pCallback) {",
                            "\tESP_LOGD(LOG_TAG, \">> setCallbacks: 0x%x\", (uint32_t) pCallback);",
                            "\tm_pCallback = pCallback;",
                            "\tESP_LOGD(LOG_TAG, \"<< setCallbacks\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the handle of this descriptor.",
                            " * Set the handle of this descriptor to be the supplied value.",
                            " * @param [in] handle The handle to be associated with this descriptor.",
                            " * @return N/A.",
                            " */",
                            "void BLEDescriptor::setHandle(uint16_t handle) {",
                            "\tESP_LOGD(LOG_TAG, \">> setHandle(0x%.2x): Setting descriptor handle to be 0x%.2x\", handle, handle);",
                            "\tm_handle = handle;",
                            "\tESP_LOGD(LOG_TAG, \"<< setHandle()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the value of the descriptor.",
                            " * @param [in] data The data to set for the descriptor.",
                            " * @param [in] length The length of the data in bytes.",
                            " */",
                            "void BLEDescriptor::setValue(uint8_t* data, size_t length) {",
                            "\tif (length > ESP_GATT_MAX_ATTR_LEN) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Size %d too large, must be no bigger than %d\", length, ESP_GATT_MAX_ATTR_LEN);",
                            "\t\treturn;",
                            "\t}",
                            "\tm_value.attr_len = length;",
                            "\tmemcpy(m_value.attr_value, data, length);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the value of the descriptor.",
                            " * @param [in] value The value of the descriptor in string form.",
                            " */",
                            "void BLEDescriptor::setValue(std::string value) {",
                            "\tsetValue((uint8_t*) value.data(), value.length());",
                            "",
                            "void BLEDescriptor::setAccessPermissions(esp_gatt_perm_t perm) {",
                            "\tm_permissions = perm;",
                            "}",
                            "",
                            "/**",
                            " * @brief Return a string representation of the descriptor.",
                            " * @return A string representation of the descriptor.",
                            " */",
                            "std::string BLEDescriptor::toString() {",
                            "\tstd::stringstream stringstream;",
                            "\tstringstream << std::hex << std::setfill('0');",
                            "\tstringstream << \"UUID: \" << m_bleUUID.toString() + \", handle: 0x\" << std::setw(2) << m_handle;",
                            "\treturn stringstream.str();",
                            "",
                            "",
                            "BLEDescriptorCallbacks::~BLEDescriptorCallbacks() {}",
                            "",
                            "/**",
                            " * @brief Callback function to support a read request.",
                            " * @param [in] pDescriptor The descriptor that is the source of the event.",
                            " */",
                            "void BLEDescriptorCallbacks::onRead(BLEDescriptor* pDescriptor) {",
                            "\tESP_LOGD(\"BLEDescriptorCallbacks\", \">> onRead: default\");",
                            "\tESP_LOGD(\"BLEDescriptorCallbacks\", \"<< onRead\");",
                            "",
                            "",
                            "/**",
                            " * @brief Callback function to support a write request.",
                            " * @param [in] pDescriptor The descriptor that is the source of the event.",
                            " */",
                            "void BLEDescriptorCallbacks::onWrite(BLEDescriptor* pDescriptor) {",
                            "\tESP_LOGD(\"BLEDescriptorCallbacks\", \">> onWrite: default\");",
                            "\tESP_LOGD(\"BLEDescriptorCallbacks\", \"<< onWrite\");",
                            "",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "43": "\tm_value.attr_len     = 0;                                         // Initial length is 0.",
                "44": "\tm_value.attr_max_len = max_len;                     // Maximum length of the data.",
                "45": "\tm_handle             = NULL_HANDLE;                               // Handle is initially unknown.",
                "46": "\tm_pCharacteristic    = nullptr;                                   // No initial characteristic.",
                "47": "\tm_pCallback          = nullptr;                                   // No initial callback.",
                "49": "\tm_value.attr_value   = (uint8_t*) malloc(max_len);  // Allocate storage for the value.",
                "50": "} // BLEDescriptor",
                "57": "\tfree(m_value.attr_value);   // Release the storage we created in the constructor.",
                "58": "} // ~BLEDescriptor",
                "73": "\tm_pCharacteristic = pCharacteristic; // Save the characteristic associated with this service.",
                "91": "} // executeCreate",
                "100": "} // getHandle",
                "109": "} // getLength",
                "117": "} // getUUID",
                "127": "} // getValue",
                "141": "\t\t// ESP_GATTS_ADD_CHAR_DESCR_EVT",
                "143": "\t\t// add_char_descr:",
                "144": "\t\t// - esp_gatt_status_t status",
                "145": "\t\t// - uint16_t          attr_handle",
                "146": "\t\t// - uint16_t          service_handle",
                "147": "\t\t// - esp_bt_uuid_t     char_uuid",
                "157": "\t\t} // ESP_GATTS_ADD_CHAR_DESCR_EVT",
                "159": "\t\t// ESP_GATTS_WRITE_EVT - A request to write the value of a descriptor has arrived.",
                "161": "\t\t// write:",
                "162": "\t\t// - uint16_t conn_id",
                "163": "\t\t// - uint16_t trans_id",
                "164": "\t\t// - esp_bd_addr_t bda",
                "165": "\t\t// - uint16_t handle",
                "166": "\t\t// - uint16_t offset",
                "167": "\t\t// - bool need_rsp",
                "168": "\t\t// - bool is_prep",
                "169": "\t\t// - uint16_t len",
                "170": "\t\t// - uint8_t *value",
                "173": "\t\t\t\tsetValue(param->write.value, param->write.len);   // Set the value of the descriptor.",
                "175": "\t\t\t\tif (m_pCallback != nullptr) {   // We have completed the write, if there is a user supplied callback handler, invoke it now.",
                "176": "\t\t\t\t\tm_pCallback->onWrite(this);   // Invoke the onWrite callback handler.",
                "178": "\t\t\t}  // End of ... this is our handle.",
                "181": "\t\t} // ESP_GATTS_WRITE_EVT",
                "183": "\t\t// ESP_GATTS_READ_EVT - A request to read the value of a descriptor has arrived.",
                "185": "\t\t// read:",
                "186": "\t\t// - uint16_t conn_id",
                "187": "\t\t// - uint32_t trans_id",
                "188": "\t\t// - esp_bd_addr_t bda",
                "189": "\t\t// - uint16_t handle",
                "190": "\t\t// - uint16_t offset",
                "191": "\t\t// - bool is_long",
                "192": "\t\t// - bool need_rsp",
                "195": "\t\t\tif (param->read.handle == m_handle) {  // If this event is for this descriptor ... process it",
                "197": "\t\t\t\tif (m_pCallback != nullptr) {   // If we have a user supplied callback, invoke it now.",
                "198": "\t\t\t\t\tm_pCallback->onRead(this);    // Invoke the onRead callback method in the callback handler.",
                "201": "\t\t\t} // End of this is our handle",
                "203": "\t\t} // ESP_GATTS_READ_EVT",
                "207": "\t} // switch event",
                "208": "} // handleGATTServerEvent",
                "219": "} // setCallbacks",
                "232": "} // setHandle",
                "247": "} // setValue",
                "256": "} // setValue",
                "271": "} // toString",
                "283": "} // onRead",
                "293": "} // onWrite"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEDescriptor.h": [],
    "BLEDescriptorMap.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 147,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147
                        ],
                        "comments": [
                            "#include <esp_gatts_api.h>   // ESP32 BLE",
                            "} // getByUUID",
                            "} // getByHandle",
                            "} // setByUUID",
                            "} // setByUUID",
                            "} // setByHandle",
                            "} // toString",
                            "\t// Invoke the handler for every descriptor we have.",
                            "} // handleGATTServerEvent",
                            "} // getFirst",
                            "} // getNext"
                        ],
                        "lines": [
                            "#ifdef ARDUINO_ARCH_ESP32",
                            "#include \"esp32-hal-log.h\"",
                            "#endif",
                            "",
                            "/**",
                            " * @brief Return the descriptor by UUID.",
                            " * @param [in] UUID The UUID to look up the descriptor.",
                            " * @return The descriptor.  If not present, then nullptr is returned.",
                            " */",
                            "BLEDescriptor* BLEDescriptorMap::getByUUID(const char* uuid) {",
                            "\treturn getByUUID(BLEUUID(uuid));",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Return the descriptor by UUID.",
                            " * @param [in] UUID The UUID to look up the descriptor.",
                            " * @return The descriptor.  If not present, then nullptr is returned.",
                            " */",
                            "BLEDescriptor* BLEDescriptorMap::getByUUID(BLEUUID uuid) {",
                            "\tfor (auto &myPair : m_uuidMap) {",
                            "\t\tif (myPair.first->getUUID().equals(uuid)) {",
                            "\t\t\treturn myPair.first;",
                            "\t\t}",
                            "\t}",
                            "\t//return m_uuidMap.at(uuid.toString());",
                            "\treturn nullptr;",
                            "",
                            "",
                            "/**",
                            " * @brief Return the descriptor by handle.",
                            " * @param [in] handle The handle to look up the descriptor.",
                            " * @return The descriptor.",
                            " */",
                            "BLEDescriptor* BLEDescriptorMap::getByHandle(uint16_t handle) {",
                            "\treturn m_handleMap.at(handle);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the descriptor by UUID.",
                            " * @param [in] uuid The uuid of the descriptor.",
                            " * @param [in] characteristic The descriptor to cache.",
                            " * @return N/A.",
                            " */",
                            "void BLEDescriptorMap::setByUUID(const char* uuid, BLEDescriptor* pDescriptor){",
                            "\tm_uuidMap.insert(std::pair<BLEDescriptor*, std::string>(pDescriptor, uuid));",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Set the descriptor by UUID.",
                            " * @param [in] uuid The uuid of the descriptor.",
                            " * @param [in] characteristic The descriptor to cache.",
                            " * @return N/A.",
                            " */",
                            "void BLEDescriptorMap::setByUUID(BLEUUID uuid, BLEDescriptor* pDescriptor) {",
                            "\tm_uuidMap.insert(std::pair<BLEDescriptor*, std::string>(pDescriptor, uuid.toString()));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the descriptor by handle.",
                            " * @param [in] handle The handle of the descriptor.",
                            " * @param [in] descriptor The descriptor to cache.",
                            " * @return N/A.",
                            " */",
                            "void BLEDescriptorMap::setByHandle(uint16_t handle, BLEDescriptor* pDescriptor) {",
                            "\tm_handleMap.insert(std::pair<uint16_t, BLEDescriptor*>(handle, pDescriptor));",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of the descriptor map.",
                            " * @return A string representation of the descriptor map.",
                            " */",
                            "std::string BLEDescriptorMap::toString() {",
                            "\tstd::stringstream stringStream;",
                            "\tstringStream << std::hex << std::setfill('0');",
                            "\tint count = 0;",
                            "\tfor (auto &myPair : m_uuidMap) {",
                            "\t\tif (count > 0) {",
                            "\t\t\tstringStream << \"\\n\";",
                            "\t\t}",
                            "\t\tcount++;",
                            "\t\tstringStream << \"handle: 0x\" << std::setw(2) << myPair.first->getHandle() << \", uuid: \" + myPair.first->getUUID().toString();",
                            "\t}",
                            "\treturn stringStream.str();",
                            "",
                            "",
                            "/**",
                            " * @breif Pass the GATT server event onwards to each of the descriptors found in the mapping",
                            " * @param [in] event",
                            " * @param [in] gatts_if",
                            " * @param [in] param",
                            " */",
                            "void BLEDescriptorMap::handleGATTServerEvent(",
                            "\t\tesp_gatts_cb_event_t      event,",
                            "\t\tesp_gatt_if_t             gatts_if,",
                            "\t\tesp_ble_gatts_cb_param_t* param) {",
                            "\tfor (auto &myPair : m_uuidMap) {",
                            "\t\tmyPair.first->handleGATTServerEvent(event, gatts_if, param);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Get the first descriptor in the map.",
                            " * @return The first descriptor in the map.",
                            " */",
                            "BLEDescriptor* BLEDescriptorMap::getFirst() {",
                            "\tm_iterator = m_uuidMap.begin();",
                            "\tif (m_iterator == m_uuidMap.end()) return nullptr;",
                            "\tBLEDescriptor* pRet = m_iterator->first;",
                            "\tm_iterator++;",
                            "\treturn pRet;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the next descriptor in the map.",
                            " * @return The next descriptor in the map.",
                            " */",
                            "BLEDescriptor* BLEDescriptorMap::getNext() {",
                            "\tif (m_iterator == m_uuidMap.end()) return nullptr;",
                            "\tBLEDescriptor* pRet = m_iterator->first;",
                            "\tm_iterator++;",
                            "\treturn pRet;",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "13": "#include <esp_gatts_api.h>   // ESP32 BLE",
                "41": "} // getByUUID",
                "51": "} // getByHandle",
                "62": "} // setByUUID",
                "74": "} // setByUUID",
                "85": "} // setByHandle",
                "104": "} // toString",
                "117": "\t// Invoke the handler for every descriptor we have.",
                "121": "} // handleGATTServerEvent",
                "134": "} // getFirst",
                "146": "} // getNext"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEDevice.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 650,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645,
                            646,
                            647,
                            648,
                            649,
                            650
                        ],
                        "comments": [
                            "#include <esp_bt.h>            // ESP32 BLE",
                            "#include <esp_bt_device.h>     // ESP32 BLE",
                            "#include <esp_bt_main.h>       // ESP32 BLE",
                            "#include <esp_gap_ble_api.h>   // ESP32 BLE",
                            "#include <esp_gatts_api.h>     // ESP32 BLE",
                            "#include <esp_gattc_api.h>     // ESP32 BLE",
                            "#include <esp_gatt_common_api.h>// ESP32 BLE",
                            "#include <esp_err.h>           // ESP32 ESP-IDF",
                            "#include <map>                 // Part of C++ Standard library",
                            "#include <sstream>             // Part of C++ Standard library",
                            "#include <iomanip>             // Part of C++ Standard library",
                            "uint16_t   BLEDevice::m_localMTU = 23;  // not sure if this variable is useful",
                            "#ifndef CONFIG_GATTC_ENABLE  // Check that BLE GATTC is enabled in make menuconfig",
                            "#endif  // CONFIG_GATTC_ENABLE",
                            "} // createClient",
                            "#ifndef CONFIG_GATTS_ENABLE  // Check that BLE GATTS is enabled in make menuconfig",
                            "#endif // CONFIG_GATTS_ENABLE",
                            "} // createServer",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "\t\t} // ESP_GATTS_CONNECT_EVT",
                            "\t} // switch",
                            "} // gattServerEventHandler",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "\t\t} // ESP_GATTS_CONNECT_EVT",
                            "\t} // switch",
                            "} // gattClientEventHandler",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "\t\t\t// esp_log_buffer_hex(LOG_TAG, m_remote_bda, sizeof(m_remote_bda));",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif\t// CONFIG_BLE_SMP_ENABLE",
                            "\t} // switch",
                            "} // gapEventHandler",
                            "} // getAddress",
                            "} // getScan",
                            "} // getValue",
                            "\t\tinitialized = true; // Set the initialization flag to ensure we are only initialized once.",
                            "#ifdef CONFIG_GATTC_ENABLE   // Check that BLE client is configured in make menuconfig",
                            "#endif   // CONFIG_GATTC_ENABLE",
                            "#ifdef CONFIG_GATTS_ENABLE  // Check that BLE server is configured in make menuconfig",
                            "#endif   // CONFIG_GATTS_ENABLE",
                            "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                            "#endif // CONFIG_BLE_SMP_ENABLE",
                            "\tvTaskDelay(200 / portTICK_PERIOD_MS); // Delay for 200 msecs as a workaround to an apparent Arduino environment issue.",
                            "} // init",
                            "} // setPower",
                            "} // setValue",
                            "} // toString",
                            "\tesp_err_t errRc = esp_ble_gap_update_whitelist(true, *address.getNative());  // True to add an entry.",
                            "} // whiteListAdd",
                            "\tesp_err_t errRc = esp_ble_gap_update_whitelist(false, *address.getNative());  // False to remove an entry.",
                            "} // whiteListRemove",
                            "} // startAdvertising",
                            "        esp_bt_controller_mem_release(ESP_BT_MODE_BTDM);  // <-- require tests because we released classic BT memory and this can cause crash (most likely not, esp-idf takes care of it)",
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            "",
                            "#include \"BLEDevice.h\"",
                            "#include \"BLEClient.h\"",
                            "#include \"BLEUtils.h\"",
                            "#include \"GeneralUtils.h\"",
                            "",
                            "#if defined(ARDUINO_ARCH_ESP32)",
                            "#include \"esp32-hal-bt.h\"",
                            "#endif",
                            "",
                            "#if defined(CONFIG_ARDUHAL_ESP_LOG)",
                            "#include \"esp32-hal-log.h\"",
                            "#define LOG_TAG \"\"",
                            "#else",
                            "#include \"esp_log.h\"",
                            "static const char* LOG_TAG = \"BLEDevice\";",
                            "#endif",
                            "",
                            "",
                            "/**",
                            " * Singletons for the BLEDevice.",
                            " */",
                            "BLEServer* BLEDevice::m_pServer = nullptr;",
                            "BLEScan*   BLEDevice::m_pScan   = nullptr;",
                            "BLEClient* BLEDevice::m_pClient = nullptr;",
                            "bool       initialized          = false;",
                            "esp_ble_sec_act_t BLEDevice::m_securityLevel = (esp_ble_sec_act_t)0;",
                            "BLESecurityCallbacks* BLEDevice::m_securityCallbacks = nullptr;",
                            "BLEAdvertising* BLEDevice::m_bleAdvertising = nullptr;",
                            "uint16_t BLEDevice::m_appId = 0;",
                            "std::map<uint16_t, conn_status_t> BLEDevice::m_connectedClientsMap;",
                            "gap_event_handler BLEDevice::m_customGapHandler = nullptr;",
                            "gattc_event_handler BLEDevice::m_customGattcHandler = nullptr;",
                            "gatts_event_handler BLEDevice::m_customGattsHandler = nullptr;",
                            "",
                            "/**",
                            " * @brief Create a new instance of a client.",
                            " * @return A new instance of the client.",
                            " */",
                            "/* STATIC */ BLEClient* BLEDevice::createClient() {",
                            "\tESP_LOGD(LOG_TAG, \">> createClient\");",
                            "\tESP_LOGE(LOG_TAG, \"BLE GATTC is not enabled - CONFIG_GATTC_ENABLE not defined\");",
                            "\tabort();",
                            "\tm_pClient = new BLEClient();",
                            "\tESP_LOGD(LOG_TAG, \"<< createClient\");",
                            "\treturn m_pClient;",
                            "",
                            "",
                            "/**",
                            " * @brief Create a new instance of a server.",
                            " * @return A new instance of the server.",
                            " */",
                            "/* STATIC */ BLEServer* BLEDevice::createServer() {",
                            "\tESP_LOGD(LOG_TAG, \">> createServer\");",
                            "\tESP_LOGE(LOG_TAG, \"BLE GATTS is not enabled - CONFIG_GATTS_ENABLE not defined\");",
                            "\tabort();",
                            "\tm_pServer = new BLEServer();",
                            "\tm_pServer->createApp(m_appId++);",
                            "\tESP_LOGD(LOG_TAG, \"<< createServer\");",
                            "\treturn m_pServer;",
                            "",
                            "",
                            "/**",
                            " * @brief Handle GATT server events.",
                            " *",
                            " * @param [in] event The event that has been newly received.",
                            " * @param [in] gatts_if The connection to the GATT interface.",
                            " * @param [in] param Parameters for the event.",
                            " */",
                            "/* STATIC */ void BLEDevice::gattServerEventHandler(",
                            "   esp_gatts_cb_event_t      event,",
                            "   esp_gatt_if_t             gatts_if,",
                            "   esp_ble_gatts_cb_param_t* param",
                            ") {",
                            "\tESP_LOGD(LOG_TAG, \"gattServerEventHandler [esp_gatt_if: %d] ... %s\",",
                            "\t\tgatts_if,",
                            "\t\tBLEUtils::gattServerEventTypeToString(event).c_str());",
                            "",
                            "\tBLEUtils::dumpGattServerEvent(event, gatts_if, param);",
                            "",
                            "\tswitch (event) {",
                            "\t\tcase ESP_GATTS_CONNECT_EVT: {",
                            "\t\t\tif(BLEDevice::m_securityLevel){",
                            "\t\t\t\tesp_ble_set_encryption(param->connect.remote_bda, BLEDevice::m_securityLevel);",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\tdefault: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "",
                            "\tif (BLEDevice::m_pServer != nullptr) {",
                            "\t\tBLEDevice::m_pServer->handleGATTServerEvent(event, gatts_if, param);",
                            "\t}",
                            "",
                            "\tif(m_customGattsHandler != nullptr) {",
                            "\t\tm_customGattsHandler(event, gatts_if, param);",
                            "\t}",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Handle GATT client events.",
                            " *",
                            " * Handler for the GATT client events.",
                            " *",
                            " * @param [in] event",
                            " * @param [in] gattc_if",
                            " * @param [in] param",
                            " */",
                            "/* STATIC */ void BLEDevice::gattClientEventHandler(",
                            "\tesp_gattc_cb_event_t      event,",
                            "\tesp_gatt_if_t             gattc_if,",
                            "\tesp_ble_gattc_cb_param_t* param) {",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"gattClientEventHandler [esp_gatt_if: %d] ... %s\",",
                            "\t\tgattc_if, BLEUtils::gattClientEventTypeToString(event).c_str());",
                            "\tBLEUtils::dumpGattClientEvent(event, gattc_if, param);",
                            "",
                            "\tswitch(event) {",
                            "\t\tcase ESP_GATTC_CONNECT_EVT: {",
                            "\t\t\tif(BLEDevice::m_securityLevel){",
                            "\t\t\t\tesp_ble_set_encryption(param->connect.remote_bda, BLEDevice::m_securityLevel);",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "\tfor(auto &myPair : BLEDevice::getPeerDevices(true)) {",
                            "\t\tconn_status_t conn_status = (conn_status_t)myPair.second;",
                            "\t\tif(((BLEClient*)conn_status.peer_device)->getGattcIf() == gattc_if || ((BLEClient*)conn_status.peer_device)->getGattcIf() == ESP_GATT_IF_NONE || gattc_if == ESP_GATT_IF_NONE){",
                            "\t\t\t((BLEClient*)conn_status.peer_device)->gattClientEventHandler(event, gattc_if, param);",
                            "\t\t}",
                            "\t}",
                            "",
                            "\tif(m_customGattcHandler != nullptr) {",
                            "\t\tm_customGattcHandler(event, gattc_if, param);",
                            "\t}",
                            "",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Handle GAP events.",
                            " */",
                            "/* STATIC */ void BLEDevice::gapEventHandler(",
                            "\tesp_gap_ble_cb_event_t event,",
                            "\tesp_ble_gap_cb_param_t *param) {",
                            "",
                            "\tBLEUtils::dumpGapEvent(event, param);",
                            "",
                            "\tswitch(event) {",
                            "",
                            "\t\t case ESP_GAP_BLE_OOB_REQ_EVT:                                /* OOB request event */",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_OOB_REQ_EVT\");",
                            "\t\t\t break;",
                            "\t\t case ESP_GAP_BLE_LOCAL_IR_EVT:                               /* BLE local IR event */",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_LOCAL_IR_EVT\");",
                            "\t\t\t break;",
                            "\t\t case ESP_GAP_BLE_LOCAL_ER_EVT:                               /* BLE local ER event */",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_LOCAL_ER_EVT\");",
                            "\t\t\t break;",
                            "\t\t case ESP_GAP_BLE_NC_REQ_EVT:\t\t\t\t\t\t\t\t/*  NUMERIC CONFIRMATION  */",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_NC_REQ_EVT\");",
                            "\t\t\tif(BLEDevice::m_securityCallbacks != nullptr){",
                            "\t\t\t \t esp_ble_confirm_reply(param->ble_security.ble_req.bd_addr, BLEDevice::m_securityCallbacks->onConfirmPIN(param->ble_security.key_notif.passkey));",
                            "\t\t\t}",
                            "\t\t\t break;",
                            "\t\t case ESP_GAP_BLE_PASSKEY_REQ_EVT:                           /* passkey request event */",
                            "\t\t\tESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_PASSKEY_REQ_EVT: \");",
                            "\t\t\tif(BLEDevice::m_securityCallbacks != nullptr){",
                            "\t\t\t\tesp_ble_passkey_reply(param->ble_security.ble_req.bd_addr, true, BLEDevice::m_securityCallbacks->onPassKeyRequest());",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "\t\t\t/*",
                            "\t\t\t * TODO should we add white/black list comparison?",
                            "\t\t\t */",
                            "\t\t case ESP_GAP_BLE_SEC_REQ_EVT:",
                            "\t\t\t /* send the positive(true) security response to the peer device to accept the security request.",
                            "\t\t\t If not accept the security request, should sent the security response with negative(false) accept value*/",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_SEC_REQ_EVT\");",
                            "\t\t\tif(BLEDevice::m_securityCallbacks!=nullptr){",
                            "\t\t\t\tesp_ble_gap_security_rsp(param->ble_security.ble_req.bd_addr, BLEDevice::m_securityCallbacks->onSecurityRequest());",
                            "\t\t\t}",
                            "\t\t\telse{",
                            "\t\t\t\tesp_ble_gap_security_rsp(param->ble_security.ble_req.bd_addr, true);",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "\t\t\t /*",
                            "\t\t\t  *",
                            "\t\t\t  */",
                            "\t\t case ESP_GAP_BLE_PASSKEY_NOTIF_EVT:  //the app will receive this evt when the IO  has Output capability and the peer device IO has Input capability.",
                            "\t\t\t //display the passkey number to the user to input it in the peer deivce within 30 seconds",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_PASSKEY_NOTIF_EVT\");",
                            "\t\t\tESP_LOGI(LOG_TAG, \"passKey = %d\", param->ble_security.key_notif.passkey);",
                            "\t\t\tif(BLEDevice::m_securityCallbacks!=nullptr){",
                            "\t\t\t\tBLEDevice::m_securityCallbacks->onPassKeyNotify(param->ble_security.key_notif.passkey);",
                            "\t\t\t}",
                            "\t\t\t break;",
                            "\t\t case ESP_GAP_BLE_KEY_EVT:",
                            "\t\t\t //shows the ble key type info share with peer device to the user.",
                            "\t\t\t ESP_LOGD(LOG_TAG, \"ESP_GAP_BLE_KEY_EVT\");",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"key type = %s\", BLESecurity::esp_key_type_to_str(param->ble_security.ble_key.key_type));",
                            "\t\t\t break;",
                            "\t\t case ESP_GAP_BLE_AUTH_CMPL_EVT:",
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_AUTH_CMPL_EVT\");",
                            "\t\t\t if(BLEDevice::m_securityCallbacks != nullptr){",
                            "\t\t\t\t BLEDevice::m_securityCallbacks->onAuthenticationComplete(param->ble_security.auth_cmpl);",
                            "\t\t\t }",
                            "\t\t\t break;",
                            "\t\tdefault: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\tif (BLEDevice::m_pClient != nullptr) {",
                            "\t\tBLEDevice::m_pClient->handleGAPEvent(event, param);",
                            "\t}",
                            "",
                            "\tif (BLEDevice::m_pScan != nullptr) {",
                            "\t\tBLEDevice::getScan()->handleGAPEvent(event, param);",
                            "\t}",
                            "",
                            "\tif(m_bleAdvertising != nullptr) {",
                            "\t\tBLEDevice::getAdvertising()->handleGAPEvent(event, param);",
                            "\t}",
                            "",
                            "\tif(m_customGapHandler != nullptr) {",
                            "\t\tBLEDevice::m_customGapHandler(event, param);",
                            "\t}",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Get the BLE device address.",
                            " * @return The BLE device address.",
                            " */",
                            "/* STATIC*/ BLEAddress BLEDevice::getAddress() {",
                            "\tconst uint8_t* bdAddr = esp_bt_dev_get_address();",
                            "\tesp_bd_addr_t addr;",
                            "\tmemcpy(addr, bdAddr, sizeof(addr));",
                            "\treturn BLEAddress(addr);",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve the Scan object that we use for scanning.",
                            " * @return The scanning object reference.  This is a singleton object.  The caller should not",
                            " * try and release/delete it.",
                            " */",
                            "/* STATIC */ BLEScan* BLEDevice::getScan() {",
                            "\t//ESP_LOGD(LOG_TAG, \">> getScan\");",
                            "\tif (m_pScan == nullptr) {",
                            "\t\tm_pScan = new BLEScan();",
                            "\t\t//ESP_LOGD(LOG_TAG, \" - creating a new scan object\");",
                            "\t}",
                            "\t//ESP_LOGD(LOG_TAG, \"<< getScan: Returning object at 0x%x\", (uint32_t)m_pScan);",
                            "\treturn m_pScan;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the value of a characteristic of a service on a remote device.",
                            " * @param [in] bdAddress",
                            " * @param [in] serviceUUID",
                            " * @param [in] characteristicUUID",
                            " */",
                            "/* STATIC */ std::string BLEDevice::getValue(BLEAddress bdAddress, BLEUUID serviceUUID, BLEUUID characteristicUUID) {",
                            "\tESP_LOGD(LOG_TAG, \">> getValue: bdAddress: %s, serviceUUID: %s, characteristicUUID: %s\", bdAddress.toString().c_str(), serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());",
                            "\tBLEClient* pClient = createClient();",
                            "\tpClient->connect(bdAddress);",
                            "\tstd::string ret = pClient->getValue(serviceUUID, characteristicUUID);",
                            "\tpClient->disconnect();",
                            "\tESP_LOGD(LOG_TAG, \"<< getValue\");",
                            "\treturn ret;",
                            "",
                            "",
                            "/**",
                            " * @brief Initialize the %BLE environment.",
                            " * @param deviceName The device name of the device.",
                            " */",
                            "/* STATIC */ void BLEDevice::init(std::string deviceName) {",
                            "\tif(!initialized){",
                            "",
                            "\t\tesp_err_t errRc = ESP_OK;",
                            "#ifdef ARDUINO_ARCH_ESP32",
                            "\t\tif (!btStart()) {",
                            "\t\t\terrRc = ESP_FAIL;",
                            "\t\t\treturn;",
                            "\t\t}",
                            "#else",
                            "\t\terrRc = ::nvs_flash_init();",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"nvs_flash_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "",
                            "#ifndef CLASSIC_BT_ENABLED",
                            "\t\tesp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT);",
                            "#endif",
                            "\t\tesp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();",
                            "\t\terrRc = esp_bt_controller_init(&bt_cfg);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_bt_controller_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "",
                            "#ifndef CLASSIC_BT_ENABLED",
                            "\t\terrRc = esp_bt_controller_enable(ESP_BT_MODE_BLE);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "#else",
                            "\t\terrRc = esp_bt_controller_enable(ESP_BT_MODE_BTDM);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "#endif",
                            "#endif",
                            "",
                            "\t\tesp_bluedroid_status_t bt_state = esp_bluedroid_get_status();",
                            "\t\tif (bt_state == ESP_BLUEDROID_STATUS_UNINITIALIZED) {",
                            "\t\t\terrRc = esp_bluedroid_init();",
                            "\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"esp_bluedroid_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t\treturn;",
                            "\t\t\t}",
                            "\t\t}",
                            "",
                            "\t\tif (bt_state != ESP_BLUEDROID_STATUS_ENABLED) {",
                            "\t\t\terrRc = esp_bluedroid_enable();",
                            "\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"esp_bluedroid_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t\treturn;",
                            "\t\t\t}",
                            "\t\t}",
                            "",
                            "\t\terrRc = esp_ble_gap_register_callback(BLEDevice::gapEventHandler);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "",
                            "\t\terrRc = esp_ble_gattc_register_callback(BLEDevice::gattClientEventHandler);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "",
                            "\t\terrRc = esp_ble_gatts_register_callback(BLEDevice::gattServerEventHandler);",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t}",
                            "",
                            "\t\terrRc = ::esp_ble_gap_set_device_name(deviceName.c_str());",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_set_device_name: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t};",
                            "",
                            "\t\tesp_ble_io_cap_t iocap = ESP_IO_CAP_NONE;",
                            "\t\terrRc = ::esp_ble_gap_set_security_param(ESP_BLE_SM_IOCAP_MODE, &iocap, sizeof(uint8_t));",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_set_security_param: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\treturn;",
                            "\t\t};",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the transmission power.",
                            " * The power level can be one of:",
                            " * * ESP_PWR_LVL_N14",
                            " * * ESP_PWR_LVL_N11",
                            " * * ESP_PWR_LVL_N8",
                            " * * ESP_PWR_LVL_N5",
                            " * * ESP_PWR_LVL_N2",
                            " * * ESP_PWR_LVL_P1",
                            " * * ESP_PWR_LVL_P4",
                            " * * ESP_PWR_LVL_P7",
                            " * @param [in] powerLevel.",
                            " */",
                            "/* STATIC */ void BLEDevice::setPower(esp_power_level_t powerLevel) {",
                            "\tESP_LOGD(LOG_TAG, \">> setPower: %d\", powerLevel);",
                            "\tesp_err_t errRc = ::esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_DEFAULT, powerLevel);",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_tx_power_set: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t};",
                            "\tESP_LOGD(LOG_TAG, \"<< setPower\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the value of a characteristic of a service on a remote device.",
                            " * @param [in] bdAddress",
                            " * @param [in] serviceUUID",
                            " * @param [in] characteristicUUID",
                            " */",
                            "/* STATIC */ void BLEDevice::setValue(BLEAddress bdAddress, BLEUUID serviceUUID, BLEUUID characteristicUUID, std::string value) {",
                            "\tESP_LOGD(LOG_TAG, \">> setValue: bdAddress: %s, serviceUUID: %s, characteristicUUID: %s\", bdAddress.toString().c_str(), serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());",
                            "\tBLEClient* pClient = createClient();",
                            "\tpClient->connect(bdAddress);",
                            "\tpClient->setValue(serviceUUID, characteristicUUID, value);",
                            "\tpClient->disconnect();",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of the nature of this device.",
                            " * @return A string representation of the nature of this device.",
                            " */",
                            "/* STATIC */ std::string BLEDevice::toString() {",
                            "\tstd::ostringstream oss;",
                            "\toss << \"BD Address: \" << getAddress().toString();",
                            "\treturn oss.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Add an entry to the BLE white list.",
                            " * @param [in] address The address to add to the white list.",
                            " */",
                            "void BLEDevice::whiteListAdd(BLEAddress address) {",
                            "\tESP_LOGD(LOG_TAG, \">> whiteListAdd: %s\", address.toString().c_str());",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_update_whitelist: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< whiteListAdd\");",
                            "",
                            "",
                            "/**",
                            " * @brief Remove an entry from the BLE white list.",
                            " * @param [in] address The address to remove from the white list.",
                            " */",
                            "void BLEDevice::whiteListRemove(BLEAddress address) {",
                            "\tESP_LOGD(LOG_TAG, \">> whiteListRemove: %s\", address.toString().c_str());",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_update_whitelist: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< whiteListRemove\");",
                            "",
                            "/*",
                            " * @brief Set encryption level that will be negotiated with peer device durng connection",
                            " * @param [in] level Requested encryption level",
                            " */",
                            "void BLEDevice::setEncryptionLevel(esp_ble_sec_act_t level) {",
                            "\tBLEDevice::m_securityLevel = level;",
                            "}",
                            "",
                            "/*",
                            " * @brief Set callbacks that will be used to handle encryption negotiation events and authentication events",
                            " * @param [in] cllbacks Pointer to BLESecurityCallbacks class callback",
                            " */",
                            "void BLEDevice::setSecurityCallbacks(BLESecurityCallbacks* callbacks) {",
                            "\tBLEDevice::m_securityCallbacks = callbacks;",
                            "}",
                            "",
                            "/*",
                            " * @brief Setup local mtu that will be used to negotiate mtu during request from client peer",
                            " * @param [in] mtu Value to set local mtu, should be larger than 23 and lower or equal to 517",
                            " */",
                            "esp_err_t BLEDevice::setMTU(uint16_t mtu) {",
                            "\tESP_LOGD(LOG_TAG, \">> setLocalMTU: %d\", mtu);",
                            "\tesp_err_t err = esp_ble_gatt_set_local_mtu(mtu);",
                            "\tif (err == ESP_OK) {",
                            "\t\tm_localMTU = mtu;",
                            "\t} else {",
                            "\t\tESP_LOGE(LOG_TAG, \"can't set local mtu value: %d\", mtu);",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< setLocalMTU\");",
                            "\treturn err;",
                            "}",
                            "",
                            "/*",
                            " * @brief Get local MTU value set during mtu request or default value",
                            " */",
                            "uint16_t BLEDevice::getMTU() {",
                            "\treturn m_localMTU;",
                            "}",
                            "",
                            "bool BLEDevice::getInitialized() {",
                            "\treturn initialized;",
                            "}",
                            "",
                            "BLEAdvertising* BLEDevice::getAdvertising() {",
                            "\tif(m_bleAdvertising == nullptr) {",
                            "\t\tm_bleAdvertising = new BLEAdvertising();",
                            "\t\tESP_LOGI(LOG_TAG, \"create advertising\");",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"get advertising\");",
                            "\treturn m_bleAdvertising;",
                            "}",
                            "",
                            "void BLEDevice::startAdvertising() {",
                            "\tESP_LOGD(LOG_TAG, \">> startAdvertising\");",
                            "\tgetAdvertising()->start();",
                            "\tESP_LOGD(LOG_TAG, \"<< startAdvertising\");",
                            "",
                            "/* multi connect support */",
                            "/* requires a little more work */",
                            "std::map<uint16_t, conn_status_t> BLEDevice::getPeerDevices(bool _client) {",
                            "\treturn m_connectedClientsMap;",
                            "}",
                            "",
                            "BLEClient* BLEDevice::getClientByGattIf(uint16_t conn_id) {",
                            "\treturn (BLEClient*)m_connectedClientsMap.find(conn_id)->second.peer_device;",
                            "}",
                            "",
                            "void BLEDevice::updatePeerDevice(void* peer, bool _client, uint16_t conn_id) {",
                            "\tESP_LOGD(LOG_TAG, \"update conn_id: %d, GATT role: %s\", conn_id, _client? \"client\":\"server\");",
                            "\tstd::map<uint16_t, conn_status_t>::iterator it = m_connectedClientsMap.find(ESP_GATT_IF_NONE);",
                            "\tif (it != m_connectedClientsMap.end()) {",
                            "\t\tstd::swap(m_connectedClientsMap[conn_id], it->second);",
                            "\t\tm_connectedClientsMap.erase(it);",
                            "\t}else{",
                            "\t\tit = m_connectedClientsMap.find(conn_id);",
                            "\t\tif (it != m_connectedClientsMap.end()) {",
                            "\t\t\tconn_status_t _st = it->second;",
                            "\t\t\t_st.peer_device = peer;",
                            "\t\t\tstd::swap(m_connectedClientsMap[conn_id], _st);",
                            "\t\t}",
                            "\t}",
                            "}",
                            "",
                            "void BLEDevice::addPeerDevice(void* peer, bool _client, uint16_t conn_id) {",
                            "\tESP_LOGI(LOG_TAG, \"add conn_id: %d, GATT role: %s\", conn_id, _client? \"client\":\"server\");",
                            "\tconn_status_t status = {",
                            "\t\t.peer_device = peer,",
                            "\t\t.connected = true,",
                            "\t\t.mtu = 23",
                            "\t};",
                            "",
                            "\tm_connectedClientsMap.insert(std::pair<uint16_t, conn_status_t>(conn_id, status));",
                            "}",
                            "",
                            "void BLEDevice::removePeerDevice(uint16_t conn_id, bool _client) {",
                            "\tESP_LOGI(LOG_TAG, \"remove: %d, GATT role %s\", conn_id, _client?\"client\":\"server\");",
                            "\tif(m_connectedClientsMap.find(conn_id) != m_connectedClientsMap.end())",
                            "\t\tm_connectedClientsMap.erase(conn_id);",
                            "}",
                            "",
                            "/* multi connect support */",
                            "",
                            "/**",
                            " * @brief de-Initialize the %BLE environment.",
                            " * @param release_memory release the internal BT stack memory",
                            " */",
                            "/* STATIC */ void BLEDevice::deinit(bool release_memory) {",
                            "    if (!initialized) return;",
                            "",
                            "    esp_bluedroid_disable();",
                            "    esp_bluedroid_deinit();",
                            "    esp_bt_controller_disable();",
                            "    esp_bt_controller_deinit();",
                            "#ifndef ARDUINO_ARCH_ESP32",
                            "    if (release_memory) {",
                            "    } else {",
                            "        initialized = false;",
                            "    }",
                            "#endif",
                            "}",
                            "",
                            "void BLEDevice::setCustomGapHandler(gap_event_handler handler) {",
                            "\tm_customGapHandler = handler;",
                            "}",
                            "",
                            "void BLEDevice::setCustomGattcHandler(gattc_event_handler handler) {",
                            "\tm_customGattcHandler = handler;",
                            "}",
                            "",
                            "void BLEDevice::setCustomGattsHandler(gatts_event_handler handler) {",
                            "\tm_customGattsHandler = handler;",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "14": "#include <esp_bt.h>            // ESP32 BLE",
                "15": "#include <esp_bt_device.h>     // ESP32 BLE",
                "16": "#include <esp_bt_main.h>       // ESP32 BLE",
                "17": "#include <esp_gap_ble_api.h>   // ESP32 BLE",
                "18": "#include <esp_gatts_api.h>     // ESP32 BLE",
                "19": "#include <esp_gattc_api.h>     // ESP32 BLE",
                "20": "#include <esp_gatt_common_api.h>// ESP32 BLE",
                "21": "#include <esp_err.h>           // ESP32 ESP-IDF",
                "22": "#include <map>                 // Part of C++ Standard library",
                "23": "#include <sstream>             // Part of C++ Standard library",
                "24": "#include <iomanip>             // Part of C++ Standard library",
                "53": "uint16_t   BLEDevice::m_localMTU = 23;  // not sure if this variable is useful",
                "67": "#ifndef CONFIG_GATTC_ENABLE  // Check that BLE GATTC is enabled in make menuconfig",
                "70": "#endif  // CONFIG_GATTC_ENABLE",
                "74": "} // createClient",
                "83": "#ifndef CONFIG_GATTS_ENABLE  // Check that BLE GATTS is enabled in make menuconfig",
                "86": "#endif // CONFIG_GATTS_ENABLE",
                "91": "} // createServer",
                "114": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "118": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "120": "\t\t} // ESP_GATTS_CONNECT_EVT",
                "125": "\t} // switch",
                "136": "} // gattServerEventHandler",
                "159": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "163": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "165": "\t\t} // ESP_GATTS_CONNECT_EVT",
                "169": "\t} // switch",
                "182": "} // gattClientEventHandler",
                "207": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "211": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "215": "\t\t\t// esp_log_buffer_hex(LOG_TAG, m_remote_bda, sizeof(m_remote_bda));",
                "216": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "220": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "229": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "236": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "244": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "249": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "254": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "256": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "260": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "264": "#endif\t// CONFIG_BLE_SMP_ENABLE",
                "269": "\t} // switch",
                "287": "} // gapEventHandler",
                "299": "} // getAddress",
                "315": "} // getScan",
                "332": "} // getValue",
                "341": "\t\tinitialized = true; // Set the initialization flag to ensure we are only initialized once.",
                "404": "#ifdef CONFIG_GATTC_ENABLE   // Check that BLE client is configured in make menuconfig",
                "410": "#endif   // CONFIG_GATTC_ENABLE",
                "412": "#ifdef CONFIG_GATTS_ENABLE  // Check that BLE server is configured in make menuconfig",
                "418": "#endif   // CONFIG_GATTS_ENABLE",
                "426": "#ifdef CONFIG_BLE_SMP_ENABLE   // Check that BLE SMP (security) is configured in make menuconfig",
                "433": "#endif // CONFIG_BLE_SMP_ENABLE",
                "435": "\tvTaskDelay(200 / portTICK_PERIOD_MS); // Delay for 200 msecs as a workaround to an apparent Arduino environment issue.",
                "436": "} // init",
                "459": "} // setPower",
                "474": "} // setValue",
                "485": "} // toString",
                "494": "\tesp_err_t errRc = esp_ble_gap_update_whitelist(true, *address.getNative());  // True to add an entry.",
                "499": "} // whiteListAdd",
                "508": "\tesp_err_t errRc = esp_ble_gap_update_whitelist(false, *address.getNative());  // False to remove an entry.",
                "513": "} // whiteListRemove",
                "571": "} // startAdvertising",
                "631": "        esp_bt_controller_mem_release(ESP_BT_MODE_BTDM);  // <-- require tests because we released classic BT memory and this can cause crash (most likely not, esp-idf takes care of it)",
                "650": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d7ea7b80a7badbe30e6fb6f33f71375e0b133c",
            "timestamp": "2019-04-15T17:26:35+02:00",
            "author": "Bascy",
            "commit_message": "Refactored use of LOG_X(LOG_TAG, ...) to log_x(...) (#2672)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)\r\n\r\n* Change logging from Error to Verbose when not found and default available\r\n\r\n* Move Enter and Exit logging to Verbose Level\r\n\r\n* Refactored LOG_X() into log_x()",
            "additions": 57,
            "deletions": 57,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            215
                        ],
                        "comments": [
                            "\t\t\t// esp_log_buffer_hex(m_remote_bda, sizeof(m_remote_bda));"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            228
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t log_i(\"ESP_GAP_BLE_SEC_REQ_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            243
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t log_i(\"ESP_GAP_BLE_PASSKEY_NOTIF_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            245
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_i(\"passKey = %d\", param->ble_security.key_notif.passkey);"
                        ]
                    },
                    {
                        "line_numbers": [
                            253
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t log_d(\"ESP_GAP_BLE_KEY_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            255
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t log_i(\"key type = %s\", BLESecurity::esp_key_type_to_str(param->ble_security.ble_key.key_type));"
                        ]
                    },
                    {
                        "line_numbers": [
                            259
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t log_i(\"ESP_GAP_BLE_AUTH_CMPL_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            308
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_v(\">> getScan\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            311
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t//log_d(\" - creating a new scan object\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            313
                        ],
                        "comments": [],
                        "lines": [
                            "\t//log_v(\"<< getScan: Returning object at 0x%x\", (uint32_t)m_pScan);"
                        ]
                    },
                    {
                        "line_numbers": [
                            325
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> getValue: bdAddress: %s, serviceUUID: %s, characteristicUUID: %s\", bdAddress.toString().c_str(), serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            330
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< getValue\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            352
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"nvs_flash_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            362
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_bt_controller_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            369
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            375
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            385
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tlog_e(\"esp_bluedroid_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            393
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tlog_e(\"esp_bluedroid_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            400
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_ble_gap_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            407
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_ble_gattc_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            415
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_ble_gatts_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            422
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_ble_gap_set_device_name: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            430
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tlog_e(\"esp_ble_gap_set_security_param: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            453
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> setPower: %d\", powerLevel);"
                        ]
                    },
                    {
                        "line_numbers": [
                            456
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"esp_ble_tx_power_set: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            458
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< setPower\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            469
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> setValue: bdAddress: %s, serviceUUID: %s, characteristicUUID: %s\", bdAddress.toString().c_str(), serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            493
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> whiteListAdd: %s\", address.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            496
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"esp_ble_gap_update_whitelist: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            498
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< whiteListAdd\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            507
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> whiteListRemove: %s\", address.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            510
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"esp_ble_gap_update_whitelist: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            512
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< whiteListRemove\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            536
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> setLocalMTU: %d\", mtu);"
                        ]
                    },
                    {
                        "line_numbers": [
                            541
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"can't set local mtu value: %d\", mtu);"
                        ]
                    },
                    {
                        "line_numbers": [
                            543
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< setLocalMTU\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            561
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_i(\"create advertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            563
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_d(\"get advertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            568
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> startAdvertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            570
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< startAdvertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            584
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_d(\"update conn_id: %d, GATT role: %s\", conn_id, _client? \"client\":\"server\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            600
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_i(\"add conn_id: %d, GATT role: %s\", conn_id, _client? \"client\":\"server\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            611
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_i(\"remove: %d, GATT role %s\", conn_id, _client?\"client\":\"server\");"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            215
                        ],
                        "comments": [
                            "\t\t\t// esp_log_buffer_hex(LOG_TAG, m_remote_bda, sizeof(m_remote_bda));"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            228
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_SEC_REQ_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            243
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_PASSKEY_NOTIF_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            245
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGI(LOG_TAG, \"passKey = %d\", param->ble_security.key_notif.passkey);"
                        ]
                    },
                    {
                        "line_numbers": [
                            253
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t ESP_LOGD(LOG_TAG, \"ESP_GAP_BLE_KEY_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            255
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t ESP_LOGI(LOG_TAG, \"key type = %s\", BLESecurity::esp_key_type_to_str(param->ble_security.ble_key.key_type));"
                        ]
                    },
                    {
                        "line_numbers": [
                            259
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t ESP_LOGI(LOG_TAG, \"ESP_GAP_BLE_AUTH_CMPL_EVT\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            308
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \">> getScan\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            311
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t//ESP_LOGD(LOG_TAG, \" - creating a new scan object\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            313
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \"<< getScan: Returning object at 0x%x\", (uint32_t)m_pScan);"
                        ]
                    },
                    {
                        "line_numbers": [
                            325
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> getValue: bdAddress: %s, serviceUUID: %s, characteristicUUID: %s\", bdAddress.toString().c_str(), serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            330
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< getValue\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            352
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"nvs_flash_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            362
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_bt_controller_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            369
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            375
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            385
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"esp_bluedroid_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            393
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"esp_bluedroid_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            400
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            407
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            415
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            422
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_set_device_name: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            430
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_set_security_param: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            453
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setPower: %d\", powerLevel);"
                        ]
                    },
                    {
                        "line_numbers": [
                            456
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_tx_power_set: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            458
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< setPower\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            469
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setValue: bdAddress: %s, serviceUUID: %s, characteristicUUID: %s\", bdAddress.toString().c_str(), serviceUUID.toString().c_str(), characteristicUUID.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            493
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> whiteListAdd: %s\", address.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            496
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_update_whitelist: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            498
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< whiteListAdd\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            507
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> whiteListRemove: %s\", address.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            510
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_update_whitelist: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            512
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< whiteListRemove\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            536
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setLocalMTU: %d\", mtu);"
                        ]
                    },
                    {
                        "line_numbers": [
                            541
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"can't set local mtu value: %d\", mtu);"
                        ]
                    },
                    {
                        "line_numbers": [
                            543
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< setLocalMTU\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            561
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGI(LOG_TAG, \"create advertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            563
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"get advertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            568
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> startAdvertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            570
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< startAdvertising\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            584
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"update conn_id: %d, GATT role: %s\", conn_id, _client? \"client\":\"server\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            600
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGI(LOG_TAG, \"add conn_id: %d, GATT role: %s\", conn_id, _client? \"client\":\"server\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            611
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGI(LOG_TAG, \"remove: %d, GATT role %s\", conn_id, _client?\"client\":\"server\");"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "215": "\t\t\t// esp_log_buffer_hex(m_remote_bda, sizeof(m_remote_bda));"
            },
            "comment_deleted_diff": {
                "215": "\t\t\t// esp_log_buffer_hex(LOG_TAG, m_remote_bda, sizeof(m_remote_bda));"
            },
            "comment_modified_diff": {
                "215": "\t\t\t// esp_log_buffer_hex(LOG_TAG, m_remote_bda, sizeof(m_remote_bda));"
            }
        },
        {
            "commit": "ac9d04a400b8b514f5ac42743571dcd936d036d7",
            "timestamp": "2020-01-20T16:31:12+02:00",
            "author": "Robert Alfaro",
            "commit_message": "Add BLEDevice::stopAdvertising() helper method to compliment startAdvertising(). (#3624)",
            "additions": 6,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            585,
                            586
                        ],
                        "comments": [
                            "} // stopAdvertising"
                        ],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "585": "} // stopAdvertising"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEDevice.h": [],
    "BLEEddystoneTLM.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 150,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150
                        ],
                        "comments": [
                            "\tm_eddystoneData.volt = 3300; // 3300mV = 3.3V",
                            "} // BLEEddystoneTLM",
                            "} // getData",
                            "} // getUUID",
                            "} // getVersion",
                            "} // getVolt",
                            "} // getTemp",
                            "} // getCount",
                            "} // getTime",
                            "} // toString",
                            "} // setData",
                            "} // setUUID",
                            "} // setVersion",
                            "} // setVolt",
                            "} // setTemp",
                            "} // setCount",
                            "} // setTime"
                        ],
                        "lines": [
                            "\tm_eddystoneData.temp = (uint16_t) ((float) 23.00);",
                            "\tm_eddystoneData.advCount = 0;",
                            "\tm_eddystoneData.tmil = 0;",
                            "",
                            "std::string BLEEddystoneTLM::getData() {",
                            "\treturn std::string((char*) &m_eddystoneData, sizeof(m_eddystoneData));",
                            "",
                            "BLEUUID BLEEddystoneTLM::getUUID() {",
                            "\treturn BLEUUID(beaconUUID);",
                            "",
                            "uint8_t BLEEddystoneTLM::getVersion() {",
                            "\treturn m_eddystoneData.version;",
                            "",
                            "uint16_t BLEEddystoneTLM::getVolt() {",
                            "\treturn m_eddystoneData.volt;",
                            "",
                            "float BLEEddystoneTLM::getTemp() {",
                            "\treturn (float)m_eddystoneData.temp;",
                            "",
                            "uint32_t BLEEddystoneTLM::getCount() {",
                            "\treturn m_eddystoneData.advCount;",
                            "",
                            "uint32_t BLEEddystoneTLM::getTime() {",
                            "\treturn m_eddystoneData.tmil;",
                            "",
                            "std::string BLEEddystoneTLM::toString() {",
                            "\tstd::stringstream ss;",
                            "\tstd::string out = \"\";",
                            "  uint32_t rawsec;",
                            "  ss << \"Version \";",
                            "  ss << std::dec << m_eddystoneData.version;",
                            "  ss << \"\\n\";",
                            "",
                            "  ss << \"Battery Voltage \";",
                            "  ss << std::dec << ENDIAN_CHANGE_U16(m_eddystoneData.volt);",
                            "  ss << \" mV\\n\";",
                            "",
                            "  ss << \"Temperature \";",
                            "  ss << (float) m_eddystoneData.temp;",
                            "  ss << \" \u00b0C\\n\";",
                            "",
                            "  ss << \"Adv. Count \";",
                            "  ss << std::dec << ENDIAN_CHANGE_U32(m_eddystoneData.advCount);",
                            "",
                            "  ss << \"\\n\";",
                            "",
                            "  ss << \"Time \";",
                            "",
                            "  rawsec = ENDIAN_CHANGE_U32(m_eddystoneData.tmil);",
                            "  std::stringstream buffstream;",
                            "  buffstream << \"0000\";",
                            "  buffstream << std::dec << rawsec / 864000;",
                            "  std::string buff = buffstream.str();",
                            "",
                            "  ss << buff.substr(buff.length() - 4, buff.length());",
                            "  ss << \".\";",
                            "",
                            "  buffstream.str(\"\");",
                            "  buffstream.clear();",
                            "  buffstream << \"00\";",
                            "  buffstream << std::dec << (rawsec / 36000) % 24;",
                            "  buff = buffstream.str();",
                            "  ss << buff.substr(buff.length()-2, buff.length());",
                            "  ss << \":\";",
                            "",
                            "  buffstream.str(\"\");",
                            "  buffstream.clear();",
                            "  buffstream << \"00\";",
                            "  buffstream << std::dec << (rawsec / 600) % 60;",
                            "  buff = buffstream.str();",
                            "  ss << buff.substr(buff.length() - 2, buff.length());",
                            "  ss << \":\";",
                            "",
                            "  buffstream.str(\"\");",
                            "  buffstream.clear();",
                            "  buffstream << \"00\";",
                            "  buffstream << std::dec << (rawsec / 10) % 60;",
                            "  buff = buffstream.str();",
                            "  ss << buff.substr(buff.length() - 2, buff.length());",
                            "  ss << \"\\n\";",
                            "",
                            "  return ss.str();",
                            "",
                            "/**",
                            " * Set the raw data for the beacon record.",
                            " */",
                            "void BLEEddystoneTLM::setData(std::string data) {",
                            "\tif (data.length() != sizeof(m_eddystoneData)) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Unable to set the data ... length passed in was %d and expected %d\", data.length(), sizeof(m_eddystoneData));",
                            "\t\treturn;",
                            "\t}",
                            "  memcpy(&m_eddystoneData, data.data(), data.length());",
                            "",
                            "void BLEEddystoneTLM::setUUID(BLEUUID l_uuid) {",
                            "\tbeaconUUID = l_uuid.getNative()->uuid.uuid16;",
                            "",
                            "void BLEEddystoneTLM::setVersion(uint8_t version) {",
                            "\tm_eddystoneData.version = version;",
                            "",
                            "void BLEEddystoneTLM::setVolt(uint16_t volt) {",
                            "\tm_eddystoneData.volt = volt;",
                            "",
                            "void BLEEddystoneTLM::setTemp(float temp) {",
                            "\tm_eddystoneData.temp = (uint16_t)temp;",
                            "",
                            "void BLEEddystoneTLM::setCount(uint32_t advCount) {",
                            "\tm_eddystoneData.advCount = advCount;",
                            "",
                            "void BLEEddystoneTLM::setTime(uint32_t tmil) {",
                            "\tm_eddystoneData.tmil = tmil;",
                            "",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "22": "\tm_eddystoneData.volt = 3300; // 3300mV = 3.3V",
                "26": "} // BLEEddystoneTLM",
                "30": "} // getData",
                "34": "} // getUUID",
                "38": "} // getVersion",
                "42": "} // getVolt",
                "46": "} // getTemp",
                "50": "} // getCount",
                "54": "} // getTime",
                "113": "} // toString",
                "124": "} // setData",
                "128": "} // setUUID",
                "132": "} // setVersion",
                "136": "} // setVolt",
                "140": "} // setTemp",
                "144": "} // setCount",
                "148": "} // setTime"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "ef2b54547e1a7ddbcdbd46dc665e3b54ebc81ca9",
            "timestamp": "2020-09-30T14:55:58+03:00",
            "author": "Bernd Giesecke",
            "commit_message": "Fix issue #3833, data parsing of Eddystone TLM data frame (#3836)\n\n* Fix issue #3833, data parsing of Eddystone TLM data frame    \r\nAdd Beacon scanner example to show usage of BLEEddystoneTLM class and  BLEEddystoneURL class     \r\nAdd EddystoneTLM beacon example    \r\nAdd EddystoneURL beacon example\r\n\r\n* Fix buffer size for .toString()",
            "additions": 24,
            "deletions": 10,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            66,
                            67,
                            68
                        ],
                        "comments": [
                            "  out += \"Version \"; // + std::string(m_eddystoneData.version);"
                        ],
                        "lines": [
                            "  snprintf(val, sizeof(val), \"%d\", m_eddystoneData.version);",
                            "  out += val;"
                        ]
                    },
                    {
                        "line_numbers": [
                            71,
                            72
                        ],
                        "comments": [],
                        "lines": [
                            "  snprintf(val, sizeof(val), \"%d\", ENDIAN_CHANGE_U16(m_eddystoneData.volt));",
                            "  out += val;"
                        ]
                    },
                    {
                        "line_numbers": [
                            76
                        ],
                        "comments": [],
                        "lines": [
                            "  snprintf(val, sizeof(val), \"%.2f\", ENDIAN_CHANGE_U16(m_eddystoneData.temp) / 256.0f);"
                        ]
                    },
                    {
                        "line_numbers": [
                            78
                        ],
                        "comments": [],
                        "lines": [
                            "  out += \" C\\n\";"
                        ]
                    },
                    {
                        "line_numbers": [
                            85,
                            86,
                            87,
                            88,
                            89
                        ],
                        "comments": [],
                        "lines": [
                            "  out += \"Time in seconds \";",
                            "  snprintf(val, sizeof(val), \"%d\", rawsec/10);",
                            "  out += val;",
                            "  out += \"\\n\";",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "66": "  out += \"Version \"; // + std::string(m_eddystoneData.version);",
                "70": "  out += \"Battery Voltage \"; // + ENDIAN_CHANGE_U16(m_eddystoneData.volt);"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEEddystoneTLM.h": [],
    "BLEEddystoneURL.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 148,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148
                        ],
                        "comments": [
                            "} // BLEEddystoneURL",
                            "} // getData",
                            "} // getUUID",
                            "} // getPower",
                            "} // getURL",
                            "} // getDecodedURL",
                            "} // setData",
                            "} // setUUID",
                            "} // setPower",
                            "} // setURL"
                        ],
                        "lines": [
                            "",
                            "std::string BLEEddystoneURL::getData() {",
                            "\treturn std::string((char*) &m_eddystoneData, sizeof(m_eddystoneData));",
                            "",
                            "BLEUUID BLEEddystoneURL::getUUID() {",
                            "\treturn BLEUUID(beaconUUID);",
                            "",
                            "int8_t BLEEddystoneURL::getPower() {",
                            "\treturn m_eddystoneData.advertisedTxPower;",
                            "",
                            "std::string BLEEddystoneURL::getURL() {",
                            "\treturn std::string((char*) &m_eddystoneData.url, sizeof(m_eddystoneData.url));",
                            "",
                            "std::string BLEEddystoneURL::getDecodedURL() {",
                            "\tstd::string decodedURL = \"\";",
                            "",
                            "\tswitch (m_eddystoneData.url[0]) {",
                            "\t\tcase 0x00:",
                            "\t\t\tdecodedURL += \"http://www.\";",
                            "\t\t\tbreak;",
                            "\t\tcase 0x01:",
                            "\t\t\tdecodedURL += \"https://www.\";",
                            "\t\t\tbreak;",
                            "\t\tcase 0x02:",
                            "\t\t\tdecodedURL += \"http://\";",
                            "\t\t\tbreak;",
                            "\t\tcase 0x03:",
                            "\t\t\tdecodedURL += \"https://\";",
                            "\t\t\tbreak;",
                            "\t\tdefault:",
                            "\t\t\tdecodedURL += m_eddystoneData.url[0];",
                            "\t}",
                            "",
                            "\tfor (int i = 1; i < lengthURL; i++) {",
                            "\t\tif (m_eddystoneData.url[i] > 33 && m_eddystoneData.url[i] < 127) {",
                            "\t\t\tdecodedURL += m_eddystoneData.url[i];",
                            "\t\t} else {",
                            "\t\t\tswitch (m_eddystoneData.url[i]) {",
                            "\t\t\t\tcase 0x00:",
                            "\t\t\t\t\tdecodedURL += \".com/\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x01:",
                            "\t\t\t\t\tdecodedURL += \".org/\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x02:",
                            "\t\t\t\t\tdecodedURL += \".edu/\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x03:",
                            "\t\t\t\t\tdecodedURL += \".net/\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x04:",
                            "\t\t\t\t\tdecodedURL += \".info/\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x05:",
                            "\t\t\t\t\tdecodedURL += \".biz/\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x06:",
                            "\t\t\t\t\tdecodedURL += \".gov/\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x07:",
                            "\t\t\t\t\tdecodedURL += \".com\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x08:",
                            "\t\t\t\t\tdecodedURL += \".org\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x09:",
                            "\t\t\t\t\tdecodedURL += \".edu\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x0A:",
                            "\t\t\t\t\tdecodedURL += \".net\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x0B:",
                            "\t\t\t\t\tdecodedURL += \".info\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x0C:",
                            "\t\t\t\t\tdecodedURL += \".biz\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tcase 0x0D:",
                            "\t\t\t\t\tdecodedURL += \".gov\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\tdefault:",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t}",
                            "\t\t}",
                            "\t}",
                            "\treturn decodedURL;",
                            "",
                            "",
                            "",
                            "/**",
                            " * Set the raw data for the beacon record.",
                            " */",
                            "void BLEEddystoneURL::setData(std::string data) {",
                            "\tif (data.length() > sizeof(m_eddystoneData)) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Unable to set the data ... length passed in was %d and max expected %d\", data.length(), sizeof(m_eddystoneData));",
                            "\t\treturn;",
                            "\t}",
                            "\tmemset(&m_eddystoneData, 0, sizeof(m_eddystoneData));",
                            "\tmemcpy(&m_eddystoneData, data.data(), data.length());",
                            "\tlengthURL = data.length() - (sizeof(m_eddystoneData) - sizeof(m_eddystoneData.url));",
                            "",
                            "void BLEEddystoneURL::setUUID(BLEUUID l_uuid) {",
                            "\tbeaconUUID = l_uuid.getNative()->uuid.uuid16;",
                            "",
                            "void BLEEddystoneURL::setPower(int8_t advertisedTxPower) {",
                            "\tm_eddystoneData.advertisedTxPower = advertisedTxPower;",
                            "",
                            "void BLEEddystoneURL::setURL(std::string url) {",
                            "  if (url.length() > sizeof(m_eddystoneData.url)) {",
                            "\tESP_LOGE(LOG_TAG, \"Unable to set the url ... length passed in was %d and max expected %d\", url.length(), sizeof(m_eddystoneData.url));",
                            "\treturn;",
                            "  }",
                            "  memset(m_eddystoneData.url, 0, sizeof(m_eddystoneData.url));",
                            "  memcpy(m_eddystoneData.url, url.data(), url.length());",
                            "  lengthURL = url.length();",
                            "",
                            "",
                            "#endif"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "21": "} // BLEEddystoneURL",
                "25": "} // getData",
                "29": "} // getUUID",
                "33": "} // getPower",
                "37": "} // getURL",
                "112": "} // getDecodedURL",
                "127": "} // setData",
                "131": "} // setUUID",
                "135": "} // setPower",
                "145": "} // setURL"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEEddystoneURL.h": [],
    "BLEExceptions.cpp": [],
    "BLEExceptions.h": [],
    "BLEHIDDevice.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 243,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            242,
                            243
                        ],
                        "comments": [
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "242": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEHIDDevice.h": [],
    "BLERemoteCharacteristic.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 588,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588
                        ],
                        "comments": [
                            "static const char* LOG_TAG = \"BLERemoteCharacteristic\";   // The logging tag for this class.",
                            "\tretrieveDescriptors(); // Get the descriptors for this characteristic",
                            "} // BLERemoteCharacteristic",
                            "\tremoveDescriptors();   // Release resources for any descriptor information we may have allocated.",
                            "} // ~BLERemoteCharacteristic",
                            "} // canBroadcast",
                            "} // canIndicate",
                            "} // canNotify",
                            "} // canRead",
                            "} // canWrite",
                            "} // canWriteNoResponse",
                            "} // compareSrvcId",
                            "} // compareCharId",
                            "\t\t// ESP_GATTC_NOTIFY_EVT",
                            "\t\t// notify",
                            "\t\t// - uint16_t           conn_id    - The connection identifier of the server.",
                            "\t\t// - esp_bd_addr_t      remote_bda - The device address of the BLE server.",
                            "\t\t// - uint16_t           handle     - The handle of the characteristic for which the event is being received.",
                            "\t\t// - uint16_t           value_len  - The length of the received data.",
                            "\t\t// - uint8_t*           value      - The received data.",
                            "\t\t// - bool               is_notify  - True if this is a notify, false if it is an indicate.",
                            "\t\t// We have received a notification event which means that the server wishes us to know about a notification",
                            "\t\t// piece of data.  What we must now do is find the characteristic with the associated handle and then",
                            "\t\t// invoke its notification callback (if it has one).",
                            "\t\t\t} // End we have a callback function ...",
                            "\t\t} // ESP_GATTC_NOTIFY_EVT",
                            "\t\t// ESP_GATTC_READ_CHAR_EVT",
                            "\t\t// This event indicates that the server has responded to the read request.",
                            "\t\t// read:",
                            "\t\t// - esp_gatt_status_t  status",
                            "\t\t// - uint16_t           conn_id",
                            "\t\t// - uint16_t           handle",
                            "\t\t// - uint8_t*           value",
                            "\t\t// - uint16_t           value_len",
                            "\t\t\t// If this event is not for us, then nothing further to do.",
                            "\t\t\t// At this point, we have determined that the event is for us, so now we save the value",
                            "\t\t\t// and unlock the semaphore to ensure that the requestor of the data can continue.",
                            "\t\t} // ESP_GATTC_READ_CHAR_EVT",
                            "\t\t// ESP_GATTC_REG_FOR_NOTIFY_EVT",
                            "\t\t// reg_for_notify:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          handle",
                            "\t\t\t// If the request is not for this BLERemoteCharacteristic then move on to the next.",
                            "\t\t\t// We have processed the notify registration and can unlock the semaphore.",
                            "\t\t} // ESP_GATTC_REG_FOR_NOTIFY_EVT",
                            "\t\t// ESP_GATTC_UNREG_FOR_NOTIFY_EVT",
                            "\t\t// unreg_for_notify:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          handle",
                            "\t\t\t// We have processed the notify un-registration and can unlock the semaphore.",
                            "\t\t} // ESP_GATTC_UNREG_FOR_NOTIFY_EVT:",
                            "\t\t// ESP_GATTC_WRITE_CHAR_EVT",
                            "\t\t// write:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "\t\t// - uint16_t          handle",
                            "\t\t\t// Determine if this event is for us and, if not, pass onwards.",
                            "\t\t\t// There is nothing further we need to do here.  This is merely an indication",
                            "\t\t\t// that the write has completed and we can unlock the caller.",
                            "\t\t} // ESP_GATTC_WRITE_CHAR_EVT",
                            "\t} // End switch",
                            "}; // gattClientEventHandler",
                            "\tremoveDescriptors();   // Remove any existing descriptors.",
                            "\t// Loop over each of the descriptors within the service associated with this characteristic.",
                            "\t// For each descriptor we find, create a BLERemoteDescriptor instance.",
                            "\t\tif (status == ESP_GATT_INVALID_OFFSET) {   // We have reached the end of the entries.",
                            "\t\t// We now have a new characteristic ... let us add that to our set of known characteristics",
                            "\t} // while true",
                            "\t//m_haveCharacteristics = true; // Remember that we have received the characteristics.",
                            "} // getDescriptors",
                            "} // getDescriptors",
                            "} // getHandle",
                            "} // getDescriptor",
                            "} // getRemoteService",
                            "} // getUUID",
                            "} // readUInt16",
                            "} // readUInt32",
                            "} // readUInt8",
                            "\t// Check to see that we are connected.",
                            "\t// Ask the BLE subsystem to retrieve the value for the remote hosted characteristic.",
                            "\t// This is an asynchronous request which means that we must block waiting for the response",
                            "\t// to become available.",
                            "\t\tm_pRemoteService->getClient()->getConnId(),    // The connection ID to the BLE server",
                            "\t\tgetHandle(),                                   // The handle of this characteristic",
                            "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security",
                            "\t// Block waiting for the event that indicates that the read has completed.  When it has, the std::string found",
                            "\t// in m_value will contain our data.",
                            "} // readValue",
                            "\tm_notifyCallback = notifyCallback;   // Save the notification callback.",
                            "\tif (notifyCallback != nullptr) {   // If we have a callback function, then this is a registration.",
                            "\t} // End Register",
                            "\telse {   // If we weren't passed a callback function, then this is an unregistration.",
                            "\t} // End Unregister",
                            "} // registerForNotify",
                            "\t// Iterate through all the descriptors releasing their storage and erasing them from the map.",
                            "\tm_descriptorMap.clear();   // Technically not neeeded, but just to be sure.",
                            "} // removeCharacteristics",
                            "} // toString",
                            "} // writeValue",
                            "} // writeValue",
                            "\t// writeValue(std::string((char*)data, length), response);",
                            "\t// Check to see that we are connected.",
                            "\t// Invoke the ESP-IDF API to perform the write.",
                            "} // writeValue"
                        ],
                        "lines": [
                            "#endif",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Constructor.",
                            " * @param [in] handle The BLE server side handle of this characteristic.",
                            " * @param [in] uuid The UUID of this characteristic.",
                            " * @param [in] charProp The properties of this characteristic.",
                            " * @param [in] pRemoteService A reference to the remote service to which this remote characteristic pertains.",
                            " */",
                            "BLERemoteCharacteristic::BLERemoteCharacteristic(",
                            "\t\tuint16_t             handle,",
                            "\t\tBLEUUID              uuid,",
                            "\t\tesp_gatt_char_prop_t charProp,",
                            "\t\tBLERemoteService*    pRemoteService) {",
                            "\tESP_LOGD(LOG_TAG, \">> BLERemoteCharacteristic: handle: %d 0x%d, uuid: %s\", handle, handle, uuid.toString().c_str());",
                            "\tm_handle         = handle;",
                            "\tm_uuid           = uuid;",
                            "\tm_charProp       = charProp;",
                            "\tm_pRemoteService = pRemoteService;",
                            "\tm_notifyCallback = nullptr;",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< BLERemoteCharacteristic\");",
                            "",
                            "",
                            "/**",
                            " *@brief Destructor.",
                            " */",
                            "BLERemoteCharacteristic::~BLERemoteCharacteristic() {",
                            "",
                            "",
                            "/**",
                            " * @brief Does the characteristic support broadcasting?",
                            " * @return True if the characteristic supports broadcasting.",
                            " */",
                            "bool BLERemoteCharacteristic::canBroadcast() {",
                            "\treturn (m_charProp & ESP_GATT_CHAR_PROP_BIT_BROADCAST) != 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Does the characteristic support indications?",
                            " * @return True if the characteristic supports indications.",
                            " */",
                            "bool BLERemoteCharacteristic::canIndicate() {",
                            "\treturn (m_charProp & ESP_GATT_CHAR_PROP_BIT_INDICATE) != 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Does the characteristic support notifications?",
                            " * @return True if the characteristic supports notifications.",
                            " */",
                            "bool BLERemoteCharacteristic::canNotify() {",
                            "\treturn (m_charProp & ESP_GATT_CHAR_PROP_BIT_NOTIFY) != 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Does the characteristic support reading?",
                            " * @return True if the characteristic supports reading.",
                            " */",
                            "bool BLERemoteCharacteristic::canRead() {",
                            "\treturn (m_charProp & ESP_GATT_CHAR_PROP_BIT_READ) != 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Does the characteristic support writing?",
                            " * @return True if the characteristic supports writing.",
                            " */",
                            "bool BLERemoteCharacteristic::canWrite() {",
                            "\treturn (m_charProp & ESP_GATT_CHAR_PROP_BIT_WRITE) != 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Does the characteristic support writing with no response?",
                            " * @return True if the characteristic supports writing with no response.",
                            " */",
                            "bool BLERemoteCharacteristic::canWriteNoResponse() {",
                            "\treturn (m_charProp & ESP_GATT_CHAR_PROP_BIT_WRITE_NR) != 0;",
                            "",
                            "",
                            "/*",
                            "static bool compareSrvcId(esp_gatt_srvc_id_t id1, esp_gatt_srvc_id_t id2) {",
                            "\tif (id1.id.inst_id != id2.id.inst_id) {",
                            "\t\treturn false;",
                            "\t}",
                            "\tif (!BLEUUID(id1.id.uuid).equals(BLEUUID(id2.id.uuid))) {",
                            "\t\treturn false;",
                            "\t}",
                            "\treturn true;",
                            "*/",
                            "",
                            "/*",
                            "static bool compareGattId(esp_gatt_id_t id1, esp_gatt_id_t id2) {",
                            "\tif (id1.inst_id != id2.inst_id) {",
                            "\t\treturn false;",
                            "\t}",
                            "\tif (!BLEUUID(id1.uuid).equals(BLEUUID(id2.uuid))) {",
                            "\t\treturn false;",
                            "\t}",
                            "\treturn true;",
                            "*/",
                            "",
                            "",
                            "/**",
                            " * @brief Handle GATT Client events.",
                            " * When an event arrives for a GATT client we give this characteristic the opportunity to",
                            " * take a look at it to see if there is interest in it.",
                            " * @param [in] event The type of event.",
                            " * @param [in] gattc_if The interface on which the event was received.",
                            " * @param [in] evtParam Payload data for the event.",
                            " * @returns N/A",
                            " */",
                            "void BLERemoteCharacteristic::gattClientEventHandler(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t* evtParam) {",
                            "\tswitch(event) {",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_NOTIFY_EVT: {",
                            "\t\t\tif (evtParam->notify.handle != getHandle()) break;",
                            "\t\t\tif (m_notifyCallback != nullptr) {",
                            "\t\t\t\tESP_LOGD(LOG_TAG, \"Invoking callback for notification on characteristic %s\", toString().c_str());",
                            "\t\t\t\tm_notifyCallback(this, evtParam->notify.value, evtParam->notify.value_len, evtParam->notify.is_notify);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_READ_CHAR_EVT: {",
                            "\t\t\tif (evtParam->read.handle != getHandle()) break;",
                            "",
                            "\t\t\tif (evtParam->read.status == ESP_GATT_OK) {",
                            "\t\t\t\tm_value = std::string((char*) evtParam->read.value, evtParam->read.value_len);",
                            "\t\t\t\tif(m_rawData != nullptr) free(m_rawData);",
                            "\t\t\t\tm_rawData = (uint8_t*) calloc(evtParam->read.value_len, sizeof(uint8_t));",
                            "\t\t\t\tmemcpy(m_rawData, evtParam->read.value, evtParam->read.value_len);",
                            "\t\t\t} else {",
                            "\t\t\t\tm_value = \"\";",
                            "\t\t\t}",
                            "",
                            "\t\t\tm_semaphoreReadCharEvt.give();",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_REG_FOR_NOTIFY_EVT: {",
                            "\t\t\tif (evtParam->reg_for_notify.handle != getHandle()) break;",
                            "",
                            "\t\t\tm_semaphoreRegForNotifyEvt.give();",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_UNREG_FOR_NOTIFY_EVT: {",
                            "\t\t\tif (evtParam->unreg_for_notify.handle != getHandle()) break;",
                            "\t\t\tm_semaphoreRegForNotifyEvt.give();",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_WRITE_CHAR_EVT: {",
                            "\t\t\tif (evtParam->write.handle != getHandle()) break;",
                            "",
                            "\t\t\tm_semaphoreWriteCharEvt.give();",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "/**",
                            " * @brief Populate the descriptors (if any) for this characteristic.",
                            " */",
                            "void BLERemoteCharacteristic::retrieveDescriptors() {",
                            "\tESP_LOGD(LOG_TAG, \">> retrieveDescriptors() for characteristic: %s\", getUUID().toString().c_str());",
                            "",
                            "",
                            "\tuint16_t offset = 0;",
                            "\tesp_gattc_descr_elem_t result;",
                            "\twhile(true) {",
                            "\t\tuint16_t count = 10;",
                            "\t\tesp_gatt_status_t status = ::esp_ble_gattc_get_all_descr(",
                            "\t\t\tgetRemoteService()->getClient()->getGattcIf(),",
                            "\t\t\tgetRemoteService()->getClient()->getConnId(),",
                            "\t\t\tgetHandle(),",
                            "\t\t\t&result,",
                            "\t\t\t&count,",
                            "\t\t\toffset",
                            "\t\t);",
                            "",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tif (status != ESP_GATT_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_get_all_descr: %s\", BLEUtils::gattStatusToString(status).c_str());",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tif (count == 0) break;",
                            "",
                            "\t\tESP_LOGD(LOG_TAG, \"Found a descriptor: Handle: %d, UUID: %s\", result.handle, BLEUUID(result.uuid).toString().c_str());",
                            "",
                            "\t\tBLERemoteDescriptor* pNewRemoteDescriptor = new BLERemoteDescriptor(",
                            "\t\t\tresult.handle,",
                            "\t\t\tBLEUUID(result.uuid),",
                            "\t\t\tthis",
                            "\t\t);",
                            "",
                            "\t\tm_descriptorMap.insert(std::pair<std::string, BLERemoteDescriptor*>(pNewRemoteDescriptor->getUUID().toString(), pNewRemoteDescriptor));",
                            "",
                            "\t\toffset++;",
                            "\tESP_LOGD(LOG_TAG, \"<< retrieveDescriptors(): Found %d descriptors.\", offset);",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve the map of descriptors keyed by UUID.",
                            " */",
                            "std::map<std::string, BLERemoteDescriptor*>* BLERemoteCharacteristic::getDescriptors() {",
                            "\treturn &m_descriptorMap;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the handle for this characteristic.",
                            " * @return The handle for this characteristic.",
                            " */",
                            "uint16_t BLERemoteCharacteristic::getHandle() {",
                            "\t//ESP_LOGD(LOG_TAG, \">> getHandle: Characteristic: %s\", getUUID().toString().c_str());",
                            "\t//ESP_LOGD(LOG_TAG, \"<< getHandle: %d 0x%.2x\", m_handle, m_handle);",
                            "\treturn m_handle;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the descriptor instance with the given UUID that belongs to this characteristic.",
                            " * @param [in] uuid The UUID of the descriptor to find.",
                            " * @return The Remote descriptor (if present) or null if not present.",
                            " */",
                            "BLERemoteDescriptor* BLERemoteCharacteristic::getDescriptor(BLEUUID uuid) {",
                            "\tESP_LOGD(LOG_TAG, \">> getDescriptor: uuid: %s\", uuid.toString().c_str());",
                            "\tstd::string v = uuid.toString();",
                            "\tfor (auto &myPair : m_descriptorMap) {",
                            "\t\tif (myPair.first == v) {",
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< getDescriptor: found\");",
                            "\t\t\treturn myPair.second;",
                            "\t\t}",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< getDescriptor: Not found\");",
                            "\treturn nullptr;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the remote service associated with this characteristic.",
                            " * @return The remote service associated with this characteristic.",
                            " */",
                            "BLERemoteService* BLERemoteCharacteristic::getRemoteService() {",
                            "\treturn m_pRemoteService;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the UUID for this characteristic.",
                            " * @return The UUID for this characteristic.",
                            " */",
                            "BLEUUID BLERemoteCharacteristic::getUUID() {",
                            "\treturn m_uuid;",
                            "",
                            "",
                            "/**",
                            " * @brief Read an unsigned 16 bit value",
                            " * @return The unsigned 16 bit value.",
                            " */",
                            "uint16_t BLERemoteCharacteristic::readUInt16() {",
                            "\tstd::string value = readValue();",
                            "\tif (value.length() >= 2) {",
                            "\t\treturn *(uint16_t*)(value.data());",
                            "\t}",
                            "\treturn 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Read an unsigned 32 bit value.",
                            " * @return the unsigned 32 bit value.",
                            " */",
                            "uint32_t BLERemoteCharacteristic::readUInt32() {",
                            "\tstd::string value = readValue();",
                            "\tif (value.length() >= 4) {",
                            "\t\treturn *(uint32_t*)(value.data());",
                            "\t}",
                            "\treturn 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Read a byte value",
                            " * @return The value as a byte",
                            " */",
                            "uint8_t BLERemoteCharacteristic::readUInt8() {",
                            "\tstd::string value = readValue();",
                            "\tif (value.length() >= 1) {",
                            "\t\treturn (uint8_t)value[0];",
                            "\t}",
                            "\treturn 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Read the value of the remote characteristic.",
                            " * @return The value of the remote characteristic.",
                            " */",
                            "std::string BLERemoteCharacteristic::readValue() {",
                            "\tESP_LOGD(LOG_TAG, \">> readValue(): uuid: %s, handle: %d 0x%.2x\", getUUID().toString().c_str(), getHandle(), getHandle());",
                            "",
                            "\tif (!getRemoteService()->getClient()->isConnected()) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Disconnected\");",
                            "\t\tthrow BLEDisconnectedException();",
                            "\t}",
                            "",
                            "\tm_semaphoreReadCharEvt.take(\"readValue\");",
                            "",
                            "\tesp_err_t errRc = ::esp_ble_gattc_read_char(",
                            "\t\tm_pRemoteService->getClient()->getGattcIf(),",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_read_char: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn \"\";",
                            "\t}",
                            "",
                            "\tm_semaphoreReadCharEvt.wait(\"readValue\");",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< readValue(): length: %d\", m_value.length());",
                            "\treturn m_value;",
                            "",
                            "",
                            "/**",
                            " * @brief Register for notifications.",
                            " * @param [in] notifyCallback A callback to be invoked for a notification.  If NULL is provided then we are",
                            " * unregistering a notification.",
                            " * @return N/A.",
                            " */",
                            "void BLERemoteCharacteristic::registerForNotify(notify_callback notifyCallback, bool notifications) {",
                            "\tESP_LOGD(LOG_TAG, \">> registerForNotify(): %s\", toString().c_str());",
                            "",
                            "",
                            "\tm_semaphoreRegForNotifyEvt.take(\"registerForNotify\");",
                            "",
                            "\t\tesp_err_t errRc = ::esp_ble_gattc_register_for_notify(",
                            "\t\t\tm_pRemoteService->getClient()->getGattcIf(),",
                            "\t\t\t*m_pRemoteService->getClient()->getPeerAddress().getNative(),",
                            "\t\t\tgetHandle()",
                            "\t\t);",
                            "",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_register_for_notify: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t}",
                            "",
                            "\t\tuint8_t val[] = {0x01, 0x00};",
                            "\t\tif(!notifications) val[0] = 0x02;",
                            "\t\tBLERemoteDescriptor* desc = getDescriptor(BLEUUID((uint16_t)0x2902));",
                            "\t\tdesc->writeValue(val, 2);",
                            "\t\tesp_err_t errRc = ::esp_ble_gattc_unregister_for_notify(",
                            "\t\t\tm_pRemoteService->getClient()->getGattcIf(),",
                            "\t\t\t*m_pRemoteService->getClient()->getPeerAddress().getNative(),",
                            "\t\t\tgetHandle()",
                            "\t\t);",
                            "",
                            "\t\tif (errRc != ESP_OK) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_unregister_for_notify: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t}",
                            "",
                            "\t\tuint8_t val[] = {0x00, 0x00};",
                            "\t\tBLERemoteDescriptor* desc = getDescriptor((uint16_t)0x2902);",
                            "\t\tdesc->writeValue(val, 2);",
                            "",
                            "\tm_semaphoreRegForNotifyEvt.wait(\"registerForNotify\");",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< registerForNotify()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Delete the descriptors in the descriptor map.",
                            " * We maintain a map called m_descriptorMap that contains pointers to BLERemoteDescriptors",
                            " * object references.  Since we allocated these in this class, we are also responsible for deleteing",
                            " * them.  This method does just that.",
                            " * @return N/A.",
                            " */",
                            "void BLERemoteCharacteristic::removeDescriptors() {",
                            "\tfor (auto &myPair : m_descriptorMap) {",
                            "\t   m_descriptorMap.erase(myPair.first);",
                            "\t   delete myPair.second;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a BLERemoteCharacteristic to a string representation;",
                            " * @return a String representation.",
                            " */",
                            "std::string BLERemoteCharacteristic::toString() {",
                            "\tstd::ostringstream ss;",
                            "\tss << \"Characteristic: uuid: \" << m_uuid.toString() <<",
                            "\t\t\", handle: \" << getHandle() << \" 0x\" << std::hex << getHandle() <<",
                            "\t\t\", props: \" << BLEUtils::characteristicPropertiesToString(m_charProp);",
                            "\treturn ss.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Write the new value for the characteristic.",
                            " * @param [in] newValue The new value to write.",
                            " * @param [in] response Do we expect a response?",
                            " * @return N/A.",
                            " */",
                            "void BLERemoteCharacteristic::writeValue(std::string newValue, bool response) {",
                            "\twriteValue((uint8_t*)newValue.c_str(), strlen(newValue.c_str()), response);",
                            "",
                            "",
                            "/**",
                            " * @brief Write the new value for the characteristic.",
                            " *",
                            " * This is a convenience function.  Many BLE characteristics are a single byte of data.",
                            " * @param [in] newValue The new byte value to write.",
                            " * @param [in] response Whether we require a response from the write.",
                            " * @return N/A.",
                            " */",
                            "void BLERemoteCharacteristic::writeValue(uint8_t newValue, bool response) {",
                            "\twriteValue(&newValue, 1, response);",
                            "",
                            "",
                            "/**",
                            " * @brief Write the new value for the characteristic from a data buffer.",
                            " * @param [in] data A pointer to a data buffer.",
                            " * @param [in] length The length of the data in the data buffer.",
                            " * @param [in] response Whether we require a response from the write.",
                            " */",
                            "void BLERemoteCharacteristic::writeValue(uint8_t* data, size_t length, bool response) {",
                            "\tESP_LOGD(LOG_TAG, \">> writeValue(), length: %d\", length);",
                            "",
                            "\tif (!getRemoteService()->getClient()->isConnected()) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Disconnected\");",
                            "\t\tthrow BLEDisconnectedException();",
                            "\t}",
                            "",
                            "\tm_semaphoreWriteCharEvt.take(\"writeValue\");",
                            "\tesp_err_t errRc = ::esp_ble_gattc_write_char(",
                            "\t\tm_pRemoteService->getClient()->getGattcIf(),",
                            "\t\tm_pRemoteService->getClient()->getConnId(),",
                            "\t\tgetHandle(),",
                            "\t\tlength,",
                            "\t\tdata,",
                            "\t\tresponse?ESP_GATT_WRITE_TYPE_RSP:ESP_GATT_WRITE_TYPE_NO_RSP,",
                            "\t\tESP_GATT_AUTH_REQ_NONE",
                            "\t);",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_write_char: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "\tm_semaphoreWriteCharEvt.wait(\"writeValue\");",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< writeValue\");",
                            "",
                            "/**",
                            " * @brief Read raw data from remote characteristic as hex bytes",
                            " * @return return pointer data read",
                            " */",
                            "uint8_t* BLERemoteCharacteristic::readRawData() {",
                            "\treturn m_rawData;",
                            "}",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "26": "static const char* LOG_TAG = \"BLERemoteCharacteristic\";   // The logging tag for this class.",
                "50": "\tretrieveDescriptors(); // Get the descriptors for this characteristic",
                "52": "} // BLERemoteCharacteristic",
                "59": "\tremoveDescriptors();   // Release resources for any descriptor information we may have allocated.",
                "60": "} // ~BLERemoteCharacteristic",
                "69": "} // canBroadcast",
                "78": "} // canIndicate",
                "87": "} // canNotify",
                "96": "} // canRead",
                "105": "} // canWrite",
                "114": "} // canWriteNoResponse",
                "126": "} // compareSrvcId",
                "138": "} // compareCharId",
                "153": "\t\t// ESP_GATTC_NOTIFY_EVT",
                "155": "\t\t// notify",
                "156": "\t\t// - uint16_t           conn_id    - The connection identifier of the server.",
                "157": "\t\t// - esp_bd_addr_t      remote_bda - The device address of the BLE server.",
                "158": "\t\t// - uint16_t           handle     - The handle of the characteristic for which the event is being received.",
                "159": "\t\t// - uint16_t           value_len  - The length of the received data.",
                "160": "\t\t// - uint8_t*           value      - The received data.",
                "161": "\t\t// - bool               is_notify  - True if this is a notify, false if it is an indicate.",
                "163": "\t\t// We have received a notification event which means that the server wishes us to know about a notification",
                "164": "\t\t// piece of data.  What we must now do is find the characteristic with the associated handle and then",
                "165": "\t\t// invoke its notification callback (if it has one).",
                "171": "\t\t\t} // End we have a callback function ...",
                "173": "\t\t} // ESP_GATTC_NOTIFY_EVT",
                "175": "\t\t// ESP_GATTC_READ_CHAR_EVT",
                "176": "\t\t// This event indicates that the server has responded to the read request.",
                "178": "\t\t// read:",
                "179": "\t\t// - esp_gatt_status_t  status",
                "180": "\t\t// - uint16_t           conn_id",
                "181": "\t\t// - uint16_t           handle",
                "182": "\t\t// - uint8_t*           value",
                "183": "\t\t// - uint16_t           value_len",
                "185": "\t\t\t// If this event is not for us, then nothing further to do.",
                "188": "\t\t\t// At this point, we have determined that the event is for us, so now we save the value",
                "189": "\t\t\t// and unlock the semaphore to ensure that the requestor of the data can continue.",
                "201": "\t\t} // ESP_GATTC_READ_CHAR_EVT",
                "203": "\t\t// ESP_GATTC_REG_FOR_NOTIFY_EVT",
                "205": "\t\t// reg_for_notify:",
                "206": "\t\t// - esp_gatt_status_t status",
                "207": "\t\t// - uint16_t          handle",
                "209": "\t\t\t// If the request is not for this BLERemoteCharacteristic then move on to the next.",
                "212": "\t\t\t// We have processed the notify registration and can unlock the semaphore.",
                "215": "\t\t} // ESP_GATTC_REG_FOR_NOTIFY_EVT",
                "217": "\t\t// ESP_GATTC_UNREG_FOR_NOTIFY_EVT",
                "219": "\t\t// unreg_for_notify:",
                "220": "\t\t// - esp_gatt_status_t status",
                "221": "\t\t// - uint16_t          handle",
                "224": "\t\t\t// We have processed the notify un-registration and can unlock the semaphore.",
                "227": "\t\t} // ESP_GATTC_UNREG_FOR_NOTIFY_EVT:",
                "229": "\t\t// ESP_GATTC_WRITE_CHAR_EVT",
                "231": "\t\t// write:",
                "232": "\t\t// - esp_gatt_status_t status",
                "233": "\t\t// - uint16_t          conn_id",
                "234": "\t\t// - uint16_t          handle",
                "236": "\t\t\t// Determine if this event is for us and, if not, pass onwards.",
                "239": "\t\t\t// There is nothing further we need to do here.  This is merely an indication",
                "240": "\t\t\t// that the write has completed and we can unlock the caller.",
                "243": "\t\t} // ESP_GATTC_WRITE_CHAR_EVT",
                "248": "\t} // End switch",
                "249": "}; // gattClientEventHandler",
                "258": "\tremoveDescriptors();   // Remove any existing descriptors.",
                "260": "\t// Loop over each of the descriptors within the service associated with this characteristic.",
                "261": "\t// For each descriptor we find, create a BLERemoteDescriptor instance.",
                "275": "\t\tif (status == ESP_GATT_INVALID_OFFSET) {   // We have reached the end of the entries.",
                "288": "\t\t// We now have a new characteristic ... let us add that to our set of known characteristics",
                "298": "\t} // while true",
                "299": "\t//m_haveCharacteristics = true; // Remember that we have received the characteristics.",
                "301": "} // getDescriptors",
                "309": "} // getDescriptors",
                "320": "} // getHandle",
                "339": "} // getDescriptor",
                "348": "} // getRemoteService",
                "357": "} // getUUID",
                "370": "} // readUInt16",
                "383": "} // readUInt32",
                "396": "} // readUInt8",
                "406": "\t// Check to see that we are connected.",
                "414": "\t// Ask the BLE subsystem to retrieve the value for the remote hosted characteristic.",
                "415": "\t// This is an asynchronous request which means that we must block waiting for the response",
                "416": "\t// to become available.",
                "419": "\t\tm_pRemoteService->getClient()->getConnId(),    // The connection ID to the BLE server",
                "420": "\t\tgetHandle(),                                   // The handle of this characteristic",
                "421": "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security",
                "428": "\t// Block waiting for the event that indicates that the read has completed.  When it has, the std::string found",
                "429": "\t// in m_value will contain our data.",
                "434": "} // readValue",
                "446": "\tm_notifyCallback = notifyCallback;   // Save the notification callback.",
                "450": "\tif (notifyCallback != nullptr) {   // If we have a callback function, then this is a registration.",
                "465": "\t} // End Register",
                "466": "\telse {   // If we weren't passed a callback function, then this is an unregistration.",
                "480": "\t} // End Unregister",
                "485": "} // registerForNotify",
                "496": "\t// Iterate through all the descriptors releasing their storage and erasing them from the map.",
                "501": "\tm_descriptorMap.clear();   // Technically not neeeded, but just to be sure.",
                "502": "} // removeCharacteristics",
                "515": "} // toString",
                "526": "} // writeValue",
                "539": "} // writeValue",
                "549": "\t// writeValue(std::string((char*)data, length), response);",
                "552": "\t// Check to see that we are connected.",
                "559": "\t// Invoke the ESP-IDF API to perform the write.",
                "578": "} // writeValue"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d7ea7b80a7badbe30e6fb6f33f71375e0b133c",
            "timestamp": "2019-04-15T17:26:35+02:00",
            "author": "Bascy",
            "commit_message": "Refactored use of LOG_X(LOG_TAG, ...) to log_x(...) (#2672)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)\r\n\r\n* Change logging from Error to Verbose when not found and default available\r\n\r\n* Move Enter and Exit logging to Verbose Level\r\n\r\n* Refactored LOG_X() into log_x()",
            "additions": 24,
            "deletions": 31,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            26,
                            27,
                            28
                        ],
                        "comments": [
                            "static const char* LOG_TAG = \"BLERemoteCharacteristic\";   // The logging tag for this class."
                        ],
                        "lines": [
                            "#endif",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            43
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> BLERemoteCharacteristic: handle: %d 0x%d, uuid: %s\", handle, handle, uuid.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            51
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< BLERemoteCharacteristic\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            169
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGD(LOG_TAG, \"Invoking callback for notification on characteristic %s\", toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            256
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> retrieveDescriptors() for characteristic: %s\", getUUID().toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            280
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_get_all_descr: %s\", BLEUtils::gattStatusToString(status).c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            286
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGD(LOG_TAG, \"Found a descriptor: Handle: %d, UUID: %s\", result.handle, BLEUUID(result.uuid).toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            300
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< retrieveDescriptors(): Found %d descriptors.\", offset);"
                        ]
                    },
                    {
                        "line_numbers": [
                            317,
                            318
                        ],
                        "comments": [],
                        "lines": [
                            "\t//ESP_LOGD(LOG_TAG, \">> getHandle: Characteristic: %s\", getUUID().toString().c_str());",
                            "\t//ESP_LOGD(LOG_TAG, \"<< getHandle: %d 0x%.2x\", m_handle, m_handle);"
                        ]
                    },
                    {
                        "line_numbers": [
                            329
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> getDescriptor: uuid: %s\", uuid.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            333
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGD(LOG_TAG, \"<< getDescriptor: found\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            337
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< getDescriptor: Not found\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            404
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> readValue(): uuid: %s, handle: %d 0x%.2x\", getUUID().toString().c_str(), getHandle(), getHandle());"
                        ]
                    },
                    {
                        "line_numbers": [
                            408
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"Disconnected\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            424
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_read_char: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            432
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< readValue(): length: %d\", m_value.length());"
                        ]
                    },
                    {
                        "line_numbers": [
                            444
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> registerForNotify(): %s\", toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            458
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_register_for_notify: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            474
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_unregister_for_notify: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            484
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< registerForNotify()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            550
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> writeValue(), length: %d\", length);"
                        ]
                    },
                    {
                        "line_numbers": [
                            554
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"Disconnected\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            571
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_write_char: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            577
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< writeValue\");"
                        ]
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "26": "static const char* LOG_TAG = \"BLERemoteCharacteristic\";   // The logging tag for this class."
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "24b277ad92d1f769551cb9bf5f07633e2f24950f",
            "timestamp": "2019-10-06T17:28:53+03:00",
            "author": "copercini",
            "commit_message": "Add readFloat to BLE (#3321)\n\n* Add readFloat\r\n\r\n* Add readFloat to BLE",
            "additions": 11,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            402
                        ],
                        "comments": [
                            "} // readFloat"
                        ],
                        "lines": []
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "402": "} // readFloat"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "c2b37d95e0924640e2c278c7bf439503ecad9d5f",
            "timestamp": "2020-01-20T15:40:13+02:00",
            "author": "lj",
            "commit_message": "Updated BLERemoteCharacteristic to exposre esp_gatt_auth_req_t parame\u2026 (#3531)\n\n* Updated BLERemoteCharacteristic to exposre esp_gatt_auth_req_t parameter for readValue and writeValue.\r\n\r\n* Updated BLERemoteCharacteristic/Descriptor to expose a setAuth method to allow tweaking the authentication request type for that remotecharacteristic/descriptor without the need to add auth on each read/write.",
            "additions": 11,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            427
                        ],
                        "comments": [
                            "\t\tm_auth);                                         // Security"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            578
                        ],
                        "comments": [],
                        "lines": [
                            "        m_auth"
                        ]
                    },
                    {
                        "line_numbers": [
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606
                        ],
                        "comments": [],
                        "lines": [
                            "/**",
                            " * @brief Set authentication request type for characteristic",
                            " * @param [in] auth Authentication request type.",
                            " */",
                            "void BLERemoteCharacteristic::setAuth(esp_gatt_auth_req_t auth) {",
                            "    m_auth = auth;",
                            "}",
                            ""
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            426
                        ],
                        "comments": [
                            "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            577
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_GATT_AUTH_REQ_NONE"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "427": "\t\tm_auth);                                         // Security"
            },
            "comment_deleted_diff": {
                "426": "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security"
            },
            "comment_modified_diff": {}
        }
    ],
    "BLERemoteCharacteristic.h": [],
    "BLERemoteDescriptor.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 181,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181
                        ],
                        "comments": [
                            "} // getHandle",
                            "} // getRemoteCharacteristic",
                            "} // getUUID",
                            "\t// Check to see that we are connected.",
                            "\t// Ask the BLE subsystem to retrieve the value for the remote hosted characteristic.",
                            "\t\tm_pRemoteCharacteristic->getRemoteService()->getClient()->getConnId(),    // The connection ID to the BLE server",
                            "\t\tgetHandle(),                                   // The handle of this characteristic",
                            "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security",
                            "\t// Block waiting for the event that indicates that the read has completed.  When it has, the std::string found",
                            "\t// in m_value will contain our data.",
                            "} // readValue",
                            "} // readUInt8",
                            "} // readUInt16",
                            "} // readUInt32",
                            "} // toString",
                            "\t// Check to see that we are connected.",
                            "\t\tlength,                           // Data length",
                            "\t\tdata,                             // Data",
                            "} // writeValue",
                            "} // writeValue",
                            "} // writeValue"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Get the characteristic that owns this descriptor.",
                            " * @return The characteristic that owns this descriptor.",
                            " */",
                            "BLERemoteCharacteristic* BLERemoteDescriptor::getRemoteCharacteristic() {",
                            "\treturn m_pRemoteCharacteristic;",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve the UUID associated this remote descriptor.",
                            " * @return The UUID associated this remote descriptor.",
                            " */",
                            "BLEUUID BLERemoteDescriptor::getUUID() {",
                            "\treturn m_uuid;",
                            "",
                            "",
                            "std::string BLERemoteDescriptor::readValue() {",
                            "\tESP_LOGD(LOG_TAG, \">> readValue: %s\", toString().c_str());",
                            "",
                            "\tif (!getRemoteCharacteristic()->getRemoteService()->getClient()->isConnected()) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Disconnected\");",
                            "\t\tthrow BLEDisconnectedException();",
                            "\t}",
                            "",
                            "\tm_semaphoreReadDescrEvt.take(\"readValue\");",
                            "",
                            "\tesp_err_t errRc = ::esp_ble_gattc_read_char_descr(",
                            "\t\tm_pRemoteCharacteristic->getRemoteService()->getClient()->getGattcIf(),",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_read_char: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn \"\";",
                            "\t}",
                            "",
                            "\tm_semaphoreReadDescrEvt.wait(\"readValue\");",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< readValue(): length: %d\", m_value.length());",
                            "\treturn m_value;",
                            "",
                            "",
                            "uint8_t BLERemoteDescriptor::readUInt8() {",
                            "\tstd::string value = readValue();",
                            "\tif (value.length() >= 1) {",
                            "\t\treturn (uint8_t) value[0];",
                            "\t}",
                            "\treturn 0;",
                            "",
                            "",
                            "uint16_t BLERemoteDescriptor::readUInt16() {",
                            "\tstd::string value = readValue();",
                            "\tif (value.length() >= 2) {",
                            "\t\treturn *(uint16_t*) value.data();",
                            "\t}",
                            "\treturn 0;",
                            "",
                            "",
                            "uint32_t BLERemoteDescriptor::readUInt32() {",
                            "\tstd::string value = readValue();",
                            "\tif (value.length() >= 4) {",
                            "\t\treturn *(uint32_t*) value.data();",
                            "\t}",
                            "\treturn 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of this BLE Remote Descriptor.",
                            " * @retun A string representation of this BLE Remote Descriptor.",
                            " */",
                            "std::string BLERemoteDescriptor::toString() {",
                            "\tstd::stringstream ss;",
                            "\tss << \"handle: \" << getHandle() << \", uuid: \" << getUUID().toString();",
                            "\treturn ss.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Write data to the BLE Remote Descriptor.",
                            " * @param [in] data The data to send to the remote descriptor.",
                            " * @param [in] length The length of the data to send.",
                            " * @param [in] response True if we expect a response.",
                            " */",
                            "void BLERemoteDescriptor::writeValue(uint8_t* data, size_t length, bool response) {",
                            "\tESP_LOGD(LOG_TAG, \">> writeValue: %s\", toString().c_str());",
                            "\tif (!getRemoteCharacteristic()->getRemoteService()->getClient()->isConnected()) {",
                            "\t\tESP_LOGE(LOG_TAG, \"Disconnected\");",
                            "\t\tthrow BLEDisconnectedException();",
                            "\t}",
                            "",
                            "\tesp_err_t errRc = ::esp_ble_gattc_write_char_descr(",
                            "\t\tm_pRemoteCharacteristic->getRemoteService()->getClient()->getGattcIf(),",
                            "\t\tm_pRemoteCharacteristic->getRemoteService()->getClient()->getConnId(),",
                            "\t\tgetHandle(),",
                            "\t\tresponse ? ESP_GATT_WRITE_TYPE_RSP : ESP_GATT_WRITE_TYPE_NO_RSP,",
                            "\t\tESP_GATT_AUTH_REQ_NONE",
                            "\t);",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_write_char_descr: %d\", errRc);",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< writeValue\");",
                            "",
                            "",
                            "/**",
                            " * @brief Write data represented as a string to the BLE Remote Descriptor.",
                            " * @param [in] newValue The data to send to the remote descriptor.",
                            " * @param [in] response True if we expect a response.",
                            " */",
                            "void BLERemoteDescriptor::writeValue(std::string newValue, bool response) {",
                            "\twriteValue((uint8_t*) newValue.data(), newValue.length(), response);",
                            "",
                            "",
                            "/**",
                            " * @brief Write a byte value to the Descriptor.",
                            " * @param [in] The single byte to write.",
                            " * @param [in] True if we expect a response.",
                            " */",
                            "void BLERemoteDescriptor::writeValue(uint8_t newValue, bool response) {",
                            "\twriteValue(&newValue, 1, response);",
                            "",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "40": "} // getHandle",
                "49": "} // getRemoteCharacteristic",
                "58": "} // getUUID",
                "64": "\t// Check to see that we are connected.",
                "72": "\t// Ask the BLE subsystem to retrieve the value for the remote hosted characteristic.",
                "75": "\t\tm_pRemoteCharacteristic->getRemoteService()->getClient()->getConnId(),    // The connection ID to the BLE server",
                "76": "\t\tgetHandle(),                                   // The handle of this characteristic",
                "77": "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security",
                "84": "\t// Block waiting for the event that indicates that the read has completed.  When it has, the std::string found",
                "85": "\t// in m_value will contain our data.",
                "90": "} // readValue",
                "99": "} // readUInt8",
                "108": "} // readUInt16",
                "117": "} // readUInt32",
                "128": "} // toString",
                "139": "\t// Check to see that we are connected.",
                "149": "\t\tlength,                           // Data length",
                "150": "\t\tdata,                             // Data",
                "158": "} // writeValue",
                "168": "} // writeValue",
                "178": "} // writeValue"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "c2b37d95e0924640e2c278c7bf439503ecad9d5f",
            "timestamp": "2020-01-20T15:40:13+02:00",
            "author": "lj",
            "commit_message": "Updated BLERemoteCharacteristic to exposre esp_gatt_auth_req_t parame\u2026 (#3531)\n\n* Updated BLERemoteCharacteristic to exposre esp_gatt_auth_req_t parameter for readValue and writeValue.\r\n\r\n* Updated BLERemoteCharacteristic/Descriptor to expose a setAuth method to allow tweaking the authentication request type for that remotecharacteristic/descriptor without the need to add auth on each read/write.",
            "additions": 10,
            "deletions": 2,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            69
                        ],
                        "comments": [
                            "\t\tm_auth);                       // Security"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            147
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tm_auth"
                        ]
                    },
                    {
                        "line_numbers": [
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181
                        ],
                        "comments": [],
                        "lines": [
                            "/**",
                            " * @brief Set authentication request type for characteristic",
                            " * @param [in] auth Authentication request type.",
                            " */",
                            "void BLERemoteDescriptor::setAuth(esp_gatt_auth_req_t auth) {",
                            "    m_auth = auth;",
                            "}"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            68
                        ],
                        "comments": [
                            "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            146
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_GATT_AUTH_REQ_NONE"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "69": "\t\tm_auth);                       // Security"
            },
            "comment_deleted_diff": {
                "68": "\t\tESP_GATT_AUTH_REQ_NONE);                       // Security"
            },
            "comment_modified_diff": {}
        }
    ],
    "BLERemoteDescriptor.h": [],
    "BLERemoteService.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 340,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340
                        ],
                        "comments": [
                            "} // compareSrvcId",
                            "\t\t// ESP_GATTC_GET_CHAR_EVT",
                            "\t\t// get_char:",
                            "\t\t// - esp_gatt_status_t    status",
                            "\t\t// - uin1t6_t             conn_id",
                            "\t\t// - esp_gatt_srvc_id_t   srvc_id",
                            "\t\t// - esp_gatt_id_t        char_id",
                            "\t\t// - esp_gatt_char_prop_t char_prop",
                            "\t\t\t// Is this event for this service?  If yes, then the local srvc_id and the event srvc_id will be",
                            "\t\t\t// the same.",
                            "\t\t\t// If the status is NOT OK then we have a problem and continue.",
                            "\t\t\t// This is an indication that we now have the characteristic details for a characteristic owned",
                            "\t\t\t// by this service so remember it.",
                            "\t\t\t// Now that we have received a characteristic, lets ask for the next one.",
                            "\t\t} // ESP_GATTC_GET_CHAR_EVT",
                            "\t} // switch",
                            "\t// Send the event to each of the characteristics owned by this service.",
                            "} // gattClientEventHandler",
                            "} // getCharacteristic",
                            "// Design",
                            "// ------",
                            "// We wish to retrieve the characteristic given its UUID.  It is possible that we have not yet asked the",
                            "// device what characteristics it has in which case we have nothing to match against.  If we have not",
                            "// asked the device about its characteristics, then we do that now.  Once we get the results we can then",
                            "// examine the characteristics map to see if it has the characteristic we are looking for.",
                            "\t// throw new BLEUuidNotFoundException();  // <-- we dont want exception here, which will cause app crash, we want to search if any characteristic can be found one after another",
                            "} // getCharacteristic",
                            "\tremoveCharacteristics(); // Forget any previous characteristics.",
                            "\t\tuint16_t count = 10;  // this value is used as in parameter that allows to search max 10 chars with the same uuid",
                            "\t\tif (status == ESP_GATT_INVALID_OFFSET) {   // We have reached the end of the entries.",
                            "\t\tif (status != ESP_GATT_OK) {   // If we got an error, end.",
                            "\t\tif (count == 0) {   // If we failed to get any new records, end.",
                            "\t\t// We now have a new characteristic ... let us add that to our set of known characteristics",
                            "\t\toffset++;   // Increment our count of number of descriptors found.",
                            "\t} // Loop forever (until we break inside the loop).",
                            "\tm_haveCharacteristics = true; // Remember that we have received the characteristics.",
                            "} // getCharacteristics",
                            "\t// If is possible that we have not read the characteristics associated with the service so do that",
                            "\t// now.  The request to retrieve the characteristics by calling \"retrieveCharacteristics\" is a blocking",
                            "\t// call and does not return until all the characteristics are available.",
                            "} // getCharacteristics",
                            "}  // Get the characteristics map.",
                            "} // getClient",
                            "} // getEndHandle",
                            "} // getSrvcId",
                            "} // getStartHandle",
                            "} // getHandle",
                            "} // readValue",
                            "\t   //m_characteristicMap.erase(myPair.first);  // Should be no need to delete as it will be deleted by the clear",
                            "\tm_characteristicMap.clear();   // Clear the map",
                            "\tm_characteristicMapByHandle.clear();   // Clear the map",
                            "} // removeCharacteristics",
                            "} // setValue",
                            "\t   // myPair.second is the value",
                            "} // toString"
                        ],
                        "lines": [
                            "*/",
                            "",
                            "/**",
                            " * @brief Handle GATT Client events",
                            " */",
                            "void BLERemoteService::gattClientEventHandler(",
                            "\tesp_gattc_cb_event_t      event,",
                            "\tesp_gatt_if_t             gattc_if,",
                            "\tesp_ble_gattc_cb_param_t* evtParam) {",
                            "\tswitch (event) {",
                            "\t\t//",
                            "\t\t//",
                            "\t\t//",
                            "\t/*",
                            "\t\tcase ESP_GATTC_GET_CHAR_EVT: {",
                            "\t\t\tif (compareSrvcId(m_srvcId, evtParam->get_char.srvc_id) == false) {",
                            "\t\t\t\tbreak;",
                            "\t\t\t}",
                            "",
                            "\t\t\tif (evtParam->get_char.status != ESP_GATT_OK) {",
                            "\t\t\t\tm_semaphoreGetCharEvt.give();",
                            "\t\t\t\tbreak;",
                            "\t\t\t}",
                            "",
                            "\t\t\tm_characteristicMap.insert(std::pair<std::string, BLERemoteCharacteristic*>(",
                            "\t\t\t\t\tBLEUUID(evtParam->get_char.char_id.uuid).toString(),",
                            "\t\t\t\t\tnew BLERemoteCharacteristic(evtParam->get_char.char_id, evtParam->get_char.char_prop, this)\t));",
                            "",
                            "",
                            "\t\t\tesp_err_t errRc = ::esp_ble_gattc_get_characteristic(",
                            "\t\t\t\t\tm_pClient->getGattcIf(),",
                            "\t\t\t\t\tm_pClient->getConnId(),",
                            "\t\t\t\t\t&m_srvcId,",
                            "\t\t\t\t\t&evtParam->get_char.char_id);",
                            "\t\t\tif (errRc != ESP_OK) {",
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_get_characteristic: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\t\t\tbreak;",
                            "\t\t\t}",
                            "",
                            "\t\t\t//m_semaphoreGetCharEvt.give();",
                            "\t\t\tbreak;",
                            "*/",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "",
                            "\tfor (auto &myPair : m_characteristicMapByHandle) {",
                            "\t   myPair.second->gattClientEventHandler(event, gattc_if, evtParam);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Get the remote characteristic object for the characteristic UUID.",
                            " * @param [in] uuid Remote characteristic uuid.",
                            " * @return Reference to the remote characteristic object.",
                            " * @throws BLEUuidNotFoundException",
                            " */",
                            "BLERemoteCharacteristic* BLERemoteService::getCharacteristic(const char* uuid) {",
                            "    return getCharacteristic(BLEUUID(uuid));",
                            "",
                            "/**",
                            " * @brief Get the characteristic object for the UUID.",
                            " * @param [in] uuid Characteristic uuid.",
                            " * @return Reference to the characteristic object.",
                            " * @throws BLEUuidNotFoundException",
                            " */",
                            "BLERemoteCharacteristic* BLERemoteService::getCharacteristic(BLEUUID uuid) {",
                            "\tif (!m_haveCharacteristics) {",
                            "\t\tretrieveCharacteristics();",
                            "\t}",
                            "\tstd::string v = uuid.toString();",
                            "\tfor (auto &myPair : m_characteristicMap) {",
                            "\t\tif (myPair.first == v) {",
                            "\t\t\treturn myPair.second;",
                            "\t\t}",
                            "\t}",
                            "\treturn nullptr;",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve all the characteristics for this service.",
                            " * This function will not return until we have all the characteristics.",
                            " * @return N/A",
                            " */",
                            "void BLERemoteService::retrieveCharacteristics() {",
                            "\tESP_LOGD(LOG_TAG, \">> getCharacteristics() for service: %s\", getUUID().toString().c_str());",
                            "",
                            "",
                            "\tuint16_t offset = 0;",
                            "\tesp_gattc_char_elem_t result;",
                            "\twhile (true) {",
                            "\t\tesp_gatt_status_t status = ::esp_ble_gattc_get_all_char(",
                            "\t\t\tgetClient()->getGattcIf(),",
                            "\t\t\tgetClient()->getConnId(),",
                            "\t\t\tm_startHandle,",
                            "\t\t\tm_endHandle,",
                            "\t\t\t&result,",
                            "\t\t\t&count,",
                            "\t\t\toffset",
                            "\t\t);",
                            "",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_get_all_char: %s\", BLEUtils::gattStatusToString(status).c_str());",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tESP_LOGD(LOG_TAG, \"Found a characteristic: Handle: %d, UUID: %s\", result.char_handle, BLEUUID(result.uuid).toString().c_str());",
                            "",
                            "\t\tBLERemoteCharacteristic *pNewRemoteCharacteristic = new BLERemoteCharacteristic(",
                            "\t\t\tresult.char_handle,",
                            "\t\t\tBLEUUID(result.uuid),",
                            "\t\t\tresult.properties,",
                            "\t\t\tthis",
                            "\t\t);",
                            "",
                            "\t\tm_characteristicMap.insert(std::pair<std::string, BLERemoteCharacteristic*>(pNewRemoteCharacteristic->getUUID().toString(), pNewRemoteCharacteristic));",
                            "\t\tm_characteristicMapByHandle.insert(std::pair<uint16_t, BLERemoteCharacteristic*>(result.char_handle, pNewRemoteCharacteristic));",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< getCharacteristics()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Retrieve a map of all the characteristics of this service.",
                            " * @return A map of all the characteristics of this service.",
                            " */",
                            "std::map<std::string, BLERemoteCharacteristic*>* BLERemoteService::getCharacteristics() {",
                            "\tESP_LOGD(LOG_TAG, \">> getCharacteristics() for service: %s\", getUUID().toString().c_str());",
                            "\tif (!m_haveCharacteristics) {",
                            "\t\tretrieveCharacteristics();",
                            "\t}",
                            "\tESP_LOGD(LOG_TAG, \"<< getCharacteristics() for service: %s\", getUUID().toString().c_str());",
                            "\treturn &m_characteristicMap;",
                            "",
                            "/**",
                            " * @brief This function is designed to get characteristics map when we have multiple characteristics with the same UUID",
                            " */",
                            "void BLERemoteService::getCharacteristics(std::map<uint16_t, BLERemoteCharacteristic*>* pCharacteristicMap) {",
                            "#pragma GCC diagnostic ignored \"-Wunused-but-set-parameter\"",
                            "\tpCharacteristicMap = &m_characteristicMapByHandle;",
                            "",
                            "/**",
                            " * @brief Get the client associated with this service.",
                            " * @return A reference to the client associated with this service.",
                            " */",
                            "BLEClient* BLERemoteService::getClient() {",
                            "\treturn m_pClient;",
                            "",
                            "",
                            "uint16_t BLERemoteService::getEndHandle() {",
                            "\treturn m_endHandle;",
                            "",
                            "",
                            "esp_gatt_id_t* BLERemoteService::getSrvcId() {",
                            "\treturn &m_srvcId;",
                            "",
                            "",
                            "uint16_t BLERemoteService::getStartHandle() {",
                            "\treturn m_startHandle;",
                            "",
                            "",
                            "uint16_t BLERemoteService::getHandle() {",
                            "\tESP_LOGD(LOG_TAG, \">> getHandle: service: %s\", getUUID().toString().c_str());",
                            "\tESP_LOGD(LOG_TAG, \"<< getHandle: %d 0x%.2x\", getStartHandle(), getStartHandle());",
                            "\treturn getStartHandle();",
                            "",
                            "",
                            "BLEUUID BLERemoteService::getUUID() {",
                            "\treturn m_uuid;",
                            "}",
                            "",
                            "/**",
                            " * @brief Read the value of a characteristic associated with this service.",
                            " */",
                            "std::string BLERemoteService::getValue(BLEUUID characteristicUuid) {",
                            "\tESP_LOGD(LOG_TAG, \">> readValue: uuid: %s\", characteristicUuid.toString().c_str());",
                            "\tstd::string ret =  getCharacteristic(characteristicUuid)->readValue();",
                            "\tESP_LOGD(LOG_TAG, \"<< readValue\");",
                            "\treturn ret;",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Delete the characteristics in the characteristics map.",
                            " * We maintain a map called m_characteristicsMap that contains pointers to BLERemoteCharacteristic",
                            " * object references.  Since we allocated these in this class, we are also responsible for deleteing",
                            " * them.  This method does just that.",
                            " * @return N/A.",
                            " */",
                            "void BLERemoteService::removeCharacteristics() {",
                            "\tfor (auto &myPair : m_characteristicMap) {",
                            "\t   delete myPair.second;",
                            "\t}",
                            "\tfor (auto &myPair : m_characteristicMapByHandle) {",
                            "\t   delete myPair.second;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the value of a characteristic.",
                            " * @param [in] characteristicUuid The characteristic to set.",
                            " * @param [in] value The value to set.",
                            " * @throws BLEUuidNotFound",
                            " */",
                            "void BLERemoteService::setValue(BLEUUID characteristicUuid, std::string value) {",
                            "\tESP_LOGD(LOG_TAG, \">> setValue: uuid: %s\", characteristicUuid.toString().c_str());",
                            "\tgetCharacteristic(characteristicUuid)->writeValue(value);",
                            "\tESP_LOGD(LOG_TAG, \"<< setValue\");",
                            "",
                            "",
                            "/**",
                            " * @brief Create a string representation of this remote service.",
                            " * @return A string representation of this remote service.",
                            " */",
                            "std::string BLERemoteService::toString() {",
                            "\tstd::ostringstream ss;",
                            "\tss << \"Service: uuid: \" + m_uuid.toString();",
                            "\tss << \", start_handle: \" << std::dec << m_startHandle << \" 0x\" << std::hex << m_startHandle <<",
                            "\t\t\t\", end_handle: \" << std::dec << m_endHandle << \" 0x\" << std::hex << m_endHandle;",
                            "\tfor (auto &myPair : m_characteristicMap) {",
                            "\t\tss << \"\\n\" << myPair.second->toString();",
                            "\t}",
                            "\treturn ss.str();",
                            "",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "57": "} // compareSrvcId",
                "69": "\t\t// ESP_GATTC_GET_CHAR_EVT",
                "71": "\t\t// get_char:",
                "72": "\t\t// - esp_gatt_status_t    status",
                "73": "\t\t// - uin1t6_t             conn_id",
                "74": "\t\t// - esp_gatt_srvc_id_t   srvc_id",
                "75": "\t\t// - esp_gatt_id_t        char_id",
                "76": "\t\t// - esp_gatt_char_prop_t char_prop",
                "80": "\t\t\t// Is this event for this service?  If yes, then the local srvc_id and the event srvc_id will be",
                "81": "\t\t\t// the same.",
                "86": "\t\t\t// If the status is NOT OK then we have a problem and continue.",
                "92": "\t\t\t// This is an indication that we now have the characteristic details for a characteristic owned",
                "93": "\t\t\t// by this service so remember it.",
                "99": "\t\t\t// Now that we have received a characteristic, lets ask for the next one.",
                "112": "\t\t} // ESP_GATTC_GET_CHAR_EVT",
                "116": "\t} // switch",
                "118": "\t// Send the event to each of the characteristics owned by this service.",
                "122": "} // gattClientEventHandler",
                "133": "} // getCharacteristic",
                "142": "// Design",
                "143": "// ------",
                "144": "// We wish to retrieve the characteristic given its UUID.  It is possible that we have not yet asked the",
                "145": "// device what characteristics it has in which case we have nothing to match against.  If we have not",
                "146": "// asked the device about its characteristics, then we do that now.  Once we get the results we can then",
                "147": "// examine the characteristics map to see if it has the characteristic we are looking for.",
                "157": "\t// throw new BLEUuidNotFoundException();  // <-- we dont want exception here, which will cause app crash, we want to search if any characteristic can be found one after another",
                "159": "} // getCharacteristic",
                "170": "\tremoveCharacteristics(); // Forget any previous characteristics.",
                "175": "\t\tuint16_t count = 10;  // this value is used as in parameter that allows to search max 10 chars with the same uuid",
                "186": "\t\tif (status == ESP_GATT_INVALID_OFFSET) {   // We have reached the end of the entries.",
                "190": "\t\tif (status != ESP_GATT_OK) {   // If we got an error, end.",
                "195": "\t\tif (count == 0) {   // If we failed to get any new records, end.",
                "201": "\t\t// We now have a new characteristic ... let us add that to our set of known characteristics",
                "211": "\t\toffset++;   // Increment our count of number of descriptors found.",
                "212": "\t} // Loop forever (until we break inside the loop).",
                "214": "\tm_haveCharacteristics = true; // Remember that we have received the characteristics.",
                "216": "} // getCharacteristics",
                "225": "\t// If is possible that we have not read the characteristics associated with the service so do that",
                "226": "\t// now.  The request to retrieve the characteristics by calling \"retrieveCharacteristics\" is a blocking",
                "227": "\t// call and does not return until all the characteristics are available.",
                "233": "} // getCharacteristics",
                "241": "}  // Get the characteristics map.",
                "249": "} // getClient",
                "254": "} // getEndHandle",
                "259": "} // getSrvcId",
                "264": "} // getStartHandle",
                "271": "} // getHandle",
                "286": "} // readValue",
                "300": "\t   //m_characteristicMap.erase(myPair.first);  // Should be no need to delete as it will be deleted by the clear",
                "302": "\tm_characteristicMap.clear();   // Clear the map",
                "306": "\tm_characteristicMapByHandle.clear();   // Clear the map",
                "307": "} // removeCharacteristics",
                "320": "} // setValue",
                "334": "\t   // myPair.second is the value",
                "337": "} // toString"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "a12d609b221ce339de092cfe096c6bef7542c943",
            "timestamp": "2019-08-20T16:38:59+03:00",
            "author": "Arjan Mels",
            "commit_message": "Corrected count of characteristics to get (#3082)\n\nOnly space for 1 characteristic is allocated, requesting 10 leads to stack corruption.",
            "additions": 1,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            167
                        ],
                        "comments": [
                            "\t\tuint16_t count = 1; // only room for 1 result allocated, so go one by one"
                        ],
                        "lines": []
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            167
                        ],
                        "comments": [
                            "\t\tuint16_t count = 10;  // this value is used as in parameter that allows to search max 10 chars with the same uuid"
                        ],
                        "lines": []
                    }
                ]
            },
            "comment_added_diff": {
                "167": "\t\tuint16_t count = 1; // only room for 1 result allocated, so go one by one"
            },
            "comment_deleted_diff": {
                "167": "\t\tuint16_t count = 10;  // this value is used as in parameter that allows to search max 10 chars with the same uuid"
            },
            "comment_modified_diff": {
                "167": "\t\tuint16_t count = 10;  // this value is used as in parameter that allows to search max 10 chars with the same uuid"
            }
        },
        {
            "commit": "64cfb33deb63a5cda3c994190fdb03ae41119081",
            "timestamp": "2019-10-01T11:43:59+03:00",
            "author": "TANAKA Masayuki",
            "commit_message": "Add Added unimplemented getCharacteristicsByHandle function (#3277)\n\n* Add Added unimplemented getCharacteristicsByHandle function\r\n\r\nDefined in BLERemoteService.h\r\nBut, Not included in BLERemoteService.cpp\r\n\r\n* Delete log output",
            "additions": 14,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242
                        ],
                        "comments": [
                            "\t// If is possible that we have not read the characteristics associated with the service so do that",
                            "\t// now.  The request to retrieve the characteristics by calling \"retrieveCharacteristics\" is a blocking",
                            "\t// call and does not return until all the characteristics are available.",
                            "} // getCharacteristicsByHandle"
                        ],
                        "lines": [
                            "\tif (!m_haveCharacteristics) {",
                            "\t\tretrieveCharacteristics();",
                            "\t}",
                            "\treturn &m_characteristicMapByHandle;",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "234": "\t// If is possible that we have not read the characteristics associated with the service so do that",
                "235": "\t// now.  The request to retrieve the characteristics by calling \"retrieveCharacteristics\" is a blocking",
                "236": "\t// call and does not return until all the characteristics are available.",
                "241": "} // getCharacteristicsByHandle"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "5999b7ba4686bf8a4fad30fa09801a32d0dafd80",
            "timestamp": "2020-09-30T14:25:31+03:00",
            "author": "crnchbng",
            "commit_message": "removed double delete of characteristics (#3521)",
            "additions": 1,
            "deletions": 4,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            308
                        ],
                        "comments": [
                            "\t   // delete the characteristics only once"
                        ],
                        "lines": []
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            307,
                            308
                        ],
                        "comments": [
                            "\t   //m_characteristicMap.erase(myPair.first);  // Should be no need to delete as it will be deleted by the clear"
                        ],
                        "lines": [
                            "\t}"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "308": "\t   // delete the characteristics only once"
            },
            "comment_deleted_diff": {
                "307": "\t   //m_characteristicMap.erase(myPair.first);  // Should be no need to delete as it will be deleted by the clear"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "675a40b25790901a906b5ead57730b3053cc8d00",
            "timestamp": "2020-10-03T03:41:03+03:00",
            "author": "TANAKA Masayuki",
            "commit_message": "Fix Not by reference. But the value was updated. (#3279)",
            "additions": 9,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255
                        ],
                        "comments": [
                            "\t// If is possible that we have not read the characteristics associated with the service so do that",
                            "\t// now.  The request to retrieve the characteristics by calling \"retrieveCharacteristics\" is a blocking",
                            "\t// call and does not return until all the characteristics are available."
                        ],
                        "lines": [
                            "\tif (!m_haveCharacteristics) {",
                            "\t\tretrieveCharacteristics();",
                            "\t}",
                            "\tlog_v(\"<< getCharacteristics() for service: %s\", getUUID().toString().c_str());",
                            "\t*pCharacteristicMap = m_characteristicMapByHandle;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "248": "\t// If is possible that we have not read the characteristics associated with the service so do that",
                "249": "\t// now.  The request to retrieve the characteristics by calling \"retrieveCharacteristics\" is a blocking",
                "250": "\t// call and does not return until all the characteristics are available."
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLERemoteService.h": [],
    "BLEScan.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 331,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331
                        ],
                        "comments": [
                            "\tm_scan_params.scan_type          = BLE_SCAN_TYPE_PASSIVE; // Default is a passive scan.",
                            "} // BLEScan",
                            "\t\t// ---------------------------",
                            "\t\t// scan_rst:",
                            "\t\t// esp_gap_search_evt_t search_evt",
                            "\t\t// esp_bd_addr_t bda",
                            "\t\t// esp_bt_dev_type_t dev_type",
                            "\t\t// esp_ble_addr_type_t ble_addr_type",
                            "\t\t// esp_ble_evt_type_t ble_evt_type",
                            "\t\t// int rssi",
                            "\t\t// uint8_t ble_adv[ESP_BLE_ADV_DATA_LEN_MAX]",
                            "\t\t// int flag",
                            "\t\t// int num_resps",
                            "\t\t// uint8_t adv_data_len",
                            "\t\t// uint8_t scan_rsp_len",
                            "\t\t\t\t// ESP_GAP_SEARCH_INQ_CMPL_EVT",
                            "\t\t\t\t// Event that indicates that the duration allowed for the search has completed or that we have been",
                            "\t\t\t\t// asked to stop.",
                            "\t\t\t\t} // ESP_GAP_SEARCH_INQ_CMPL_EVT",
                            "\t\t\t\t// ESP_GAP_SEARCH_INQ_RES_EVT",
                            "\t\t\t\t// Result that has arrived back from a Scan inquiry.",
                            "\t\t\t\t\tif (m_stopped) { // If we are not scanning, nothing to do with the extra results.",
                            "// Examine our list of previously scanned addresses and, if we found this one already,",
                            "// ignore it.",
                            "\t\t\t\t\tif (found && !m_wantDuplicates) {  // If we found a previous entry AND we don't want duplicates, then we are done.",
                            "\t\t\t\t\t\tvTaskDelay(1);  // <--- allow to switch task in case we scan infinity and dont have new devices to report, or we are blocked here",
                            "\t\t\t\t\t// We now construct a model of the advertised device that we have just found for the first",
                            "\t\t\t\t\t// time.",
                            "\t\t\t\t\t// ESP_LOG_BUFFER_HEXDUMP(LOG_TAG, (uint8_t*)param->scan_rst.ble_adv, param->scan_rst.adv_data_len + param->scan_rst.scan_rsp_len, ESP_LOG_DEBUG);",
                            "\t\t\t\t\t// ESP_LOGW(LOG_TAG, \"bytes length: %d + %d, addr type: %d\", param->scan_rst.adv_data_len, param->scan_rst.scan_rsp_len, param->scan_rst.ble_addr_type);",
                            "\t\t\t\t\tif (!found) {   // If we have previously seen this device, don't record it again.",
                            "\t\t\t\t} // ESP_GAP_SEARCH_INQ_RES_EVT",
                            "\t\t\t} // switch - search_evt",
                            "\t\t} // ESP_GAP_BLE_SCAN_RESULT_EVT",
                            "\t\t} // default",
                            "\t} // End switch",
                            "} // gapEventHandler",
                            "} // setActiveScan",
                            "} // setAdvertisedDeviceCallbacks",
                            "} // setInterval",
                            "} // setWindow",
                            "\tm_scanCompleteCB = scanCompleteCB;                  // Save the callback to be invoked when the scan completes.",
                            "\t//  if we are connecting to devices that are advertising even after being connected, multiconnecting peripherals",
                            "\t//  then we should not clear map or we will connect the same device few times",
                            "} // start",
                            "\t\tm_semaphoreScanEnd.wait(\"start\");   // Wait for the semaphore to release.",
                            "} // start",
                            "} // stop",
                            "// delete peer device from cache after disconnecting, it is required in case we are connecting to devices with not public address",
                            "} // dump",
                            "} // getCount"
                        ],
                        "lines": [
                            "\tm_scan_params.own_addr_type      = BLE_ADDR_TYPE_PUBLIC;",
                            "\tm_scan_params.scan_filter_policy = BLE_SCAN_FILTER_ALLOW_ALL;",
                            "\tm_pAdvertisedDeviceCallbacks     = nullptr;",
                            "\tm_stopped                        = true;",
                            "\tm_wantDuplicates                 = false;",
                            "\tsetInterval(100);",
                            "\tsetWindow(100);",
                            "",
                            "",
                            "/**",
                            " * @brief Handle GAP events related to scans.",
                            " * @param [in] event The event type for this event.",
                            " * @param [in] param Parameter data for this event.",
                            " */",
                            "void BLEScan::handleGAPEvent(",
                            "\tesp_gap_ble_cb_event_t  event,",
                            "\tesp_ble_gap_cb_param_t* param) {",
                            "",
                            "\tswitch(event) {",
                            "",
                            "\t\tcase ESP_GAP_BLE_SCAN_RESULT_EVT: {",
                            "",
                            "\t\t\tswitch(param->scan_rst.search_evt) {",
                            "\t\t\t\t//",
                            "\t\t\t\t//",
                            "\t\t\t\tcase ESP_GAP_SEARCH_INQ_CMPL_EVT: {",
                            "\t\t\t\t\tESP_LOGW(LOG_TAG, \"ESP_GAP_SEARCH_INQ_CMPL_EVT\");",
                            "\t\t\t\t\tm_stopped = true;",
                            "\t\t\t\t\tm_semaphoreScanEnd.give();",
                            "\t\t\t\t\tif (m_scanCompleteCB != nullptr) {",
                            "\t\t\t\t\t\tm_scanCompleteCB(m_scanResults);",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\t//",
                            "\t\t\t\t//",
                            "\t\t\t\tcase ESP_GAP_SEARCH_INQ_RES_EVT: {",
                            "\t\t\t\t\t\tbreak;",
                            "\t\t\t\t\t}",
                            "",
                            "\t\t\t\t\tBLEAddress advertisedAddress(param->scan_rst.bda);",
                            "\t\t\t\t\tbool found = false;",
                            "",
                            "\t\t\t\t\tif (m_scanResults.m_vectorAdvertisedDevices.count(advertisedAddress.toString()) != 0) {",
                            "\t\t\t\t\t\tfound = true;",
                            "\t\t\t\t\t}",
                            "",
                            "\t\t\t\t\t\tESP_LOGD(LOG_TAG, \"Ignoring %s, already seen it.\", advertisedAddress.toString().c_str());",
                            "\t\t\t\t\t\tbreak;",
                            "\t\t\t\t\t}",
                            "",
                            "\t\t\t\t\tBLEAdvertisedDevice *advertisedDevice = new BLEAdvertisedDevice();",
                            "\t\t\t\t\tadvertisedDevice->setAddress(advertisedAddress);",
                            "\t\t\t\t\tadvertisedDevice->setRSSI(param->scan_rst.rssi);",
                            "\t\t\t\t\tadvertisedDevice->setAdFlag(param->scan_rst.flag);",
                            "\t\t\t\t\tadvertisedDevice->parseAdvertisement((uint8_t*)param->scan_rst.ble_adv, param->scan_rst.adv_data_len + param->scan_rst.scan_rsp_len);",
                            "\t\t\t\t\tadvertisedDevice->setScan(this);",
                            "\t\t\t\t\tadvertisedDevice->setAddressType(param->scan_rst.ble_addr_type);",
                            "",
                            "\t\t\t\t\t\tm_scanResults.m_vectorAdvertisedDevices.insert(std::pair<std::string, BLEAdvertisedDevice*>(advertisedAddress.toString(), advertisedDevice));",
                            "\t\t\t\t\t}",
                            "",
                            "\t\t\t\t\tif (m_pAdvertisedDeviceCallbacks) {",
                            "\t\t\t\t\t\tm_pAdvertisedDeviceCallbacks->onResult(*advertisedDevice);",
                            "\t\t\t\t\t}",
                            "\t\t\t\t\tif(found)",
                            "\t\t\t\t\t\tdelete advertisedDevice;",
                            "",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\tdefault: {",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t}",
                            "",
                            "",
                            "\t\t\tbreak;",
                            "",
                            "\t\tdefault: {",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "/**",
                            " * @brief Should we perform an active or passive scan?",
                            " * The default is a passive scan.  An active scan means that we will wish a scan response.",
                            " * @param [in] active If true, we perform an active scan otherwise a passive scan.",
                            " * @return N/A.",
                            " */",
                            "void BLEScan::setActiveScan(bool active) {",
                            "\tif (active) {",
                            "\t\tm_scan_params.scan_type = BLE_SCAN_TYPE_ACTIVE;",
                            "\t} else {",
                            "\t\tm_scan_params.scan_type = BLE_SCAN_TYPE_PASSIVE;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Set the call backs to be invoked.",
                            " * @param [in] pAdvertisedDeviceCallbacks Call backs to be invoked.",
                            " * @param [in] wantDuplicates  True if we wish to be called back with duplicates.  Default is false.",
                            " */",
                            "void BLEScan::setAdvertisedDeviceCallbacks(BLEAdvertisedDeviceCallbacks* pAdvertisedDeviceCallbacks, bool wantDuplicates) {",
                            "\tm_wantDuplicates = wantDuplicates;",
                            "\tm_pAdvertisedDeviceCallbacks = pAdvertisedDeviceCallbacks;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the interval to scan.",
                            " * @param [in] The interval in msecs.",
                            " */",
                            "void BLEScan::setInterval(uint16_t intervalMSecs) {",
                            "\tm_scan_params.scan_interval = intervalMSecs / 0.625;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the window to actively scan.",
                            " * @param [in] windowMSecs How long to actively scan.",
                            " */",
                            "void BLEScan::setWindow(uint16_t windowMSecs) {",
                            "\tm_scan_params.scan_window = windowMSecs / 0.625;",
                            "",
                            "",
                            "/**",
                            " * @brief Start scanning.",
                            " * @param [in] duration The duration in seconds for which to scan.",
                            " * @param [in] scanCompleteCB A function to be called when scanning has completed.",
                            " * @param [in] are we continue scan (true) or we want to clear stored devices (false)",
                            " * @return True if scan started or false if there was an error.",
                            " */",
                            "bool BLEScan::start(uint32_t duration, void (*scanCompleteCB)(BLEScanResults), bool is_continue) {",
                            "\tESP_LOGD(LOG_TAG, \">> start(duration=%d)\", duration);",
                            "",
                            "\tm_semaphoreScanEnd.take(std::string(\"start\"));",
                            "",
                            "\tif(!is_continue) {",
                            "\t\tfor(auto _dev : m_scanResults.m_vectorAdvertisedDevices){",
                            "\t\t\tdelete _dev.second;",
                            "\t\t}",
                            "\t\tm_scanResults.m_vectorAdvertisedDevices.clear();",
                            "\t}",
                            "",
                            "\tesp_err_t errRc = ::esp_ble_gap_set_scan_params(&m_scan_params);",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_set_scan_params: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\tm_semaphoreScanEnd.give();",
                            "\t\treturn false;",
                            "\t}",
                            "",
                            "\terrRc = ::esp_ble_gap_start_scanning(duration);",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_start_scanning: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\tm_semaphoreScanEnd.give();",
                            "\t\treturn false;",
                            "\t}",
                            "",
                            "\tm_stopped = false;",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< start()\");",
                            "\treturn true;",
                            "",
                            "",
                            "/**",
                            " * @brief Start scanning and block until scanning has been completed.",
                            " * @param [in] duration The duration in seconds for which to scan.",
                            " * @return The BLEScanResults.",
                            " */",
                            "BLEScanResults BLEScan::start(uint32_t duration, bool is_continue) {",
                            "\tif(start(duration, nullptr, is_continue)) {",
                            "\t}",
                            "\treturn m_scanResults;",
                            "",
                            "",
                            "/**",
                            " * @brief Stop an in progress scan.",
                            " * @return N/A.",
                            " */",
                            "void BLEScan::stop() {",
                            "\tESP_LOGD(LOG_TAG, \">> stop()\");",
                            "",
                            "\tesp_err_t errRc = ::esp_ble_gap_stop_scanning();",
                            "",
                            "\tm_stopped = true;",
                            "\tm_semaphoreScanEnd.give();",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_stop_scanning: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< stop()\");",
                            "",
                            "void BLEScan::erase(BLEAddress address) {",
                            "\tESP_LOGI(LOG_TAG, \"erase device: %s\", address.toString().c_str());",
                            "\tBLEAdvertisedDevice *advertisedDevice = m_scanResults.m_vectorAdvertisedDevices.find(address.toString())->second;",
                            "\tm_scanResults.m_vectorAdvertisedDevices.erase(address.toString());",
                            "\tdelete advertisedDevice;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Dump the scan results to the log.",
                            " */",
                            "void BLEScanResults::dump() {",
                            "\tESP_LOGD(LOG_TAG, \">> Dump scan results:\");",
                            "\tfor (int i=0; i<getCount(); i++) {",
                            "\t\tESP_LOGD(LOG_TAG, \"- %s\", getDevice(i).toString().c_str());",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Return the count of devices found in the last scan.",
                            " * @return The number of devices found in the last scan.",
                            " */",
                            "int BLEScanResults::getCount() {",
                            "\treturn m_vectorAdvertisedDevices.size();",
                            "",
                            "",
                            "/**",
                            " * @brief Return the specified device at the given index.",
                            " * The index should be between 0 and getCount()-1.",
                            " * @param [in] i The index of the device.",
                            " * @return The device at the specified index.",
                            " */",
                            "BLEAdvertisedDevice BLEScanResults::getDevice(uint32_t i) {",
                            "\tuint32_t x = 0;",
                            "\tBLEAdvertisedDevice dev = *m_vectorAdvertisedDevices.begin()->second;",
                            "\tfor (auto it = m_vectorAdvertisedDevices.begin(); it != m_vectorAdvertisedDevices.end(); it++) {",
                            "\t\tdev = *it->second;",
                            "\t\tif (x==i)\tbreak;",
                            "\t\tx++;",
                            "\t}",
                            "\treturn dev;",
                            "}",
                            "",
                            "BLEScanResults BLEScan::getResults() {",
                            "\treturn m_scanResults;",
                            "}",
                            "",
                            "void BLEScan::clearResults() {",
                            "\tfor(auto _dev : m_scanResults.m_vectorAdvertisedDevices){",
                            "\t\tdelete _dev.second;",
                            "\t}",
                            "\tm_scanResults.m_vectorAdvertisedDevices.clear();",
                            "}",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "34": "\tm_scan_params.scan_type          = BLE_SCAN_TYPE_PASSIVE; // Default is a passive scan.",
                "42": "} // BLEScan",
                "56": "\t\t// ---------------------------",
                "57": "\t\t// scan_rst:",
                "58": "\t\t// esp_gap_search_evt_t search_evt",
                "59": "\t\t// esp_bd_addr_t bda",
                "60": "\t\t// esp_bt_dev_type_t dev_type",
                "61": "\t\t// esp_ble_addr_type_t ble_addr_type",
                "62": "\t\t// esp_ble_evt_type_t ble_evt_type",
                "63": "\t\t// int rssi",
                "64": "\t\t// uint8_t ble_adv[ESP_BLE_ADV_DATA_LEN_MAX]",
                "65": "\t\t// int flag",
                "66": "\t\t// int num_resps",
                "67": "\t\t// uint8_t adv_data_len",
                "68": "\t\t// uint8_t scan_rsp_len",
                "73": "\t\t\t\t// ESP_GAP_SEARCH_INQ_CMPL_EVT",
                "75": "\t\t\t\t// Event that indicates that the duration allowed for the search has completed or that we have been",
                "76": "\t\t\t\t// asked to stop.",
                "85": "\t\t\t\t} // ESP_GAP_SEARCH_INQ_CMPL_EVT",
                "88": "\t\t\t\t// ESP_GAP_SEARCH_INQ_RES_EVT",
                "90": "\t\t\t\t// Result that has arrived back from a Scan inquiry.",
                "92": "\t\t\t\t\tif (m_stopped) { // If we are not scanning, nothing to do with the extra results.",
                "96": "// Examine our list of previously scanned addresses and, if we found this one already,",
                "97": "// ignore it.",
                "105": "\t\t\t\t\tif (found && !m_wantDuplicates) {  // If we found a previous entry AND we don't want duplicates, then we are done.",
                "107": "\t\t\t\t\t\tvTaskDelay(1);  // <--- allow to switch task in case we scan infinity and dont have new devices to report, or we are blocked here",
                "111": "\t\t\t\t\t// We now construct a model of the advertised device that we have just found for the first",
                "112": "\t\t\t\t\t// time.",
                "113": "\t\t\t\t\t// ESP_LOG_BUFFER_HEXDUMP(LOG_TAG, (uint8_t*)param->scan_rst.ble_adv, param->scan_rst.adv_data_len + param->scan_rst.scan_rsp_len, ESP_LOG_DEBUG);",
                "114": "\t\t\t\t\t// ESP_LOGW(LOG_TAG, \"bytes length: %d + %d, addr type: %d\", param->scan_rst.adv_data_len, param->scan_rst.scan_rsp_len, param->scan_rst.ble_addr_type);",
                "123": "\t\t\t\t\tif (!found) {   // If we have previously seen this device, don't record it again.",
                "134": "\t\t\t\t} // ESP_GAP_SEARCH_INQ_RES_EVT",
                "139": "\t\t\t} // switch - search_evt",
                "143": "\t\t} // ESP_GAP_BLE_SCAN_RESULT_EVT",
                "147": "\t\t} // default",
                "148": "\t} // End switch",
                "149": "} // gapEventHandler",
                "164": "} // setActiveScan",
                "175": "} // setAdvertisedDeviceCallbacks",
                "184": "} // setInterval",
                "193": "} // setWindow",
                "207": "\tm_scanCompleteCB = scanCompleteCB;                  // Save the callback to be invoked when the scan completes.",
                "209": "\t//  if we are connecting to devices that are advertising even after being connected, multiconnecting peripherals",
                "210": "\t//  then we should not clear map or we will connect the same device few times",
                "238": "} // start",
                "248": "\t\tm_semaphoreScanEnd.wait(\"start\");   // Wait for the semaphore to release.",
                "251": "} // start",
                "272": "} // stop",
                "274": "// delete peer device from cache after disconnecting, it is required in case we are connecting to devices with not public address",
                "291": "} // dump",
                "300": "} // getCount"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d7ea7b80a7badbe30e6fb6f33f71375e0b133c",
            "timestamp": "2019-04-15T17:26:35+02:00",
            "author": "Bascy",
            "commit_message": "Refactored use of LOG_X(LOG_TAG, ...) to log_x(...) (#2672)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)\r\n\r\n* Change logging from Error to Verbose when not found and default available\r\n\r\n* Move Enter and Exit logging to Verbose Level\r\n\r\n* Refactored LOG_X() into log_x()",
            "additions": 14,
            "deletions": 23,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            104,
                            105
                        ],
                        "comments": [
                            "\t\t\t\t\t// ESP_LOG_BUFFER_HEXDUMP((uint8_t*)param->scan_rst.ble_adv, param->scan_rst.adv_data_len + param->scan_rst.scan_rsp_len, ESP_LOG_DEBUG);",
                            "\t\t\t\t\t// log_w(\"bytes length: %d + %d, addr type: %d\", param->scan_rst.adv_data_len, param->scan_rst.scan_rsp_len, param->scan_rst.ble_addr_type);"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            195
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> start(duration=%d)\", duration);"
                        ]
                    },
                    {
                        "line_numbers": [
                            212
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"esp_ble_gap_set_scan_params: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            220
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"esp_ble_gap_start_scanning: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            227
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< start()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            250
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> stop()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            258
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_e(\"esp_ble_gap_stop_scanning: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            262
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\"<< stop()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            267
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_i(\"erase device: %s\", address.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            278
                        ],
                        "comments": [],
                        "lines": [
                            "\tlog_v(\">> Dump scan results:\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            280
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tlog_d(\"- %s\", getDevice(i).toString().c_str());"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            113,
                            114
                        ],
                        "comments": [
                            "\t\t\t\t\t// ESP_LOG_BUFFER_HEXDUMP(LOG_TAG, (uint8_t*)param->scan_rst.ble_adv, param->scan_rst.adv_data_len + param->scan_rst.scan_rsp_len, ESP_LOG_DEBUG);",
                            "\t\t\t\t\t// ESP_LOGW(LOG_TAG, \"bytes length: %d + %d, addr type: %d\", param->scan_rst.adv_data_len, param->scan_rst.scan_rsp_len, param->scan_rst.ble_addr_type);"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            204
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> start(duration=%d)\", duration);"
                        ]
                    },
                    {
                        "line_numbers": [
                            221
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_set_scan_params: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            229
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_start_scanning: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            236
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< start()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            259
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> stop()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            267
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gap_stop_scanning: err: %d, text: %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            271
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< stop()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            276
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGI(LOG_TAG, \"erase device: %s\", address.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            287
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> Dump scan results:\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            289
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGD(LOG_TAG, \"- %s\", getDevice(i).toString().c_str());"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "104": "\t\t\t\t\t// ESP_LOG_BUFFER_HEXDUMP((uint8_t*)param->scan_rst.ble_adv, param->scan_rst.adv_data_len + param->scan_rst.scan_rsp_len, ESP_LOG_DEBUG);",
                "105": "\t\t\t\t\t// log_w(\"bytes length: %d + %d, addr type: %d\", param->scan_rst.adv_data_len, param->scan_rst.scan_rsp_len, param->scan_rst.ble_addr_type);"
            },
            "comment_deleted_diff": {
                "113": "\t\t\t\t\t// ESP_LOG_BUFFER_HEXDUMP(LOG_TAG, (uint8_t*)param->scan_rst.ble_adv, param->scan_rst.adv_data_len + param->scan_rst.scan_rsp_len, ESP_LOG_DEBUG);",
                "114": "\t\t\t\t\t// ESP_LOGW(LOG_TAG, \"bytes length: %d + %d, addr type: %d\", param->scan_rst.adv_data_len, param->scan_rst.scan_rsp_len, param->scan_rst.ble_addr_type);"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "82670b96f88e25e21dbeb09f7ee0dd9ab4f074d9",
            "timestamp": "2020-10-01T15:43:30+03:00",
            "author": "Jens Hauke",
            "commit_message": "Fix for missed scan response data (BLEScan). (#4358)\n\nThis is a fix for missing scan responses after a first successfull scan.\r\n\r\nWhile running the BLE_scan.ino sketch with wantDuplicates=false, i got\r\nonly one result with correct advertising and scan response length (31,26):\r\n\r\npBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks(), false);\r\npBLEScan->start(scanTime, false);\r\n...\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 31 + 26, addr type: 1\r\n\r\nAll following calls to start() just returned the advertising data without\r\nscan response data:\r\n\r\npBLEScan->start(scanTime, false);\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 31 + 0, addr type: 1\r\n\r\nWith \"wantDuplicates=true\" i got:\r\n\r\npBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks(), true);\r\npBLEScan->start(scanTime, false);\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 31 + 26, addr type: 1\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 31 + 26, addr type: 1\r\n[W][BLEScan.cpp:73] handleGAPEvent(): ESP_GAP_SEARCH_INQ_CMPL_EVT\r\nDevices found: 1\r\nScan done!\r\npBLEScan->start(scanTime, false);\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 31 + 0, addr type: 1\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 0 + 26, addr type: 1\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 31 + 0, addr type: 1\r\n[W][BLEScan.cpp:109] handleGAPEvent(): bytes length: 0 + 26, addr type: 1\r\n\r\nExplicitly initializing m_scan_params.scan_duplicate of BLEScan solves\r\nthis issue (In my case the un-initialized value was\r\nm_scan_params.scan_duplicate == 1073599044).\r\n\r\nCo-authored-by: Me No Dev <me-no-dev@users.noreply.github.com>",
            "additions": 1,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            25
                        ],
                        "comments": [
                            "\tmemset(&m_scan_params, 0, sizeof(m_scan_params)); // Initialize all params"
                        ],
                        "lines": []
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "25": "\tmemset(&m_scan_params, 0, sizeof(m_scan_params)); // Initialize all params"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEScan.h": [],
    "BLESecurity.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 104,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104
                        ],
                        "comments": [
                            "\tesp_ble_gap_set_security_param(ESP_BLE_SM_AUTHEN_REQ_MODE, &m_authReq, sizeof(uint8_t));\t\t  // <--- setup requested authentication mode",
                            "} // setCapability",
                            "} // setInitEncryptionKey",
                            "} // setRespEncryptionKey",
                            "} // esp_key_type_to_str",
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            "}",
                            "",
                            "/**",
                            " * @brief \tSet our device IO capability to let end user perform authorization",
                            " * \t\t\teither by displaying or entering generated 6-digits pin code",
                            " */",
                            "void BLESecurity::setCapability(esp_ble_io_cap_t iocap) {",
                            "\tm_iocap = iocap;",
                            "\tesp_ble_gap_set_security_param(ESP_BLE_SM_IOCAP_MODE, &iocap, sizeof(uint8_t));",
                            "",
                            "",
                            "/**",
                            " * @brief Init encryption key by server",
                            " * @param key_size is value between 7 and 16",
                            " */",
                            "void BLESecurity::setInitEncryptionKey(uint8_t init_key) {",
                            "\tm_initKey = init_key;",
                            "\tesp_ble_gap_set_security_param(ESP_BLE_SM_SET_INIT_KEY, &m_initKey, sizeof(uint8_t));",
                            "",
                            "",
                            "/**",
                            " * @brief Init encryption key by client",
                            " * @param key_size is value between 7 and 16",
                            " */",
                            "void BLESecurity::setRespEncryptionKey(uint8_t resp_key) {",
                            "\tm_respKey = resp_key;",
                            "\tesp_ble_gap_set_security_param(ESP_BLE_SM_SET_RSP_KEY, &m_respKey, sizeof(uint8_t));",
                            "",
                            "",
                            "/**",
                            " *",
                            " *",
                            " */",
                            "void BLESecurity::setKeySize(uint8_t key_size) {",
                            "\tm_keySize = key_size;",
                            "\tesp_ble_gap_set_security_param(ESP_BLE_SM_MAX_KEY_SIZE, &m_keySize, sizeof(uint8_t));",
                            "} //setKeySize",
                            "",
                            "",
                            "/**",
                            " * @brief Debug function to display what keys are exchanged by peers",
                            " */",
                            "char* BLESecurity::esp_key_type_to_str(esp_ble_key_type_t key_type) {",
                            "\tchar* key_str = nullptr;",
                            "\tswitch (key_type) {",
                            "\t\tcase ESP_LE_KEY_NONE:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_NONE\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_PENC:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_PENC\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_PID:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_PID\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_PCSRK:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_PCSRK\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_PLK:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_PLK\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_LLK:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_LLK\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_LENC:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_LENC\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_LID:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_LID\";",
                            "\t\t\tbreak;",
                            "\t\tcase ESP_LE_KEY_LCSRK:",
                            "\t\t\tkey_str = (char*) \"ESP_LE_KEY_LCSRK\";",
                            "\t\t\tbreak;",
                            "\t\tdefault:",
                            "\t\t\tkey_str = (char*) \"INVALID BLE KEY TYPE\";",
                            "\t\t\tbreak;",
                            "\t}",
                            "\treturn key_str;"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "22": "\tesp_ble_gap_set_security_param(ESP_BLE_SM_AUTHEN_REQ_MODE, &m_authReq, sizeof(uint8_t));\t\t  // <--- setup requested authentication mode",
                "32": "} // setCapability",
                "42": "} // setInitEncryptionKey",
                "52": "} // setRespEncryptionKey",
                "103": "} // esp_key_type_to_str",
                "104": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLESecurity.h": [],
    "BLEServer.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 424,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424
                        ],
                        "comments": [
                            "} // BLEServer",
                            "} // createApp",
                            "\t// Check that a service with the supplied UUID does not already exist.",
                            "\tm_serviceMap.setByUUID(uuid, pService); // Save a reference to this service being on this server.",
                            "\tpService->executeCreate(this);          // Perform the API calls to actually create the service.",
                            "} // createService",
                            "} // getConnectedCount",
                            "\t\t// ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.",
                            "\t\t// add_char:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          attr_handle",
                            "\t\t// - uint16_t          service_handle",
                            "\t\t// - esp_bt_uuid_t     char_uuid",
                            "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                            "\t\t// ESP_GATTS_CONNECT_EVT",
                            "\t\t// connect:",
                            "\t\t// - uint16_t      conn_id",
                            "\t\t// - esp_bd_addr_t remote_bda",
                            "\t\t\tm_connectedCount++;   // Increment the number of connected devices count.",
                            "\t\t} // ESP_GATTS_CONNECT_EVT",
                            "\t\t// ESP_GATTS_CREATE_EVT",
                            "\t\t// Called when a new service is registered as having been created.",
                            "\t\t// create:",
                            "\t\t// * esp_gatt_status_t  status",
                            "\t\t// * uint16_t           service_handle",
                            "\t\t// * esp_gatt_srvc_id_t service_id",
                            "\t\t\tBLEService* pService = m_serviceMap.getByUUID(param->create.service_id.id.uuid, param->create.service_id.id.inst_id);  // <--- very big bug for multi services with the same uuid",
                            "\t\t} // ESP_GATTS_CREATE_EVT",
                            "\t\t// ESP_GATTS_DISCONNECT_EVT",
                            "\t\t// disconnect",
                            "\t\t// - uint16_t      \t\t\t\t\tconn_id",
                            "\t\t// - esp_bd_addr_t \t\t\t\t\tremote_bda",
                            "\t\t// - esp_gatt_conn_reason_t         reason",
                            "\t\t// If we receive a disconnect event then invoke the callback for disconnects (if one is present).",
                            "\t\t// we also want to start advertising again.",
                            "\t\t\tm_connectedCount--;                          // Decrement the number of connected devices count.",
                            "\t\t\tif (m_pServerCallbacks != nullptr) {         // If we have callbacks, call now.",
                            "\t\t} // ESP_GATTS_DISCONNECT_EVT",
                            "\t\t// ESP_GATTS_READ_EVT - A request to read the value of a characteristic has arrived.",
                            "\t\t// read:",
                            "\t\t// - uint16_t      conn_id",
                            "\t\t// - uint32_t      trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint16_t      handle",
                            "\t\t// - uint16_t      offset",
                            "\t\t// - bool          is_long",
                            "\t\t// - bool          need_rsp",
                            "\t\t} // ESP_GATTS_READ_EVT",
                            "\t\t// ESP_GATTS_REG_EVT",
                            "\t\t// reg:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t app_id",
                            "\t\t\tm_semaphoreRegisterAppEvt.give(); // Unlock the mutex waiting for the registration of the app.",
                            "\t\t} // ESP_GATTS_REG_EVT",
                            "\t\t// ESP_GATTS_WRITE_EVT - A request to write the value of a characteristic has arrived.",
                            "\t\t// write:",
                            "\t\t// - uint16_t      conn_id",
                            "\t\t// - uint16_t      trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint16_t      handle",
                            "\t\t// - uint16_t      offset",
                            "\t\t// - bool          need_rsp",
                            "\t\t// - bool          is_prep",
                            "\t\t// - uint16_t      len",
                            "\t\t// - uint8_t*      value",
                            "\t// Invoke the handler for every Service we have.",
                            "} // handleGATTServerEvent",
                            "\tm_semaphoreRegisterAppEvt.take(\"registerApp\"); // Take the mutex, will be released by ESP_GATTS_REG_EVT event.",
                            "} // registerApp",
                            "} // setCallbacks",
                            "} // startAdvertising",
                            "\t// Perform the open connection request against the target BLE Server.",
                            "\t\taddr, // address",
                            "\t\t1                              // direct connection",
                            "\tuint32_t rc = m_semaphoreOpenEvt.wait(\"connect\");   // Wait for the connection to complete.",
                            "} // connect",
                            "} // onConnect",
                            "} // onConnect",
                            "} // onDisconnect",
                            "\t// set mtu in conn_status_t",
                            "\tconn_params.max_int = maxInterval;    // max_int = 0x20*1.25ms = 40ms",
                            "\tconn_params.min_int = minInterval;    // min_int = 0x10*1.25ms = 20ms",
                            "\tconn_params.timeout = timeout;    // timeout = 400*10ms = 4000ms",
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            "",
                            "",
                            "void BLEServer::createApp(uint16_t appId) {",
                            "\tm_appId = appId;",
                            "\tregisterApp(appId);",
                            "",
                            "",
                            "/**",
                            " * @brief Create a %BLE Service.",
                            " *",
                            " * With a %BLE server, we can host one or more services.  Invoking this function causes the creation of a definition",
                            " * of a new service.  Every service must have a unique UUID.",
                            " * @param [in] uuid The UUID of the new service.",
                            " * @return A reference to the new service object.",
                            " */",
                            "BLEService* BLEServer::createService(const char* uuid) {",
                            "\treturn createService(BLEUUID(uuid));",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Create a %BLE Service.",
                            " *",
                            " * With a %BLE server, we can host one or more services.  Invoking this function causes the creation of a definition",
                            " * of a new service.  Every service must have a unique UUID.",
                            " * @param [in] uuid The UUID of the new service.",
                            " * @param [in] numHandles The maximum number of handles associated with this service.",
                            " * @param [in] inst_id With multiple services with the same UUID we need to provide inst_id value different for each service.",
                            " * @return A reference to the new service object.",
                            " */",
                            "BLEService* BLEServer::createService(BLEUUID uuid, uint32_t numHandles, uint8_t inst_id) {",
                            "\tESP_LOGD(LOG_TAG, \">> createService - %s\", uuid.toString().c_str());",
                            "\tm_semaphoreCreateEvt.take(\"createService\");",
                            "",
                            "\tif (m_serviceMap.getByUUID(uuid) != nullptr) {",
                            "\t\tESP_LOGW(LOG_TAG, \"<< Attempt to create a new service with uuid %s but a service with that UUID already exists.\",",
                            "\t\t\tuuid.toString().c_str());",
                            "\t}",
                            "",
                            "\tBLEService* pService = new BLEService(uuid, numHandles);",
                            "\tpService->m_instId = inst_id;",
                            "",
                            "\tm_semaphoreCreateEvt.wait(\"createService\");",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< createService\");",
                            "\treturn pService;",
                            "",
                            "",
                            "/**",
                            " * @brief Get a %BLE Service by its UUID",
                            " * @param [in] uuid The UUID of the new service.",
                            " * @return A reference to the service object.",
                            " */",
                            "BLEService* BLEServer::getServiceByUUID(const char* uuid) {",
                            "\treturn m_serviceMap.getByUUID(uuid);",
                            "}",
                            "",
                            "/**",
                            " * @brief Get a %BLE Service by its UUID",
                            " * @param [in] uuid The UUID of the new service.",
                            " * @return A reference to the service object.",
                            " */",
                            "BLEService* BLEServer::getServiceByUUID(BLEUUID uuid) {",
                            "\treturn m_serviceMap.getByUUID(uuid);",
                            "}",
                            "",
                            "/**",
                            " * @brief Retrieve the advertising object that can be used to advertise the existence of the server.",
                            " *",
                            " * @return An advertising object.",
                            " */",
                            "BLEAdvertising* BLEServer::getAdvertising() {",
                            "\treturn BLEDevice::getAdvertising();",
                            "}",
                            "",
                            "uint16_t BLEServer::getConnId() {",
                            "\treturn m_connId;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Return the number of connected clients.",
                            " * @return The number of connected clients.",
                            " */",
                            "uint32_t BLEServer::getConnectedCount() {",
                            "\treturn m_connectedCount;",
                            "",
                            "",
                            "uint16_t BLEServer::getGattsIf() {",
                            "\treturn m_gatts_if;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Handle a GATT Server Event.",
                            " *",
                            " * @param [in] event",
                            " * @param [in] gatts_if",
                            " * @param [in] param",
                            " *",
                            " */",
                            "void BLEServer::handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t* param) {",
                            "\tESP_LOGD(LOG_TAG, \">> handleGATTServerEvent: %s\",",
                            "\t\tBLEUtils::gattServerEventTypeToString(event).c_str());",
                            "",
                            "\tswitch(event) {",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_ADD_CHAR_EVT: {",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_MTU_EVT:",
                            "\t\t\tupdatePeerMTU(param->mtu.conn_id, param->mtu.mtu);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_CONNECT_EVT: {",
                            "\t\t\tm_connId = param->connect.conn_id;",
                            "\t\t\taddPeerDevice((void*)this, false, m_connId);",
                            "\t\t\tif (m_pServerCallbacks != nullptr) {",
                            "\t\t\t\tm_pServerCallbacks->onConnect(this);",
                            "\t\t\t\tm_pServerCallbacks->onConnect(this, param);",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_CREATE_EVT: {",
                            "\t\t\tm_serviceMap.setByHandle(param->create.service_handle, pService);",
                            "\t\t\tm_semaphoreCreateEvt.give();",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_DISCONNECT_EVT: {",
                            "\t\t\t\tm_pServerCallbacks->onDisconnect(this);",
                            "\t\t\t}",
                            "\t\t\tstartAdvertising(); //- do this with some delay from the loop()",
                            "\t\t\tremovePeerDevice(param->disconnect.conn_id, false);",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_READ_EVT: {",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_REG_EVT: {",
                            "\t\t\tm_gatts_if = gatts_if;",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_WRITE_EVT: {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\tcase ESP_GATTS_OPEN_EVT:",
                            "\t\t\tm_semaphoreOpenEvt.give(param->open.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "\t}",
                            "",
                            "\tm_serviceMap.handleGATTServerEvent(event, gatts_if, param);",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< handleGATTServerEvent\");",
                            "",
                            "",
                            "/**",
                            " * @brief Register the app.",
                            " *",
                            " * @return N/A",
                            " */",
                            "void BLEServer::registerApp(uint16_t m_appId) {",
                            "\tESP_LOGD(LOG_TAG, \">> registerApp - %d\", m_appId);",
                            "\t::esp_ble_gatts_app_register(m_appId);",
                            "\tm_semaphoreRegisterAppEvt.wait(\"registerApp\");",
                            "\tESP_LOGD(LOG_TAG, \"<< registerApp\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the server callbacks.",
                            " *",
                            " * As a %BLE server operates, it will generate server level events such as a new client connecting or a previous client",
                            " * disconnecting.  This function can be called to register a callback handler that will be invoked when these",
                            " * events are detected.",
                            " *",
                            " * @param [in] pCallbacks The callbacks to be invoked.",
                            " */",
                            "void BLEServer::setCallbacks(BLEServerCallbacks* pCallbacks) {",
                            "\tm_pServerCallbacks = pCallbacks;",
                            "",
                            "/*",
                            " * Remove service",
                            " */",
                            "void BLEServer::removeService(BLEService* service) {",
                            "\tservice->stop();",
                            "\tservice->executeDelete();",
                            "\tm_serviceMap.removeService(service);",
                            "}",
                            "",
                            "/**",
                            " * @brief Start advertising.",
                            " *",
                            " * Start the server advertising its existence.  This is a convenience function and is equivalent to",
                            " * retrieving the advertising object and invoking start upon it.",
                            " */",
                            "void BLEServer::startAdvertising() {",
                            "\tESP_LOGD(LOG_TAG, \">> startAdvertising\");",
                            "\tBLEDevice::startAdvertising();",
                            "\tESP_LOGD(LOG_TAG, \"<< startAdvertising\");",
                            "",
                            "/**",
                            " * Allow to connect GATT server to peer device",
                            " * Probably can be used in ANCS for iPhone",
                            " */",
                            "bool BLEServer::connect(BLEAddress address) {",
                            "\tesp_bd_addr_t addr;",
                            "\tmemcpy(&addr, address.getNative(), 6);",
                            "\tm_semaphoreOpenEvt.take(\"connect\");",
                            "\tesp_err_t errRc = ::esp_ble_gatts_open(",
                            "\t\tgetGattsIf(),",
                            "\t);",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gattc_open: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn false;",
                            "\t}",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< connect(), rc=%d\", rc==ESP_GATT_OK);",
                            "\treturn rc == ESP_GATT_OK;",
                            "",
                            "",
                            "",
                            "void BLEServerCallbacks::onConnect(BLEServer* pServer) {",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \">> onConnect(): Default\");",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \"Device: %s\", BLEDevice::toString().c_str());",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \"<< onConnect()\");",
                            "",
                            "void BLEServerCallbacks::onConnect(BLEServer* pServer, esp_ble_gatts_cb_param_t* param) {",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \">> onConnect(): Default\");",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \"Device: %s\", BLEDevice::toString().c_str());",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \"<< onConnect()\");",
                            "",
                            "",
                            "void BLEServerCallbacks::onDisconnect(BLEServer* pServer) {",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \">> onDisconnect(): Default\");",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \"Device: %s\", BLEDevice::toString().c_str());",
                            "\tESP_LOGD(\"BLEServerCallbacks\", \"<< onDisconnect()\");",
                            "",
                            "/* multi connect support */",
                            "/* TODO do some more tweaks */",
                            "void BLEServer::updatePeerMTU(uint16_t conn_id, uint16_t mtu) {",
                            "\tconst std::map<uint16_t, conn_status_t>::iterator it = m_connectedServersMap.find(conn_id);",
                            "\tif (it != m_connectedServersMap.end()) {",
                            "\t\tit->second.mtu = mtu;",
                            "\t\tstd::swap(m_connectedServersMap[conn_id], it->second);",
                            "\t}",
                            "}",
                            "",
                            "std::map<uint16_t, conn_status_t> BLEServer::getPeerDevices(bool _client) {",
                            "\treturn m_connectedServersMap;",
                            "}",
                            "",
                            "",
                            "uint16_t BLEServer::getPeerMTU(uint16_t conn_id) {",
                            "\treturn m_connectedServersMap.find(conn_id)->second.mtu;",
                            "}",
                            "",
                            "void BLEServer::addPeerDevice(void* peer, bool _client, uint16_t conn_id) {",
                            "\tconn_status_t status = {",
                            "\t\t.peer_device = peer,",
                            "\t\t.connected = true,",
                            "\t\t.mtu = 23",
                            "\t};",
                            "",
                            "\tm_connectedServersMap.insert(std::pair<uint16_t, conn_status_t>(conn_id, status));",
                            "}",
                            "",
                            "void BLEServer::removePeerDevice(uint16_t conn_id, bool _client) {",
                            "\tm_connectedServersMap.erase(conn_id);",
                            "}",
                            "/* multi connect support */",
                            "",
                            "/**",
                            " * Update connection parameters can be called only after connection has been established",
                            " */",
                            "void BLEServer::updateConnParams(esp_bd_addr_t remote_bda, uint16_t minInterval, uint16_t maxInterval, uint16_t latency, uint16_t timeout) {",
                            "\tesp_ble_conn_update_params_t conn_params;",
                            "\tmemcpy(conn_params.bda, remote_bda, sizeof(esp_bd_addr_t));",
                            "\tconn_params.latency = latency;",
                            "\tesp_ble_gap_update_conn_params(&conn_params);",
                            "}"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "43": "} // BLEServer",
                "49": "} // createApp",
                "79": "\t// Check that a service with the supplied UUID does not already exist.",
                "87": "\tm_serviceMap.setByUUID(uuid, pService); // Save a reference to this service being on this server.",
                "88": "\tpService->executeCreate(this);          // Perform the API calls to actually create the service.",
                "94": "} // createService",
                "135": "} // getConnectedCount",
                "156": "\t\t// ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.",
                "157": "\t\t// add_char:",
                "158": "\t\t// - esp_gatt_status_t status",
                "159": "\t\t// - uint16_t          attr_handle",
                "160": "\t\t// - uint16_t          service_handle",
                "161": "\t\t// - esp_bt_uuid_t     char_uuid",
                "165": "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                "171": "\t\t// ESP_GATTS_CONNECT_EVT",
                "172": "\t\t// connect:",
                "173": "\t\t// - uint16_t      conn_id",
                "174": "\t\t// - esp_bd_addr_t remote_bda",
                "183": "\t\t\tm_connectedCount++;   // Increment the number of connected devices count.",
                "185": "\t\t} // ESP_GATTS_CONNECT_EVT",
                "188": "\t\t// ESP_GATTS_CREATE_EVT",
                "189": "\t\t// Called when a new service is registered as having been created.",
                "191": "\t\t// create:",
                "192": "\t\t// * esp_gatt_status_t  status",
                "193": "\t\t// * uint16_t           service_handle",
                "194": "\t\t// * esp_gatt_srvc_id_t service_id",
                "197": "\t\t\tBLEService* pService = m_serviceMap.getByUUID(param->create.service_id.id.uuid, param->create.service_id.id.inst_id);  // <--- very big bug for multi services with the same uuid",
                "201": "\t\t} // ESP_GATTS_CREATE_EVT",
                "204": "\t\t// ESP_GATTS_DISCONNECT_EVT",
                "206": "\t\t// disconnect",
                "207": "\t\t// - uint16_t      \t\t\t\t\tconn_id",
                "208": "\t\t// - esp_bd_addr_t \t\t\t\t\tremote_bda",
                "209": "\t\t// - esp_gatt_conn_reason_t         reason",
                "211": "\t\t// If we receive a disconnect event then invoke the callback for disconnects (if one is present).",
                "212": "\t\t// we also want to start advertising again.",
                "214": "\t\t\tm_connectedCount--;                          // Decrement the number of connected devices count.",
                "215": "\t\t\tif (m_pServerCallbacks != nullptr) {         // If we have callbacks, call now.",
                "221": "\t\t} // ESP_GATTS_DISCONNECT_EVT",
                "224": "\t\t// ESP_GATTS_READ_EVT - A request to read the value of a characteristic has arrived.",
                "226": "\t\t// read:",
                "227": "\t\t// - uint16_t      conn_id",
                "228": "\t\t// - uint32_t      trans_id",
                "229": "\t\t// - esp_bd_addr_t bda",
                "230": "\t\t// - uint16_t      handle",
                "231": "\t\t// - uint16_t      offset",
                "232": "\t\t// - bool          is_long",
                "233": "\t\t// - bool          need_rsp",
                "237": "\t\t} // ESP_GATTS_READ_EVT",
                "240": "\t\t// ESP_GATTS_REG_EVT",
                "241": "\t\t// reg:",
                "242": "\t\t// - esp_gatt_status_t status",
                "243": "\t\t// - uint16_t app_id",
                "247": "\t\t\tm_semaphoreRegisterAppEvt.give(); // Unlock the mutex waiting for the registration of the app.",
                "249": "\t\t} // ESP_GATTS_REG_EVT",
                "252": "\t\t// ESP_GATTS_WRITE_EVT - A request to write the value of a characteristic has arrived.",
                "254": "\t\t// write:",
                "255": "\t\t// - uint16_t      conn_id",
                "256": "\t\t// - uint16_t      trans_id",
                "257": "\t\t// - esp_bd_addr_t bda",
                "258": "\t\t// - uint16_t      handle",
                "259": "\t\t// - uint16_t      offset",
                "260": "\t\t// - bool          need_rsp",
                "261": "\t\t// - bool          is_prep",
                "262": "\t\t// - uint16_t      len",
                "263": "\t\t// - uint8_t*      value",
                "277": "\t// Invoke the handler for every Service we have.",
                "281": "} // handleGATTServerEvent",
                "291": "\tm_semaphoreRegisterAppEvt.take(\"registerApp\"); // Take the mutex, will be released by ESP_GATTS_REG_EVT event.",
                "295": "} // registerApp",
                "309": "} // setCallbacks",
                "330": "} // startAdvertising",
                "339": "\t// Perform the open connection request against the target BLE Server.",
                "343": "\t\taddr, // address",
                "344": "\t\t1                              // direct connection",
                "351": "\tuint32_t rc = m_semaphoreOpenEvt.wait(\"connect\");   // Wait for the connection to complete.",
                "354": "} // connect",
                "362": "} // onConnect",
                "368": "} // onConnect",
                "375": "} // onDisconnect",
                "380": "\t// set mtu in conn_status_t",
                "419": "\tconn_params.max_int = maxInterval;    // max_int = 0x20*1.25ms = 40ms",
                "420": "\tconn_params.min_int = minInterval;    // min_int = 0x10*1.25ms = 20ms",
                "421": "\tconn_params.timeout = timeout;    // timeout = 400*10ms = 4000ms",
                "424": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "35d9759fa696be68ae5c0a52d2913e09222f689d",
            "timestamp": "2020-06-01T01:35:01+03:00",
            "author": "James.Y",
            "commit_message": "Fix for issue 3974 m_connectedCount incorrectly decremented when no connection exists\n\nThere is no need to decrement if nothing was removed from removePeerDevice\r\n\r\nReference issue:\r\n#3974",
            "additions": 12,
            "deletions": 6,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            212,
                            213,
                            214,
                            215,
                            216,
                            217
                        ],
                        "comments": [
                            "            // only decrement if connection is found in map and removed",
                            "            // sometimes this event triggers w/o a valid connection",
                            "                m_connectedCount--;                          // Decrement the number of connected devices count."
                        ],
                        "lines": [
                            "\t\t\tif(removePeerDevice(param->disconnect.conn_id, false)) {",
                            "            }",
                            "            break;"
                        ]
                    },
                    {
                        "line_numbers": [
                            404,
                            405
                        ],
                        "comments": [],
                        "lines": [
                            "bool BLEServer::removePeerDevice(uint16_t conn_id, bool _client) {",
                            "\treturn m_connectedServersMap.erase(conn_id) > 0;"
                        ]
                    }
                ],
                "deleted": [
                    {
                        "line_numbers": [
                            205
                        ],
                        "comments": [
                            "\t\t\tm_connectedCount--;                          // Decrement the number of connected devices count."
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            209,
                            210,
                            211
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tstartAdvertising(); //- do this with some delay from the loop()",
                            "\t\t\tremovePeerDevice(param->disconnect.conn_id, false);",
                            "\t\t\tbreak;"
                        ]
                    },
                    {
                        "line_numbers": [
                            398,
                            399
                        ],
                        "comments": [],
                        "lines": [
                            "void BLEServer::removePeerDevice(uint16_t conn_id, bool _client) {",
                            "\tm_connectedServersMap.erase(conn_id);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {
                "212": "            // only decrement if connection is found in map and removed",
                "213": "            // sometimes this event triggers w/o a valid connection",
                "215": "                m_connectedCount--;                          // Decrement the number of connected devices count."
            },
            "comment_deleted_diff": {
                "205": "\t\t\tm_connectedCount--;                          // Decrement the number of connected devices count."
            },
            "comment_modified_diff": {}
        }
    ],
    "BLEServer.h": [],
    "BLEService.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 418,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418
                        ],
                        "comments": [
                            "// A service is identified by a UUID.  A service is also the container for one or more characteristics.",
                            "static const char* LOG_TAG = \"BLEService\"; // Tag for logging.",
                            "} // BLEService",
                            "\tm_semaphoreCreateEvt.take(\"executeCreate\"); // Take the mutex and release at event ESP_GATTS_CREATE_EVT",
                            "\tesp_err_t errRc = ::esp_ble_gatts_create_service(getServer()->getGattsIf(), &srvc_id, m_numHandles); // The maximum number of handles associated with the service.",
                            "} // executeCreate",
                            "\tm_semaphoreDeleteEvt.take(\"executeDelete\"); // Take the mutex and release at event ESP_GATTS_DELETE_EVT",
                            "} // executeDelete",
                            "} // dump",
                            "} // getUUID",
                            "// We ask the BLE runtime to start the service and then create each of the characteristics.",
                            "// We start the service through its local handle which was returned in the ESP_GATTS_CREATE_EVT event",
                            "// obtained as a result of calling esp_ble_gatts_create_service().",
                            "\t// Start each of the characteristics ... these are found in the m_characteristicMap.",
                            "} // start",
                            "// We ask the BLE runtime to start the service and then create each of the characteristics.",
                            "// We start the service through its local handle which was returned in the ESP_GATTS_CREATE_EVT event",
                            "// obtained as a result of calling esp_ble_gatts_create_service().",
                            "} // start",
                            "} // setHandle",
                            "} // getHandle",
                            "\t// We maintain a mapping of characteristics owned by this service.  These are managed by the",
                            "\t// BLECharacteristicMap class instance found in m_characteristicMap.  We add the characteristic",
                            "\t// to the map and then ask the service to add the characteristic at the BLE level (ESP-IDF).",
                            "\t// Check that we don't add the same characteristic twice.",
                            "\t// Remember this characteristic in our map of characteristics.  At this point, we can lookup by UUID",
                            "\t// but not by handle.  The handle is allocated to us on the ESP_GATTS_ADD_CHAR_EVT.",
                            "} // addCharacteristic",
                            "} // createCharacteristic",
                            "\t\t// ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.",
                            "\t\t// add_char:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t attr_handle",
                            "\t\t// - uint16_t service_handle",
                            "\t\t// - esp_bt_uuid_t char_uuid",
                            "\t\t// If we have reached the correct service, then locate the characteristic and remember the handle",
                            "\t\t// for that characteristic.",
                            "\t\t\t} // Reached the correct service.",
                            "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                            "\t\t// ESP_GATTS_START_EVT",
                            "\t\t// start:",
                            "\t\t// esp_gatt_status_t status",
                            "\t\t// uint16_t service_handle",
                            "\t\t} // ESP_GATTS_START_EVT",
                            "\t\t// ESP_GATTS_STOP_EVT",
                            "\t\t// stop:",
                            "\t\t// esp_gatt_status_t status",
                            "\t\t// uint16_t service_handle",
                            "\t\t} // ESP_GATTS_STOP_EVT",
                            "\t\t// ESP_GATTS_CREATE_EVT",
                            "\t\t// Called when a new service is registered as having been created.",
                            "\t\t// create:",
                            "\t\t// * esp_gatt_status_t status",
                            "\t\t// * uint16_t service_handle",
                            "\t\t// * esp_gatt_srvc_id_t service_id",
                            "\t\t// * - esp_gatt_id id",
                            "\t\t// *   - esp_bt_uuid uuid",
                            "\t\t// *   - uint8_t inst_id",
                            "\t\t// * - bool is_primary",
                            "\t\t} // ESP_GATTS_CREATE_EVT",
                            "\t\t// ESP_GATTS_DELETE_EVT",
                            "\t\t// Called when a service is deleted.",
                            "\t\t// delete:",
                            "\t\t// * esp_gatt_status_t status",
                            "\t\t// * uint16_t service_handle",
                            "\t\t} // ESP_GATTS_DELETE_EVT",
                            "\t} // Switch",
                            "\t// Invoke the GATTS handler in each of the associated characteristics.",
                            "} // handleGATTServerEvent",
                            "} // toString",
                            "} // getLastCreatedCharacteristic",
                            "} // getServer",
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            "",
                            "#include \"sdkconfig.h\"",
                            "#if defined(CONFIG_BT_ENABLED)",
                            "#include <esp_err.h>",
                            "#include <esp_gatts_api.h>",
                            "",
                            "#include <iomanip>",
                            "#include <sstream>",
                            "#include <string>",
                            "",
                            "#include \"BLEServer.h\"",
                            "#include \"BLEService.h\"",
                            "#include \"BLEUtils.h\"",
                            "#include \"GeneralUtils.h\"",
                            "",
                            "#if defined(ARDUINO_ARCH_ESP32) && defined(CONFIG_ARDUHAL_ESP_LOG)",
                            "#include \"esp32-hal-log.h\"",
                            "#define LOG_TAG \"\"",
                            "#else",
                            "#include \"esp_log.h\"",
                            "#endif",
                            "",
                            "#define NULL_HANDLE (0xffff)",
                            "",
                            "",
                            "/**",
                            " * @brief Construct an instance of the BLEService",
                            " * @param [in] uuid The UUID of the service.",
                            " * @param [in] numHandles The maximum number of handles associated with the service.",
                            " */",
                            "BLEService::BLEService(const char* uuid, uint16_t numHandles) : BLEService(BLEUUID(uuid), numHandles) {",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Construct an instance of the BLEService",
                            " * @param [in] uuid The UUID of the service.",
                            " * @param [in] numHandles The maximum number of handles associated with the service.",
                            " */",
                            "BLEService::BLEService(BLEUUID uuid, uint16_t numHandles) {",
                            "\tm_uuid      = uuid;",
                            "\tm_handle    = NULL_HANDLE;",
                            "\tm_pServer   = nullptr;",
                            "\t//m_serializeMutex.setName(\"BLEService\");",
                            "\tm_lastCreatedCharacteristic = nullptr;",
                            "\tm_numHandles = numHandles;",
                            "",
                            "",
                            "/**",
                            " * @brief Create the service.",
                            " * Create the service.",
                            " * @param [in] gatts_if The handle of the GATT server interface.",
                            " * @return N/A.",
                            " */",
                            "",
                            "void BLEService::executeCreate(BLEServer* pServer) {",
                            "\tESP_LOGD(LOG_TAG, \">> executeCreate() - Creating service (esp_ble_gatts_create_service) service uuid: %s\", getUUID().toString().c_str());",
                            "\tm_pServer          = pServer;",
                            "",
                            "\tesp_gatt_srvc_id_t srvc_id;",
                            "\tsrvc_id.is_primary = true;",
                            "\tsrvc_id.id.inst_id = m_instId;",
                            "\tsrvc_id.id.uuid    = *m_uuid.getNative();",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_create_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "\tm_semaphoreCreateEvt.wait(\"executeCreate\");",
                            "\tESP_LOGD(LOG_TAG, \"<< executeCreate\");",
                            "",
                            "",
                            "/**",
                            " * @brief Delete the service.",
                            " * Delete the service.",
                            " * @return N/A.",
                            " */",
                            "",
                            "void BLEService::executeDelete() {",
                            "\tESP_LOGD(LOG_TAG, \">> executeDelete()\");",
                            "",
                            "\tesp_err_t errRc = ::esp_ble_gatts_delete_service(getHandle());",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_delete_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "\tm_semaphoreDeleteEvt.wait(\"executeDelete\");",
                            "\tESP_LOGD(LOG_TAG, \"<< executeDelete\");",
                            "",
                            "",
                            "/**",
                            " * @brief Dump details of this BLE GATT service.",
                            " * @return N/A.",
                            " */",
                            "void BLEService::dump() {",
                            "\tESP_LOGD(LOG_TAG, \"Service: uuid:%s, handle: 0x%.2x\",",
                            "\t\tm_uuid.toString().c_str(),",
                            "\t\tm_handle);",
                            "\tESP_LOGD(LOG_TAG, \"Characteristics:\\n%s\", m_characteristicMap.toString().c_str());",
                            "",
                            "",
                            "/**",
                            " * @brief Get the UUID of the service.",
                            " * @return the UUID of the service.",
                            " */",
                            "BLEUUID BLEService::getUUID() {",
                            "\treturn m_uuid;",
                            "",
                            "",
                            "/**",
                            " * @brief Start the service.",
                            " * Here we wish to start the service which means that we will respond to partner requests about it.",
                            " * Starting a service also means that we can create the corresponding characteristics.",
                            " * @return Start the service.",
                            " */",
                            "void BLEService::start() {",
                            "//",
                            "\tESP_LOGD(LOG_TAG, \">> start(): Starting service (esp_ble_gatts_start_service): %s\", toString().c_str());",
                            "\tif (m_handle == NULL_HANDLE) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< !!! We attempted to start a service but don't know its handle!\");",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "\tBLECharacteristic *pCharacteristic = m_characteristicMap.getFirst();",
                            "",
                            "\twhile (pCharacteristic != nullptr) {",
                            "\t\tm_lastCreatedCharacteristic = pCharacteristic;",
                            "\t\tpCharacteristic->executeCreate(this);",
                            "",
                            "\t\tpCharacteristic = m_characteristicMap.getNext();",
                            "\t}",
                            "",
                            "\tm_semaphoreStartEvt.take(\"start\");",
                            "\tesp_err_t errRc = ::esp_ble_gatts_start_service(m_handle);",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_start_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "\tm_semaphoreStartEvt.wait(\"start\");",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< start()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Stop the service.",
                            " */",
                            "void BLEService::stop() {",
                            "\tESP_LOGD(LOG_TAG, \">> stop(): Stopping service (esp_ble_gatts_stop_service): %s\", toString().c_str());",
                            "\tif (m_handle == NULL_HANDLE) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< !!! We attempted to stop a service but don't know its handle!\");",
                            "\t\treturn;",
                            "\t}",
                            "",
                            "\tm_semaphoreStopEvt.take(\"stop\");",
                            "\tesp_err_t errRc = ::esp_ble_gatts_stop_service(m_handle);",
                            "",
                            "\tif (errRc != ESP_OK) {",
                            "\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_stop_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));",
                            "\t\treturn;",
                            "\t}",
                            "\tm_semaphoreStopEvt.wait(\"stop\");",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< stop()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Set the handle associated with this service.",
                            " * @param [in] handle The handle associated with the service.",
                            " */",
                            "void BLEService::setHandle(uint16_t handle) {",
                            "\tESP_LOGD(LOG_TAG, \">> setHandle - Handle=0x%.2x, service UUID=%s)\", handle, getUUID().toString().c_str());",
                            "\tif (m_handle != NULL_HANDLE) {",
                            "\t\tESP_LOGE(LOG_TAG, \"!!! Handle is already set %.2x\", m_handle);",
                            "\t\treturn;",
                            "\t}",
                            "\tm_handle = handle;",
                            "\tESP_LOGD(LOG_TAG, \"<< setHandle\");",
                            "",
                            "",
                            "/**",
                            " * @brief Get the handle associated with this service.",
                            " * @return The handle associated with this service.",
                            " */",
                            "uint16_t BLEService::getHandle() {",
                            "\treturn m_handle;",
                            "",
                            "",
                            "/**",
                            " * @brief Add a characteristic to the service.",
                            " * @param [in] pCharacteristic A pointer to the characteristic to be added.",
                            " */",
                            "void BLEService::addCharacteristic(BLECharacteristic* pCharacteristic) {",
                            "",
                            "\tESP_LOGD(LOG_TAG, \">> addCharacteristic()\");",
                            "\tESP_LOGD(LOG_TAG, \"Adding characteristic: uuid=%s to service: %s\",",
                            "\t\tpCharacteristic->getUUID().toString().c_str(),",
                            "\t\ttoString().c_str());",
                            "",
                            "\tif (m_characteristicMap.getByUUID(pCharacteristic->getUUID()) != nullptr) {",
                            "\t\tESP_LOGW(LOG_TAG, \"<< Adding a new characteristic with the same UUID as a previous one\");",
                            "\t\t//return;",
                            "\t}",
                            "",
                            "\tm_characteristicMap.setByUUID(pCharacteristic, pCharacteristic->getUUID());",
                            "",
                            "\tESP_LOGD(LOG_TAG, \"<< addCharacteristic()\");",
                            "",
                            "",
                            "/**",
                            " * @brief Create a new BLE Characteristic associated with this service.",
                            " * @param [in] uuid - The UUID of the characteristic.",
                            " * @param [in] properties - The properties of the characteristic.",
                            " * @return The new BLE characteristic.",
                            " */",
                            "BLECharacteristic* BLEService::createCharacteristic(const char* uuid, uint32_t properties) {",
                            "\treturn createCharacteristic(BLEUUID(uuid), properties);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Create a new BLE Characteristic associated with this service.",
                            " * @param [in] uuid - The UUID of the characteristic.",
                            " * @param [in] properties - The properties of the characteristic.",
                            " * @return The new BLE characteristic.",
                            " */",
                            "BLECharacteristic* BLEService::createCharacteristic(BLEUUID uuid, uint32_t properties) {",
                            "\tBLECharacteristic* pCharacteristic = new BLECharacteristic(uuid, properties);",
                            "\taddCharacteristic(pCharacteristic);",
                            "\treturn pCharacteristic;",
                            "",
                            "",
                            "/**",
                            " * @brief Handle a GATTS server event.",
                            " */",
                            "void BLEService::handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t* param) {",
                            "\tswitch (event) {",
                            "",
                            "\t\tcase ESP_GATTS_ADD_CHAR_EVT: {",
                            "\t\t\tif (m_handle == param->add_char.service_handle) {",
                            "\t\t\t\tBLECharacteristic *pCharacteristic = getLastCreatedCharacteristic();",
                            "\t\t\t\tif (pCharacteristic == nullptr) {",
                            "\t\t\t\t\tESP_LOGE(LOG_TAG, \"Expected to find characteristic with UUID: %s, but didnt!\",",
                            "\t\t\t\t\t\t\tBLEUUID(param->add_char.char_uuid).toString().c_str());",
                            "\t\t\t\t\tdump();",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t}",
                            "\t\t\t\tpCharacteristic->setHandle(param->add_char.attr_handle);",
                            "\t\t\t\tm_characteristicMap.setByHandle(param->add_char.attr_handle, pCharacteristic);",
                            "\t\t\t\tbreak;",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_START_EVT: {",
                            "\t\t\tif (param->start.service_handle == getHandle()) {",
                            "\t\t\t\tm_semaphoreStartEvt.give();",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_STOP_EVT: {",
                            "\t\t\tif (param->stop.service_handle == getHandle()) {",
                            "\t\t\t\tm_semaphoreStopEvt.give();",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_CREATE_EVT: {",
                            "\t\t\tif (getUUID().equals(BLEUUID(param->create.service_id.id.uuid)) && m_instId == param->create.service_id.id.inst_id) {",
                            "\t\t\t\tsetHandle(param->create.service_handle);",
                            "\t\t\t\tm_semaphoreCreateEvt.give();",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_DELETE_EVT: {",
                            "\t\t\tif (param->del.service_handle == getHandle()) {",
                            "\t\t\t\tm_semaphoreDeleteEvt.give();",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "",
                            "\tm_characteristicMap.handleGATTServerEvent(event, gatts_if, param);",
                            "",
                            "",
                            "BLECharacteristic* BLEService::getCharacteristic(const char* uuid) {",
                            "\treturn getCharacteristic(BLEUUID(uuid));",
                            "}",
                            "",
                            "",
                            "BLECharacteristic* BLEService::getCharacteristic(BLEUUID uuid) {",
                            "\treturn m_characteristicMap.getByUUID(uuid);",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of this service.",
                            " * A service is defined by:",
                            " * * Its UUID",
                            " * * Its handle",
                            " * @return A string representation of this service.",
                            " */",
                            "std::string BLEService::toString() {",
                            "\tstd::stringstream stringStream;",
                            "\tstringStream << \"UUID: \" << getUUID().toString() <<",
                            "\t\t\", handle: 0x\" << std::hex << std::setfill('0') << std::setw(2) << getHandle();",
                            "\treturn stringStream.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Get the last created characteristic.",
                            " * It is lamentable that this function has to exist.  It returns the last created characteristic.",
                            " * We need this because the descriptor API is built around the notion that a new descriptor, when created,",
                            " * is associated with the last characteristics created and we need that information.",
                            " * @return The last created characteristic.",
                            " */",
                            "BLECharacteristic* BLEService::getLastCreatedCharacteristic() {",
                            "\treturn m_lastCreatedCharacteristic;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the BLE server associated with this service.",
                            " * @return The BLEServer associated with this service.",
                            " */",
                            "BLEServer* BLEService::getServer() {",
                            "\treturn m_pServer;",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "8": "// A service is identified by a UUID.  A service is also the container for one or more characteristics.",
                "29": "static const char* LOG_TAG = \"BLEService\"; // Tag for logging.",
                "56": "} // BLEService",
                "69": "\tm_semaphoreCreateEvt.take(\"executeCreate\"); // Take the mutex and release at event ESP_GATTS_CREATE_EVT",
                "75": "\tesp_err_t errRc = ::esp_ble_gatts_create_service(getServer()->getGattsIf(), &srvc_id, m_numHandles); // The maximum number of handles associated with the service.",
                "84": "} // executeCreate",
                "95": "\tm_semaphoreDeleteEvt.take(\"executeDelete\"); // Take the mutex and release at event ESP_GATTS_DELETE_EVT",
                "106": "} // executeDelete",
                "118": "} // dump",
                "127": "} // getUUID",
                "137": "// We ask the BLE runtime to start the service and then create each of the characteristics.",
                "138": "// We start the service through its local handle which was returned in the ESP_GATTS_CREATE_EVT event",
                "139": "// obtained as a result of calling esp_ble_gatts_create_service().",
                "155": "\t// Start each of the characteristics ... these are found in the m_characteristicMap.",
                "167": "} // start",
                "174": "// We ask the BLE runtime to start the service and then create each of the characteristics.",
                "175": "// We start the service through its local handle which was returned in the ESP_GATTS_CREATE_EVT event",
                "176": "// obtained as a result of calling esp_ble_gatts_create_service().",
                "193": "} // start",
                "208": "} // setHandle",
                "217": "} // getHandle",
                "225": "\t// We maintain a mapping of characteristics owned by this service.  These are managed by the",
                "226": "\t// BLECharacteristicMap class instance found in m_characteristicMap.  We add the characteristic",
                "227": "\t// to the map and then ask the service to add the characteristic at the BLE level (ESP-IDF).",
                "234": "\t// Check that we don't add the same characteristic twice.",
                "240": "\t// Remember this characteristic in our map of characteristics.  At this point, we can lookup by UUID",
                "241": "\t// but not by handle.  The handle is allocated to us on the ESP_GATTS_ADD_CHAR_EVT.",
                "245": "} // addCharacteristic",
                "269": "} // createCharacteristic",
                "277": "\t\t// ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.",
                "278": "\t\t// add_char:",
                "279": "\t\t// - esp_gatt_status_t status",
                "280": "\t\t// - uint16_t attr_handle",
                "281": "\t\t// - uint16_t service_handle",
                "282": "\t\t// - esp_bt_uuid_t char_uuid",
                "284": "\t\t// If we have reached the correct service, then locate the characteristic and remember the handle",
                "285": "\t\t// for that characteristic.",
                "298": "\t\t\t} // Reached the correct service.",
                "300": "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                "303": "\t\t// ESP_GATTS_START_EVT",
                "305": "\t\t// start:",
                "306": "\t\t// esp_gatt_status_t status",
                "307": "\t\t// uint16_t service_handle",
                "313": "\t\t} // ESP_GATTS_START_EVT",
                "315": "\t\t// ESP_GATTS_STOP_EVT",
                "317": "\t\t// stop:",
                "318": "\t\t// esp_gatt_status_t status",
                "319": "\t\t// uint16_t service_handle",
                "326": "\t\t} // ESP_GATTS_STOP_EVT",
                "329": "\t\t// ESP_GATTS_CREATE_EVT",
                "330": "\t\t// Called when a new service is registered as having been created.",
                "332": "\t\t// create:",
                "333": "\t\t// * esp_gatt_status_t status",
                "334": "\t\t// * uint16_t service_handle",
                "335": "\t\t// * esp_gatt_srvc_id_t service_id",
                "336": "\t\t// * - esp_gatt_id id",
                "337": "\t\t// *   - esp_bt_uuid uuid",
                "338": "\t\t// *   - uint8_t inst_id",
                "339": "\t\t// * - bool is_primary",
                "347": "\t\t} // ESP_GATTS_CREATE_EVT",
                "350": "\t\t// ESP_GATTS_DELETE_EVT",
                "351": "\t\t// Called when a service is deleted.",
                "353": "\t\t// delete:",
                "354": "\t\t// * esp_gatt_status_t status",
                "355": "\t\t// * uint16_t service_handle",
                "362": "\t\t} // ESP_GATTS_DELETE_EVT",
                "366": "\t} // Switch",
                "368": "\t// Invoke the GATTS handler in each of the associated characteristics.",
                "370": "} // handleGATTServerEvent",
                "395": "} // toString",
                "407": "} // getLastCreatedCharacteristic",
                "416": "} // getServer",
                "418": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d7ea7b80a7badbe30e6fb6f33f71375e0b133c",
            "timestamp": "2019-04-15T17:26:35+02:00",
            "author": "Bascy",
            "commit_message": "Refactored use of LOG_X(LOG_TAG, ...) to log_x(...) (#2672)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)\r\n\r\n* Change logging from Error to Verbose when not found and default available\r\n\r\n* Move Enter and Exit logging to Verbose Level\r\n\r\n* Refactored LOG_X() into log_x()",
            "additions": 24,
            "deletions": 31,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            29,
                            30
                        ],
                        "comments": [
                            "static const char* LOG_TAG = \"BLEService\"; // Tag for logging."
                        ],
                        "lines": [
                            "#endif"
                        ]
                    },
                    {
                        "line_numbers": [
                            67
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> executeCreate() - Creating service (esp_ble_gatts_create_service) service uuid: %s\", getUUID().toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            78
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_create_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            83
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< executeCreate\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            94
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> executeDelete()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            100
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"esp_ble_gatts_delete_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            105
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< executeDelete\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            114
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"Service: uuid:%s, handle: 0x%.2x\","
                        ]
                    },
                    {
                        "line_numbers": [
                            117
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"Characteristics:\\n%s\", m_characteristicMap.toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            141
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> start(): Starting service (esp_ble_gatts_start_service): %s\", toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            143
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"<< !!! We attempted to start a service but don't know its handle!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            161
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_start_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            166
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< start()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            177
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> stop(): Stopping service (esp_ble_gatts_stop_service): %s\", toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            179
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"<< !!! We attempted to stop a service but don't know its handle!\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            187
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"<< esp_ble_gatts_stop_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));"
                        ]
                    },
                    {
                        "line_numbers": [
                            192
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< stop()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            201
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> setHandle - Handle=0x%.2x, service UUID=%s)\", handle, getUUID().toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            203
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGE(LOG_TAG, \"!!! Handle is already set %.2x\", m_handle);"
                        ]
                    },
                    {
                        "line_numbers": [
                            207
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< setHandle\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            229,
                            230
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \">> addCharacteristic()\");",
                            "\tESP_LOGD(LOG_TAG, \"Adding characteristic: uuid=%s to service: %s\","
                        ]
                    },
                    {
                        "line_numbers": [
                            236
                        ],
                        "comments": [],
                        "lines": [
                            "\t\tESP_LOGW(LOG_TAG, \"<< Adding a new characteristic with the same UUID as a previous one\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            244
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGD(LOG_TAG, \"<< addCharacteristic()\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            290
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\t\tESP_LOGE(LOG_TAG, \"Expected to find characteristic with UUID: %s, but didnt!\","
                        ]
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "29": "static const char* LOG_TAG = \"BLEService\"; // Tag for logging."
            },
            "comment_modified_diff": {}
        }
    ],
    "BLEService.h": [],
    "BLEServiceMap.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 134,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134
                        ],
                        "comments": [
                            "} // getByUUID",
                            "} // getByHandle",
                            "} // setByUUID",
                            "} // setByHandle",
                            "} // toString",
                            "\t// Invoke the handler for every Service we have.",
                            "} // getFirst",
                            "} // getNext",
                            "} // removeService"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Return the service by handle.",
                            " * @param [in] handle The handle to look up the service.",
                            " * @return The service.",
                            " */",
                            "BLEService* BLEServiceMap::getByHandle(uint16_t handle) {",
                            "\treturn m_handleMap.at(handle);",
                            "",
                            "",
                            "/**",
                            " * @brief Set the service by UUID.",
                            " * @param [in] uuid The uuid of the service.",
                            " * @param [in] characteristic The service to cache.",
                            " * @return N/A.",
                            " */",
                            "void BLEServiceMap::setByUUID(BLEUUID uuid, BLEService* service) {",
                            "\tm_uuidMap.insert(std::pair<BLEService*, std::string>(service, uuid.toString()));",
                            "",
                            "",
                            "/**",
                            " * @brief Set the service by handle.",
                            " * @param [in] handle The handle of the service.",
                            " * @param [in] service The service to cache.",
                            " * @return N/A.",
                            " */",
                            "void BLEServiceMap::setByHandle(uint16_t handle, BLEService* service) {",
                            "\tm_handleMap.insert(std::pair<uint16_t, BLEService*>(handle, service));",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of the service map.",
                            " * @return A string representation of the service map.",
                            " */",
                            "std::string BLEServiceMap::toString() {",
                            "\tstd::stringstream stringStream;",
                            "\tstringStream << std::hex << std::setfill('0');",
                            "\tfor (auto &myPair: m_handleMap) {",
                            "\t\tstringStream << \"handle: 0x\" << std::setw(2) << myPair.first << \", uuid: \" + myPair.second->getUUID().toString() << \"\\n\";",
                            "\t}",
                            "\treturn stringStream.str();",
                            "",
                            "void BLEServiceMap::handleGATTServerEvent(",
                            "\t\tesp_gatts_cb_event_t      event,",
                            "\t\tesp_gatt_if_t             gatts_if,",
                            "\t\tesp_ble_gatts_cb_param_t* param) {",
                            "\tfor (auto &myPair : m_uuidMap) {",
                            "\t\tmyPair.first->handleGATTServerEvent(event, gatts_if, param);",
                            "\t}",
                            "}",
                            "",
                            "/**",
                            " * @brief Get the first service in the map.",
                            " * @return The first service in the map.",
                            " */",
                            "BLEService* BLEServiceMap::getFirst() {",
                            "\tm_iterator = m_uuidMap.begin();",
                            "\tif (m_iterator == m_uuidMap.end()) return nullptr;",
                            "\tBLEService* pRet = m_iterator->first;",
                            "\tm_iterator++;",
                            "\treturn pRet;",
                            "",
                            "/**",
                            " * @brief Get the next service in the map.",
                            " * @return The next service in the map.",
                            " */",
                            "BLEService* BLEServiceMap::getNext() {",
                            "\tif (m_iterator == m_uuidMap.end()) return nullptr;",
                            "\tBLEService* pRet = m_iterator->first;",
                            "\tm_iterator++;",
                            "\treturn pRet;",
                            "",
                            "/**",
                            " * @brief Removes service from maps.",
                            " * @return N/A.",
                            " */",
                            "void BLEServiceMap::removeService(BLEService* service) {",
                            "\tm_handleMap.erase(service->getHandle());",
                            "\tm_uuidMap.erase(service);",
                            "",
                            "/**",
                            " * @brief Returns the amount of registered services",
                            " * @return amount of registered services",
                            " */",
                            "int BLEServiceMap::getRegisteredServiceCount(){",
                            "\treturn m_handleMap.size();",
                            "}",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "36": "} // getByUUID",
                "46": "} // getByHandle",
                "57": "} // setByUUID",
                "68": "} // setByHandle",
                "82": "} // toString",
                "88": "\t// Invoke the handler for every Service we have.",
                "104": "} // getFirst",
                "115": "} // getNext",
                "124": "} // removeService"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEUUID.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 407,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407
                        ],
                        "comments": [
                            "\ttarget += (size - 1); // Point target to the last byte of the target data",
                            "} // memrcpy",
                            "\telse if (value.length() == 16) {  // how we can have 16 byte length string reprezenting 128 bit uuid??? needs to be investigated (lack of time)",
                            "\t\t// If the length of the string is 36 bytes then we will assume it is a long hex string in",
                            "\t\t// UUID format.",
                            "} // BLEUUID",
                            "} // BLEUUID",
                            "} // BLEUUID",
                            "} // BLEUUID",
                            "} // BLEUUID",
                            "} // BLEUUID",
                            "\t} // End of switch",
                            "} // bitSize",
                            "} // equals",
                            "\tif (strstr(_uuid.c_str(), \"0x\") != nullptr) { // If the string starts with 0x, skip those characters.",
                            "\tuint8_t len = _uuid.length() - start; // Calculate the length of the string we are going to use.",
                            "} // fromString",
                            "} // getNative",
                            "\t// If we either don't have a value or are already a 128 bit UUID, nothing further to do.",
                            "\t// If we are 16 bit or 32 bit, then set the 4 bytes of the variable part of the UUID.",
                            "\t// Set the fixed parts of the UUID.",
                            "} // to128",
                            "\tif (!m_valueSet) return \"<NULL>\";   // If we have no value, nothing to format.",
                            "\t// If the UUIDs are 16 or 32 bit, pad correctly.",
                            "\tif (m_uuid.len == ESP_UUID_LEN_16) {  // If the UUID is 16bit, pad correctly.",
                            "\t\treturn ss.str();                    // Return the string",
                            "\t} // End 16bit UUID",
                            "\tif (m_uuid.len == ESP_UUID_LEN_32) {  // If the UUID is 32bit, pad correctly.",
                            "\t\treturn ss.str();                    // return the string",
                            "\t} // End 32bit UUID",
                            "\t// The UUID is not 16bit or 32bit which means that it is 128bit.",
                            "\t// UUID string format:",
                            "\t// AABBCCDD-EEFF-GGHH-IIJJ-KKLLMMNNOOPP",
                            "} // toString"
                        ],
                        "lines": [
                            "\twhile (size > 0) {",
                            "\t\t*target = *source;",
                            "\t\ttarget--;",
                            "\t\tsource++;",
                            "\t\tsize--;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Create a UUID from a string.",
                            " *",
                            " * Create a UUID from a string.  There will be two possible stories here.  Either the string represents",
                            " * a binary data field or the string represents a hex encoding of a UUID.",
                            " * For the hex encoding, here is an example:",
                            " *",
                            " * ```",
                            " * \"beb5483e-36e1-4688-b7f5-ea07361b26a8\"",
                            " *  0 1 2 3  4 5  6 7  8 9  0 1 2 3 4 5",
                            " *  12345678-90ab-cdef-1234-567890abcdef",
                            " * ```",
                            " *",
                            " * This has a length of 36 characters.  We need to parse this into 16 bytes.",
                            " *",
                            " * @param [in] value The string to build a UUID from.",
                            " */",
                            "BLEUUID::BLEUUID(std::string value) {",
                            "\tm_valueSet = true;",
                            "\tif (value.length() == 4) {",
                            "\t\tm_uuid.len         = ESP_UUID_LEN_16;",
                            "\t\tm_uuid.uuid.uuid16 = 0;",
                            "\t\tfor(int i=0;i<value.length();){",
                            "\t\t\tuint8_t MSB = value.c_str()[i];",
                            "\t\t\tuint8_t LSB = value.c_str()[i+1];",
                            "",
                            "\t\t\tif(MSB > '9') MSB -= 7;",
                            "\t\t\tif(LSB > '9') LSB -= 7;",
                            "\t\t\tm_uuid.uuid.uuid16 += (((MSB&0x0F) <<4) | (LSB & 0x0F))<<(2-i)*4;",
                            "\t\t\ti+=2;",
                            "\t\t}",
                            "\t}",
                            "\telse if (value.length() == 8) {",
                            "\t\tm_uuid.len         = ESP_UUID_LEN_32;",
                            "\t\tm_uuid.uuid.uuid32 = 0;",
                            "\t\tfor(int i=0;i<value.length();){",
                            "\t\t\tuint8_t MSB = value.c_str()[i];",
                            "\t\t\tuint8_t LSB = value.c_str()[i+1];",
                            "",
                            "\t\t\tif(MSB > '9') MSB -= 7;",
                            "\t\t\tif(LSB > '9') LSB -= 7;",
                            "\t\t\tm_uuid.uuid.uuid32 += (((MSB&0x0F) <<4) | (LSB & 0x0F))<<(6-i)*4;",
                            "\t\t\ti+=2;",
                            "\t\t}",
                            "\t}",
                            "\t\tm_uuid.len = ESP_UUID_LEN_128;",
                            "\t\tmemrcpy(m_uuid.uuid.uuid128, (uint8_t*)value.data(), 16);",
                            "\t}",
                            "\telse if (value.length() == 36) {",
                            "\t\tm_uuid.len = ESP_UUID_LEN_128;",
                            "\t\tint n = 0;",
                            "\t\tfor(int i=0;i<value.length();){",
                            "\t\t\tif(value.c_str()[i] == '-')",
                            "\t\t\t\ti++;",
                            "\t\t\tuint8_t MSB = value.c_str()[i];",
                            "\t\t\tuint8_t LSB = value.c_str()[i+1];",
                            "",
                            "\t\t\tif(MSB > '9') MSB -= 7;",
                            "\t\t\tif(LSB > '9') LSB -= 7;",
                            "\t\t\tm_uuid.uuid.uuid128[15-n++] = ((MSB&0x0F) <<4) | (LSB & 0x0F);",
                            "\t\t\ti+=2;",
                            "\t\t}",
                            "\t}",
                            "\telse {",
                            "\t\tESP_LOGE(LOG_TAG, \"ERROR: UUID value not 2, 4, 16 or 36 bytes\");",
                            "\t\tm_valueSet = false;",
                            "\t}",
                            "} //BLEUUID(std::string)",
                            "",
                            "",
                            "/**",
                            " * @brief Create a UUID from 16 bytes of memory.",
                            " *",
                            " * @param [in] pData The pointer to the start of the UUID.",
                            " * @param [in] size The size of the data.",
                            " * @param [in] msbFirst Is the MSB first in pData memory?",
                            " */",
                            "BLEUUID::BLEUUID(uint8_t* pData, size_t size, bool msbFirst) {",
                            "\tif (size != 16) {",
                            "\t\tESP_LOGE(LOG_TAG, \"ERROR: UUID length not 16 bytes\");",
                            "\t\treturn;",
                            "\t}",
                            "\tm_uuid.len = ESP_UUID_LEN_128;",
                            "\tif (msbFirst) {",
                            "\t\tmemrcpy(m_uuid.uuid.uuid128, pData, 16);",
                            "\t} else {",
                            "\t\tmemcpy(m_uuid.uuid.uuid128, pData, 16);",
                            "\t}",
                            "\tm_valueSet = true;",
                            "",
                            "",
                            "/**",
                            " * @brief Create a UUID from the 16bit value.",
                            " *",
                            " * @param [in] uuid The 16bit short form UUID.",
                            " */",
                            "BLEUUID::BLEUUID(uint16_t uuid) {",
                            "\tm_uuid.len         = ESP_UUID_LEN_16;",
                            "\tm_uuid.uuid.uuid16 = uuid;",
                            "\tm_valueSet         = true;",
                            "",
                            "",
                            "/**",
                            " * @brief Create a UUID from the 32bit value.",
                            " *",
                            " * @param [in] uuid The 32bit short form UUID.",
                            " */",
                            "BLEUUID::BLEUUID(uint32_t uuid) {",
                            "\tm_uuid.len         = ESP_UUID_LEN_32;",
                            "\tm_uuid.uuid.uuid32 = uuid;",
                            "\tm_valueSet         = true;",
                            "",
                            "",
                            "/**",
                            " * @brief Create a UUID from the native UUID.",
                            " *",
                            " * @param [in] uuid The native UUID.",
                            " */",
                            "BLEUUID::BLEUUID(esp_bt_uuid_t uuid) {",
                            "\tm_uuid     = uuid;",
                            "\tm_valueSet = true;",
                            "",
                            "",
                            "/**",
                            " * @brief Create a UUID from the ESP32 esp_gat_id_t.",
                            " *",
                            " * @param [in] gattId The data to create the UUID from.",
                            " */",
                            "BLEUUID::BLEUUID(esp_gatt_id_t gattId) : BLEUUID(gattId.uuid) {",
                            "",
                            "",
                            "BLEUUID::BLEUUID() {",
                            "\tm_valueSet = false;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the number of bits in this uuid.",
                            " * @return The number of bits in the UUID.  One of 16, 32 or 128.",
                            " */",
                            "uint8_t BLEUUID::bitSize() {",
                            "\tif (!m_valueSet) return 0;",
                            "\tswitch (m_uuid.len) {",
                            "\t\tcase ESP_UUID_LEN_16:",
                            "\t\t\treturn 16;",
                            "\t\tcase ESP_UUID_LEN_32:",
                            "\t\t\treturn 32;",
                            "\t\tcase ESP_UUID_LEN_128:",
                            "\t\t\treturn 128;",
                            "\t\tdefault:",
                            "\t\t\tESP_LOGE(LOG_TAG, \"Unknown UUID length: %d\", m_uuid.len);",
                            "\t\t\treturn 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Compare a UUID against this UUID.",
                            " *",
                            " * @param [in] uuid The UUID to compare against.",
                            " * @return True if the UUIDs are equal and false otherwise.",
                            " */",
                            "bool BLEUUID::equals(BLEUUID uuid) {",
                            "\t//ESP_LOGD(TAG, \"Comparing: %s to %s\", toString().c_str(), uuid.toString().c_str());",
                            "\tif (!m_valueSet || !uuid.m_valueSet) return false;",
                            "",
                            "\tif (uuid.m_uuid.len != m_uuid.len) {",
                            "\t\treturn uuid.toString() == toString();",
                            "\t}",
                            "",
                            "\tif (uuid.m_uuid.len == ESP_UUID_LEN_16) {",
                            "\t\treturn uuid.m_uuid.uuid.uuid16 == m_uuid.uuid.uuid16;",
                            "\t}",
                            "",
                            "\tif (uuid.m_uuid.len == ESP_UUID_LEN_32) {",
                            "\t\treturn uuid.m_uuid.uuid.uuid32 == m_uuid.uuid.uuid32;",
                            "\t}",
                            "",
                            "\treturn memcmp(uuid.m_uuid.uuid.uuid128, m_uuid.uuid.uuid128, 16) == 0;",
                            "",
                            "",
                            "/**",
                            " * Create a BLEUUID from a string of the form:",
                            " * 0xNNNN",
                            " * 0xNNNNNNNN",
                            " * 0x<UUID>",
                            " * NNNN",
                            " * NNNNNNNN",
                            " * <UUID>",
                            " */",
                            "BLEUUID BLEUUID::fromString(std::string _uuid) {",
                            "\tuint8_t start = 0;",
                            "\t\tstart = 2;",
                            "\t}",
                            "",
                            "\tif(len == 4) {",
                            "\t\tuint16_t x = strtoul(_uuid.substr(start, len).c_str(), NULL, 16);",
                            "\t\treturn BLEUUID(x);",
                            "\t} else if (len == 8) {",
                            "\t\tuint32_t x = strtoul(_uuid.substr(start, len).c_str(), NULL, 16);",
                            "\t\treturn BLEUUID(x);",
                            "\t} else if (len == 36) {",
                            "\t\treturn BLEUUID(_uuid);",
                            "\t}",
                            "\treturn BLEUUID();",
                            "",
                            "",
                            "/**",
                            " * @brief Get the native UUID value.",
                            " *",
                            " * @return The native UUID value or NULL if not set.",
                            " */",
                            "esp_bt_uuid_t* BLEUUID::getNative() {",
                            "\t//ESP_LOGD(TAG, \">> getNative()\")",
                            "\tif (m_valueSet == false) {",
                            "\t\tESP_LOGD(LOG_TAG, \"<< Return of un-initialized UUID!\");",
                            "\t\treturn nullptr;",
                            "\t}",
                            "\t//ESP_LOGD(TAG, \"<< getNative()\");",
                            "\treturn &m_uuid;",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a UUID to its 128 bit representation.",
                            " *",
                            " * A UUID can be internally represented as 16bit, 32bit or the full 128bit.  This method",
                            " * will convert 16 or 32 bit representations to the full 128bit.",
                            " */",
                            "BLEUUID BLEUUID::to128() {",
                            "\t//ESP_LOGD(LOG_TAG, \">> toFull() - %s\", toString().c_str());",
                            "",
                            "\tif (!m_valueSet || m_uuid.len == ESP_UUID_LEN_128) {",
                            "\t\treturn *this;",
                            "\t}",
                            "",
                            "\tif (m_uuid.len == ESP_UUID_LEN_16) {",
                            "\t\tuint16_t temp = m_uuid.uuid.uuid16;",
                            "\t\tm_uuid.uuid.uuid128[15] = 0;",
                            "\t\tm_uuid.uuid.uuid128[14] = 0;",
                            "\t\tm_uuid.uuid.uuid128[13] = (temp >> 8) & 0xff;",
                            "\t\tm_uuid.uuid.uuid128[12] = temp & 0xff;",
                            "",
                            "\t}",
                            "\telse if (m_uuid.len == ESP_UUID_LEN_32) {",
                            "\t\tuint32_t temp = m_uuid.uuid.uuid32;",
                            "\t\tm_uuid.uuid.uuid128[15] = (temp >> 24) & 0xff;",
                            "\t\tm_uuid.uuid.uuid128[14] = (temp >> 16) & 0xff;",
                            "\t\tm_uuid.uuid.uuid128[13] = (temp >> 8) & 0xff;",
                            "\t\tm_uuid.uuid.uuid128[12] = temp & 0xff;",
                            "\t}",
                            "",
                            "\tm_uuid.uuid.uuid128[11] = 0x00;",
                            "\tm_uuid.uuid.uuid128[10] = 0x00;",
                            "",
                            "\tm_uuid.uuid.uuid128[9]  = 0x10;",
                            "\tm_uuid.uuid.uuid128[8]  = 0x00;",
                            "",
                            "\tm_uuid.uuid.uuid128[7]  = 0x80;",
                            "\tm_uuid.uuid.uuid128[6]  = 0x00;",
                            "",
                            "\tm_uuid.uuid.uuid128[5]  = 0x00;",
                            "\tm_uuid.uuid.uuid128[4]  = 0x80;",
                            "\tm_uuid.uuid.uuid128[3]  = 0x5f;",
                            "\tm_uuid.uuid.uuid128[2]  = 0x9b;",
                            "\tm_uuid.uuid.uuid128[1]  = 0x34;",
                            "\tm_uuid.uuid.uuid128[0]  = 0xfb;",
                            "",
                            "\tm_uuid.len = ESP_UUID_LEN_128;",
                            "\t//ESP_LOGD(TAG, \"<< toFull <-  %s\", toString().c_str());",
                            "\treturn *this;",
                            "",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Get a string representation of the UUID.",
                            " *",
                            " * The format of a string is:",
                            " * 01234567 8901 2345 6789 012345678901",
                            " * 0000180d-0000-1000-8000-00805f9b34fb",
                            " * 0 1 2 3  4 5  6 7  8 9  0 1 2 3 4 5",
                            " *",
                            " * @return A string representation of the UUID.",
                            " */",
                            "std::string BLEUUID::toString() {",
                            "",
                            "\tstd::stringstream ss;",
                            "",
                            "\t\tss << \"0000\" <<",
                            "\t\t\tstd::hex <<",
                            "\t\t\tstd::setfill('0') <<",
                            "\t\t\tstd::setw(4) <<",
                            "\t\t\tm_uuid.uuid.uuid16 <<",
                            "\t\t\t\"-0000-1000-8000-00805f9b34fb\";",
                            "",
                            "\t\tss << std::hex <<",
                            "\t\t\tstd::setfill('0') <<",
                            "\t\t\tstd::setw(8) <<",
                            "\t\t\tm_uuid.uuid.uuid32 <<",
                            "\t\t\t\"-0000-1000-8000-00805f9b34fb\";",
                            "",
                            "\t//",
                            "\tss << std::hex << std::setfill('0') <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[15] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[14] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[13] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[12] << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[11] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[10] << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[9]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[8]  << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[7]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[6]  << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[5]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[4]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[3]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[2]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[1]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[0];",
                            "\treturn ss.str();",
                            "",
                            "#endif /* CONFIG_BT_ENABLED */"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "47": "\ttarget += (size - 1); // Point target to the last byte of the target data",
                "54": "} // memrcpy",
                "102": "\telse if (value.length() == 16) {  // how we can have 16 byte length string reprezenting 128 bit uuid??? needs to be investigated (lack of time)",
                "107": "\t\t// If the length of the string is 36 bytes then we will assume it is a long hex string in",
                "108": "\t\t// UUID format.",
                "149": "} // BLEUUID",
                "161": "} // BLEUUID",
                "173": "} // BLEUUID",
                "184": "} // BLEUUID",
                "193": "} // BLEUUID",
                "198": "} // BLEUUID",
                "217": "\t} // End of switch",
                "218": "} // bitSize",
                "244": "} // equals",
                "258": "\tif (strstr(_uuid.c_str(), \"0x\") != nullptr) { // If the string starts with 0x, skip those characters.",
                "261": "\tuint8_t len = _uuid.length() - start; // Calculate the length of the string we are going to use.",
                "273": "} // fromString",
                "289": "} // getNative",
                "301": "\t// If we either don't have a value or are already a 128 bit UUID, nothing further to do.",
                "306": "\t// If we are 16 bit or 32 bit, then set the 4 bytes of the variable part of the UUID.",
                "323": "\t// Set the fixed parts of the UUID.",
                "343": "} // to128",
                "359": "\tif (!m_valueSet) return \"<NULL>\";   // If we have no value, nothing to format.",
                "361": "\t// If the UUIDs are 16 or 32 bit, pad correctly.",
                "364": "\tif (m_uuid.len == ESP_UUID_LEN_16) {  // If the UUID is 16bit, pad correctly.",
                "371": "\t\treturn ss.str();                    // Return the string",
                "372": "\t} // End 16bit UUID",
                "374": "\tif (m_uuid.len == ESP_UUID_LEN_32) {  // If the UUID is 32bit, pad correctly.",
                "380": "\t\treturn ss.str();                    // return the string",
                "381": "\t} // End 32bit UUID",
                "383": "\t// The UUID is not 16bit or 32bit which means that it is 128bit.",
                "385": "\t// UUID string format:",
                "386": "\t// AABBCCDD-EEFF-GGHH-IIJJ-KKLLMMNNOOPP",
                "405": "} // toString"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "a22ec4a9787dbfe84afbe67543fdd2e22b995aec",
            "timestamp": "2019-07-09T19:31:17+03:00",
            "author": "Roman Savrulin",
            "commit_message": "Reduce flash usage up to 214k in one click (#2929)\n\n* std::stringstream -> std::string\r\n\r\n* Fix small issues\r\n\r\n* Small fix 2",
            "additions": 20,
            "deletions": 33,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            363
                        ],
                        "comments": [
                            "\t\treturn ss.str();                    // Return the string"
                        ],
                        "lines": []
                    },
                    {
                        "line_numbers": [
                            367,
                            368,
                            369,
                            370,
                            371,
                            372
                        ],
                        "comments": [
                            "\t\treturn ss.str();                    // return the string"
                        ],
                        "lines": [
                            "\t\tss << std::hex <<",
                            "\t\t\tstd::setfill('0') <<",
                            "\t\t\tstd::setw(8) <<",
                            "\t\t\tm_uuid.uuid.uuid32 <<",
                            "\t\t\t\"-0000-1000-8000-00805f9b34fb\";"
                        ]
                    },
                    {
                        "line_numbers": [
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396
                        ],
                        "comments": [],
                        "lines": [
                            "\tss << std::hex << std::setfill('0') <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[15] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[14] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[13] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[12] << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[11] <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[10] << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[9]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[8]  << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[7]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[6]  << \"-\" <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[5]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[4]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[3]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[2]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[1]  <<",
                            "\t\tstd::setw(2) << (int) m_uuid.uuid.uuid128[0];",
                            "\treturn ss.str();"
                        ]
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "363": "\t\treturn ss.str();                    // Return the string",
                "372": "\t\treturn ss.str();                    // return the string"
            },
            "comment_modified_diff": {}
        },
        {
            "commit": "5bff89f0be51da3a6306a342e75517f861ba61c9",
            "timestamp": "2019-09-29T23:03:48+03:00",
            "author": "William Ferguson",
            "commit_message": "Fixed issue-3153 - Allocating enough memory to construct the entire UUID as a String. (#3297)",
            "additions": 1,
            "deletions": 1,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            370
                        ],
                        "comments": [
                            "\tauto size = 37; // 32 for UUID data, 4 for '-' delimiters and one for a terminator == 37 chars"
                        ],
                        "lines": []
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "370": "\tauto size = 37; // 32 for UUID data, 4 for '-' delimiters and one for a terminator == 37 chars"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEUUID.h": [],
    "BLEUtils.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 2033,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544,
                            545,
                            546,
                            547,
                            548,
                            549,
                            550,
                            551,
                            552,
                            553,
                            554,
                            555,
                            556,
                            557,
                            558,
                            559,
                            560,
                            561,
                            562,
                            563,
                            564,
                            565,
                            566,
                            567,
                            568,
                            569,
                            570,
                            571,
                            572,
                            573,
                            574,
                            575,
                            576,
                            577,
                            578,
                            579,
                            580,
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            589,
                            590,
                            591,
                            592,
                            593,
                            594,
                            595,
                            596,
                            597,
                            598,
                            599,
                            600,
                            601,
                            602,
                            603,
                            604,
                            605,
                            606,
                            607,
                            608,
                            609,
                            610,
                            611,
                            612,
                            613,
                            614,
                            615,
                            616,
                            617,
                            618,
                            619,
                            620,
                            621,
                            622,
                            623,
                            624,
                            625,
                            626,
                            627,
                            628,
                            629,
                            630,
                            631,
                            632,
                            633,
                            634,
                            635,
                            636,
                            637,
                            638,
                            639,
                            640,
                            641,
                            642,
                            643,
                            644,
                            645,
                            646,
                            647,
                            648,
                            649,
                            650,
                            651,
                            652,
                            653,
                            654,
                            655,
                            656,
                            657,
                            658,
                            659,
                            660,
                            661,
                            662,
                            663,
                            664,
                            665,
                            666,
                            667,
                            668,
                            669,
                            670,
                            671,
                            672,
                            673,
                            674,
                            675,
                            676,
                            677,
                            678,
                            679,
                            680,
                            681,
                            682,
                            683,
                            684,
                            685,
                            686,
                            687,
                            688,
                            689,
                            690,
                            691,
                            692,
                            693,
                            694,
                            695,
                            696,
                            697,
                            698,
                            699,
                            700,
                            701,
                            702,
                            703,
                            704,
                            705,
                            706,
                            707,
                            708,
                            709,
                            710,
                            711,
                            712,
                            713,
                            714,
                            715,
                            716,
                            717,
                            718,
                            719,
                            720,
                            721,
                            722,
                            723,
                            724,
                            725,
                            726,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732,
                            733,
                            734,
                            735,
                            736,
                            737,
                            738,
                            739,
                            740,
                            741,
                            742,
                            743,
                            744,
                            745,
                            746,
                            747,
                            748,
                            749,
                            750,
                            751,
                            752,
                            753,
                            754,
                            755,
                            756,
                            757,
                            758,
                            759,
                            760,
                            761,
                            762,
                            763,
                            764,
                            765,
                            766,
                            767,
                            768,
                            769,
                            770,
                            771,
                            772,
                            773,
                            774,
                            775,
                            776,
                            777,
                            778,
                            779,
                            780,
                            781,
                            782,
                            783,
                            784,
                            785,
                            786,
                            787,
                            788,
                            789,
                            790,
                            791,
                            792,
                            793,
                            794,
                            795,
                            796,
                            797,
                            798,
                            799,
                            800,
                            801,
                            802,
                            803,
                            804,
                            805,
                            806,
                            807,
                            808,
                            809,
                            810,
                            811,
                            812,
                            813,
                            814,
                            815,
                            816,
                            817,
                            818,
                            819,
                            820,
                            821,
                            822,
                            823,
                            824,
                            825,
                            826,
                            827,
                            828,
                            829,
                            830,
                            831,
                            832,
                            833,
                            834,
                            835,
                            836,
                            837,
                            838,
                            839,
                            840,
                            841,
                            842,
                            843,
                            844,
                            845,
                            846,
                            847,
                            848,
                            849,
                            850,
                            851,
                            852,
                            853,
                            854,
                            855,
                            856,
                            857,
                            858,
                            859,
                            860,
                            861,
                            862,
                            863,
                            864,
                            865,
                            866,
                            867,
                            868,
                            869,
                            870,
                            871,
                            872,
                            873,
                            874,
                            875,
                            876,
                            877,
                            878,
                            879,
                            880,
                            881,
                            882,
                            883,
                            884,
                            885,
                            886,
                            887,
                            888,
                            889,
                            890,
                            891,
                            892,
                            893,
                            894,
                            895,
                            896,
                            897,
                            898,
                            899,
                            900,
                            901,
                            902,
                            903,
                            904,
                            905,
                            906,
                            907,
                            908,
                            909,
                            910,
                            911,
                            912,
                            913,
                            914,
                            915,
                            916,
                            917,
                            918,
                            919,
                            920,
                            921,
                            922,
                            923,
                            924,
                            925,
                            926,
                            927,
                            928,
                            929,
                            930,
                            931,
                            932,
                            933,
                            934,
                            935,
                            936,
                            937,
                            938,
                            939,
                            940,
                            941,
                            942,
                            943,
                            944,
                            945,
                            946,
                            947,
                            948,
                            949,
                            950,
                            951,
                            952,
                            953,
                            954,
                            955,
                            956,
                            957,
                            958,
                            959,
                            960,
                            961,
                            962,
                            963,
                            964,
                            965,
                            966,
                            967,
                            968,
                            969,
                            970,
                            971,
                            972,
                            973,
                            974,
                            975,
                            976,
                            977,
                            978,
                            979,
                            980,
                            981,
                            982,
                            983,
                            984,
                            985,
                            986,
                            987,
                            988,
                            989,
                            990,
                            991,
                            992,
                            993,
                            994,
                            995,
                            996,
                            997,
                            998,
                            999,
                            1000,
                            1001,
                            1002,
                            1003,
                            1004,
                            1005,
                            1006,
                            1007,
                            1008,
                            1009,
                            1010,
                            1011,
                            1012,
                            1013,
                            1014,
                            1015,
                            1016,
                            1017,
                            1018,
                            1019,
                            1020,
                            1021,
                            1022,
                            1023,
                            1024,
                            1025,
                            1026,
                            1027,
                            1028,
                            1029,
                            1030,
                            1031,
                            1032,
                            1033,
                            1034,
                            1035,
                            1036,
                            1037,
                            1038,
                            1039,
                            1040,
                            1041,
                            1042,
                            1043,
                            1044,
                            1045,
                            1046,
                            1047,
                            1048,
                            1049,
                            1050,
                            1051,
                            1052,
                            1053,
                            1054,
                            1055,
                            1056,
                            1057,
                            1058,
                            1059,
                            1060,
                            1061,
                            1062,
                            1063,
                            1064,
                            1065,
                            1066,
                            1067,
                            1068,
                            1069,
                            1070,
                            1071,
                            1072,
                            1073,
                            1074,
                            1075,
                            1076,
                            1077,
                            1078,
                            1079,
                            1080,
                            1081,
                            1082,
                            1083,
                            1084,
                            1085,
                            1086,
                            1087,
                            1088,
                            1089,
                            1090,
                            1091,
                            1092,
                            1093,
                            1094,
                            1095,
                            1096,
                            1097,
                            1098,
                            1099,
                            1100,
                            1101,
                            1102,
                            1103,
                            1104,
                            1105,
                            1106,
                            1107,
                            1108,
                            1109,
                            1110,
                            1111,
                            1112,
                            1113,
                            1114,
                            1115,
                            1116,
                            1117,
                            1118,
                            1119,
                            1120,
                            1121,
                            1122,
                            1123,
                            1124,
                            1125,
                            1126,
                            1127,
                            1128,
                            1129,
                            1130,
                            1131,
                            1132,
                            1133,
                            1134,
                            1135,
                            1136,
                            1137,
                            1138,
                            1139,
                            1140,
                            1141,
                            1142,
                            1143,
                            1144,
                            1145,
                            1146,
                            1147,
                            1148,
                            1149,
                            1150,
                            1151,
                            1152,
                            1153,
                            1154,
                            1155,
                            1156,
                            1157,
                            1158,
                            1159,
                            1160,
                            1161,
                            1162,
                            1163,
                            1164,
                            1165,
                            1166,
                            1167,
                            1168,
                            1169,
                            1170,
                            1171,
                            1172,
                            1173,
                            1174,
                            1175,
                            1176,
                            1177,
                            1178,
                            1179,
                            1180,
                            1181,
                            1182,
                            1183,
                            1184,
                            1185,
                            1186,
                            1187,
                            1188,
                            1189,
                            1190,
                            1191,
                            1192,
                            1193,
                            1194,
                            1195,
                            1196,
                            1197,
                            1198,
                            1199,
                            1200,
                            1201,
                            1202,
                            1203,
                            1204,
                            1205,
                            1206,
                            1207,
                            1208,
                            1209,
                            1210,
                            1211,
                            1212,
                            1213,
                            1214,
                            1215,
                            1216,
                            1217,
                            1218,
                            1219,
                            1220,
                            1221,
                            1222,
                            1223,
                            1224,
                            1225,
                            1226,
                            1227,
                            1228,
                            1229,
                            1230,
                            1231,
                            1232,
                            1233,
                            1234,
                            1235,
                            1236,
                            1237,
                            1238,
                            1239,
                            1240,
                            1241,
                            1242,
                            1243,
                            1244,
                            1245,
                            1246,
                            1247,
                            1248,
                            1249,
                            1250,
                            1251,
                            1252,
                            1253,
                            1254,
                            1255,
                            1256,
                            1257,
                            1258,
                            1259,
                            1260,
                            1261,
                            1262,
                            1263,
                            1264,
                            1265,
                            1266,
                            1267,
                            1268,
                            1269,
                            1270,
                            1271,
                            1272,
                            1273,
                            1274,
                            1275,
                            1276,
                            1277,
                            1278,
                            1279,
                            1280,
                            1281,
                            1282,
                            1283,
                            1284,
                            1285,
                            1286,
                            1287,
                            1288,
                            1289,
                            1290,
                            1291,
                            1292,
                            1293,
                            1294,
                            1295,
                            1296,
                            1297,
                            1298,
                            1299,
                            1300,
                            1301,
                            1302,
                            1303,
                            1304,
                            1305,
                            1306,
                            1307,
                            1308,
                            1309,
                            1310,
                            1311,
                            1312,
                            1313,
                            1314,
                            1315,
                            1316,
                            1317,
                            1318,
                            1319,
                            1320,
                            1321,
                            1322,
                            1323,
                            1324,
                            1325,
                            1326,
                            1327,
                            1328,
                            1329,
                            1330,
                            1331,
                            1332,
                            1333,
                            1334,
                            1335,
                            1336,
                            1337,
                            1338,
                            1339,
                            1340,
                            1341,
                            1342,
                            1343,
                            1344,
                            1345,
                            1346,
                            1347,
                            1348,
                            1349,
                            1350,
                            1351,
                            1352,
                            1353,
                            1354,
                            1355,
                            1356,
                            1357,
                            1358,
                            1359,
                            1360,
                            1361,
                            1362,
                            1363,
                            1364,
                            1365,
                            1366,
                            1367,
                            1368,
                            1369,
                            1370,
                            1371,
                            1372,
                            1373,
                            1374,
                            1375,
                            1376,
                            1377,
                            1378,
                            1379,
                            1380,
                            1381,
                            1382,
                            1383,
                            1384,
                            1385,
                            1386,
                            1387,
                            1388,
                            1389,
                            1390,
                            1391,
                            1392,
                            1393,
                            1394,
                            1395,
                            1396,
                            1397,
                            1398,
                            1399,
                            1400,
                            1401,
                            1402,
                            1403,
                            1404,
                            1405,
                            1406,
                            1407,
                            1408,
                            1409,
                            1410,
                            1411,
                            1412,
                            1413,
                            1414,
                            1415,
                            1416,
                            1417,
                            1418,
                            1419,
                            1420,
                            1421,
                            1422,
                            1423,
                            1424,
                            1425,
                            1426,
                            1427,
                            1428,
                            1429,
                            1430,
                            1431,
                            1432,
                            1433,
                            1434,
                            1435,
                            1436,
                            1437,
                            1438,
                            1439,
                            1440,
                            1441,
                            1442,
                            1443,
                            1444,
                            1445,
                            1446,
                            1447,
                            1448,
                            1449,
                            1450,
                            1451,
                            1452,
                            1453,
                            1454,
                            1455,
                            1456,
                            1457,
                            1458,
                            1459,
                            1460,
                            1461,
                            1462,
                            1463,
                            1464,
                            1465,
                            1466,
                            1467,
                            1468,
                            1469,
                            1470,
                            1471,
                            1472,
                            1473,
                            1474,
                            1475,
                            1476,
                            1477,
                            1478,
                            1479,
                            1480,
                            1481,
                            1482,
                            1483,
                            1484,
                            1485,
                            1486,
                            1487,
                            1488,
                            1489,
                            1490,
                            1491,
                            1492,
                            1493,
                            1494,
                            1495,
                            1496,
                            1497,
                            1498,
                            1499,
                            1500,
                            1501,
                            1502,
                            1503,
                            1504,
                            1505,
                            1506,
                            1507,
                            1508,
                            1509,
                            1510,
                            1511,
                            1512,
                            1513,
                            1514,
                            1515,
                            1516,
                            1517,
                            1518,
                            1519,
                            1520,
                            1521,
                            1522,
                            1523,
                            1524,
                            1525,
                            1526,
                            1527,
                            1528,
                            1529,
                            1530,
                            1531,
                            1532,
                            1533,
                            1534,
                            1535,
                            1536,
                            1537,
                            1538,
                            1539,
                            1540,
                            1541,
                            1542,
                            1543,
                            1544,
                            1545,
                            1546,
                            1547,
                            1548,
                            1549,
                            1550,
                            1551,
                            1552,
                            1553,
                            1554,
                            1555,
                            1556,
                            1557,
                            1558,
                            1559,
                            1560,
                            1561,
                            1562,
                            1563,
                            1564,
                            1565,
                            1566,
                            1567,
                            1568,
                            1569,
                            1570,
                            1571,
                            1572,
                            1573,
                            1574,
                            1575,
                            1576,
                            1577,
                            1578,
                            1579,
                            1580,
                            1581,
                            1582,
                            1583,
                            1584,
                            1585,
                            1586,
                            1587,
                            1588,
                            1589,
                            1590,
                            1591,
                            1592,
                            1593,
                            1594,
                            1595,
                            1596,
                            1597,
                            1598,
                            1599,
                            1600,
                            1601,
                            1602,
                            1603,
                            1604,
                            1605,
                            1606,
                            1607,
                            1608,
                            1609,
                            1610,
                            1611,
                            1612,
                            1613,
                            1614,
                            1615,
                            1616,
                            1617,
                            1618,
                            1619,
                            1620,
                            1621,
                            1622,
                            1623,
                            1624,
                            1625,
                            1626,
                            1627,
                            1628,
                            1629,
                            1630,
                            1631,
                            1632,
                            1633,
                            1634,
                            1635,
                            1636,
                            1637,
                            1638,
                            1639,
                            1640,
                            1641,
                            1642,
                            1643,
                            1644,
                            1645,
                            1646,
                            1647,
                            1648,
                            1649,
                            1650,
                            1651,
                            1652,
                            1653,
                            1654,
                            1655,
                            1656,
                            1657,
                            1658,
                            1659,
                            1660,
                            1661,
                            1662,
                            1663,
                            1664,
                            1665,
                            1666,
                            1667,
                            1668,
                            1669,
                            1670,
                            1671,
                            1672,
                            1673,
                            1674,
                            1675,
                            1676,
                            1677,
                            1678,
                            1679,
                            1680,
                            1681,
                            1682,
                            1683,
                            1684,
                            1685,
                            1686,
                            1687,
                            1688,
                            1689,
                            1690,
                            1691,
                            1692,
                            1693,
                            1694,
                            1695,
                            1696,
                            1697,
                            1698,
                            1699,
                            1700,
                            1701,
                            1702,
                            1703,
                            1704,
                            1705,
                            1706,
                            1707,
                            1708,
                            1709,
                            1710,
                            1711,
                            1712,
                            1713,
                            1714,
                            1715,
                            1716,
                            1717,
                            1718,
                            1719,
                            1720,
                            1721,
                            1722,
                            1723,
                            1724,
                            1725,
                            1726,
                            1727,
                            1728,
                            1729,
                            1730,
                            1731,
                            1732,
                            1733,
                            1734,
                            1735,
                            1736,
                            1737,
                            1738,
                            1739,
                            1740,
                            1741,
                            1742,
                            1743,
                            1744,
                            1745,
                            1746,
                            1747,
                            1748,
                            1749,
                            1750,
                            1751,
                            1752,
                            1753,
                            1754,
                            1755,
                            1756,
                            1757,
                            1758,
                            1759,
                            1760,
                            1761,
                            1762,
                            1763,
                            1764,
                            1765,
                            1766,
                            1767,
                            1768,
                            1769,
                            1770,
                            1771,
                            1772,
                            1773,
                            1774,
                            1775,
                            1776,
                            1777,
                            1778,
                            1779,
                            1780,
                            1781,
                            1782,
                            1783,
                            1784,
                            1785,
                            1786,
                            1787,
                            1788,
                            1789,
                            1790,
                            1791,
                            1792,
                            1793,
                            1794,
                            1795,
                            1796,
                            1797,
                            1798,
                            1799,
                            1800,
                            1801,
                            1802,
                            1803,
                            1804,
                            1805,
                            1806,
                            1807,
                            1808,
                            1809,
                            1810,
                            1811,
                            1812,
                            1813,
                            1814,
                            1815,
                            1816,
                            1817,
                            1818,
                            1819,
                            1820,
                            1821,
                            1822,
                            1823,
                            1824,
                            1825,
                            1826,
                            1827,
                            1828,
                            1829,
                            1830,
                            1831,
                            1832,
                            1833,
                            1834,
                            1835,
                            1836,
                            1837,
                            1838,
                            1839,
                            1840,
                            1841,
                            1842,
                            1843,
                            1844,
                            1845,
                            1846,
                            1847,
                            1848,
                            1849,
                            1850,
                            1851,
                            1852,
                            1853,
                            1854,
                            1855,
                            1856,
                            1857,
                            1858,
                            1859,
                            1860,
                            1861,
                            1862,
                            1863,
                            1864,
                            1865,
                            1866,
                            1867,
                            1868,
                            1869,
                            1870,
                            1871,
                            1872,
                            1873,
                            1874,
                            1875,
                            1876,
                            1877,
                            1878,
                            1879,
                            1880,
                            1881,
                            1882,
                            1883,
                            1884,
                            1885,
                            1886,
                            1887,
                            1888,
                            1889,
                            1890,
                            1891,
                            1892,
                            1893,
                            1894,
                            1895,
                            1896,
                            1897,
                            1898,
                            1899,
                            1900,
                            1901,
                            1902,
                            1903,
                            1904,
                            1905,
                            1906,
                            1907,
                            1908,
                            1909,
                            1910,
                            1911,
                            1912,
                            1913,
                            1914,
                            1915,
                            1916,
                            1917,
                            1918,
                            1919,
                            1920,
                            1921,
                            1922,
                            1923,
                            1924,
                            1925,
                            1926,
                            1927,
                            1928,
                            1929,
                            1930,
                            1931,
                            1932,
                            1933,
                            1934,
                            1935,
                            1936,
                            1937,
                            1938,
                            1939,
                            1940,
                            1941,
                            1942,
                            1943,
                            1944,
                            1945,
                            1946,
                            1947,
                            1948,
                            1949,
                            1950,
                            1951,
                            1952,
                            1953,
                            1954,
                            1955,
                            1956,
                            1957,
                            1958,
                            1959,
                            1960,
                            1961,
                            1962,
                            1963,
                            1964,
                            1965,
                            1966,
                            1967,
                            1968,
                            1969,
                            1970,
                            1971,
                            1972,
                            1973,
                            1974,
                            1975,
                            1976,
                            1977,
                            1978,
                            1979,
                            1980,
                            1981,
                            1982,
                            1983,
                            1984,
                            1985,
                            1986,
                            1987,
                            1988,
                            1989,
                            1990,
                            1991,
                            1992,
                            1993,
                            1994,
                            1995,
                            1996,
                            1997,
                            1998,
                            1999,
                            2000,
                            2001,
                            2002,
                            2003,
                            2004,
                            2005,
                            2006,
                            2007,
                            2008,
                            2009,
                            2010,
                            2011,
                            2012,
                            2013,
                            2014,
                            2015,
                            2016,
                            2017,
                            2018,
                            2019,
                            2020,
                            2021,
                            2022,
                            2023,
                            2024,
                            2025,
                            2026,
                            2027,
                            2028,
                            2029,
                            2030,
                            2031,
                            2032,
                            2033
                        ],
                        "comments": [
                            "#include <esp_bt.h>              // ESP32 BLE",
                            "#include <esp_bt_main.h>     // ESP32 BLE",
                            "#include <esp_gap_ble_api.h> // ESP32 BLE",
                            "#include <esp_gattc_api.h>   // ESP32 BLE",
                            "#include <esp_err.h>         // ESP32 ESP-IDF",
                            "#include <map>               // Part of C++ STL",
                            "static const char* LOG_TAG = \"BLEUtils\";  // Tag for logging.",
                            "} // characteristicPropertiesToString",
                            "} // gattIdToString",
                            "} // addressTypeToString",
                            "} // adFlagsToString",
                            "\t\tcase ESP_BLE_AD_TYPE_FLAG:\t\t\t\t   // 0x01",
                            "\t\tcase ESP_BLE_AD_TYPE_16SRV_PART:\t\t\t // 0x02",
                            "\t\tcase ESP_BLE_AD_TYPE_16SRV_CMPL:\t\t\t // 0x03",
                            "\t\tcase ESP_BLE_AD_TYPE_32SRV_PART:\t\t\t // 0x04",
                            "\t\tcase ESP_BLE_AD_TYPE_32SRV_CMPL:\t\t\t // 0x05",
                            "\t\tcase ESP_BLE_AD_TYPE_128SRV_PART:\t\t\t// 0x06",
                            "\t\tcase ESP_BLE_AD_TYPE_128SRV_CMPL:\t\t\t// 0x07",
                            "\t\tcase ESP_BLE_AD_TYPE_NAME_SHORT:\t\t\t // 0x08",
                            "\t\tcase ESP_BLE_AD_TYPE_NAME_CMPL:\t\t\t  // 0x09",
                            "\t\tcase ESP_BLE_AD_TYPE_TX_PWR:\t\t\t\t // 0x0a",
                            "\t\tcase ESP_BLE_AD_TYPE_DEV_CLASS:\t\t\t  // 0x0b",
                            "\t\tcase ESP_BLE_AD_TYPE_SM_TK:\t\t\t\t  // 0x10",
                            "\t\tcase ESP_BLE_AD_TYPE_SM_OOB_FLAG:\t\t\t// 0x11",
                            "\t\tcase ESP_BLE_AD_TYPE_INT_RANGE:\t\t\t  // 0x12",
                            "\t\tcase ESP_BLE_AD_TYPE_SOL_SRV_UUID:\t\t   // 0x14",
                            "\t\tcase ESP_BLE_AD_TYPE_128SOL_SRV_UUID:\t\t// 0x15",
                            "\t\tcase ESP_BLE_AD_TYPE_SERVICE_DATA:\t\t   // 0x16",
                            "\t\tcase ESP_BLE_AD_TYPE_PUBLIC_TARGET:\t\t  // 0x17",
                            "\t\tcase ESP_BLE_AD_TYPE_RANDOM_TARGET:\t\t  // 0x18",
                            "\t\tcase ESP_BLE_AD_TYPE_APPEARANCE:\t\t\t // 0x19",
                            "\t\tcase ESP_BLE_AD_TYPE_ADV_INT:\t\t\t\t// 0x1a",
                            "\t\tcase ESP_BLE_AD_TYPE_32SERVICE_DATA:\t\t // 0x20",
                            "\t\tcase ESP_BLE_AD_TYPE_128SERVICE_DATA:\t\t// 0x21",
                            "\t\tcase ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE:  // 0xff",
                            "\t} // End switch",
                            "} // advTypeToString",
                            "\t// Guard against too much data.",
                            "\t// Handle the special case where there was no data.",
                            "} // buildHexData",
                            "} // buildPrintData",
                            "} // gattCloseReasonToString",
                            "} // gattClientEventTypeToString",
                            "} // gattServerEventTypeToString",
                            "} // devTypeToString",
                            "\t\t// ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT",
                            "\t\t// adv_data_cmpl",
                            "\t\t// - esp_bt_status_t",
                            "\t\t} // ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT",
                            "\t\t// adv_data_raw_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_ADV_START_COMPLETE_EVT",
                            "\t\t// adv_start_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_ADV_START_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT",
                            "\t\t// adv_stop_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_AUTH_CMPL_EVT",
                            "\t\t// auth_cmpl",
                            "\t\t// - esp_bd_addr_t bd_addr",
                            "\t\t// - bool key_present",
                            "\t\t// - esp_link_key key",
                            "\t\t// - bool success",
                            "\t\t// - uint8_t fail_reason",
                            "\t\t// - esp_bd_addr_type_t addr_type",
                            "\t\t// - esp_bt_dev_type_t dev_type",
                            "\t\t} // ESP_GAP_BLE_AUTH_CMPL_EVT",
                            "\t\t// ESP_GAP_BLE_CLEAR_BOND_DEV_COMPLETE_EVT",
                            "\t\t// clear_bond_dev_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_CLEAR_BOND_DEV_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_LOCAL_IR_EVT",
                            "\t\t} // ESP_GAP_BLE_LOCAL_IR_EVT",
                            "\t\t// ESP_GAP_BLE_LOCAL_ER_EVT",
                            "\t\t} // ESP_GAP_BLE_LOCAL_ER_EVT",
                            "\t\t// ESP_GAP_BLE_NC_REQ_EVT",
                            "\t\t} // ESP_GAP_BLE_NC_REQ_EVT",
                            "\t\t// ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                            "\t\t// read_rssi_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t// - int8_t rssi",
                            "\t\t// - esp_bd_addr_t remote_addr",
                            "\t\t} // ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT",
                            "\t\t// scan_param_cmpl.",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_SCAN_RESULT_EVT",
                            "\t\t// scan_rst:",
                            "\t\t// - search_evt",
                            "\t\t// - bda",
                            "\t\t// - dev_type",
                            "\t\t// - ble_addr_type",
                            "\t\t// - ble_evt_type",
                            "\t\t// - rssi",
                            "\t\t// - ble_adv",
                            "\t\t// - flag",
                            "\t\t// - num_resps",
                            "\t\t// - adv_data_len",
                            "\t\t// - scan_rsp_len",
                            "\t\t\t\t} // ESP_GAP_SEARCH_INQ_RES_EVT",
                            "\t\t} // ESP_GAP_BLE_SCAN_RESULT_EVT",
                            "\t\t// ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT",
                            "\t\t// scan_rsp_data_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT",
                            "\t\t} // ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_SCAN_START_COMPLETE_EVT",
                            "\t\t// scan_start_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_SCAN_START_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT",
                            "\t\t// scan_stop_cmpl",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t} // ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT",
                            "\t\t// ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT",
                            "\t\t// update_conn_params",
                            "\t\t// - esp_bt_status_t status",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint16_t min_int",
                            "\t\t// - uint16_t max_int",
                            "\t\t// - uint16_t latency",
                            "\t\t// - uint16_t conn_int",
                            "\t\t// - uint16_t timeout",
                            "\t\t} // ESP_GAP_BLE_SCAN_UPDATE_CONN_PARAMS_EVT",
                            "\t\t// ESP_GAP_BLE_SEC_REQ_EVT",
                            "\t\t} // ESP_GAP_BLE_SEC_REQ_EVT",
                            "\t\t} // default",
                            "\t} // switch",
                            "} // dumpGapEvent",
                            "\t\t// ESP_GATTC_CLOSE_EVT",
                            "\t\t// close:",
                            "\t\t// - esp_gatt_status_t      status",
                            "\t\t// - uint16_t               conn_id",
                            "\t\t// - esp_bd_addr_t          remote_bda",
                            "\t\t// - esp_gatt_conn_reason_t reason",
                            "\t\t// ESP_GATTC_CONNECT_EVT",
                            "\t\t// connect:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "\t\t// - esp_bd_addr_t     remote_bda",
                            "\t\t// ESP_GATTC_DISCONNECT_EVT",
                            "\t\t// disconnect:",
                            "\t\t// - esp_gatt_conn_reason_t reason",
                            "\t\t// - uint16_t               conn_id",
                            "\t\t// - esp_bd_addr_t          remote_bda",
                            "\t\t} // ESP_GATTC_DISCONNECT_EVT",
                            "\t\t// ESP_GATTC_GET_CHAR_EVT",
                            "\t\t// get_char:",
                            "\t\t// - esp_gatt_status_t    status",
                            "\t\t// - uin1t6_t             conn_id",
                            "\t\t// - esp_gatt_srvc_id_t   srvc_id",
                            "\t\t// - esp_gatt_id_t        char_id",
                            "\t\t// - esp_gatt_char_prop_t char_prop",
                            "\t\t\t// If the status of the event shows that we have a value other than ESP_GATT_OK then the",
                            "\t\t\t// characteristic fields are not set to a usable value .. so don't try and log them.",
                            "\t\t} // ESP_GATTC_GET_CHAR_EVT",
                            "\t\t// ESP_GATTC_NOTIFY_EVT",
                            "\t\t// notify",
                            "\t\t// uint16_t           conn_id",
                            "\t\t// esp_bd_addr_t      remote_bda",
                            "\t\t// handle             handle",
                            "\t\t// uint16_t           value_len",
                            "\t\t// uint8_t*           value",
                            "\t\t// bool               is_notify",
                            "\t\t// ESP_GATTC_OPEN_EVT",
                            "\t\t// open:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "\t\t// - esp_bd_addr_t     remote_bda",
                            "\t\t// - uint16_t          mtu",
                            "\t\t} // ESP_GATTC_OPEN_EVT",
                            "\t\t// ESP_GATTC_READ_CHAR_EVT",
                            "\t\t// Callback to indicate that requested data that we wanted to read is now available.",
                            "\t\t// read:",
                            "\t\t// esp_gatt_status_t  status",
                            "\t\t// uint16_t           conn_id",
                            "\t\t// uint16_t           handle",
                            "\t\t// uint8_t*           value",
                            "\t\t// uint16_t           value_type",
                            "\t\t// uint16_t           value_len",
                            "\t\t} // ESP_GATTC_READ_CHAR_EVT",
                            "\t\t// ESP_GATTC_REG_EVT",
                            "\t\t// reg:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          app_id",
                            "\t\t} // ESP_GATTC_REG_EVT",
                            "\t\t// ESP_GATTC_REG_FOR_NOTIFY_EVT",
                            "\t\t// reg_for_notify:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          handle",
                            "\t\t} // ESP_GATTC_REG_FOR_NOTIFY_EVT",
                            "\t\t// ESP_GATTC_SEARCH_CMPL_EVT",
                            "\t\t// search_cmpl:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "\t\t} // ESP_GATTC_SEARCH_CMPL_EVT",
                            "\t\t// ESP_GATTC_SEARCH_RES_EVT",
                            "\t\t// search_res:",
                            "\t\t// - uint16_t      conn_id",
                            "\t\t// - uint16_t      start_handle",
                            "\t\t// - uint16_t      end_handle",
                            "\t\t// - esp_gatt_id_t srvc_id",
                            "\t\t} // ESP_GATTC_SEARCH_RES_EVT",
                            "\t\t// ESP_GATTC_WRITE_CHAR_EVT",
                            "\t\t// write:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          conn_id",
                            "\t\t// - uint16_t          handle",
                            "\t\t// - uint16_t          offset",
                            "\t\t} // ESP_GATTC_WRITE_CHAR_EVT",
                            "} // dumpGattClientEvent",
                            "\t\t} // ESP_GATTS_ADD_CHAR_DESCR_EVT",
                            "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                            "\t\t// ESP_GATTS_CONF_EVT",
                            "\t\t// conf:",
                            "\t\t// - esp_gatt_status_t status  \u2013 The status code.",
                            "\t\t// - uint16_t          conn_id \u2013 The connection used.",
                            "\t\t} // ESP_GATTS_CONF_EVT",
                            "\t\t} // ESP_GATTS_CONGEST_EVT",
                            "\t\t} // ESP_GATTS_CONNECT_EVT",
                            "\t\t} // ESP_GATTS_CREATE_EVT",
                            "\t\t} // ESP_GATTS_DISCONNECT_EVT",
                            "\t\t// ESP_GATTS_EXEC_WRITE_EVT",
                            "\t\t// exec_write:",
                            "\t\t// - uint16_t conn_id",
                            "\t\t// - uint32_t trans_id",
                            "\t\t// - esp_bd_addr_t bda",
                            "\t\t// - uint8_t exec_write_flag",
                            "\t\t} // ESP_GATTS_DISCONNECT_EVT",
                            "\t\t} // ESP_GATTS_MTU_EVT",
                            "\t\t} // ESP_GATTS_READ_EVT",
                            "\t\t} // ESP_GATTS_RESPONSE_EVT",
                            "\t\t} // ESP_GATTS_REG_EVT",
                            "\t\t// ESP_GATTS_START_EVT",
                            "\t\t// start:",
                            "\t\t// - esp_gatt_status_t status",
                            "\t\t// - uint16_t          service_handle",
                            "\t\t} // ESP_GATTS_START_EVT",
                            "\t\t// ESP_GATTS_WRITE_EVT",
                            "\t\t// write:",
                            "\t\t// - uint16_t      conn_id  \u2013 The connection id.",
                            "\t\t// - uint16_t      trans_id \u2013 The transfer id.",
                            "\t\t// - esp_bd_addr_t bda      \u2013 The address of the partner.",
                            "\t\t// - uint16_t      handle   \u2013 The attribute handle.",
                            "\t\t// - uint16_t      offset   \u2013 The offset of the currently received within the whole value.",
                            "\t\t// - bool          need_rsp \u2013 Do we need a response?",
                            "\t\t// - bool          is_prep  \u2013 Is this a write prepare?  If set, then this is to be considered part of the received value and not the whole value.  A subsequent ESP_GATTS_EXEC_WRITE will mark the total.",
                            "\t\t// - uint16_t      len      \u2013 The length of the incoming value part.",
                            "\t\t// - uint8_t*      value    \u2013 The data for this value part.",
                            "\t\t} // ESP_GATTS_WRITE_EVT",
                            "} // dumpGattServerEvent",
                            "} // eventTypeToString",
                            "} // gapEventToString",
                            "} // gattCharacteristicUUIDToString",
                            "} // gattDescriptorUUIDToString",
                            "} // gattcServiceElementToString",
                            "} // gattServiceIdToString",
                            "} // gattServiceToString",
                            "} // gattStatusToString",
                            "} // searchEventTypeToString",
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            "#include <sstream>",
                            "#include <iomanip>",
                            "",
                            "#if defined(ARDUINO_ARCH_ESP32) && defined(CONFIG_ARDUHAL_ESP_LOG)",
                            "#include \"esp32-hal-log.h\"",
                            "#define LOG_TAG \"\"",
                            "#else",
                            "#include \"esp_log.h\"",
                            "#endif",
                            "",
                            "",
                            "/*",
                            "static std::map<std::string, BLEClient*> g_addressMap;",
                            "static std::map<uint16_t, BLEClient*> g_connIdMap;",
                            "*/",
                            "",
                            "typedef struct {",
                            "\tuint32_t    assignedNumber;",
                            "\tconst char* name;",
                            "} member_t;",
                            "",
                            "static const member_t members_ids[] = {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t{0xFE08, \"Microsoft\"},",
                            "\t{0xFE09, \"Pillsy, Inc.\"},",
                            "\t{0xFE0A, \"ruwido austria gmbh\"},",
                            "\t{0xFE0B, \"ruwido austria gmbh\"},",
                            "\t{0xFE0C, \"Procter & Gamble\"},",
                            "\t{0xFE0D, \"Procter & Gamble\"},",
                            "\t{0xFE0E, \"Setec Pty Ltd\"},",
                            "\t{0xFE0F, \"Philips Lighting B.V.\"},",
                            "\t{0xFE10, \"Lapis Semiconductor Co., Ltd.\"},",
                            "\t{0xFE11, \"GMC-I Messtechnik GmbH\"},",
                            "\t{0xFE12, \"M-Way Solutions GmbH\"},",
                            "\t{0xFE13, \"Apple Inc.\"},",
                            "\t{0xFE14, \"Flextronics International USA Inc.\"},",
                            "\t{0xFE15, \"Amazon Fulfillment Services, Inc.\"},",
                            "\t{0xFE16, \"Footmarks, Inc.\"},",
                            "\t{0xFE17, \"Telit Wireless Solutions GmbH\"},",
                            "\t{0xFE18, \"Runtime, Inc.\"},",
                            "\t{0xFE19, \"Google Inc.\"},",
                            "\t{0xFE1A, \"Tyto Life LLC\"},",
                            "\t{0xFE1B, \"Tyto Life LLC\"},",
                            "\t{0xFE1C, \"NetMedia, Inc.\"},",
                            "\t{0xFE1D, \"Illuminati Instrument Corporation\"},",
                            "\t{0xFE1E, \"Smart Innovations Co., Ltd\"},",
                            "\t{0xFE1F, \"Garmin International, Inc.\"},",
                            "\t{0xFE20, \"Emerson\"},",
                            "\t{0xFE21, \"Bose Corporation\"},",
                            "\t{0xFE22, \"Zoll Medical Corporation\"},",
                            "\t{0xFE23, \"Zoll Medical Corporation\"},",
                            "\t{0xFE24, \"August Home Inc\"},",
                            "\t{0xFE25, \"Apple, Inc. \"},",
                            "\t{0xFE26, \"Google Inc.\"},",
                            "\t{0xFE27, \"Google Inc.\"},",
                            "\t{0xFE28, \"Ayla Networks\"},",
                            "\t{0xFE29, \"Gibson Innovations\"},",
                            "\t{0xFE2A, \"DaisyWorks, Inc.\"},",
                            "\t{0xFE2B, \"ITT Industries\"},",
                            "\t{0xFE2C, \"Google Inc.\"},",
                            "\t{0xFE2D, \"SMART INNOVATION Co.,Ltd\"},",
                            "\t{0xFE2E, \"ERi,Inc.\"},",
                            "\t{0xFE2F, \"CRESCO Wireless, Inc\"},",
                            "\t{0xFE30, \"Volkswagen AG\"},",
                            "\t{0xFE31, \"Volkswagen AG\"},",
                            "\t{0xFE32, \"Pro-Mark, Inc.\"},",
                            "\t{0xFE33, \"CHIPOLO d.o.o.\"},",
                            "\t{0xFE34, \"SmallLoop LLC\"},",
                            "\t{0xFE35, \"HUAWEI Technologies Co., Ltd\"},",
                            "\t{0xFE36, \"HUAWEI Technologies Co., Ltd\"},",
                            "\t{0xFE37, \"Spaceek LTD\"},",
                            "\t{0xFE38, \"Spaceek LTD\"},",
                            "\t{0xFE39, \"TTS Tooltechnic Systems AG & Co. KG\"},",
                            "\t{0xFE3A, \"TTS Tooltechnic Systems AG & Co. KG\"},",
                            "\t{0xFE3B, \"Dolby Laboratories\"},",
                            "\t{0xFE3C, \"Alibaba\"},",
                            "\t{0xFE3D, \"BD Medical\"},",
                            "\t{0xFE3E, \"BD Medical\"},",
                            "\t{0xFE3F, \"Friday Labs Limited\"},",
                            "\t{0xFE40, \"Inugo Systems Limited\"},",
                            "\t{0xFE41, \"Inugo Systems Limited\"},",
                            "\t{0xFE42, \"Nets A/S \"},",
                            "\t{0xFE43, \"Andreas Stihl AG & Co. KG\"},",
                            "\t{0xFE44, \"SK Telecom \"},",
                            "\t{0xFE45, \"Snapchat Inc\"},",
                            "\t{0xFE46, \"B&O Play A/S \"},",
                            "\t{0xFE47, \"General Motors\"},",
                            "\t{0xFE48, \"General Motors\"},",
                            "\t{0xFE49, \"SenionLab AB\"},",
                            "\t{0xFE4A, \"OMRON HEALTHCARE Co., Ltd.\"},",
                            "\t{0xFE4B, \"Philips Lighting B.V.\"},",
                            "\t{0xFE4C, \"Volkswagen AG\"},",
                            "\t{0xFE4D, \"Casambi Technologies Oy\"},",
                            "\t{0xFE4E, \"NTT docomo\"},",
                            "\t{0xFE4F, \"Molekule, Inc.\"},",
                            "\t{0xFE50, \"Google Inc.\"},",
                            "\t{0xFE51, \"SRAM\"},",
                            "\t{0xFE52, \"SetPoint Medical\"},",
                            "\t{0xFE53, \"3M\"},",
                            "\t{0xFE54, \"Motiv, Inc.\"},",
                            "\t{0xFE55, \"Google Inc.\"},",
                            "\t{0xFE56, \"Google Inc.\"},",
                            "\t{0xFE57, \"Dotted Labs\"},",
                            "\t{0xFE58, \"Nordic Semiconductor ASA\"},",
                            "\t{0xFE59, \"Nordic Semiconductor ASA\"},",
                            "\t{0xFE5A, \"Chronologics Corporation\"},",
                            "\t{0xFE5B, \"GT-tronics HK Ltd\"},",
                            "\t{0xFE5C, \"million hunters GmbH\"},",
                            "\t{0xFE5D, \"Grundfos A/S\"},",
                            "\t{0xFE5E, \"Plastc Corporation\"},",
                            "\t{0xFE5F, \"Eyefi, Inc.\"},",
                            "\t{0xFE60, \"Lierda Science & Technology Group Co., Ltd.\"},",
                            "\t{0xFE61, \"Logitech International SA\"},",
                            "\t{0xFE62, \"Indagem Tech LLC\"},",
                            "\t{0xFE63, \"Connected Yard, Inc.\"},",
                            "\t{0xFE64, \"Siemens AG\"},",
                            "\t{0xFE65, \"CHIPOLO d.o.o.\"},",
                            "\t{0xFE66, \"Intel Corporation\"},",
                            "\t{0xFE67, \"Lab Sensor Solutions\"},",
                            "\t{0xFE68, \"Qualcomm Life Inc\"},",
                            "\t{0xFE69, \"Qualcomm Life Inc\"},",
                            "\t{0xFE6A, \"Kontakt Micro-Location Sp. z o.o.\"},",
                            "\t{0xFE6B, \"TASER International, Inc.\"},",
                            "\t{0xFE6C, \"TASER International, Inc.\"},",
                            "\t{0xFE6D, \"The University of Tokyo\"},",
                            "\t{0xFE6E, \"The University of Tokyo\"},",
                            "\t{0xFE6F, \"LINE Corporation\"},",
                            "\t{0xFE70, \"Beijing Jingdong Century Trading Co., Ltd.\"},",
                            "\t{0xFE71, \"Plume Design Inc\"},",
                            "\t{0xFE72, \"St. Jude Medical, Inc.\"},",
                            "\t{0xFE73, \"St. Jude Medical, Inc.\"},",
                            "\t{0xFE74, \"unwire\"},",
                            "\t{0xFE75, \"TangoMe\"},",
                            "\t{0xFE76, \"TangoMe\"},",
                            "\t{0xFE77, \"Hewlett-Packard Company\"},",
                            "\t{0xFE78, \"Hewlett-Packard Company\"},",
                            "\t{0xFE79, \"Zebra Technologies\"},",
                            "\t{0xFE7A, \"Bragi GmbH\"},",
                            "\t{0xFE7B, \"Orion Labs, Inc.\"},",
                            "\t{0xFE7C, \"Telit Wireless Solutions (Formerly Stollmann E+V GmbH)\"},",
                            "\t{0xFE7D, \"Aterica Health Inc.\"},",
                            "\t{0xFE7E, \"Awear Solutions Ltd\"},",
                            "\t{0xFE7F, \"Doppler Lab\"},",
                            "\t{0xFE80, \"Doppler Lab\"},",
                            "\t{0xFE81, \"Medtronic Inc.\"},",
                            "\t{0xFE82, \"Medtronic Inc.\"},",
                            "\t{0xFE83, \"Blue Bite\"},",
                            "\t{0xFE84, \"RF Digital Corp\"},",
                            "\t{0xFE85, \"RF Digital Corp\"},",
                            "\t{0xFE86, \"HUAWEI Technologies Co., Ltd. ( )\"},",
                            "\t{0xFE87, \"Qingdao Yeelink Information Technology Co., Ltd. ( )\"},",
                            "\t{0xFE88, \"SALTO SYSTEMS S.L.\"},",
                            "\t{0xFE89, \"B&O Play A/S\"},",
                            "\t{0xFE8A, \"Apple, Inc.\"},",
                            "\t{0xFE8B, \"Apple, Inc.\"},",
                            "\t{0xFE8C, \"TRON Forum\"},",
                            "\t{0xFE8D, \"Interaxon Inc.\"},",
                            "\t{0xFE8E, \"ARM Ltd\"},",
                            "\t{0xFE8F, \"CSR\"},",
                            "\t{0xFE90, \"JUMA\"},",
                            "\t{0xFE91, \"Shanghai Imilab Technology Co.,Ltd\"},",
                            "\t{0xFE92, \"Jarden Safety & Security\"},",
                            "\t{0xFE93, \"OttoQ Inc.\"},",
                            "\t{0xFE94, \"OttoQ Inc.\"},",
                            "\t{0xFE95, \"Xiaomi Inc.\"},",
                            "\t{0xFE96, \"Tesla Motor Inc.\"},",
                            "\t{0xFE97, \"Tesla Motor Inc.\"},",
                            "\t{0xFE98, \"Currant, Inc.\"},",
                            "\t{0xFE99, \"Currant, Inc.\"},",
                            "\t{0xFE9A, \"Estimote\"},",
                            "\t{0xFE9B, \"Samsara Networks, Inc\"},",
                            "\t{0xFE9C, \"GSI Laboratories, Inc.\"},",
                            "\t{0xFE9D, \"Mobiquity Networks Inc\"},",
                            "\t{0xFE9E, \"Dialog Semiconductor B.V.\"},",
                            "\t{0xFE9F, \"Google Inc.\"},",
                            "\t{0xFEA0, \"Google Inc.\"},",
                            "\t{0xFEA1, \"Intrepid Control Systems, Inc.\"},",
                            "\t{0xFEA2, \"Intrepid Control Systems, Inc.\"},",
                            "\t{0xFEA3, \"ITT Industries\"},",
                            "\t{0xFEA4, \"Paxton Access Ltd\"},",
                            "\t{0xFEA5, \"GoPro, Inc.\"},",
                            "\t{0xFEA6, \"GoPro, Inc.\"},",
                            "\t{0xFEA7, \"UTC Fire and Security\"},",
                            "\t{0xFEA8, \"Savant Systems LLC\"},",
                            "\t{0xFEA9, \"Savant Systems LLC\"},",
                            "\t{0xFEAA, \"Google Inc.\"},",
                            "\t{0xFEAB, \"Nokia Corporation\"},",
                            "\t{0xFEAC, \"Nokia Corporation\"},",
                            "\t{0xFEAD, \"Nokia Corporation\"},",
                            "\t{0xFEAE, \"Nokia Corporation\"},",
                            "\t{0xFEAF, \"Nest Labs Inc.\"},",
                            "\t{0xFEB0, \"Nest Labs Inc.\"},",
                            "\t{0xFEB1, \"Electronics Tomorrow Limited\"},",
                            "\t{0xFEB2, \"Microsoft Corporation\"},",
                            "\t{0xFEB3, \"Taobao\"},",
                            "\t{0xFEB4, \"WiSilica Inc.\"},",
                            "\t{0xFEB5, \"WiSilica Inc.\"},",
                            "\t{0xFEB6, \"Vencer Co, Ltd\"},",
                            "\t{0xFEB7, \"Facebook, Inc.\"},",
                            "\t{0xFEB8, \"Facebook, Inc.\"},",
                            "\t{0xFEB9, \"LG Electronics\"},",
                            "\t{0xFEBA, \"Tencent Holdings Limited\"},",
                            "\t{0xFEBB, \"adafruit industries\"},",
                            "\t{0xFEBC, \"Dexcom, Inc. \"},",
                            "\t{0xFEBD, \"Clover Network, Inc.\"},",
                            "\t{0xFEBE, \"Bose Corporation\"},",
                            "\t{0xFEBF, \"Nod, Inc.\"},",
                            "\t{0xFEC0, \"KDDI Corporation\"},",
                            "\t{0xFEC1, \"KDDI Corporation\"},",
                            "\t{0xFEC2, \"Blue Spark Technologies, Inc.\"},",
                            "\t{0xFEC3, \"360fly, Inc.\"},",
                            "\t{0xFEC4, \"PLUS Location Systems\"},",
                            "\t{0xFEC5, \"Realtek Semiconductor Corp.\"},",
                            "\t{0xFEC6, \"Kocomojo, LLC\"},",
                            "\t{0xFEC7, \"Apple, Inc.\"},",
                            "\t{0xFEC8, \"Apple, Inc.\"},",
                            "\t{0xFEC9, \"Apple, Inc.\"},",
                            "\t{0xFECA, \"Apple, Inc.\"},",
                            "\t{0xFECB, \"Apple, Inc.\"},",
                            "\t{0xFECC, \"Apple, Inc.\"},",
                            "\t{0xFECD, \"Apple, Inc.\"},",
                            "\t{0xFECE, \"Apple, Inc.\"},",
                            "\t{0xFECF, \"Apple, Inc.\"},",
                            "\t{0xFED0, \"Apple, Inc.\"},",
                            "\t{0xFED1, \"Apple, Inc.\"},",
                            "\t{0xFED2, \"Apple, Inc.\"},",
                            "\t{0xFED3, \"Apple, Inc.\"},",
                            "\t{0xFED4, \"Apple, Inc.\"},",
                            "\t{0xFED5, \"Plantronics Inc.\"},",
                            "\t{0xFED6, \"Broadcom Corporation\"},",
                            "\t{0xFED7, \"Broadcom Corporation\"},",
                            "\t{0xFED8, \"Google Inc.\"},",
                            "\t{0xFED9, \"Pebble Technology Corporation\"},",
                            "\t{0xFEDA, \"ISSC Technologies Corporation\"},",
                            "\t{0xFEDB, \"Perka, Inc.\"},",
                            "\t{0xFEDC, \"Jawbone\"},",
                            "\t{0xFEDD, \"Jawbone\"},",
                            "\t{0xFEDE, \"Coin, Inc.\"},",
                            "\t{0xFEDF, \"Design SHIFT\"},",
                            "\t{0xFEE0, \"Anhui Huami Information Technology Co.\"},",
                            "\t{0xFEE1, \"Anhui Huami Information Technology Co.\"},",
                            "\t{0xFEE2, \"Anki, Inc.\"},",
                            "\t{0xFEE3, \"Anki, Inc.\"},",
                            "\t{0xFEE4, \"Nordic Semiconductor ASA\"},",
                            "\t{0xFEE5, \"Nordic Semiconductor ASA\"},",
                            "\t{0xFEE6, \"Silvair, Inc.\"},",
                            "\t{0xFEE7, \"Tencent Holdings Limited\"},",
                            "\t{0xFEE8, \"Quintic Corp.\"},",
                            "\t{0xFEE9, \"Quintic Corp.\"},",
                            "\t{0xFEEA, \"Swirl Networks, Inc.\"},",
                            "\t{0xFEEB, \"Swirl Networks, Inc.\"},",
                            "\t{0xFEEC, \"Tile, Inc.\"},",
                            "\t{0xFEED, \"Tile, Inc.\"},",
                            "\t{0xFEEE, \"Polar Electro Oy\"},",
                            "\t{0xFEEF, \"Polar Electro Oy\"},",
                            "\t{0xFEF0, \"Intel\"},",
                            "\t{0xFEF1, \"CSR\"},",
                            "\t{0xFEF2, \"CSR\"},",
                            "\t{0xFEF3, \"Google Inc.\"},",
                            "\t{0xFEF4, \"Google Inc.\"},",
                            "\t{0xFEF5, \"Dialog Semiconductor GmbH\"},",
                            "\t{0xFEF6, \"Wicentric, Inc.\"},",
                            "\t{0xFEF7, \"Aplix Corporation\"},",
                            "\t{0xFEF8, \"Aplix Corporation\"},",
                            "\t{0xFEF9, \"PayPal, Inc.\"},",
                            "\t{0xFEFA, \"PayPal, Inc.\"},",
                            "\t{0xFEFB, \"Telit Wireless Solutions (Formerly Stollmann E+V GmbH)\"},",
                            "\t{0xFEFC, \"Gimbal, Inc.\"},",
                            "\t{0xFEFD, \"Gimbal, Inc.\"},",
                            "\t{0xFEFE, \"GN ReSound A/S\"},",
                            "\t{0xFEFF, \"GN Netcom\"},",
                            "\t{0xFFFF, \"Reserved\"}, /*for testing purposes only*/",
                            "#endif",
                            "\t{0, \"\" }",
                            "};",
                            "",
                            "typedef struct {",
                            "\tuint32_t    assignedNumber;",
                            "\tconst char* name;",
                            "} gattdescriptor_t;",
                            "",
                            "static const gattdescriptor_t g_descriptor_ids[] = {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\t{0x2905,\"Characteristic Aggregate Format\"},",
                            "\t\t{0x2900,\"Characteristic Extended Properties\"},",
                            "\t\t{0x2904,\"Characteristic Presentation Format\"},",
                            "\t\t{0x2901,\"Characteristic User Description\"},",
                            "\t\t{0x2902,\"Client Characteristic Configuration\"},",
                            "\t\t{0x290B,\"Environmental Sensing Configuration\"},",
                            "\t\t{0x290C,\"Environmental Sensing Measurement\"},",
                            "\t\t{0x290D,\"Environmental Sensing Trigger Setting\"},",
                            "\t\t{0x2907,\"External Report Reference\"},",
                            "\t\t{0x2909,\"Number of Digitals\"},",
                            "\t\t{0x2908,\"Report Reference\"},",
                            "\t\t{0x2903,\"Server Characteristic Configuration\"},",
                            "\t\t{0x290E,\"Time Trigger Setting\"},",
                            "\t\t{0x2906,\"Valid Range\"},",
                            "\t\t{0x290A,\"Value Trigger Setting\"},",
                            "#endif",
                            "\t\t{ 0, \"\" }",
                            "};",
                            "",
                            "typedef struct {",
                            "\tuint32_t    assignedNumber;",
                            "\tconst char* name;",
                            "} characteristicMap_t;",
                            "",
                            "static const characteristicMap_t g_characteristicsMappings[] = {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\t{0x2A7E,\"Aerobic Heart Rate Lower Limit\"},",
                            "\t\t{0x2A84,\"Aerobic Heart Rate Upper Limit\"},",
                            "\t\t{0x2A7F,\"Aerobic Threshold\"},",
                            "\t\t{0x2A80,\"Age\"},",
                            "\t\t{0x2A5A,\"Aggregate\"},",
                            "\t\t{0x2A43,\"Alert Category ID\"},",
                            "\t\t{0x2A42,\"Alert Category ID Bit Mask\"},",
                            "\t\t{0x2A06,\"Alert Level\"},",
                            "\t\t{0x2A44,\"Alert Notification Control Point\"},",
                            "\t\t{0x2A3F,\"Alert Status\"},",
                            "\t\t{0x2AB3,\"Altitude\"},",
                            "\t\t{0x2A81,\"Anaerobic Heart Rate Lower Limit\"},",
                            "\t\t{0x2A82,\"Anaerobic Heart Rate Upper Limit\"},",
                            "\t\t{0x2A83,\"Anaerobic Threshold\"},",
                            "\t\t{0x2A58,\"Analog\"},",
                            "\t\t{0x2A59,\"Analog Output\"},",
                            "\t\t{0x2A73,\"Apparent Wind Direction\"},",
                            "\t\t{0x2A72,\"Apparent Wind Speed\"},",
                            "\t\t{0x2A01,\"Appearance\"},",
                            "\t\t{0x2AA3,\"Barometric Pressure Trend\"},",
                            "\t\t{0x2A19,\"Battery Level\"},",
                            "\t\t{0x2A1B,\"Battery Level State\"},",
                            "\t\t{0x2A1A,\"Battery Power State\"},",
                            "\t\t{0x2A49,\"Blood Pressure Feature\"},",
                            "\t\t{0x2A35,\"Blood Pressure Measurement\"},",
                            "\t\t{0x2A9B,\"Body Composition Feature\"},",
                            "\t\t{0x2A9C,\"Body Composition Measurement\"},",
                            "\t\t{0x2A38,\"Body Sensor Location\"},",
                            "\t\t{0x2AA4,\"Bond Management Control Point\"},",
                            "\t\t{0x2AA5,\"Bond Management Features\"},",
                            "\t\t{0x2A22,\"Boot Keyboard Input Report\"},",
                            "\t\t{0x2A32,\"Boot Keyboard Output Report\"},",
                            "\t\t{0x2A33,\"Boot Mouse Input Report\"},",
                            "\t\t{0x2AA6,\"Central Address Resolution\"},",
                            "\t\t{0x2AA8,\"CGM Feature\"},",
                            "\t\t{0x2AA7,\"CGM Measurement\"},",
                            "\t\t{0x2AAB,\"CGM Session Run Time\"},",
                            "\t\t{0x2AAA,\"CGM Session Start Time\"},",
                            "\t\t{0x2AAC,\"CGM Specific Ops Control Point\"},",
                            "\t\t{0x2AA9,\"CGM Status\"},",
                            "\t\t{0x2ACE,\"Cross Trainer Data\"},",
                            "\t\t{0x2A5C,\"CSC Feature\"},",
                            "\t\t{0x2A5B,\"CSC Measurement\"},",
                            "\t\t{0x2A2B,\"Current Time\"},",
                            "\t\t{0x2A66,\"Cycling Power Control Point\"},",
                            "\t\t{0x2A66,\"Cycling Power Control Point\"},",
                            "\t\t{0x2A65,\"Cycling Power Feature\"},",
                            "\t\t{0x2A65,\"Cycling Power Feature\"},",
                            "\t\t{0x2A63,\"Cycling Power Measurement\"},",
                            "\t\t{0x2A64,\"Cycling Power Vector\"},",
                            "\t\t{0x2A99,\"Database Change Increment\"},",
                            "\t\t{0x2A85,\"Date of Birth\"},",
                            "\t\t{0x2A86,\"Date of Threshold Assessment\"},",
                            "\t\t{0x2A08,\"Date Time\"},",
                            "\t\t{0x2A0A,\"Day Date Time\"},",
                            "\t\t{0x2A09,\"Day of Week\"},",
                            "\t\t{0x2A7D,\"Descriptor Value Changed\"},",
                            "\t\t{0x2A00,\"Device Name\"},",
                            "\t\t{0x2A7B,\"Dew Point\"},",
                            "\t\t{0x2A56,\"Digital\"},",
                            "\t\t{0x2A57,\"Digital Output\"},",
                            "\t\t{0x2A0D,\"DST Offset\"},",
                            "\t\t{0x2A6C,\"Elevation\"},",
                            "\t\t{0x2A87,\"Email Address\"},",
                            "\t\t{0x2A0B,\"Exact Time 100\"},",
                            "\t\t{0x2A0C,\"Exact Time 256\"},",
                            "\t\t{0x2A88,\"Fat Burn Heart Rate Lower Limit\"},",
                            "\t\t{0x2A89,\"Fat Burn Heart Rate Upper Limit\"},",
                            "\t\t{0x2A26,\"Firmware Revision String\"},",
                            "\t\t{0x2A8A,\"First Name\"},",
                            "\t\t{0x2AD9,\"Fitness Machine Control Point\"},",
                            "\t\t{0x2ACC,\"Fitness Machine Feature\"},",
                            "\t\t{0x2ADA,\"Fitness Machine Status\"},",
                            "\t\t{0x2A8B,\"Five Zone Heart Rate Limits\"},",
                            "\t\t{0x2AB2,\"Floor Number\"},",
                            "\t\t{0x2A8C,\"Gender\"},",
                            "\t\t{0x2A51,\"Glucose Feature\"},",
                            "\t\t{0x2A18,\"Glucose Measurement\"},",
                            "\t\t{0x2A34,\"Glucose Measurement Context\"},",
                            "\t\t{0x2A74,\"Gust Factor\"},",
                            "\t\t{0x2A27,\"Hardware Revision String\"},",
                            "\t\t{0x2A39,\"Heart Rate Control Point\"},",
                            "\t\t{0x2A8D,\"Heart Rate Max\"},",
                            "\t\t{0x2A37,\"Heart Rate Measurement\"},",
                            "\t\t{0x2A7A,\"Heat Index\"},",
                            "\t\t{0x2A8E,\"Height\"},",
                            "\t\t{0x2A4C,\"HID Control Point\"},",
                            "\t\t{0x2A4A,\"HID Information\"},",
                            "\t\t{0x2A8F,\"Hip Circumference\"},",
                            "\t\t{0x2ABA,\"HTTP Control Point\"},",
                            "\t\t{0x2AB9,\"HTTP Entity Body\"},",
                            "\t\t{0x2AB7,\"HTTP Headers\"},",
                            "\t\t{0x2AB8,\"HTTP Status Code\"},",
                            "\t\t{0x2ABB,\"HTTPS Security\"},",
                            "\t\t{0x2A6F,\"Humidity\"},",
                            "\t\t{0x2A2A,\"IEEE 11073-20601 Regulatory Certification Data List\"},",
                            "\t\t{0x2AD2,\"Indoor Bike Data\"},",
                            "\t\t{0x2AAD,\"Indoor Positioning Configuration\"},",
                            "\t\t{0x2A36,\"Intermediate Cuff Pressure\"},",
                            "\t\t{0x2A1E,\"Intermediate Temperature\"},",
                            "\t\t{0x2A77,\"Irradiance\"},",
                            "\t\t{0x2AA2,\"Language\"},",
                            "\t\t{0x2A90,\"Last Name\"},",
                            "\t\t{0x2AAE,\"Latitude\"},",
                            "\t\t{0x2A6B,\"LN Control Point\"},",
                            "\t\t{0x2A6A,\"LN Feature\"},",
                            "\t\t{0x2AB1,\"Local East Coordinate\"},",
                            "\t\t{0x2AB0,\"Local North Coordinate\"},",
                            "\t\t{0x2A0F,\"Local Time Information\"},",
                            "\t\t{0x2A67,\"Location and Speed Characteristic\"},",
                            "\t\t{0x2AB5,\"Location Name\"},",
                            "\t\t{0x2AAF,\"Longitude\"},",
                            "\t\t{0x2A2C,\"Magnetic Declination\"},",
                            "\t\t{0x2AA0,\"Magnetic Flux Density - 2D\"},",
                            "\t\t{0x2AA1,\"Magnetic Flux Density - 3D\"},",
                            "\t\t{0x2A29,\"Manufacturer Name String\"},",
                            "\t\t{0x2A91,\"Maximum Recommended Heart Rate\"},",
                            "\t\t{0x2A21,\"Measurement Interval\"},",
                            "\t\t{0x2A24,\"Model Number String\"},",
                            "\t\t{0x2A68,\"Navigation\"},",
                            "\t\t{0x2A3E,\"Network Availability\"},",
                            "\t\t{0x2A46,\"New Alert\"},",
                            "\t\t{0x2AC5,\"Object Action Control Point\"},",
                            "\t\t{0x2AC8,\"Object Changed\"},",
                            "\t\t{0x2AC1,\"Object First-Created\"},",
                            "\t\t{0x2AC3,\"Object ID\"},",
                            "\t\t{0x2AC2,\"Object Last-Modified\"},",
                            "\t\t{0x2AC6,\"Object List Control Point\"},",
                            "\t\t{0x2AC7,\"Object List Filter\"},",
                            "\t\t{0x2ABE,\"Object Name\"},",
                            "\t\t{0x2AC4,\"Object Properties\"},",
                            "\t\t{0x2AC0,\"Object Size\"},",
                            "\t\t{0x2ABF,\"Object Type\"},",
                            "\t\t{0x2ABD,\"OTS Feature\"},",
                            "\t\t{0x2A04,\"Peripheral Preferred Connection Parameters\"},",
                            "\t\t{0x2A02,\"Peripheral Privacy Flag\"},",
                            "\t\t{0x2A5F,\"PLX Continuous Measurement Characteristic\"},",
                            "\t\t{0x2A60,\"PLX Features\"},",
                            "\t\t{0x2A5E,\"PLX Spot-Check Measurement\"},",
                            "\t\t{0x2A50,\"PnP ID\"},",
                            "\t\t{0x2A75,\"Pollen Concentration\"},",
                            "\t\t{0x2A2F,\"Position 2D\"},",
                            "\t\t{0x2A30,\"Position 3D\"},",
                            "\t\t{0x2A69,\"Position Quality\"},",
                            "\t\t{0x2A6D,\"Pressure\"},",
                            "\t\t{0x2A4E,\"Protocol Mode\"},",
                            "\t\t{0x2A62,\"Pulse Oximetry Control Point\"},",
                            "\t\t{0x2A60,\"Pulse Oximetry Pulsatile Event Characteristic\"},",
                            "\t\t{0x2A78,\"Rainfall\"},",
                            "\t\t{0x2A03,\"Reconnection Address\"},",
                            "\t\t{0x2A52,\"Record Access Control Point\"},",
                            "\t\t{0x2A14,\"Reference Time Information\"},",
                            "\t\t{0x2A3A,\"Removable\"},",
                            "\t\t{0x2A4D,\"Report\"},",
                            "\t\t{0x2A4B,\"Report Map\"},",
                            "\t\t{0x2AC9,\"Resolvable Private Address Only\"},",
                            "\t\t{0x2A92,\"Resting Heart Rate\"},",
                            "\t\t{0x2A40,\"Ringer Control point\"},",
                            "\t\t{0x2A41,\"Ringer Setting\"},",
                            "\t\t{0x2AD1,\"Rower Data\"},",
                            "\t\t{0x2A54,\"RSC Feature\"},",
                            "\t\t{0x2A53,\"RSC Measurement\"},",
                            "\t\t{0x2A55,\"SC Control Point\"},",
                            "\t\t{0x2A4F,\"Scan Interval Window\"},",
                            "\t\t{0x2A31,\"Scan Refresh\"},",
                            "\t\t{0x2A3C,\"Scientific Temperature Celsius\"},",
                            "\t\t{0x2A10,\"Secondary Time Zone\"},",
                            "\t\t{0x2A5D,\"Sensor Location\"},",
                            "\t\t{0x2A25,\"Serial Number String\"},",
                            "\t\t{0x2A05,\"Service Changed\"},",
                            "\t\t{0x2A3B,\"Service Required\"},",
                            "\t\t{0x2A28,\"Software Revision String\"},",
                            "\t\t{0x2A93,\"Sport Type for Aerobic and Anaerobic Thresholds\"},",
                            "\t\t{0x2AD0,\"Stair Climber Data\"},",
                            "\t\t{0x2ACF,\"Step Climber Data\"},",
                            "\t\t{0x2A3D,\"String\"},",
                            "\t\t{0x2AD7,\"Supported Heart Rate Range\"},",
                            "\t\t{0x2AD5,\"Supported Inclination Range\"},",
                            "\t\t{0x2A47,\"Supported New Alert Category\"},",
                            "\t\t{0x2AD8,\"Supported Power Range\"},",
                            "\t\t{0x2AD6,\"Supported Resistance Level Range\"},",
                            "\t\t{0x2AD4,\"Supported Speed Range\"},",
                            "\t\t{0x2A48,\"Supported Unread Alert Category\"},",
                            "\t\t{0x2A23,\"System ID\"},",
                            "\t\t{0x2ABC,\"TDS Control Point\"},",
                            "\t\t{0x2A6E,\"Temperature\"},",
                            "\t\t{0x2A1F,\"Temperature Celsius\"},",
                            "\t\t{0x2A20,\"Temperature Fahrenheit\"},",
                            "\t\t{0x2A1C,\"Temperature Measurement\"},",
                            "\t\t{0x2A1D,\"Temperature Type\"},",
                            "\t\t{0x2A94,\"Three Zone Heart Rate Limits\"},",
                            "\t\t{0x2A12,\"Time Accuracy\"},",
                            "\t\t{0x2A15,\"Time Broadcast\"},",
                            "\t\t{0x2A13,\"Time Source\"},",
                            "\t\t{0x2A16,\"Time Update Control Point\"},",
                            "\t\t{0x2A17,\"Time Update State\"},",
                            "\t\t{0x2A11,\"Time with DST\"},",
                            "\t\t{0x2A0E,\"Time Zone\"},",
                            "\t\t{0x2AD3,\"Training Status\"},",
                            "\t\t{0x2ACD,\"Treadmill Data\"},",
                            "\t\t{0x2A71,\"True Wind Direction\"},",
                            "\t\t{0x2A70,\"True Wind Speed\"},",
                            "\t\t{0x2A95,\"Two Zone Heart Rate Limit\"},",
                            "\t\t{0x2A07,\"Tx Power Level\"},",
                            "\t\t{0x2AB4,\"Uncertainty\"},",
                            "\t\t{0x2A45,\"Unread Alert Status\"},",
                            "\t\t{0x2AB6,\"URI\"},",
                            "\t\t{0x2A9F,\"User Control Point\"},",
                            "\t\t{0x2A9A,\"User Index\"},",
                            "\t\t{0x2A76,\"UV Index\"},",
                            "\t\t{0x2A96,\"VO2 Max\"},",
                            "\t\t{0x2A97,\"Waist Circumference\"},",
                            "\t\t{0x2A98,\"Weight\"},",
                            "\t\t{0x2A9D,\"Weight Measurement\"},",
                            "\t\t{0x2A9E,\"Weight Scale Feature\"},",
                            "\t\t{0x2A79,\"Wind Chill\"},",
                            "#endif",
                            "\t\t{0, \"\"}",
                            "};",
                            "",
                            "/**",
                            " * @brief Mapping from service ids to names",
                            " */",
                            "typedef struct {",
                            "\tconst char* name;",
                            "\tconst char* type;",
                            "\tuint32_t    assignedNumber;",
                            "} gattService_t;",
                            "",
                            "",
                            "/**",
                            " * Definition of the service ids to names that we know about.",
                            " */",
                            "static const gattService_t g_gattServices[] = {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t{\"Alert Notification Service\", \"org.bluetooth.service.alert_notification\", 0x1811},",
                            "\t{\"Automation IO\", \"org.bluetooth.service.automation_io\",\t0x1815 },",
                            "\t{\"Battery Service\",\"org.bluetooth.service.battery_service\",\t0x180F},",
                            "\t{\"Blood Pressure\", \"org.bluetooth.service.blood_pressure\", 0x1810},",
                            "\t{\"Body Composition\", \"org.bluetooth.service.body_composition\", 0x181B},",
                            "\t{\"Bond Management\", \"org.bluetooth.service.bond_management\", 0x181E},",
                            "\t{\"Continuous Glucose Monitoring\", \"org.bluetooth.service.continuous_glucose_monitoring\", 0x181F},",
                            "\t{\"Current Time Service\", \"org.bluetooth.service.current_time\", 0x1805},",
                            "\t{\"Cycling Power\", \"org.bluetooth.service.cycling_power\", 0x1818},",
                            "\t{\"Cycling Speed and Cadence\", \"org.bluetooth.service.cycling_speed_and_cadence\", 0x1816},",
                            "\t{\"Device Information\", \"org.bluetooth.service.device_information\", 0x180A},",
                            "\t{\"Environmental Sensing\", \"org.bluetooth.service.environmental_sensing\", 0x181A},",
                            "\t{\"Generic Access\", \"org.bluetooth.service.generic_access\", 0x1800},",
                            "\t{\"Generic Attribute\", \"org.bluetooth.service.generic_attribute\", 0x1801},",
                            "\t{\"Glucose\", \"org.bluetooth.service.glucose\", 0x1808},",
                            "\t{\"Health Thermometer\", \"org.bluetooth.service.health_thermometer\", 0x1809},",
                            "\t{\"Heart Rate\", \"org.bluetooth.service.heart_rate\", 0x180D},",
                            "\t{\"HTTP Proxy\", \"org.bluetooth.service.http_proxy\", 0x1823},",
                            "\t{\"Human Interface Device\", \"org.bluetooth.service.human_interface_device\", 0x1812},",
                            "\t{\"Immediate Alert\", \"org.bluetooth.service.immediate_alert\", 0x1802},",
                            "\t{\"Indoor Positioning\", \"org.bluetooth.service.indoor_positioning\", 0x1821},",
                            "\t{\"Internet Protocol Support\", \"org.bluetooth.service.internet_protocol_support\", 0x1820},",
                            "\t{\"Link Loss\", \"org.bluetooth.service.link_loss\", 0x1803},",
                            "\t{\"Location and Navigation\", \"org.bluetooth.service.location_and_navigation\", 0x1819},",
                            "\t{\"Next DST Change Service\", \"org.bluetooth.service.next_dst_change\", 0x1807},",
                            "\t{\"Object Transfer\", \"org.bluetooth.service.object_transfer\", 0x1825},",
                            "\t{\"Phone Alert Status Service\", \"org.bluetooth.service.phone_alert_status\", 0x180E},",
                            "\t{\"Pulse Oximeter\", \"org.bluetooth.service.pulse_oximeter\", 0x1822},",
                            "\t{\"Reference Time Update Service\", \"org.bluetooth.service.reference_time_update\", 0x1806},",
                            "\t{\"Running Speed and Cadence\", \"org.bluetooth.service.running_speed_and_cadence\", 0x1814},",
                            "\t{\"Scan Parameters\", \"org.bluetooth.service.scan_parameters\", 0x1813},",
                            "\t{\"Transport Discovery\", \"org.bluetooth.service.transport_discovery\", 0x1824},",
                            "\t{\"Tx Power\", \"org.bluetooth.service.tx_power\", 0x1804},",
                            "\t{\"User Data\", \"org.bluetooth.service.user_data\", 0x181C},",
                            "\t{\"Weight Scale\", \"org.bluetooth.service.weight_scale\", 0x181D},",
                            "#endif",
                            "\t{\"\", \"\", 0 }",
                            "};",
                            "",
                            "",
                            "/**",
                            " * @brief Convert characteristic properties into a string representation.",
                            " * @param [in] prop Characteristic properties.",
                            " * @return A string representation of characteristic properties.",
                            " */",
                            "std::string BLEUtils::characteristicPropertiesToString(esp_gatt_char_prop_t prop) {",
                            "\tstd::stringstream stream;",
                            "\tstream <<",
                            "\t\t\t\"broadcast: \"  << ((prop & ESP_GATT_CHAR_PROP_BIT_BROADCAST)?\"1\":\"0\") <<",
                            "\t\t\t\", read: \"     << ((prop & ESP_GATT_CHAR_PROP_BIT_READ)?\"1\":\"0\") <<",
                            "\t\t\t\", write_nr: \" << ((prop & ESP_GATT_CHAR_PROP_BIT_WRITE_NR)?\"1\":\"0\") <<",
                            "\t\t\t\", write: \"    << ((prop & ESP_GATT_CHAR_PROP_BIT_WRITE)?\"1\":\"0\") <<",
                            "\t\t\t\", notify: \"   << ((prop & ESP_GATT_CHAR_PROP_BIT_NOTIFY)?\"1\":\"0\") <<",
                            "\t\t\t\", indicate: \" << ((prop & ESP_GATT_CHAR_PROP_BIT_INDICATE)?\"1\":\"0\") <<",
                            "\t\t\t\", auth: \"     << ((prop & ESP_GATT_CHAR_PROP_BIT_AUTH)?\"1\":\"0\");",
                            "\treturn stream.str();",
                            "",
                            "/**",
                            " * @brief Convert an esp_gatt_id_t to a string.",
                            " */",
                            "static std::string gattIdToString(esp_gatt_id_t gattId) {",
                            "\tstd::stringstream stream;",
                            "\tstream << \"uuid: \" << BLEUUID(gattId.uuid).toString() << \", inst_id: \" << (int)gattId.inst_id;",
                            "\t//sprintf(buffer, \"uuid: %s, inst_id: %d\", uuidToString(gattId.uuid).c_str(), gattId.inst_id);",
                            "\treturn stream.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Convert an esp_ble_addr_type_t to a string representation.",
                            " */",
                            "const char* BLEUtils::addressTypeToString(esp_ble_addr_type_t type) {",
                            "\tswitch (type) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase BLE_ADDR_TYPE_PUBLIC:",
                            "\t\t\treturn \"BLE_ADDR_TYPE_PUBLIC\";",
                            "\t\tcase BLE_ADDR_TYPE_RANDOM:",
                            "\t\t\treturn \"BLE_ADDR_TYPE_RANDOM\";",
                            "\t\tcase BLE_ADDR_TYPE_RPA_PUBLIC:",
                            "\t\t\treturn \"BLE_ADDR_TYPE_RPA_PUBLIC\";",
                            "\t\tcase BLE_ADDR_TYPE_RPA_RANDOM:",
                            "\t\t\treturn \"BLE_ADDR_TYPE_RPA_RANDOM\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\treturn \" esp_ble_addr_type_t\";",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Convert the BLE Advertising Data flags to a string.",
                            " * @param adFlags The flags to convert",
                            " * @return std::string A string representation of the advertising flags.",
                            " */",
                            "std::string BLEUtils::adFlagsToString(uint8_t adFlags) {",
                            "\tstd::stringstream ss;",
                            "\tif (adFlags & (1 << 0)) {",
                            "\t\tss << \"[LE Limited Discoverable Mode] \";",
                            "\t}",
                            "\tif (adFlags & (1 << 1)) {",
                            "\t\tss << \"[LE General Discoverable Mode] \";",
                            "\t}",
                            "\tif (adFlags & (1 << 2)) {",
                            "\t\tss << \"[BR/EDR Not Supported] \";",
                            "\t}",
                            "\tif (adFlags & (1 << 3)) {",
                            "\t\tss << \"[Simultaneous LE and BR/EDR to Same Device Capable (Controller)] \";",
                            "\t}",
                            "\tif (adFlags & (1 << 4)) {",
                            "\t\tss << \"[Simultaneous LE and BR/EDR to Same Device Capable (Host)] \";",
                            "\t}",
                            "\treturn ss.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Given an advertising type, return a string representation of the type.",
                            " *",
                            " * For details see ...",
                            " * https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile",
                            " *",
                            " * @return A string representation of the type.",
                            " */",
                            "const char* BLEUtils::advTypeToString(uint8_t advType) {",
                            "\tswitch (advType) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_FLAG\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_16SRV_PART\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_16SRV_CMPL\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_32SRV_PART\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_32SRV_CMPL\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_128SRV_PART\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_128SRV_CMPL\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_NAME_SHORT\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_NAME_CMPL\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_TX_PWR\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_DEV_CLASS\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_SM_TK\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_SM_OOB_FLAG\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_INT_RANGE\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_SOL_SRV_UUID\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_128SOL_SRV_UUID\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_SERVICE_DATA\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_PUBLIC_TARGET\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_RANDOM_TARGET\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_APPEARANCE\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_ADV_INT\";",
                            "\t\tcase ESP_BLE_AD_TYPE_32SOL_SRV_UUID:",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_32SOL_SRV_UUID\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_32SERVICE_DATA\";",
                            "\t\t\treturn \"ESP_BLE_AD_TYPE_128SERVICE_DATA\";",
                            "\t\t\treturn \"ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\tESP_LOGV(LOG_TAG, \" adv data type: 0x%x\", advType);",
                            "\t\t\treturn \"\";",
                            "",
                            "",
                            "esp_gatt_id_t BLEUtils::buildGattId(esp_bt_uuid_t uuid, uint8_t inst_id) {",
                            "\tesp_gatt_id_t retGattId;",
                            "\tretGattId.uuid = uuid;",
                            "\tretGattId.inst_id = inst_id;",
                            "\treturn retGattId;",
                            "}",
                            "",
                            "esp_gatt_srvc_id_t BLEUtils::buildGattSrvcId(esp_gatt_id_t gattId, bool is_primary) {",
                            "\tesp_gatt_srvc_id_t retSrvcId;",
                            "\tretSrvcId.id = gattId;",
                            "\tretSrvcId.is_primary = is_primary;",
                            "\treturn retSrvcId;",
                            "}",
                            "",
                            "/**",
                            " * @brief Create a hex representation of data.",
                            " *",
                            " * @param [in] target Where to write the hex string.  If this is null, we malloc storage.",
                            " * @param [in] source The start of the binary data.",
                            " * @param [in] length The length of the data to convert.",
                            " * @return A pointer to the formatted buffer.",
                            " */",
                            "char* BLEUtils::buildHexData(uint8_t* target, uint8_t* source, uint8_t length) {",
                            "\tif (length > 100) length = 100;",
                            "",
                            "\tif (target == nullptr) {",
                            "\t\ttarget = (uint8_t*) malloc(length * 2 + 1);",
                            "\t\tif (target == nullptr) {",
                            "\t\t\tESP_LOGE(LOG_TAG, \"buildHexData: malloc failed\");",
                            "\t\t\treturn nullptr;",
                            "\t\t}",
                            "\t}",
                            "\tchar* startOfData = (char*) target;",
                            "",
                            "\tfor (int i = 0; i < length; i++) {",
                            "\t\tsprintf((char*) target, \"%.2x\", (char) *source);",
                            "\t\tsource++;",
                            "\t\ttarget += 2;",
                            "\t}",
                            "",
                            "\tif (length == 0) {",
                            "\t\t*startOfData = 0;",
                            "\t}",
                            "",
                            "\treturn startOfData;",
                            "",
                            "",
                            "/**",
                            " * @brief Build a printable string of memory range.",
                            " * Create a string representation of a piece of memory. Only printable characters will be included",
                            " * while those that are not printable will be replaced with '.'.",
                            " * @param [in] source Start of memory.",
                            " * @param [in] length Length of memory.",
                            " * @return A string representation of a piece of memory.",
                            " */",
                            "std::string BLEUtils::buildPrintData(uint8_t* source, size_t length) {",
                            "\tstd::ostringstream ss;",
                            "\tfor (int i = 0; i < length; i++) {",
                            "\t\tchar c = *source;",
                            "\t\tss << (isprint(c) ? c : '.');",
                            "\t\tsource++;",
                            "\t}",
                            "\treturn ss.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a close/disconnect reason to a string.",
                            " * @param [in] reason The close reason.",
                            " * @return A string representation of the reason.",
                            " */",
                            "std::string BLEUtils::gattCloseReasonToString(esp_gatt_conn_reason_t reason) {",
                            "\tswitch (reason) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_GATT_CONN_UNKNOWN: {",
                            "\t\t\treturn \"ESP_GATT_CONN_UNKNOWN\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_L2C_FAILURE: {",
                            "\t\t\treturn \"ESP_GATT_CONN_L2C_FAILURE\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_TIMEOUT: {",
                            "\t\t\treturn \"ESP_GATT_CONN_TIMEOUT\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_TERMINATE_PEER_USER: {",
                            "\t\t\treturn \"ESP_GATT_CONN_TERMINATE_PEER_USER\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_TERMINATE_LOCAL_HOST: {",
                            "\t\t\treturn \"ESP_GATT_CONN_TERMINATE_LOCAL_HOST\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_FAIL_ESTABLISH: {",
                            "\t\t\treturn \"ESP_GATT_CONN_FAIL_ESTABLISH\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_LMP_TIMEOUT: {",
                            "\t\t\treturn \"ESP_GATT_CONN_LMP_TIMEOUT\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_CONN_CANCEL: {",
                            "\t\t\treturn \"ESP_GATT_CONN_CONN_CANCEL\";",
                            "\t\t}",
                            "\t\tcase ESP_GATT_CONN_NONE: {",
                            "\t\t\treturn \"ESP_GATT_CONN_NONE\";",
                            "\t\t}",
                            "#endif",
                            "\t\tdefault: {",
                            "\t\t\treturn \"Unknown\";",
                            "\t\t}",
                            "\t}",
                            "",
                            "",
                            "std::string BLEUtils::gattClientEventTypeToString(esp_gattc_cb_event_t eventType) {",
                            "\tswitch (eventType) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_GATTC_ACL_EVT:",
                            "\t\t\treturn \"ESP_GATTC_ACL_EVT\";",
                            "\t\tcase ESP_GATTC_ADV_DATA_EVT:",
                            "\t\t\treturn \"ESP_GATTC_ADV_DATA_EVT\";",
                            "\t\tcase ESP_GATTC_ADV_VSC_EVT:",
                            "\t\t\treturn \"ESP_GATTC_ADV_VSC_EVT\";",
                            "\t\tcase ESP_GATTC_BTH_SCAN_CFG_EVT:",
                            "\t\t\treturn \"ESP_GATTC_BTH_SCAN_CFG_EVT\";",
                            "\t\tcase ESP_GATTC_BTH_SCAN_DIS_EVT:",
                            "\t\t\treturn \"ESP_GATTC_BTH_SCAN_DIS_EVT\";",
                            "\t\tcase ESP_GATTC_BTH_SCAN_ENB_EVT:",
                            "\t\t\treturn \"ESP_GATTC_BTH_SCAN_ENB_EVT\";",
                            "\t\tcase ESP_GATTC_BTH_SCAN_PARAM_EVT:",
                            "\t\t\treturn \"ESP_GATTC_BTH_SCAN_PARAM_EVT\";",
                            "\t\tcase ESP_GATTC_BTH_SCAN_RD_EVT:",
                            "\t\t\treturn \"ESP_GATTC_BTH_SCAN_RD_EVT\";",
                            "\t\tcase ESP_GATTC_BTH_SCAN_THR_EVT:",
                            "\t\t\treturn \"ESP_GATTC_BTH_SCAN_THR_EVT\";",
                            "\t\tcase ESP_GATTC_CANCEL_OPEN_EVT:",
                            "\t\t\treturn \"ESP_GATTC_CANCEL_OPEN_EVT\";",
                            "\t\tcase ESP_GATTC_CFG_MTU_EVT:",
                            "\t\t\treturn \"ESP_GATTC_CFG_MTU_EVT\";",
                            "\t\tcase ESP_GATTC_CLOSE_EVT:",
                            "\t\t\treturn \"ESP_GATTC_CLOSE_EVT\";",
                            "\t\tcase ESP_GATTC_CONGEST_EVT:",
                            "\t\t\treturn \"ESP_GATTC_CONGEST_EVT\";",
                            "\t\tcase ESP_GATTC_CONNECT_EVT:",
                            "\t\t\treturn \"ESP_GATTC_CONNECT_EVT\";",
                            "\t\tcase ESP_GATTC_DISCONNECT_EVT:",
                            "\t\t\treturn \"ESP_GATTC_DISCONNECT_EVT\";",
                            "\t\tcase ESP_GATTC_ENC_CMPL_CB_EVT:",
                            "\t\t\treturn \"ESP_GATTC_ENC_CMPL_CB_EVT\";",
                            "\t\tcase ESP_GATTC_EXEC_EVT:",
                            "\t\t\treturn \"ESP_GATTC_EXEC_EVT\";",
                            "\t\t//case ESP_GATTC_GET_CHAR_EVT:",
                            "//\t\t\treturn \"ESP_GATTC_GET_CHAR_EVT\";",
                            "\t\t//case ESP_GATTC_GET_DESCR_EVT:",
                            "//\t\t\treturn \"ESP_GATTC_GET_DESCR_EVT\";",
                            "\t\t//case ESP_GATTC_GET_INCL_SRVC_EVT:",
                            "//\t\t\treturn \"ESP_GATTC_GET_INCL_SRVC_EVT\";",
                            "\t\tcase ESP_GATTC_MULT_ADV_DATA_EVT:",
                            "\t\t\treturn \"ESP_GATTC_MULT_ADV_DATA_EVT\";",
                            "\t\tcase ESP_GATTC_MULT_ADV_DIS_EVT:",
                            "\t\t\treturn \"ESP_GATTC_MULT_ADV_DIS_EVT\";",
                            "\t\tcase ESP_GATTC_MULT_ADV_ENB_EVT:",
                            "\t\t\treturn \"ESP_GATTC_MULT_ADV_ENB_EVT\";",
                            "\t\tcase ESP_GATTC_MULT_ADV_UPD_EVT:",
                            "\t\t\treturn \"ESP_GATTC_MULT_ADV_UPD_EVT\";",
                            "\t\tcase ESP_GATTC_NOTIFY_EVT:",
                            "\t\t\treturn \"ESP_GATTC_NOTIFY_EVT\";",
                            "\t\tcase ESP_GATTC_OPEN_EVT:",
                            "\t\t\treturn \"ESP_GATTC_OPEN_EVT\";",
                            "\t\tcase ESP_GATTC_PREP_WRITE_EVT:",
                            "\t\t\treturn \"ESP_GATTC_PREP_WRITE_EVT\";",
                            "\t\tcase ESP_GATTC_READ_CHAR_EVT:",
                            "\t\t\treturn \"ESP_GATTC_READ_CHAR_EVT\";",
                            "\t\tcase ESP_GATTC_REG_EVT:",
                            "\t\t\treturn \"ESP_GATTC_REG_EVT\";",
                            "\t\tcase ESP_GATTC_REG_FOR_NOTIFY_EVT:",
                            "\t\t\treturn \"ESP_GATTC_REG_FOR_NOTIFY_EVT\";",
                            "\t\tcase ESP_GATTC_SCAN_FLT_CFG_EVT:",
                            "\t\t\treturn \"ESP_GATTC_SCAN_FLT_CFG_EVT\";",
                            "\t\tcase ESP_GATTC_SCAN_FLT_PARAM_EVT:",
                            "\t\t\treturn \"ESP_GATTC_SCAN_FLT_PARAM_EVT\";",
                            "\t\tcase ESP_GATTC_SCAN_FLT_STATUS_EVT:",
                            "\t\t\treturn \"ESP_GATTC_SCAN_FLT_STATUS_EVT\";",
                            "\t\tcase ESP_GATTC_SEARCH_CMPL_EVT:",
                            "\t\t\treturn \"ESP_GATTC_SEARCH_CMPL_EVT\";",
                            "\t\tcase ESP_GATTC_SEARCH_RES_EVT:",
                            "\t\t\treturn \"ESP_GATTC_SEARCH_RES_EVT\";",
                            "\t\tcase ESP_GATTC_SRVC_CHG_EVT:",
                            "\t\t\treturn \"ESP_GATTC_SRVC_CHG_EVT\";",
                            "\t\tcase ESP_GATTC_READ_DESCR_EVT:",
                            "\t\t\treturn \"ESP_GATTC_READ_DESCR_EVT\";",
                            "\t\tcase ESP_GATTC_UNREG_EVT:",
                            "\t\t\treturn \"ESP_GATTC_UNREG_EVT\";",
                            "\t\tcase ESP_GATTC_UNREG_FOR_NOTIFY_EVT:",
                            "\t\t\treturn \"ESP_GATTC_UNREG_FOR_NOTIFY_EVT\";",
                            "\t\tcase ESP_GATTC_WRITE_CHAR_EVT:",
                            "\t\t\treturn \"ESP_GATTC_WRITE_CHAR_EVT\";",
                            "\t\tcase ESP_GATTC_WRITE_DESCR_EVT:",
                            "\t\t\treturn \"ESP_GATTC_WRITE_DESCR_EVT\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\tESP_LOGV(LOG_TAG, \"Unknown GATT Client event type: %d\", eventType);",
                            "\t\t\treturn \"Unknown\";",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of a GATT server event code.",
                            " * @param [in] eventType A GATT server event code.",
                            " * @return A string representation of the GATT server event code.",
                            " */",
                            "std::string BLEUtils::gattServerEventTypeToString(esp_gatts_cb_event_t eventType) {",
                            "\tswitch (eventType) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_GATTS_REG_EVT:",
                            "\t\t\treturn \"ESP_GATTS_REG_EVT\";",
                            "\t\tcase ESP_GATTS_READ_EVT:",
                            "\t\t\treturn \"ESP_GATTS_READ_EVT\";",
                            "\t\tcase ESP_GATTS_WRITE_EVT:",
                            "\t\t\treturn \"ESP_GATTS_WRITE_EVT\";",
                            "\t\tcase ESP_GATTS_EXEC_WRITE_EVT:",
                            "\t\t\treturn \"ESP_GATTS_EXEC_WRITE_EVT\";",
                            "\t\tcase ESP_GATTS_MTU_EVT:",
                            "\t\t\treturn \"ESP_GATTS_MTU_EVT\";",
                            "\t\tcase ESP_GATTS_CONF_EVT:",
                            "\t\t\treturn \"ESP_GATTS_CONF_EVT\";",
                            "\t\tcase ESP_GATTS_UNREG_EVT:",
                            "\t\t\treturn \"ESP_GATTS_UNREG_EVT\";",
                            "\t\tcase ESP_GATTS_CREATE_EVT:",
                            "\t\t\treturn \"ESP_GATTS_CREATE_EVT\";",
                            "\t\tcase ESP_GATTS_ADD_INCL_SRVC_EVT:",
                            "\t\t\treturn \"ESP_GATTS_ADD_INCL_SRVC_EVT\";",
                            "\t\tcase ESP_GATTS_ADD_CHAR_EVT:",
                            "\t\t\treturn \"ESP_GATTS_ADD_CHAR_EVT\";",
                            "\t\tcase ESP_GATTS_ADD_CHAR_DESCR_EVT:",
                            "\t\t\treturn \"ESP_GATTS_ADD_CHAR_DESCR_EVT\";",
                            "\t\tcase ESP_GATTS_DELETE_EVT:",
                            "\t\t\treturn \"ESP_GATTS_DELETE_EVT\";",
                            "\t\tcase ESP_GATTS_START_EVT:",
                            "\t\t\treturn \"ESP_GATTS_START_EVT\";",
                            "\t\tcase ESP_GATTS_STOP_EVT:",
                            "\t\t\treturn \"ESP_GATTS_STOP_EVT\";",
                            "\t\tcase ESP_GATTS_CONNECT_EVT:",
                            "\t\t\treturn \"ESP_GATTS_CONNECT_EVT\";",
                            "\t\tcase ESP_GATTS_DISCONNECT_EVT:",
                            "\t\t\treturn \"ESP_GATTS_DISCONNECT_EVT\";",
                            "\t\tcase ESP_GATTS_OPEN_EVT:",
                            "\t\t\treturn \"ESP_GATTS_OPEN_EVT\";",
                            "\t\tcase ESP_GATTS_CANCEL_OPEN_EVT:",
                            "\t\t\treturn \"ESP_GATTS_CANCEL_OPEN_EVT\";",
                            "\t\tcase ESP_GATTS_CLOSE_EVT:",
                            "\t\t\treturn \"ESP_GATTS_CLOSE_EVT\";",
                            "\t\tcase ESP_GATTS_LISTEN_EVT:",
                            "\t\t\treturn \"ESP_GATTS_LISTEN_EVT\";",
                            "\t\tcase ESP_GATTS_CONGEST_EVT:",
                            "\t\t\treturn \"ESP_GATTS_CONGEST_EVT\";",
                            "\t\tcase ESP_GATTS_RESPONSE_EVT:",
                            "\t\t\treturn \"ESP_GATTS_RESPONSE_EVT\";",
                            "\t\tcase ESP_GATTS_CREAT_ATTR_TAB_EVT:",
                            "\t\t\treturn \"ESP_GATTS_CREAT_ATTR_TAB_EVT\";",
                            "\t\tcase ESP_GATTS_SET_ATTR_VAL_EVT:",
                            "\t\t\treturn \"ESP_GATTS_SET_ATTR_VAL_EVT\";",
                            "\t\tcase ESP_GATTS_SEND_SERVICE_CHANGE_EVT:",
                            "\t\t\treturn \"ESP_GATTS_SEND_SERVICE_CHANGE_EVT\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\treturn \"Unknown\";",
                            "\t}",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a BLE device type to a string.",
                            " * @param [in] type The device type.",
                            " */",
                            "const char* BLEUtils::devTypeToString(esp_bt_dev_type_t type) {",
                            "\tswitch (type) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_BT_DEVICE_TYPE_BREDR:",
                            "\t\t\treturn \"ESP_BT_DEVICE_TYPE_BREDR\";",
                            "\t\tcase ESP_BT_DEVICE_TYPE_BLE:",
                            "\t\t\treturn \"ESP_BT_DEVICE_TYPE_BLE\";",
                            "\t\tcase ESP_BT_DEVICE_TYPE_DUMO:",
                            "\t\t\treturn \"ESP_BT_DEVICE_TYPE_DUMO\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\treturn \"Unknown\";",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Dump the GAP event to the log.",
                            " */",
                            "void BLEUtils::dumpGapEvent(",
                            "\tesp_gap_ble_cb_event_t  event,",
                            "\tesp_ble_gap_cb_param_t* param) {",
                            "\tESP_LOGV(LOG_TAG, \"Received a GAP event: %s\", gapEventToString(event));",
                            "\tswitch (event) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_data_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_data_raw_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_ADV_START_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_start_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_stop_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_AUTH_CMPL_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[bd_addr: %s, key_present: %d, key: ***, key_type: %d, success: %d, fail_reason: %d, addr_type: ***, dev_type: %s]\",",
                            "\t\t\t\tBLEAddress(param->ble_security.auth_cmpl.bd_addr).toString().c_str(),",
                            "\t\t\t\tparam->ble_security.auth_cmpl.key_present,",
                            "\t\t\t\tparam->ble_security.auth_cmpl.key_type,",
                            "\t\t\t\tparam->ble_security.auth_cmpl.success,",
                            "\t\t\t\tparam->ble_security.auth_cmpl.fail_reason,",
                            "\t\t\t\tBLEUtils::devTypeToString(param->ble_security.auth_cmpl.dev_type)",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_CLEAR_BOND_DEV_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->clear_bond_dev_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GAP_BLE_LOCAL_IR_EVT: {",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GAP_BLE_LOCAL_ER_EVT: {",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GAP_BLE_NC_REQ_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[bd_addr: %s, passkey: %d]\",",
                            "\t\t\t\tBLEAddress(param->ble_security.key_notif.bd_addr).toString().c_str(),",
                            "\t\t\t\tparam->ble_security.key_notif.passkey);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d, rssi: %d, remote_addr: %s]\",",
                            "\t\t\t\t\tparam->read_rssi_cmpl.status,",
                            "\t\t\t\t\tparam->read_rssi_cmpl.rssi,",
                            "\t\t\t\t\tBLEAddress(param->read_rssi_cmpl.remote_addr).toString().c_str()",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_param_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_SCAN_RESULT_EVT: {",
                            "\t\t\tswitch (param->scan_rst.search_evt) {",
                            "\t\t\t\tcase ESP_GAP_SEARCH_INQ_RES_EVT: {",
                            "\t\t\t\t\tESP_LOGV(LOG_TAG, \"search_evt: %s, bda: %s, dev_type: %s, ble_addr_type: %s, ble_evt_type: %s, rssi: %d, ble_adv: ??, flag: %d (%s), num_resps: %d, adv_data_len: %d, scan_rsp_len: %d\",",
                            "\t\t\t\t\t\tsearchEventTypeToString(param->scan_rst.search_evt),",
                            "\t\t\t\t\t\tBLEAddress(param->scan_rst.bda).toString().c_str(),",
                            "\t\t\t\t\t\tdevTypeToString(param->scan_rst.dev_type),",
                            "\t\t\t\t\t\taddressTypeToString(param->scan_rst.ble_addr_type),",
                            "\t\t\t\t\t\teventTypeToString(param->scan_rst.ble_evt_type),",
                            "\t\t\t\t\t\tparam->scan_rst.rssi,",
                            "\t\t\t\t\t\tparam->scan_rst.flag,",
                            "\t\t\t\t\t\tadFlagsToString(param->scan_rst.flag).c_str(),",
                            "\t\t\t\t\t\tparam->scan_rst.num_resps,",
                            "\t\t\t\t\t\tparam->scan_rst.adv_data_len,",
                            "\t\t\t\t\t\tparam->scan_rst.scan_rsp_len",
                            "\t\t\t\t\t);",
                            "\t\t\t\t\tbreak;",
                            "",
                            "\t\t\t\tdefault: {",
                            "\t\t\t\t\tESP_LOGV(LOG_TAG, \"search_evt: %s\",searchEventTypeToString(param->scan_rst.search_evt));",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t}",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_rsp_data_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_rsp_data_raw_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_SCAN_START_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_start_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_stop_cmpl.status);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d, bd_addr: %s, min_int: %d, max_int: %d, latency: %d, conn_int: %d, timeout: %d]\",",
                            "\t\t\t\tparam->update_conn_params.status,",
                            "\t\t\t\tBLEAddress(param->update_conn_params.bda).toString().c_str(),",
                            "\t\t\t\tparam->update_conn_params.min_int,",
                            "\t\t\t\tparam->update_conn_params.max_int,",
                            "\t\t\t\tparam->update_conn_params.latency,",
                            "\t\t\t\tparam->update_conn_params.conn_int,",
                            "\t\t\t\tparam->update_conn_params.timeout",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GAP_BLE_SEC_REQ_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[bd_addr: %s]\", BLEAddress(param->ble_security.ble_req.bd_addr).toString().c_str());",
                            "\t\t\tbreak;",
                            "#endif",
                            "\t\tdefault: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"*** dumpGapEvent: Logger not coded ***\");",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "/**",
                            " * @brief Decode and dump a GATT client event",
                            " *",
                            " * @param [in] event The type of event received.",
                            " * @param [in] evtParam The data associated with the event.",
                            " */",
                            "void BLEUtils::dumpGattClientEvent(",
                            "\tesp_gattc_cb_event_t      event,",
                            "\tesp_gatt_if_t             gattc_if,",
                            "\tesp_ble_gattc_cb_param_t* evtParam) {",
                            "",
                            "\t//esp_ble_gattc_cb_param_t* evtParam = (esp_ble_gattc_cb_param_t*) param;",
                            "\tESP_LOGV(LOG_TAG, \"GATT Event: %s\", BLEUtils::gattClientEventTypeToString(event).c_str());",
                            "\tswitch (event) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_CLOSE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, reason:%s, conn_id: %d]\",",
                            "\t\t\t\tBLEUtils::gattStatusToString(evtParam->close.status).c_str(),",
                            "\t\t\t\tBLEUtils::gattCloseReasonToString(evtParam->close.reason).c_str(),",
                            "\t\t\t\tevtParam->close.conn_id);",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_CONNECT_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s]\",",
                            "\t\t\t\tevtParam->connect.conn_id,",
                            "\t\t\t\tBLEAddress(evtParam->connect.remote_bda).toString().c_str()",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_DISCONNECT_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[reason: %s, conn_id: %d, remote_bda: %s]\",",
                            "\t\t\t\tBLEUtils::gattCloseReasonToString(evtParam->disconnect.reason).c_str(),",
                            "\t\t\t\tevtParam->disconnect.conn_id,",
                            "\t\t\t\tBLEAddress(evtParam->disconnect.remote_bda).toString().c_str()",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\t/*",
                            "\t\tcase ESP_GATTC_GET_CHAR_EVT: {",
                            "",
                            "\t\t\tif (evtParam->get_char.status == ESP_GATT_OK) {",
                            "\t\t\t\tstd::string description = \"Unknown\";",
                            "\t\t\t\tif (evtParam->get_char.char_id.uuid.len == ESP_UUID_LEN_16) {",
                            "\t\t\t\t\tdescription = BLEUtils::gattCharacteristicUUIDToString(evtParam->get_char.char_id.uuid.uuid.uuid16);",
                            "\t\t\t\t}",
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, srvc_id: %s, char_id: %s [description: %s]\\nchar_prop: %s]\",",
                            "\t\t\t\t\tBLEUtils::gattStatusToString(evtParam->get_char.status).c_str(),",
                            "\t\t\t\t\tevtParam->get_char.conn_id,",
                            "\t\t\t\t\tBLEUtils::gattServiceIdToString(evtParam->get_char.srvc_id).c_str(),",
                            "\t\t\t\t\tgattIdToString(evtParam->get_char.char_id).c_str(),",
                            "\t\t\t\t\tdescription.c_str(),",
                            "\t\t\t\t\tBLEUtils::characteristicPropertiesToString(evtParam->get_char.char_prop).c_str()",
                            "\t\t\t\t);",
                            "\t\t\t} else {",
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, srvc_id: %s]\",",
                            "\t\t\t\t\tBLEUtils::gattStatusToString(evtParam->get_char.status).c_str(),",
                            "\t\t\t\t\tevtParam->get_char.conn_id,",
                            "\t\t\t\t\tBLEUtils::gattServiceIdToString(evtParam->get_char.srvc_id).c_str()",
                            "\t\t\t\t);",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "\t\t*/",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_NOTIFY_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s, handle: %d 0x%.2x, value_len: %d, is_notify: %d]\",",
                            "\t\t\t\tevtParam->notify.conn_id,",
                            "\t\t\t\tBLEAddress(evtParam->notify.remote_bda).toString().c_str(),",
                            "\t\t\t\tevtParam->notify.handle,",
                            "\t\t\t\tevtParam->notify.handle,",
                            "\t\t\t\tevtParam->notify.value_len,",
                            "\t\t\t\tevtParam->notify.is_notify",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_OPEN_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, remote_bda: %s, mtu: %d]\",",
                            "\t\t\t\tBLEUtils::gattStatusToString(evtParam->open.status).c_str(),",
                            "\t\t\t\tevtParam->open.conn_id,",
                            "\t\t\t\tBLEAddress(evtParam->open.remote_bda).toString().c_str(),",
                            "\t\t\t\tevtParam->open.mtu);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_READ_CHAR_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, handle: %d 0x%.2x, value_len: %d]\",",
                            "\t\t\t\tBLEUtils::gattStatusToString(evtParam->read.status).c_str(),",
                            "\t\t\t\tevtParam->read.conn_id,",
                            "\t\t\t\tevtParam->read.handle,",
                            "\t\t\t\tevtParam->read.handle,",
                            "\t\t\t\tevtParam->read.value_len",
                            "\t\t\t);",
                            "\t\t\tif (evtParam->read.status == ESP_GATT_OK) {",
                            "\t\t\t\tGeneralUtils::hexDump(evtParam->read.value, evtParam->read.value_len);",
                            "\t\t\t\t/*",
                            "\t\t\t\tchar* pHexData = BLEUtils::buildHexData(nullptr, evtParam->read.value, evtParam->read.value_len);",
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"value: %s \\\"%s\\\"\", pHexData, BLEUtils::buildPrintData(evtParam->read.value, evtParam->read.value_len).c_str());",
                            "\t\t\t\tfree(pHexData);",
                            "\t\t\t\t*/",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_REG_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, app_id: 0x%x]\",",
                            "\t\t\t\tBLEUtils::gattStatusToString(evtParam->reg.status).c_str(),",
                            "\t\t\t\tevtParam->reg.app_id);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_REG_FOR_NOTIFY_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, handle: %d 0x%.2x]\",",
                            "\t\t\t\tBLEUtils::gattStatusToString(evtParam->reg_for_notify.status).c_str(),",
                            "\t\t\t\tevtParam->reg_for_notify.handle,",
                            "\t\t\t\tevtParam->reg_for_notify.handle",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_SEARCH_CMPL_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d]\",",
                            "\t\t\t\tBLEUtils::gattStatusToString(evtParam->search_cmpl.status).c_str(),",
                            "\t\t\t\tevtParam->search_cmpl.conn_id);",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_SEARCH_RES_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, start_handle: %d 0x%.2x, end_handle: %d 0x%.2x, srvc_id: %s\",",
                            "\t\t\t\tevtParam->search_res.conn_id,",
                            "\t\t\t\tevtParam->search_res.start_handle,",
                            "\t\t\t\tevtParam->search_res.start_handle,",
                            "\t\t\t\tevtParam->search_res.end_handle,",
                            "\t\t\t\tevtParam->search_res.end_handle,",
                            "\t\t\t\tgattIdToString(evtParam->search_res.srvc_id).c_str());",
                            "\t\t\tbreak;",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTC_WRITE_CHAR_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, handle: %d 0x%.2x, offset: %d]\",",
                            "\t\t\t\tBLEUtils::gattStatusToString(evtParam->write.status).c_str(),",
                            "\t\t\t\tevtParam->write.conn_id,",
                            "\t\t\t\tevtParam->write.handle,",
                            "\t\t\t\tevtParam->write.handle,",
                            "\t\t\t\tevtParam->write.offset",
                            "\t\t\t);",
                            "\t\t\tbreak;",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\tbreak;",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Dump the details of a GATT server event.",
                            " * A GATT Server event is a callback received from the BLE subsystem when we are acting as a BLE",
                            " * server.  The callback indicates the type of event in the `event` field.  The `evtParam` is a",
                            " * union of structures where we can use the `event` to indicate which of the structures has been",
                            " * populated and hence is valid.",
                            " *",
                            " * @param [in] event The event type that was posted.",
                            " * @param [in] evtParam A union of structures only one of which is populated.",
                            " */",
                            "void BLEUtils::dumpGattServerEvent(",
                            "\t\tesp_gatts_cb_event_t      event,",
                            "\t\tesp_gatt_if_t             gatts_if,",
                            "\t\tesp_ble_gatts_cb_param_t* evtParam) {",
                            "\tESP_LOGV(LOG_TAG, \"GATT ServerEvent: %s\", BLEUtils::gattServerEventTypeToString(event).c_str());",
                            "\tswitch (event) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "",
                            "\t\tcase ESP_GATTS_ADD_CHAR_DESCR_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, attr_handle: %d 0x%.2x, service_handle: %d 0x%.2x, char_uuid: %s]\",",
                            "\t\t\t\tgattStatusToString(evtParam->add_char_descr.status).c_str(),",
                            "\t\t\t\tevtParam->add_char_descr.attr_handle,",
                            "\t\t\t\tevtParam->add_char_descr.attr_handle,",
                            "\t\t\t\tevtParam->add_char_descr.service_handle,",
                            "\t\t\t\tevtParam->add_char_descr.service_handle,",
                            "\t\t\t\tBLEUUID(evtParam->add_char_descr.descr_uuid).toString().c_str());",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_ADD_CHAR_EVT: {",
                            "\t\t\tif (evtParam->add_char.status == ESP_GATT_OK) {",
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, attr_handle: %d 0x%.2x, service_handle: %d 0x%.2x, char_uuid: %s]\",",
                            "\t\t\t\t\tgattStatusToString(evtParam->add_char.status).c_str(),",
                            "\t\t\t\t\tevtParam->add_char.attr_handle,",
                            "\t\t\t\t\tevtParam->add_char.attr_handle,",
                            "\t\t\t\t\tevtParam->add_char.service_handle,",
                            "\t\t\t\t\tevtParam->add_char.service_handle,",
                            "\t\t\t\t\tBLEUUID(evtParam->add_char.char_uuid).toString().c_str());",
                            "\t\t\t} else {",
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"[status: %s, attr_handle: %d 0x%.2x, service_handle: %d 0x%.2x, char_uuid: %s]\",",
                            "\t\t\t\t\tgattStatusToString(evtParam->add_char.status).c_str(),",
                            "\t\t\t\t\tevtParam->add_char.attr_handle,",
                            "\t\t\t\t\tevtParam->add_char.attr_handle,",
                            "\t\t\t\t\tevtParam->add_char.service_handle,",
                            "\t\t\t\t\tevtParam->add_char.service_handle,",
                            "\t\t\t\t\tBLEUUID(evtParam->add_char.char_uuid).toString().c_str());",
                            "\t\t\t}",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_CONF_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: 0x%.2x]\",",
                            "\t\t\t\tgattStatusToString(evtParam->conf.status).c_str(),",
                            "\t\t\t\tevtParam->conf.conn_id);",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\tcase ESP_GATTS_CONGEST_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, congested: %d]\",",
                            "\t\t\t\tevtParam->congest.conn_id,",
                            "\t\t\t\tevtParam->congest.congested);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_CONNECT_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s]\",",
                            "\t\t\t\tevtParam->connect.conn_id,",
                            "\t\t\t\tBLEAddress(evtParam->connect.remote_bda).toString().c_str());",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_CREATE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, service_handle: %d 0x%.2x, service_id: [%s]]\",",
                            "\t\t\t\tgattStatusToString(evtParam->create.status).c_str(),",
                            "\t\t\t\tevtParam->create.service_handle,",
                            "\t\t\t\tevtParam->create.service_handle,",
                            "\t\t\t\tgattServiceIdToString(evtParam->create.service_id).c_str());",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_DISCONNECT_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s]\",",
                            "\t\t\t\tevtParam->connect.conn_id,",
                            "\t\t\t\tBLEAddress(evtParam->connect.remote_bda).toString().c_str());",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\tcase ESP_GATTS_EXEC_WRITE_EVT: {",
                            "\t\t\tchar* pWriteFlagText;",
                            "\t\t\tswitch (evtParam->exec_write.exec_write_flag) {",
                            "\t\t\t\tcase ESP_GATT_PREP_WRITE_EXEC: {",
                            "\t\t\t\t\tpWriteFlagText = (char*) \"WRITE\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t}",
                            "",
                            "\t\t\t\tcase ESP_GATT_PREP_WRITE_CANCEL: {",
                            "\t\t\t\t\tpWriteFlagText = (char*) \"CANCEL\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t\t}",
                            "",
                            "\t\t\t\tdefault:",
                            "\t\t\t\t\tpWriteFlagText = (char*) \"<Unknown>\";",
                            "\t\t\t\t\tbreak;",
                            "\t\t\t}",
                            "",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, trans_id: %d, bda: %s, exec_write_flag: 0x%.2x=%s]\",",
                            "\t\t\t\tevtParam->exec_write.conn_id,",
                            "\t\t\t\tevtParam->exec_write.trans_id,",
                            "\t\t\t\tBLEAddress(evtParam->exec_write.bda).toString().c_str(),",
                            "\t\t\t\tevtParam->exec_write.exec_write_flag,",
                            "\t\t\t\tpWriteFlagText);",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\tcase ESP_GATTS_MTU_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, mtu: %d]\",",
                            "\t\t\t\t\tevtParam->mtu.conn_id,",
                            "\t\t\t\t\tevtParam->mtu.mtu);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_READ_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, trans_id: %d, bda: %s, handle: 0x%.2x, is_long: %d, need_rsp:%d]\",",
                            "\t\t\t\t\tevtParam->read.conn_id,",
                            "\t\t\t\t\tevtParam->read.trans_id,",
                            "\t\t\t\t\tBLEAddress(evtParam->read.bda).toString().c_str(),",
                            "\t\t\t\t\tevtParam->read.handle,",
                            "\t\t\t\t\tevtParam->read.is_long,",
                            "\t\t\t\t\tevtParam->read.need_rsp);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_RESPONSE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, handle: 0x%.2x]\",",
                            "\t\t\t\tgattStatusToString(evtParam->rsp.status).c_str(),",
                            "\t\t\t\tevtParam->rsp.handle);",
                            "\t\t\tbreak;",
                            "",
                            "\t\tcase ESP_GATTS_REG_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, app_id: %d]\",",
                            "\t\t\t\tgattStatusToString(evtParam->reg.status).c_str(),",
                            "\t\t\t\tevtParam->reg.app_id);",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_START_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, service_handle: 0x%.2x]\",",
                            "\t\t\t\tgattStatusToString(evtParam->start.status).c_str(),",
                            "\t\t\t\tevtParam->start.service_handle);",
                            "\t\t\tbreak;",
                            "",
                            "",
                            "\t\t//",
                            "\t\tcase ESP_GATTS_WRITE_EVT: {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, trans_id: %d, bda: %s, handle: 0x%.2x, offset: %d, need_rsp: %d, is_prep: %d, len: %d]\",",
                            "\t\t\t\t\tevtParam->write.conn_id,",
                            "\t\t\t\t\tevtParam->write.trans_id,",
                            "\t\t\t\t\tBLEAddress(evtParam->write.bda).toString().c_str(),",
                            "\t\t\t\t\tevtParam->write.handle,",
                            "\t\t\t\t\tevtParam->write.offset,",
                            "\t\t\t\t\tevtParam->write.need_rsp,",
                            "\t\t\t\t\tevtParam->write.is_prep,",
                            "\t\t\t\t\tevtParam->write.len);",
                            "\t\t\tchar* pHex = buildHexData(nullptr, evtParam->write.value, evtParam->write.len);",
                            "\t\t\tESP_LOGV(LOG_TAG, \"[Data: %s]\", pHex);",
                            "\t\t\tfree(pHex);",
                            "\t\t\tbreak;",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\tESP_LOGV(LOG_TAG, \"dumpGattServerEvent: *** NOT CODED ***\");",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a BLE event type to a string.",
                            " * @param [in] eventType The event type.",
                            " * @return The event type as a string.",
                            " */",
                            "const char* BLEUtils::eventTypeToString(esp_ble_evt_type_t eventType) {",
                            "\tswitch (eventType) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_BLE_EVT_CONN_ADV:",
                            "\t\t\treturn \"ESP_BLE_EVT_CONN_ADV\";",
                            "\t\tcase ESP_BLE_EVT_CONN_DIR_ADV:",
                            "\t\t\treturn \"ESP_BLE_EVT_CONN_DIR_ADV\";",
                            "\t\tcase ESP_BLE_EVT_DISC_ADV:",
                            "\t\t\treturn \"ESP_BLE_EVT_DISC_ADV\";",
                            "\t\tcase ESP_BLE_EVT_NON_CONN_ADV:",
                            "\t\t\treturn \"ESP_BLE_EVT_NON_CONN_ADV\";",
                            "\t\tcase ESP_BLE_EVT_SCAN_RSP:",
                            "\t\t\treturn \"ESP_BLE_EVT_SCAN_RSP\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\tESP_LOGV(LOG_TAG, \"Unknown esp_ble_evt_type_t: %d (0x%.2x)\", eventType, eventType);",
                            "\t\t\treturn \"*** Unknown ***\";",
                            "\t}",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a BT GAP event type to a string representation.",
                            " * @param [in] eventType The type of event.",
                            " * @return A string representation of the event type.",
                            " */",
                            "const char* BLEUtils::gapEventToString(uint32_t eventType) {",
                            "\tswitch (eventType) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_ADV_START_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_ADV_START_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:\t\t\t\t\t  /* !< When stop adv complete, the event comes */",
                            "\t\t\treturn \"ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_AUTH_CMPL_EVT:\t\t\t\t\t\t\t  /* Authentication complete indication. */",
                            "\t\t\treturn \"ESP_GAP_BLE_AUTH_CMPL_EVT\";",
                            "\t\tcase ESP_GAP_BLE_CLEAR_BOND_DEV_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_CLEAR_BOND_DEV_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_GET_BOND_DEV_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_GET_BOND_DEV_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_KEY_EVT:\t\t\t\t\t\t\t\t\t/* BLE  key event for peer device keys */",
                            "\t\t\treturn \"ESP_GAP_BLE_KEY_EVT\";",
                            "\t\tcase ESP_GAP_BLE_LOCAL_IR_EVT:\t\t\t\t\t\t\t   /* BLE local IR event */",
                            "\t\t\treturn \"ESP_GAP_BLE_LOCAL_IR_EVT\";",
                            "\t\tcase ESP_GAP_BLE_LOCAL_ER_EVT:\t\t\t\t\t\t\t   /* BLE local ER event */",
                            "\t\t\treturn \"ESP_GAP_BLE_LOCAL_ER_EVT\";",
                            "\t\tcase ESP_GAP_BLE_NC_REQ_EVT:\t\t\t\t\t\t\t\t /* Numeric Comparison request event */",
                            "\t\t\treturn \"ESP_GAP_BLE_NC_REQ_EVT\";",
                            "\t\tcase ESP_GAP_BLE_OOB_REQ_EVT:\t\t\t\t\t\t\t\t/* OOB request event */",
                            "\t\t\treturn \"ESP_GAP_BLE_OOB_REQ_EVT\";",
                            "\t\tcase ESP_GAP_BLE_PASSKEY_NOTIF_EVT:\t\t\t\t\t\t  /* passkey notification event */",
                            "\t\t\treturn \"ESP_GAP_BLE_PASSKEY_NOTIF_EVT\";",
                            "\t\tcase ESP_GAP_BLE_PASSKEY_REQ_EVT:\t\t\t\t\t\t\t/* passkey request event */",
                            "\t\t\treturn \"ESP_GAP_BLE_PASSKEY_REQ_EVT\";",
                            "\t\tcase ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SCAN_RESULT_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SCAN_RESULT_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SCAN_START_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SCAN_START_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SEC_REQ_EVT:\t\t\t\t\t\t\t\t/* BLE  security request */",
                            "\t\t\treturn \"ESP_GAP_BLE_SEC_REQ_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SET_LOCAL_PRIVACY_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SET_LOCAL_PRIVACY_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SET_PKT_LENGTH_COMPLETE_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SET_PKT_LENGTH_COMPLETE_EVT\";",
                            "\t\tcase ESP_GAP_BLE_SET_STATIC_RAND_ADDR_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_SET_STATIC_RAND_ADDR_EVT\";",
                            "\t\tcase ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT:",
                            "\t\t\treturn \"ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\tESP_LOGV(LOG_TAG, \"gapEventToString: Unknown event type %d 0x%.2x\", eventType, eventType);",
                            "\t\t\treturn \"Unknown event type\";",
                            "\t}",
                            "",
                            "",
                            "std::string BLEUtils::gattCharacteristicUUIDToString(uint32_t characteristicUUID) {",
                            "\tconst characteristicMap_t* p = g_characteristicsMappings;",
                            "\twhile (strlen(p->name) > 0) {",
                            "\t\tif (p->assignedNumber == characteristicUUID) {",
                            "\t\t\treturn std::string(p->name);",
                            "\t\t}",
                            "\t\tp++;",
                            "\t}",
                            "\treturn \"Unknown\";",
                            "",
                            "",
                            "/**",
                            " * @brief Given the UUID for a BLE defined descriptor, return its string representation.",
                            " * @param [in] descriptorUUID UUID of the descriptor to be returned as a string.",
                            " * @return The string representation of a descriptor UUID.",
                            " */",
                            "std::string BLEUtils::gattDescriptorUUIDToString(uint32_t descriptorUUID) {",
                            "\tgattdescriptor_t* p = (gattdescriptor_t*) g_descriptor_ids;",
                            "\twhile (strlen(p->name) > 0) {",
                            "\t\tif (p->assignedNumber == descriptorUUID) {",
                            "\t\t\treturn std::string(p->name);",
                            "\t\t}",
                            "\t\tp++;",
                            "\t}",
                            "\treturn \"\";",
                            "",
                            "",
                            "/**",
                            " * @brief Return a string representation of an esp_gattc_service_elem_t.",
                            " * @return A string representation of an esp_gattc_service_elem_t.",
                            " */",
                            "std::string BLEUtils::gattcServiceElementToString(esp_gattc_service_elem_t* pGATTCServiceElement) {",
                            "\tstd::stringstream ss;",
                            "",
                            "\tss << \"[uuid: \" << BLEUUID(pGATTCServiceElement->uuid).toString() <<",
                            "\t\t\", start_handle: \" << pGATTCServiceElement->start_handle <<",
                            "\t\t\t\" 0x\" << std::hex << pGATTCServiceElement->start_handle <<",
                            "\t\t\", end_handle: \" << std::dec << pGATTCServiceElement->end_handle <<",
                            "\t\t  \" 0x\" << std::hex << pGATTCServiceElement->end_handle << \"]\";",
                            "\treturn ss.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Convert an esp_gatt_srvc_id_t to a string.",
                            " */",
                            "std::string BLEUtils::gattServiceIdToString(esp_gatt_srvc_id_t srvcId) {",
                            "\treturn gattIdToString(srvcId.id);",
                            "",
                            "",
                            "std::string BLEUtils::gattServiceToString(uint32_t serviceId) {",
                            "\tgattService_t* p = (gattService_t*) g_gattServices;",
                            "\twhile (strlen(p->name) > 0) {",
                            "\t\tif (p->assignedNumber == serviceId) {",
                            "\t\t\treturn std::string(p->name);",
                            "\t\t}",
                            "\t\tp++;",
                            "\t}",
                            "\treturn \"Unknown\";",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a GATT status to a string.",
                            " *",
                            " * @param [in] status The status to convert.",
                            " * @return A string representation of the status.",
                            " */",
                            "std::string BLEUtils::gattStatusToString(esp_gatt_status_t status) {",
                            "\tswitch (status) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_GATT_OK:",
                            "\t\t\treturn \"ESP_GATT_OK\";",
                            "\t\tcase ESP_GATT_INVALID_HANDLE:",
                            "\t\t\treturn \"ESP_GATT_INVALID_HANDLE\";",
                            "\t\tcase ESP_GATT_READ_NOT_PERMIT:",
                            "\t\t\treturn \"ESP_GATT_READ_NOT_PERMIT\";",
                            "\t\tcase ESP_GATT_WRITE_NOT_PERMIT:",
                            "\t\t\treturn \"ESP_GATT_WRITE_NOT_PERMIT\";",
                            "\t\tcase ESP_GATT_INVALID_PDU:",
                            "\t\t\treturn \"ESP_GATT_INVALID_PDU\";",
                            "\t\tcase ESP_GATT_INSUF_AUTHENTICATION:",
                            "\t\t\treturn \"ESP_GATT_INSUF_AUTHENTICATION\";",
                            "\t\tcase ESP_GATT_REQ_NOT_SUPPORTED:",
                            "\t\t\treturn \"ESP_GATT_REQ_NOT_SUPPORTED\";",
                            "\t\tcase ESP_GATT_INVALID_OFFSET:",
                            "\t\t\treturn \"ESP_GATT_INVALID_OFFSET\";",
                            "\t\tcase ESP_GATT_INSUF_AUTHORIZATION:",
                            "\t\t\treturn \"ESP_GATT_INSUF_AUTHORIZATION\";",
                            "\t\tcase ESP_GATT_PREPARE_Q_FULL:",
                            "\t\t\treturn \"ESP_GATT_PREPARE_Q_FULL\";",
                            "\t\tcase ESP_GATT_NOT_FOUND:",
                            "\t\t\treturn \"ESP_GATT_NOT_FOUND\";",
                            "\t\tcase ESP_GATT_NOT_LONG:",
                            "\t\t\treturn \"ESP_GATT_NOT_LONG\";",
                            "\t\tcase ESP_GATT_INSUF_KEY_SIZE:",
                            "\t\t\treturn \"ESP_GATT_INSUF_KEY_SIZE\";",
                            "\t\tcase ESP_GATT_INVALID_ATTR_LEN:",
                            "\t\t\treturn \"ESP_GATT_INVALID_ATTR_LEN\";",
                            "\t\tcase ESP_GATT_ERR_UNLIKELY:",
                            "\t\t\treturn \"ESP_GATT_ERR_UNLIKELY\";",
                            "\t\tcase ESP_GATT_INSUF_ENCRYPTION:",
                            "\t\t\treturn \"ESP_GATT_INSUF_ENCRYPTION\";",
                            "\t\tcase ESP_GATT_UNSUPPORT_GRP_TYPE:",
                            "\t\t\treturn \"ESP_GATT_UNSUPPORT_GRP_TYPE\";",
                            "\t\tcase ESP_GATT_INSUF_RESOURCE:",
                            "\t\t\treturn \"ESP_GATT_INSUF_RESOURCE\";",
                            "\t\tcase ESP_GATT_NO_RESOURCES:",
                            "\t\t\treturn \"ESP_GATT_NO_RESOURCES\";",
                            "\t\tcase ESP_GATT_INTERNAL_ERROR:",
                            "\t\t\treturn \"ESP_GATT_INTERNAL_ERROR\";",
                            "\t\tcase ESP_GATT_WRONG_STATE:",
                            "\t\t\treturn \"ESP_GATT_WRONG_STATE\";",
                            "\t\tcase ESP_GATT_DB_FULL:",
                            "\t\t\treturn \"ESP_GATT_DB_FULL\";",
                            "\t\tcase ESP_GATT_BUSY:",
                            "\t\t\treturn \"ESP_GATT_BUSY\";",
                            "\t\tcase ESP_GATT_ERROR:",
                            "\t\t\treturn \"ESP_GATT_ERROR\";",
                            "\t\tcase ESP_GATT_CMD_STARTED:",
                            "\t\t\treturn \"ESP_GATT_CMD_STARTED\";",
                            "\t\tcase ESP_GATT_ILLEGAL_PARAMETER:",
                            "\t\t\treturn \"ESP_GATT_ILLEGAL_PARAMETER\";",
                            "\t\tcase ESP_GATT_PENDING:",
                            "\t\t\treturn \"ESP_GATT_PENDING\";",
                            "\t\tcase ESP_GATT_AUTH_FAIL:",
                            "\t\t\treturn \"ESP_GATT_AUTH_FAIL\";",
                            "\t\tcase ESP_GATT_MORE:",
                            "\t\t\treturn \"ESP_GATT_MORE\";",
                            "\t\tcase ESP_GATT_INVALID_CFG:",
                            "\t\t\treturn \"ESP_GATT_INVALID_CFG\";",
                            "\t\tcase ESP_GATT_SERVICE_STARTED:",
                            "\t\t\treturn \"ESP_GATT_SERVICE_STARTED\";",
                            "\t\tcase ESP_GATT_ENCRYPED_NO_MITM:",
                            "\t\t\treturn \"ESP_GATT_ENCRYPED_NO_MITM\";",
                            "\t\tcase ESP_GATT_NOT_ENCRYPTED:",
                            "\t\t\treturn \"ESP_GATT_NOT_ENCRYPTED\";",
                            "\t\tcase ESP_GATT_CONGESTED:",
                            "\t\t\treturn \"ESP_GATT_CONGESTED\";",
                            "\t\tcase ESP_GATT_DUP_REG:",
                            "\t\t\treturn \"ESP_GATT_DUP_REG\";",
                            "\t\tcase ESP_GATT_ALREADY_OPEN:",
                            "\t\t\treturn \"ESP_GATT_ALREADY_OPEN\";",
                            "\t\tcase ESP_GATT_CANCEL:",
                            "\t\t\treturn \"ESP_GATT_CANCEL\";",
                            "\t\tcase ESP_GATT_STACK_RSP:",
                            "\t\t\treturn \"ESP_GATT_STACK_RSP\";",
                            "\t\tcase ESP_GATT_APP_RSP:",
                            "\t\t\treturn \"ESP_GATT_APP_RSP\";",
                            "\t\tcase ESP_GATT_UNKNOWN_ERROR:",
                            "\t\t\treturn \"ESP_GATT_UNKNOWN_ERROR\";",
                            "\t\tcase ESP_GATT_CCC_CFG_ERR:",
                            "\t\t\treturn \"ESP_GATT_CCC_CFG_ERR\";",
                            "\t\tcase ESP_GATT_PRC_IN_PROGRESS:",
                            "\t\t\treturn \"ESP_GATT_PRC_IN_PROGRESS\";",
                            "\t\tcase ESP_GATT_OUT_OF_RANGE:",
                            "\t\t\treturn \"ESP_GATT_OUT_OF_RANGE\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\treturn \"Unknown\";",
                            "\t}",
                            "",
                            "",
                            "",
                            "std::string BLEUtils::getMember(uint32_t memberId) {",
                            "\tmember_t* p = (member_t*) members_ids;",
                            "",
                            "\twhile (strlen(p->name) > 0) {",
                            "\t\tif (p->assignedNumber == memberId) {",
                            "\t\t\treturn std::string(p->name);",
                            "\t\t}",
                            "\t\tp++;",
                            "\t}",
                            "\treturn \"Unknown\";",
                            "}",
                            "",
                            "/**",
                            " * @brief convert a GAP search event to a string.",
                            " * @param [in] searchEvt",
                            " * @return The search event type as a string.",
                            " */",
                            "const char* BLEUtils::searchEventTypeToString(esp_gap_search_evt_t searchEvt) {",
                            "\tswitch (searchEvt) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_GAP_SEARCH_INQ_RES_EVT:",
                            "\t\t\treturn \"ESP_GAP_SEARCH_INQ_RES_EVT\";",
                            "\t\tcase ESP_GAP_SEARCH_INQ_CMPL_EVT:",
                            "\t\t\treturn \"ESP_GAP_SEARCH_INQ_CMPL_EVT\";",
                            "\t\tcase ESP_GAP_SEARCH_DISC_RES_EVT:",
                            "\t\t\treturn \"ESP_GAP_SEARCH_DISC_RES_EVT\";",
                            "\t\tcase ESP_GAP_SEARCH_DISC_BLE_RES_EVT:",
                            "\t\t\treturn \"ESP_GAP_SEARCH_DISC_BLE_RES_EVT\";",
                            "\t\tcase ESP_GAP_SEARCH_DISC_CMPL_EVT:",
                            "\t\t\treturn \"ESP_GAP_SEARCH_DISC_CMPL_EVT\";",
                            "\t\tcase ESP_GAP_SEARCH_DI_DISC_CMPL_EVT:",
                            "\t\t\treturn \"ESP_GAP_SEARCH_DI_DISC_CMPL_EVT\";",
                            "\t\tcase ESP_GAP_SEARCH_SEARCH_CANCEL_CMPL_EVT:",
                            "\t\t\treturn \"ESP_GAP_SEARCH_SEARCH_CANCEL_CMPL_EVT\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\tESP_LOGV(LOG_TAG, \"Unknown event type: 0x%x\", searchEvt);",
                            "\t\t\treturn \"Unknown event type\";",
                            "\t}",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "17": "#include <esp_bt.h>              // ESP32 BLE",
                "18": "#include <esp_bt_main.h>     // ESP32 BLE",
                "19": "#include <esp_gap_ble_api.h> // ESP32 BLE",
                "20": "#include <esp_gattc_api.h>   // ESP32 BLE",
                "21": "#include <esp_err.h>         // ESP32 ESP-IDF",
                "22": "#include <map>               // Part of C++ STL",
                "31": "static const char* LOG_TAG = \"BLEUtils\";  // Tag for logging.",
                "624": "} // characteristicPropertiesToString",
                "634": "} // gattIdToString",
                "655": "} // addressTypeToString",
                "681": "} // adFlagsToString",
                "695": "\t\tcase ESP_BLE_AD_TYPE_FLAG:\t\t\t\t   // 0x01",
                "697": "\t\tcase ESP_BLE_AD_TYPE_16SRV_PART:\t\t\t // 0x02",
                "699": "\t\tcase ESP_BLE_AD_TYPE_16SRV_CMPL:\t\t\t // 0x03",
                "701": "\t\tcase ESP_BLE_AD_TYPE_32SRV_PART:\t\t\t // 0x04",
                "703": "\t\tcase ESP_BLE_AD_TYPE_32SRV_CMPL:\t\t\t // 0x05",
                "705": "\t\tcase ESP_BLE_AD_TYPE_128SRV_PART:\t\t\t// 0x06",
                "707": "\t\tcase ESP_BLE_AD_TYPE_128SRV_CMPL:\t\t\t// 0x07",
                "709": "\t\tcase ESP_BLE_AD_TYPE_NAME_SHORT:\t\t\t // 0x08",
                "711": "\t\tcase ESP_BLE_AD_TYPE_NAME_CMPL:\t\t\t  // 0x09",
                "713": "\t\tcase ESP_BLE_AD_TYPE_TX_PWR:\t\t\t\t // 0x0a",
                "715": "\t\tcase ESP_BLE_AD_TYPE_DEV_CLASS:\t\t\t  // 0x0b",
                "717": "\t\tcase ESP_BLE_AD_TYPE_SM_TK:\t\t\t\t  // 0x10",
                "719": "\t\tcase ESP_BLE_AD_TYPE_SM_OOB_FLAG:\t\t\t// 0x11",
                "721": "\t\tcase ESP_BLE_AD_TYPE_INT_RANGE:\t\t\t  // 0x12",
                "723": "\t\tcase ESP_BLE_AD_TYPE_SOL_SRV_UUID:\t\t   // 0x14",
                "725": "\t\tcase ESP_BLE_AD_TYPE_128SOL_SRV_UUID:\t\t// 0x15",
                "727": "\t\tcase ESP_BLE_AD_TYPE_SERVICE_DATA:\t\t   // 0x16",
                "729": "\t\tcase ESP_BLE_AD_TYPE_PUBLIC_TARGET:\t\t  // 0x17",
                "731": "\t\tcase ESP_BLE_AD_TYPE_RANDOM_TARGET:\t\t  // 0x18",
                "733": "\t\tcase ESP_BLE_AD_TYPE_APPEARANCE:\t\t\t // 0x19",
                "735": "\t\tcase ESP_BLE_AD_TYPE_ADV_INT:\t\t\t\t// 0x1a",
                "739": "\t\tcase ESP_BLE_AD_TYPE_32SERVICE_DATA:\t\t // 0x20",
                "741": "\t\tcase ESP_BLE_AD_TYPE_128SERVICE_DATA:\t\t// 0x21",
                "743": "\t\tcase ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE:  // 0xff",
                "749": "\t} // End switch",
                "750": "} // advTypeToString",
                "776": "\t// Guard against too much data.",
                "794": "\t// Handle the special case where there was no data.",
                "800": "} // buildHexData",
                "819": "} // buildPrintData",
                "862": "} // gattCloseReasonToString",
                "955": "} // gattClientEventTypeToString",
                "1020": "} // gattServerEventTypeToString",
                "1041": "} // devTypeToString",
                "1053": "\t\t// ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT",
                "1054": "\t\t// adv_data_cmpl",
                "1055": "\t\t// - esp_bt_status_t",
                "1059": "\t\t} // ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT",
                "1061": "\t\t// ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT",
                "1063": "\t\t// adv_data_raw_cmpl",
                "1064": "\t\t// - esp_bt_status_t status",
                "1068": "\t\t} // ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT",
                "1070": "\t\t// ESP_GAP_BLE_ADV_START_COMPLETE_EVT",
                "1072": "\t\t// adv_start_cmpl",
                "1073": "\t\t// - esp_bt_status_t status",
                "1077": "\t\t} // ESP_GAP_BLE_ADV_START_COMPLETE_EVT",
                "1079": "\t\t// ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT",
                "1081": "\t\t// adv_stop_cmpl",
                "1082": "\t\t// - esp_bt_status_t status",
                "1086": "\t\t} // ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT",
                "1088": "\t\t// ESP_GAP_BLE_AUTH_CMPL_EVT",
                "1090": "\t\t// auth_cmpl",
                "1091": "\t\t// - esp_bd_addr_t bd_addr",
                "1092": "\t\t// - bool key_present",
                "1093": "\t\t// - esp_link_key key",
                "1094": "\t\t// - bool success",
                "1095": "\t\t// - uint8_t fail_reason",
                "1096": "\t\t// - esp_bd_addr_type_t addr_type",
                "1097": "\t\t// - esp_bt_dev_type_t dev_type",
                "1108": "\t\t} // ESP_GAP_BLE_AUTH_CMPL_EVT",
                "1110": "\t\t// ESP_GAP_BLE_CLEAR_BOND_DEV_COMPLETE_EVT",
                "1112": "\t\t// clear_bond_dev_cmpl",
                "1113": "\t\t// - esp_bt_status_t status",
                "1117": "\t\t} // ESP_GAP_BLE_CLEAR_BOND_DEV_COMPLETE_EVT",
                "1119": "\t\t// ESP_GAP_BLE_LOCAL_IR_EVT",
                "1122": "\t\t} // ESP_GAP_BLE_LOCAL_IR_EVT",
                "1124": "\t\t// ESP_GAP_BLE_LOCAL_ER_EVT",
                "1127": "\t\t} // ESP_GAP_BLE_LOCAL_ER_EVT",
                "1129": "\t\t// ESP_GAP_BLE_NC_REQ_EVT",
                "1135": "\t\t} // ESP_GAP_BLE_NC_REQ_EVT",
                "1137": "\t\t// ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                "1139": "\t\t// read_rssi_cmpl",
                "1140": "\t\t// - esp_bt_status_t status",
                "1141": "\t\t// - int8_t rssi",
                "1142": "\t\t// - esp_bd_addr_t remote_addr",
                "1150": "\t\t} // ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT",
                "1152": "\t\t// ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT",
                "1154": "\t\t// scan_param_cmpl.",
                "1155": "\t\t// - esp_bt_status_t status",
                "1159": "\t\t} // ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT",
                "1161": "\t\t// ESP_GAP_BLE_SCAN_RESULT_EVT",
                "1163": "\t\t// scan_rst:",
                "1164": "\t\t// - search_evt",
                "1165": "\t\t// - bda",
                "1166": "\t\t// - dev_type",
                "1167": "\t\t// - ble_addr_type",
                "1168": "\t\t// - ble_evt_type",
                "1169": "\t\t// - rssi",
                "1170": "\t\t// - ble_adv",
                "1171": "\t\t// - flag",
                "1172": "\t\t// - num_resps",
                "1173": "\t\t// - adv_data_len",
                "1174": "\t\t// - scan_rsp_len",
                "1192": "\t\t\t\t} // ESP_GAP_SEARCH_INQ_RES_EVT",
                "1200": "\t\t} // ESP_GAP_BLE_SCAN_RESULT_EVT",
                "1202": "\t\t// ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT",
                "1204": "\t\t// scan_rsp_data_cmpl",
                "1205": "\t\t// - esp_bt_status_t status",
                "1209": "\t\t} // ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT",
                "1211": "\t\t// ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT",
                "1215": "\t\t} // ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT",
                "1217": "\t\t// ESP_GAP_BLE_SCAN_START_COMPLETE_EVT",
                "1219": "\t\t// scan_start_cmpl",
                "1220": "\t\t// - esp_bt_status_t status",
                "1224": "\t\t} // ESP_GAP_BLE_SCAN_START_COMPLETE_EVT",
                "1226": "\t\t// ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT",
                "1228": "\t\t// scan_stop_cmpl",
                "1229": "\t\t// - esp_bt_status_t status",
                "1233": "\t\t} // ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT",
                "1235": "\t\t// ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT",
                "1237": "\t\t// update_conn_params",
                "1238": "\t\t// - esp_bt_status_t status",
                "1239": "\t\t// - esp_bd_addr_t bda",
                "1240": "\t\t// - uint16_t min_int",
                "1241": "\t\t// - uint16_t max_int",
                "1242": "\t\t// - uint16_t latency",
                "1243": "\t\t// - uint16_t conn_int",
                "1244": "\t\t// - uint16_t timeout",
                "1256": "\t\t} // ESP_GAP_BLE_SCAN_UPDATE_CONN_PARAMS_EVT",
                "1258": "\t\t// ESP_GAP_BLE_SEC_REQ_EVT",
                "1262": "\t\t} // ESP_GAP_BLE_SEC_REQ_EVT",
                "1267": "\t\t} // default",
                "1268": "\t} // switch",
                "1269": "} // dumpGapEvent",
                "1287": "\t\t// ESP_GATTC_CLOSE_EVT",
                "1289": "\t\t// close:",
                "1290": "\t\t// - esp_gatt_status_t      status",
                "1291": "\t\t// - uint16_t               conn_id",
                "1292": "\t\t// - esp_bd_addr_t          remote_bda",
                "1293": "\t\t// - esp_gatt_conn_reason_t reason",
                "1302": "\t\t// ESP_GATTC_CONNECT_EVT",
                "1304": "\t\t// connect:",
                "1305": "\t\t// - esp_gatt_status_t status",
                "1306": "\t\t// - uint16_t          conn_id",
                "1307": "\t\t// - esp_bd_addr_t     remote_bda",
                "1316": "\t\t// ESP_GATTC_DISCONNECT_EVT",
                "1318": "\t\t// disconnect:",
                "1319": "\t\t// - esp_gatt_conn_reason_t reason",
                "1320": "\t\t// - uint16_t               conn_id",
                "1321": "\t\t// - esp_bd_addr_t          remote_bda",
                "1329": "\t\t} // ESP_GATTC_DISCONNECT_EVT",
                "1331": "\t\t// ESP_GATTC_GET_CHAR_EVT",
                "1333": "\t\t// get_char:",
                "1334": "\t\t// - esp_gatt_status_t    status",
                "1335": "\t\t// - uin1t6_t             conn_id",
                "1336": "\t\t// - esp_gatt_srvc_id_t   srvc_id",
                "1337": "\t\t// - esp_gatt_id_t        char_id",
                "1338": "\t\t// - esp_gatt_char_prop_t char_prop",
                "1342": "\t\t\t// If the status of the event shows that we have a value other than ESP_GATT_OK then the",
                "1343": "\t\t\t// characteristic fields are not set to a usable value .. so don't try and log them.",
                "1365": "\t\t} // ESP_GATTC_GET_CHAR_EVT",
                "1368": "\t\t// ESP_GATTC_NOTIFY_EVT",
                "1370": "\t\t// notify",
                "1371": "\t\t// uint16_t           conn_id",
                "1372": "\t\t// esp_bd_addr_t      remote_bda",
                "1373": "\t\t// handle             handle",
                "1374": "\t\t// uint16_t           value_len",
                "1375": "\t\t// uint8_t*           value",
                "1376": "\t\t// bool               is_notify",
                "1390": "\t\t// ESP_GATTC_OPEN_EVT",
                "1392": "\t\t// open:",
                "1393": "\t\t// - esp_gatt_status_t status",
                "1394": "\t\t// - uint16_t          conn_id",
                "1395": "\t\t// - esp_bd_addr_t     remote_bda",
                "1396": "\t\t// - uint16_t          mtu",
                "1405": "\t\t} // ESP_GATTC_OPEN_EVT",
                "1407": "\t\t// ESP_GATTC_READ_CHAR_EVT",
                "1409": "\t\t// Callback to indicate that requested data that we wanted to read is now available.",
                "1411": "\t\t// read:",
                "1412": "\t\t// esp_gatt_status_t  status",
                "1413": "\t\t// uint16_t           conn_id",
                "1414": "\t\t// uint16_t           handle",
                "1415": "\t\t// uint8_t*           value",
                "1416": "\t\t// uint16_t           value_type",
                "1417": "\t\t// uint16_t           value_len",
                "1435": "\t\t} // ESP_GATTC_READ_CHAR_EVT",
                "1437": "\t\t// ESP_GATTC_REG_EVT",
                "1439": "\t\t// reg:",
                "1440": "\t\t// - esp_gatt_status_t status",
                "1441": "\t\t// - uint16_t          app_id",
                "1447": "\t\t} // ESP_GATTC_REG_EVT",
                "1449": "\t\t// ESP_GATTC_REG_FOR_NOTIFY_EVT",
                "1451": "\t\t// reg_for_notify:",
                "1452": "\t\t// - esp_gatt_status_t status",
                "1453": "\t\t// - uint16_t          handle",
                "1461": "\t\t} // ESP_GATTC_REG_FOR_NOTIFY_EVT",
                "1463": "\t\t// ESP_GATTC_SEARCH_CMPL_EVT",
                "1465": "\t\t// search_cmpl:",
                "1466": "\t\t// - esp_gatt_status_t status",
                "1467": "\t\t// - uint16_t          conn_id",
                "1473": "\t\t} // ESP_GATTC_SEARCH_CMPL_EVT",
                "1475": "\t\t// ESP_GATTC_SEARCH_RES_EVT",
                "1477": "\t\t// search_res:",
                "1478": "\t\t// - uint16_t      conn_id",
                "1479": "\t\t// - uint16_t      start_handle",
                "1480": "\t\t// - uint16_t      end_handle",
                "1481": "\t\t// - esp_gatt_id_t srvc_id",
                "1491": "\t\t} // ESP_GATTC_SEARCH_RES_EVT",
                "1493": "\t\t// ESP_GATTC_WRITE_CHAR_EVT",
                "1495": "\t\t// write:",
                "1496": "\t\t// - esp_gatt_status_t status",
                "1497": "\t\t// - uint16_t          conn_id",
                "1498": "\t\t// - uint16_t          handle",
                "1499": "\t\t// - uint16_t          offset",
                "1509": "\t\t} // ESP_GATTC_WRITE_CHAR_EVT",
                "1514": "} // dumpGattClientEvent",
                "1544": "\t\t} // ESP_GATTS_ADD_CHAR_DESCR_EVT",
                "1565": "\t\t} // ESP_GATTS_ADD_CHAR_EVT",
                "1568": "\t\t// ESP_GATTS_CONF_EVT",
                "1570": "\t\t// conf:",
                "1571": "\t\t// - esp_gatt_status_t status  \u2013 The status code.",
                "1572": "\t\t// - uint16_t          conn_id \u2013 The connection used.",
                "1578": "\t\t} // ESP_GATTS_CONF_EVT",
                "1586": "\t\t} // ESP_GATTS_CONGEST_EVT",
                "1593": "\t\t} // ESP_GATTS_CONNECT_EVT",
                "1602": "\t\t} // ESP_GATTS_CREATE_EVT",
                "1609": "\t\t} // ESP_GATTS_DISCONNECT_EVT",
                "1612": "\t\t// ESP_GATTS_EXEC_WRITE_EVT",
                "1613": "\t\t// exec_write:",
                "1614": "\t\t// - uint16_t conn_id",
                "1615": "\t\t// - uint32_t trans_id",
                "1616": "\t\t// - esp_bd_addr_t bda",
                "1617": "\t\t// - uint8_t exec_write_flag",
                "1643": "\t\t} // ESP_GATTS_DISCONNECT_EVT",
                "1651": "\t\t} // ESP_GATTS_MTU_EVT",
                "1662": "\t\t} // ESP_GATTS_READ_EVT",
                "1669": "\t\t} // ESP_GATTS_RESPONSE_EVT",
                "1676": "\t\t} // ESP_GATTS_REG_EVT",
                "1679": "\t\t// ESP_GATTS_START_EVT",
                "1681": "\t\t// start:",
                "1682": "\t\t// - esp_gatt_status_t status",
                "1683": "\t\t// - uint16_t          service_handle",
                "1689": "\t\t} // ESP_GATTS_START_EVT",
                "1692": "\t\t// ESP_GATTS_WRITE_EVT",
                "1694": "\t\t// write:",
                "1695": "\t\t// - uint16_t      conn_id  \u2013 The connection id.",
                "1696": "\t\t// - uint16_t      trans_id \u2013 The transfer id.",
                "1697": "\t\t// - esp_bd_addr_t bda      \u2013 The address of the partner.",
                "1698": "\t\t// - uint16_t      handle   \u2013 The attribute handle.",
                "1699": "\t\t// - uint16_t      offset   \u2013 The offset of the currently received within the whole value.",
                "1700": "\t\t// - bool          need_rsp \u2013 Do we need a response?",
                "1701": "\t\t// - bool          is_prep  \u2013 Is this a write prepare?  If set, then this is to be considered part of the received value and not the whole value.  A subsequent ESP_GATTS_EXEC_WRITE will mark the total.",
                "1702": "\t\t// - uint16_t      len      \u2013 The length of the incoming value part.",
                "1703": "\t\t// - uint8_t*      value    \u2013 The data for this value part.",
                "1718": "\t\t} // ESP_GATTS_WRITE_EVT",
                "1724": "} // dumpGattServerEvent",
                "1750": "} // eventTypeToString",
                "1821": "} // gapEventToString",
                "1833": "} // gattCharacteristicUUIDToString",
                "1850": "} // gattDescriptorUUIDToString",
                "1866": "} // gattcServiceElementToString",
                "1874": "} // gattServiceIdToString",
                "1886": "} // gattServiceToString",
                "1988": "} // gattStatusToString",
                "2031": "} // searchEventTypeToString",
                "2033": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "01d7ea7b80a7badbe30e6fb6f33f71375e0b133c",
            "timestamp": "2019-04-15T17:26:35+02:00",
            "author": "Bascy",
            "commit_message": "Refactored use of LOG_X(LOG_TAG, ...) to log_x(...) (#2672)\n\n* Replaced ARDUINO_VARIANT with const char\r\n\r\n* Fixed missing return value\r\n\r\n* Added quotes around defined value in macro (Issue #2193)\r\n\r\n* Change logging from Error to Verbose when not found and default available\r\n\r\n* Move Enter and Exit logging to Verbose Level\r\n\r\n* Refactored LOG_X() into log_x()",
            "additions": 58,
            "deletions": 65,
            "change_type": "MODIFY",
            "diff": {
                "added": [],
                "deleted": [
                    {
                        "line_numbers": [
                            31,
                            32,
                            33
                        ],
                        "comments": [
                            "static const char* LOG_TAG = \"BLEUtils\";  // Tag for logging."
                        ],
                        "lines": [
                            "#endif",
                            ""
                        ]
                    },
                    {
                        "line_numbers": [
                            747
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \" adv data type: 0x%x\", advType);"
                        ]
                    },
                    {
                        "line_numbers": [
                            782
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGE(LOG_TAG, \"buildHexData: malloc failed\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            952
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"Unknown GATT Client event type: %d\", eventType);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1050
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGV(LOG_TAG, \"Received a GAP event: %s\", gapEventToString(event));"
                        ]
                    },
                    {
                        "line_numbers": [
                            1057
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_data_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1066
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_data_raw_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1075
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_start_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1084
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->adv_stop_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1099
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[bd_addr: %s, key_present: %d, key: ***, key_type: %d, success: %d, fail_reason: %d, addr_type: ***, dev_type: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1115
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->clear_bond_dev_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1131
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[bd_addr: %s, passkey: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1144
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d, rssi: %d, remote_addr: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1157
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_param_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1178
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\t\tESP_LOGV(LOG_TAG, \"search_evt: %s, bda: %s, dev_type: %s, ble_addr_type: %s, ble_evt_type: %s, rssi: %d, ble_adv: ??, flag: %d (%s), num_resps: %d, adv_data_len: %d, scan_rsp_len: %d\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1195
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\t\tESP_LOGV(LOG_TAG, \"search_evt: %s\",searchEventTypeToString(param->scan_rst.search_evt));"
                        ]
                    },
                    {
                        "line_numbers": [
                            1207
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_rsp_data_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1213
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_rsp_data_raw_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1222
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_start_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1231
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d]\", param->scan_stop_cmpl.status);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1246
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %d, bd_addr: %s, min_int: %d, max_int: %d, latency: %d, conn_int: %d, timeout: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1260
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[bd_addr: %s]\", BLEAddress(param->ble_security.ble_req.bd_addr).toString().c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            1265
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"*** dumpGapEvent: Logger not coded ***\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            1284
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGV(LOG_TAG, \"GATT Event: %s\", BLEUtils::gattClientEventTypeToString(event).c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            1295
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, reason:%s, conn_id: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1309
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1323
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[reason: %s, conn_id: %d, remote_bda: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1349
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, srvc_id: %s, char_id: %s [description: %s]\\nchar_prop: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1358
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, srvc_id: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1379
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s, handle: %d 0x%.2x, value_len: %d, is_notify: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1399
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, remote_bda: %s, mtu: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1419
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, handle: %d 0x%.2x, value_len: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1430
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"value: %s \\\"%s\\\"\", pHexData, BLEUtils::buildPrintData(evtParam->read.value, evtParam->read.value_len).c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            1443
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, app_id: 0x%x]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1455
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, handle: %d 0x%.2x]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1469
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1483
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, start_handle: %d 0x%.2x, end_handle: %d 0x%.2x, srvc_id: %s\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1501
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: %d, handle: %d 0x%.2x, offset: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1531
                        ],
                        "comments": [],
                        "lines": [
                            "\tESP_LOGV(LOG_TAG, \"GATT ServerEvent: %s\", BLEUtils::gattServerEventTypeToString(event).c_str());"
                        ]
                    },
                    {
                        "line_numbers": [
                            1536
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, attr_handle: %d 0x%.2x, service_handle: %d 0x%.2x, char_uuid: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1548
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, attr_handle: %d 0x%.2x, service_handle: %d 0x%.2x, char_uuid: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1556
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\t\tESP_LOGE(LOG_TAG, \"[status: %s, attr_handle: %d 0x%.2x, service_handle: %d 0x%.2x, char_uuid: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1574
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, conn_id: 0x%.2x]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1582
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, congested: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1589
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1596
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, service_handle: %d 0x%.2x, service_id: [%s]]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1605
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, remote_bda: %s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1636
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, trans_id: %d, bda: %s, exec_write_flag: 0x%.2x=%s]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1647
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, mtu: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1654
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, trans_id: %d, bda: %s, handle: 0x%.2x, is_long: %d, need_rsp:%d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1665
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, handle: 0x%.2x]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1672
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, app_id: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1685
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[status: %s, service_handle: 0x%.2x]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1705
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[conn_id: %d, trans_id: %d, bda: %s, handle: 0x%.2x, offset: %d, need_rsp: %d, is_prep: %d, len: %d]\","
                        ]
                    },
                    {
                        "line_numbers": [
                            1715
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"[Data: %s]\", pHex);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1721
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"dumpGattServerEvent: *** NOT CODED ***\");"
                        ]
                    },
                    {
                        "line_numbers": [
                            1747
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"Unknown esp_ble_evt_type_t: %d (0x%.2x)\", eventType, eventType);"
                        ]
                    },
                    {
                        "line_numbers": [
                            1818
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"gapEventToString: Unknown event type %d 0x%.2x\", eventType, eventType);"
                        ]
                    },
                    {
                        "line_numbers": [
                            2028
                        ],
                        "comments": [],
                        "lines": [
                            "\t\t\tESP_LOGV(LOG_TAG, \"Unknown event type: 0x%x\", searchEvt);"
                        ]
                    }
                ]
            },
            "comment_added_diff": {},
            "comment_deleted_diff": {
                "31": "static const char* LOG_TAG = \"BLEUtils\";  // Tag for logging."
            },
            "comment_modified_diff": {}
        }
    ],
    "BLEUtils.h": [],
    "BLEValue.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 139,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139
                        ],
                        "comments": [
                            "} // BLEValue",
                            "} // addPart",
                            "} // addPart",
                            "} // cancel",
                            "\t// If there is nothing to commit, do nothing.",
                            "} // commit",
                            "} // getLength",
                            "} // getReadOffset",
                            "} // getValue",
                            "} // setReadOffset",
                            "} // setValue",
                            "} // setValue",
                            "#endif // CONFIG_BT_ENABLED"
                        ],
                        "lines": [
                            "",
                            "",
                            "/**",
                            " * @brief Add a message part to the accumulation.",
                            " * The accumulation is a growing set of data that is added to until a commit or cancel.",
                            " * @param [in] part A message part being added.",
                            " */",
                            "void BLEValue::addPart(std::string part) {",
                            "\tESP_LOGD(LOG_TAG, \">> addPart: length=%d\", part.length());",
                            "\tm_accumulation += part;",
                            "",
                            "",
                            "/**",
                            " * @brief Add a message part to the accumulation.",
                            " * The accumulation is a growing set of data that is added to until a commit or cancel.",
                            " * @param [in] pData A message part being added.",
                            " * @param [in] length The number of bytes being added.",
                            " */",
                            "void BLEValue::addPart(uint8_t* pData, size_t length) {",
                            "\tESP_LOGD(LOG_TAG, \">> addPart: length=%d\", length);",
                            "\tm_accumulation += std::string((char*) pData, length);",
                            "",
                            "",
                            "/**",
                            " * @brief Cancel the current accumulation.",
                            " */",
                            "void BLEValue::cancel() {",
                            "\tESP_LOGD(LOG_TAG, \">> cancel\");",
                            "\tm_accumulation = \"\";",
                            "\tm_readOffset   = 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Commit the current accumulation.",
                            " * When writing a value, we may find that we write it in \"parts\" meaning that the writes come in in pieces",
                            " * of the overall message.  After the last part has been received, we may perform a commit which means that",
                            " * we now have the complete message and commit the change as a unit.",
                            " */",
                            "void BLEValue::commit() {",
                            "\tESP_LOGD(LOG_TAG, \">> commit\");",
                            "\tif (m_accumulation.length() == 0) return;",
                            "\tsetValue(m_accumulation);",
                            "\tm_accumulation = \"\";",
                            "\tm_readOffset   = 0;",
                            "",
                            "",
                            "/**",
                            " * @brief Get a pointer to the data.",
                            " * @return A pointer to the data.",
                            " */",
                            "uint8_t* BLEValue::getData() {",
                            "\treturn (uint8_t*) m_value.data();",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Get the length of the data in bytes.",
                            " * @return The length of the data in bytes.",
                            " */",
                            "size_t BLEValue::getLength() {",
                            "\treturn m_value.length();",
                            "",
                            "",
                            "/**",
                            " * @brief Get the read offset.",
                            " * @return The read offset into the read.",
                            " */",
                            "uint16_t BLEValue::getReadOffset() {",
                            "\treturn m_readOffset;",
                            "",
                            "",
                            "/**",
                            " * @brief Get the current value.",
                            " */",
                            "std::string BLEValue::getValue() {",
                            "\treturn m_value;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the read offset",
                            " * @param [in] readOffset The offset into the read.",
                            " */",
                            "void BLEValue::setReadOffset(uint16_t readOffset) {",
                            "\tm_readOffset = readOffset;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the current value.",
                            " */",
                            "void BLEValue::setValue(std::string value) {",
                            "\tm_value = value;",
                            "",
                            "",
                            "/**",
                            " * @brief Set the current value.",
                            " * @param [in] pData The data for the current value.",
                            " * @param [in] The length of the new current value.",
                            " */",
                            "void BLEValue::setValue(uint8_t* pData, size_t length) {",
                            "\tm_value = std::string((char*) pData, length);",
                            "",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "25": "} // BLEValue",
                "36": "} // addPart",
                "48": "} // addPart",
                "58": "} // cancel",
                "69": "\t// If there is nothing to commit, do nothing.",
                "74": "} // commit",
                "92": "} // getLength",
                "101": "} // getReadOffset",
                "109": "} // getValue",
                "118": "} // setReadOffset",
                "126": "} // setValue",
                "136": "} // setValue",
                "139": "#endif // CONFIG_BT_ENABLED"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "BLEValue.h": [],
    "FreeRTOS.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 274,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15,
                            16,
                            17,
                            18,
                            19,
                            20,
                            21,
                            22,
                            23,
                            24,
                            25,
                            26,
                            27,
                            28,
                            29,
                            30,
                            31,
                            32,
                            33,
                            34,
                            35,
                            36,
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274
                        ],
                        "comments": [
                            "#include <freertos/FreeRTOS.h>   // Include the base FreeRTOS definitions",
                            "#include <freertos/task.h>       // Include the task definitions",
                            "#include <freertos/semphr.h>     // Include the semaphore definitions",
                            "} // sleep",
                            "} // startTask",
                            "} // deleteTask",
                            "} // getTimeSinceStart",
                            "} // wait",
                            "\tm_usePthreads = false;   \t// Are we using pThreads or FreeRTOS?",
                            "// #ifdef ARDUINO_ARCH_ESP32",
                            "// \tFreeRTOS::sleep(10);",
                            "// #endif",
                            "} // Semaphore::give",
                            "} // give",
                            "} // giveFromISR",
                            "} // Semaphore::take",
                            "\t\tassert(false);  // We apparently don't have a timed wait for pthreads.",
                            "} // Semaphore::take",
                            "} // toString",
                            "} // setName",
                            "} // Ringbuffer",
                            "} // ~Ringbuffer",
                            "} // receive",
                            "} // returnItem",
                            "} // send"
                        ],
                        "lines": [
                            "#include <string>",
                            "#include <sstream>",
                            "#include <iomanip>",
                            "#include \"FreeRTOS.h\"",
                            "#include \"sdkconfig.h\"",
                            "#if defined(ARDUINO_ARCH_ESP32) && defined(CONFIG_ARDUHAL_ESP_LOG)",
                            "#include \"esp32-hal-log.h\"",
                            "#define LOG_TAG \"\"",
                            "#else",
                            "#include \"esp_log.h\"",
                            "static const char* LOG_TAG = \"FreeRTOS\";",
                            "#endif",
                            "",
                            "",
                            "/**",
                            " * Sleep for the specified number of milliseconds.",
                            " * @param[in] ms The period in milliseconds for which to sleep.",
                            " */",
                            "void FreeRTOS::sleep(uint32_t ms) {",
                            "\t::vTaskDelay(ms / portTICK_PERIOD_MS);",
                            "",
                            "",
                            "/**",
                            " * Start a new task.",
                            " * @param[in] task The function pointer to the function to be run in the task.",
                            " * @param[in] taskName A string identifier for the task.",
                            " * @param[in] param An optional parameter to be passed to the started task.",
                            " * @param[in] stackSize An optional paremeter supplying the size of the stack in which to run the task.",
                            " */",
                            "void FreeRTOS::startTask(void task(void*), std::string taskName, void* param, uint32_t stackSize) {",
                            "\t::xTaskCreate(task, taskName.data(), stackSize, param, 5, NULL);",
                            "",
                            "",
                            "/**",
                            " * Delete the task.",
                            " * @param[in] pTask An optional handle to the task to be deleted.  If not supplied the calling task will be deleted.",
                            " */",
                            "void FreeRTOS::deleteTask(TaskHandle_t pTask) {",
                            "\t::vTaskDelete(pTask);",
                            "",
                            "",
                            "/**",
                            " * Get the time in milliseconds since the %FreeRTOS scheduler started.",
                            " * @return The time in milliseconds since the %FreeRTOS scheduler started.",
                            " */",
                            "uint32_t FreeRTOS::getTimeSinceStart() {",
                            "\treturn (uint32_t) (xTaskGetTickCount() * portTICK_PERIOD_MS);",
                            "",
                            "",
                            "/**",
                            " * @brief Wait for a semaphore to be released by trying to take it and",
                            " * then releasing it again.",
                            " * @param [in] owner A debug tag.",
                            " * @return The value associated with the semaphore.",
                            " */",
                            "uint32_t FreeRTOS::Semaphore::wait(std::string owner) {",
                            "\tESP_LOGV(LOG_TAG, \">> wait: Semaphore waiting: %s for %s\", toString().c_str(), owner.c_str());",
                            "",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_lock(&m_pthread_mutex);",
                            "\t} else {",
                            "\t\txSemaphoreTake(m_semaphore, portMAX_DELAY);",
                            "\t}",
                            "",
                            "\tm_owner = owner;",
                            "",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_unlock(&m_pthread_mutex);",
                            "\t} else {",
                            "\t\txSemaphoreGive(m_semaphore);",
                            "\t}",
                            "",
                            "\tESP_LOGV(LOG_TAG, \"<< wait: Semaphore released: %s\", toString().c_str());",
                            "\tm_owner = std::string(\"<N/A>\");",
                            "\treturn m_value;",
                            "",
                            "",
                            "FreeRTOS::Semaphore::Semaphore(std::string name) {",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_init(&m_pthread_mutex, nullptr);",
                            "\t} else {",
                            "\t\tm_semaphore = xSemaphoreCreateMutex();",
                            "\t}",
                            "",
                            "\tm_name      = name;",
                            "\tm_owner     = std::string(\"<N/A>\");",
                            "\tm_value     = 0;",
                            "}",
                            "",
                            "",
                            "FreeRTOS::Semaphore::~Semaphore() {",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_destroy(&m_pthread_mutex);",
                            "\t} else {",
                            "\t\tvSemaphoreDelete(m_semaphore);",
                            "\t}",
                            "}",
                            "",
                            "",
                            "/**",
                            " * @brief Give a semaphore.",
                            " * The Semaphore is given.",
                            " */",
                            "void FreeRTOS::Semaphore::give() {",
                            "\tESP_LOGV(LOG_TAG, \"Semaphore giving: %s\", toString().c_str());",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_unlock(&m_pthread_mutex);",
                            "\t} else {",
                            "\t\txSemaphoreGive(m_semaphore);",
                            "\t}",
                            "",
                            "\tm_owner = std::string(\"<N/A>\");",
                            "",
                            "",
                            "/**",
                            " * @brief Give a semaphore.",
                            " * The Semaphore is given with an associated value.",
                            " * @param [in] value The value to associate with the semaphore.",
                            " */",
                            "void FreeRTOS::Semaphore::give(uint32_t value) {",
                            "\tm_value = value;",
                            "\tgive();",
                            "",
                            "",
                            "/**",
                            " * @brief Give a semaphore from an ISR.",
                            " */",
                            "void FreeRTOS::Semaphore::giveFromISR() {",
                            "\tBaseType_t higherPriorityTaskWoken;",
                            "\tif (m_usePthreads) {",
                            "\t\tassert(false);",
                            "\t} else {",
                            "\t\txSemaphoreGiveFromISR(m_semaphore, &higherPriorityTaskWoken);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Take a semaphore.",
                            " * Take a semaphore and wait indefinitely.",
                            " * @param [in] owner The new owner (for debugging)",
                            " * @return True if we took the semaphore.",
                            " */",
                            "bool FreeRTOS::Semaphore::take(std::string owner) {",
                            "\tESP_LOGD(LOG_TAG, \"Semaphore taking: %s for %s\", toString().c_str(), owner.c_str());",
                            "\tbool rc = false;",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_lock(&m_pthread_mutex);",
                            "\t} else {",
                            "\t\trc = ::xSemaphoreTake(m_semaphore, portMAX_DELAY) == pdTRUE;",
                            "\t}",
                            "\tm_owner = owner;",
                            "\tif (rc) {",
                            "\t\tESP_LOGD(LOG_TAG, \"Semaphore taken:  %s\", toString().c_str());",
                            "\t} else {",
                            "\t\tESP_LOGE(LOG_TAG, \"Semaphore NOT taken:  %s\", toString().c_str());",
                            "\t}",
                            "\treturn rc;",
                            "",
                            "",
                            "/**",
                            " * @brief Take a semaphore.",
                            " * Take a semaphore but return if we haven't obtained it in the given period of milliseconds.",
                            " * @param [in] timeoutMs Timeout in milliseconds.",
                            " * @param [in] owner The new owner (for debugging)",
                            " * @return True if we took the semaphore.",
                            " */",
                            "bool FreeRTOS::Semaphore::take(uint32_t timeoutMs, std::string owner) {",
                            "\tESP_LOGV(LOG_TAG, \"Semaphore taking: %s for %s\", toString().c_str(), owner.c_str());",
                            "\tbool rc = false;",
                            "\tif (m_usePthreads) {",
                            "\t} else {",
                            "\t\trc = ::xSemaphoreTake(m_semaphore, timeoutMs / portTICK_PERIOD_MS) == pdTRUE;",
                            "\t}",
                            "\tm_owner = owner;",
                            "\tif (rc) {",
                            "\t\tESP_LOGV(LOG_TAG, \"Semaphore taken:  %s\", toString().c_str());",
                            "\t} else {",
                            "\t\tESP_LOGE(LOG_TAG, \"Semaphore NOT taken:  %s\", toString().c_str());",
                            "\t}",
                            "\treturn rc;",
                            "",
                            "",
                            "",
                            "/**",
                            " * @brief Create a string representation of the semaphore.",
                            " * @return A string representation of the semaphore.",
                            " */",
                            "std::string FreeRTOS::Semaphore::toString() {",
                            "\tstd::stringstream stringStream;",
                            "\tstringStream << \"name: \"<< m_name << \" (0x\" << std::hex << std::setfill('0') << (uint32_t)m_semaphore << \"), owner: \" << m_owner;",
                            "\treturn stringStream.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Set the name of the semaphore.",
                            " * @param [in] name The name of the semaphore.",
                            " */",
                            "void FreeRTOS::Semaphore::setName(std::string name) {",
                            "\tm_name = name;",
                            "",
                            "",
                            "/**",
                            " * @brief Create a ring buffer.",
                            " * @param [in] length The amount of storage to allocate for the ring buffer.",
                            " * @param [in] type The type of buffer.  One of RINGBUF_TYPE_NOSPLIT, RINGBUF_TYPE_ALLOWSPLIT, RINGBUF_TYPE_BYTEBUF.",
                            " */",
                            "Ringbuffer::Ringbuffer(size_t length, ringbuf_type_t type) {",
                            "\tm_handle = ::xRingbufferCreate(length, type);",
                            "",
                            "",
                            "Ringbuffer::~Ringbuffer() {",
                            "\t::vRingbufferDelete(m_handle);",
                            "",
                            "",
                            "/**",
                            " * @brief Receive data from the buffer.",
                            " * @param [out] size On return, the size of data returned.",
                            " * @param [in] wait How long to wait.",
                            " * @return A pointer to the storage retrieved.",
                            " */",
                            "void* Ringbuffer::receive(size_t* size, TickType_t wait) {",
                            "\treturn ::xRingbufferReceive(m_handle, size, wait);",
                            "",
                            "",
                            "/**",
                            " * @brief Return an item.",
                            " * @param [in] item The item to be returned/released.",
                            " */",
                            "void Ringbuffer::returnItem(void* item) {",
                            "\t::vRingbufferReturnItem(m_handle, item);",
                            "",
                            "",
                            "/**",
                            " * @brief Send data to the buffer.",
                            " * @param [in] data The data to place into the buffer.",
                            " * @param [in] length The length of data to place into the buffer.",
                            " * @param [in] wait How long to wait before giving up.  The default is to wait indefinitely.",
                            " * @return",
                            " */",
                            "bool Ringbuffer::send(void* data, size_t length, TickType_t wait) {",
                            "\treturn ::xRingbufferSend(m_handle, data, length, wait) == pdTRUE;",
                            "",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "7": "#include <freertos/FreeRTOS.h>   // Include the base FreeRTOS definitions",
                "8": "#include <freertos/task.h>       // Include the task definitions",
                "9": "#include <freertos/semphr.h>     // Include the semaphore definitions",
                "30": "} // sleep",
                "42": "} // startTask",
                "51": "} // deleteTask",
                "60": "} // getTimeSinceStart",
                "89": "} // wait",
                "93": "\tm_usePthreads = false;   \t// Are we using pThreads or FreeRTOS?",
                "126": "// #ifdef ARDUINO_ARCH_ESP32",
                "127": "// \tFreeRTOS::sleep(10);",
                "128": "// #endif",
                "131": "} // Semaphore::give",
                "142": "} // give",
                "155": "} // giveFromISR",
                "179": "} // Semaphore::take",
                "193": "\t\tassert(false);  // We apparently don't have a timed wait for pthreads.",
                "204": "} // Semaphore::take",
                "216": "} // toString",
                "225": "} // setName",
                "235": "} // Ringbuffer",
                "240": "} // ~Ringbuffer",
                "251": "} // receive",
                "260": "} // returnItem",
                "272": "} // send"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        },
        {
            "commit": "5137fc5c80e8cd1d9f07879d0bc1ecf5a52e8ce4",
            "timestamp": "2019-08-20T17:15:30+03:00",
            "author": "Roman Savrulin",
            "commit_message": "Ble notification/indication status and timeout (#2998)\n\n* add timed wait\r\n\r\n* Added Notification/Indication data and status callbacks\r\n\r\n* imply null-object pattern for BLE callback",
            "additions": 32,
            "deletions": 0,
            "change_type": "MODIFY",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112
                        ],
                        "comments": [
                            "\t\tassert(false);  // We apparently don't have a timed wait for pthreads.",
                            "} // wait"
                        ],
                        "lines": [
                            "\t}",
                            "",
                            "\tauto ret = pdTRUE;",
                            "",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_lock(&m_pthread_mutex);",
                            "\t} else {",
                            "\t\tret = xSemaphoreTake(m_semaphore, timeoutMs);",
                            "\t}",
                            "",
                            "\tif (m_usePthreads) {",
                            "\t\tpthread_mutex_unlock(&m_pthread_mutex);",
                            "\t} else {",
                            "\t\txSemaphoreGive(m_semaphore);",
                            "\t}",
                            "",
                            "\tlog_v(\"<< wait: Semaphore %s released: %d\", toString().c_str(), ret);",
                            "\treturn ret;",
                            ""
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "92": "\t\tassert(false);  // We apparently don't have a timed wait for pthreads.",
                "111": "} // wait"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "GeneralUtils.cpp": [
        {
            "commit": "7b5cd47d07353747aa4b92bb9ac212d18371da20",
            "timestamp": "2019-04-12T15:43:53+02:00",
            "author": "Me No Dev",
            "commit_message": "Set ESP-IDF to 3.2 (#2662)\n\n* Set IDF to v3.2\r\n\r\n* Remove BLE submodule\r\n\r\n* Add BLE lib source\r\n\r\n* Update Camera example to support OV3660",
            "additions": 544,
            "deletions": 0,
            "change_type": "ADD",
            "diff": {
                "added": [
                    {
                        "line_numbers": [
                            37,
                            38,
                            39,
                            40,
                            41,
                            42,
                            43,
                            44,
                            45,
                            46,
                            47,
                            48,
                            49,
                            50,
                            51,
                            52,
                            53,
                            54,
                            55,
                            56,
                            57,
                            58,
                            59,
                            60,
                            61,
                            62,
                            63,
                            64,
                            65,
                            66,
                            67,
                            68,
                            69,
                            70,
                            71,
                            72,
                            73,
                            74,
                            75,
                            76,
                            77,
                            78,
                            79,
                            80,
                            81,
                            82,
                            83,
                            84,
                            85,
                            86,
                            87,
                            88,
                            89,
                            90,
                            91,
                            92,
                            93,
                            94,
                            95,
                            96,
                            97,
                            98,
                            99,
                            100,
                            101,
                            102,
                            103,
                            104,
                            105,
                            106,
                            107,
                            108,
                            109,
                            110,
                            111,
                            112,
                            113,
                            114,
                            115,
                            116,
                            117,
                            118,
                            119,
                            120,
                            121,
                            122,
                            123,
                            124,
                            125,
                            126,
                            127,
                            128,
                            129,
                            130,
                            131,
                            132,
                            133,
                            134,
                            135,
                            136,
                            137,
                            138,
                            139,
                            140,
                            141,
                            142,
                            143,
                            144,
                            145,
                            146,
                            147,
                            148,
                            149,
                            150,
                            151,
                            152,
                            153,
                            154,
                            155,
                            156,
                            157,
                            158,
                            159,
                            160,
                            161,
                            162,
                            163,
                            164,
                            165,
                            166,
                            167,
                            168,
                            169,
                            170,
                            171,
                            172,
                            173,
                            174,
                            175,
                            176,
                            177,
                            178,
                            179,
                            180,
                            181,
                            182,
                            183,
                            184,
                            185,
                            186,
                            187,
                            188,
                            189,
                            190,
                            191,
                            192,
                            193,
                            194,
                            195,
                            196,
                            197,
                            198,
                            199,
                            200,
                            201,
                            202,
                            203,
                            204,
                            205,
                            206,
                            207,
                            208,
                            209,
                            210,
                            211,
                            212,
                            213,
                            214,
                            215,
                            216,
                            217,
                            218,
                            219,
                            220,
                            221,
                            222,
                            223,
                            224,
                            225,
                            226,
                            227,
                            228,
                            229,
                            230,
                            231,
                            232,
                            233,
                            234,
                            235,
                            236,
                            237,
                            238,
                            239,
                            240,
                            241,
                            242,
                            243,
                            244,
                            245,
                            246,
                            247,
                            248,
                            249,
                            250,
                            251,
                            252,
                            253,
                            254,
                            255,
                            256,
                            257,
                            258,
                            259,
                            260,
                            261,
                            262,
                            263,
                            264,
                            265,
                            266,
                            267,
                            268,
                            269,
                            270,
                            271,
                            272,
                            273,
                            274,
                            275,
                            276,
                            277,
                            278,
                            279,
                            280,
                            281,
                            282,
                            283,
                            284,
                            285,
                            286,
                            287,
                            288,
                            289,
                            290,
                            291,
                            292,
                            293,
                            294,
                            295,
                            296,
                            297,
                            298,
                            299,
                            300,
                            301,
                            302,
                            303,
                            304,
                            305,
                            306,
                            307,
                            308,
                            309,
                            310,
                            311,
                            312,
                            313,
                            314,
                            315,
                            316,
                            317,
                            318,
                            319,
                            320,
                            321,
                            322,
                            323,
                            324,
                            325,
                            326,
                            327,
                            328,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            339,
                            340,
                            341,
                            342,
                            343,
                            344,
                            345,
                            346,
                            347,
                            348,
                            349,
                            350,
                            351,
                            352,
                            353,
                            354,
                            355,
                            356,
                            357,
                            358,
                            359,
                            360,
                            361,
                            362,
                            363,
                            364,
                            365,
                            366,
                            367,
                            368,
                            369,
                            370,
                            371,
                            372,
                            373,
                            374,
                            375,
                            376,
                            377,
                            378,
                            379,
                            380,
                            381,
                            382,
                            383,
                            384,
                            385,
                            386,
                            387,
                            388,
                            389,
                            390,
                            391,
                            392,
                            393,
                            394,
                            395,
                            396,
                            397,
                            398,
                            399,
                            400,
                            401,
                            402,
                            403,
                            404,
                            405,
                            406,
                            407,
                            408,
                            409,
                            410,
                            411,
                            412,
                            413,
                            414,
                            415,
                            416,
                            417,
                            418,
                            419,
                            420,
                            421,
                            422,
                            423,
                            424,
                            425,
                            426,
                            427,
                            428,
                            429,
                            430,
                            431,
                            432,
                            433,
                            434,
                            435,
                            436,
                            437,
                            438,
                            439,
                            440,
                            441,
                            442,
                            443,
                            444,
                            445,
                            446,
                            447,
                            448,
                            449,
                            450,
                            451,
                            452,
                            453,
                            454,
                            455,
                            456,
                            457,
                            458,
                            459,
                            460,
                            461,
                            462,
                            463,
                            464,
                            465,
                            466,
                            467,
                            468,
                            469,
                            470,
                            471,
                            472,
                            473,
                            474,
                            475,
                            476,
                            477,
                            478,
                            479,
                            480,
                            481,
                            482,
                            483,
                            484,
                            485,
                            486,
                            487,
                            488,
                            489,
                            490,
                            491,
                            492,
                            493,
                            494,
                            495,
                            496,
                            497,
                            498,
                            499,
                            500,
                            501,
                            502,
                            503,
                            504,
                            505,
                            506,
                            507,
                            508,
                            509,
                            510,
                            511,
                            512,
                            513,
                            514,
                            515,
                            516,
                            517,
                            518,
                            519,
                            520,
                            521,
                            522,
                            523,
                            524,
                            525,
                            526,
                            527,
                            528,
                            529,
                            530,
                            531,
                            532,
                            533,
                            534,
                            535,
                            536,
                            537,
                            538,
                            539,
                            540,
                            541,
                            542,
                            543,
                            544
                        ],
                        "comments": [
                            "} // base64EncodedLength",
                            "} // base64EncodedLength",
                            "} // a3_to_a4",
                            "} // a4_to_a3",
                            "} // base64Encode",
                            "} // dumpInfo",
                            "} // endsWidth",
                            "} // DecodedLength",
                            "}; // b64_lookup",
                            " } // base64Decode",
                            "} // hexDump",
                            "} // ipToString",
                            "\t// See also: https://stackoverflow.com/questions/5167625/splitting-a-c-stdstring-using-tokens-e-g",
                            "} // split",
                            "} // errorToString",
                            "} // wifiErrorToString",
                            "\t// Question: Could this be improved with a signature of:",
                            "\t// std::string& GeneralUtils::toLower(std::string& value)",
                            "} // toLower",
                            "} // trim"
                        ],
                        "lines": [
                            "",
                            "",
                            "static int base64EncodedLength(const std::string& in) {",
                            "\treturn base64EncodedLength(in.length());",
                            "",
                            "",
                            "static void a3_to_a4(unsigned char* a4, unsigned char* a3) {",
                            "\ta4[0] = (a3[0] & 0xfc) >> 2;",
                            "\ta4[1] = ((a3[0] & 0x03) << 4) + ((a3[1] & 0xf0) >> 4);",
                            "\ta4[2] = ((a3[1] & 0x0f) << 2) + ((a3[2] & 0xc0) >> 6);",
                            "\ta4[3] = (a3[2] & 0x3f);",
                            "",
                            "",
                            "static void a4_to_a3(unsigned char* a3, unsigned char* a4) {",
                            "\ta3[0] = (a4[0] << 2) + ((a4[1] & 0x30) >> 4);",
                            "\ta3[1] = ((a4[1] & 0xf) << 4) + ((a4[2] & 0x3c) >> 2);",
                            "\ta3[2] = ((a4[2] & 0x3) << 6) + a4[3];",
                            "",
                            "",
                            "/**",
                            " * @brief Encode a string into base 64.",
                            " * @param [in] in",
                            " * @param [out] out",
                            " */",
                            "bool GeneralUtils::base64Encode(const std::string& in, std::string* out) {",
                            "\tint i = 0, j = 0;",
                            "\tsize_t enc_len = 0;",
                            "\tunsigned char a3[3];",
                            "\tunsigned char a4[4];",
                            "",
                            "\tout->resize(base64EncodedLength(in));",
                            "",
                            "\tint input_len = in.size();",
                            "\tstd::string::const_iterator input = in.begin();",
                            "",
                            "\twhile (input_len--) {",
                            "\t\ta3[i++] = *(input++);",
                            "\t\tif (i == 3) {",
                            "\t\t\ta3_to_a4(a4, a3);",
                            "",
                            "\t\t\tfor (i = 0; i < 4; i++) {",
                            "\t\t\t\t(*out)[enc_len++] = kBase64Alphabet[a4[i]];",
                            "\t\t\t}",
                            "",
                            "\t\t\ti = 0;",
                            "\t\t}",
                            "\t}",
                            "",
                            "\tif (i) {",
                            "\t\tfor (j = i; j < 3; j++) {",
                            "\t\t\ta3[j] = '\\0';",
                            "\t\t}",
                            "",
                            "\t\ta3_to_a4(a4, a3);",
                            "",
                            "\t\tfor (j = 0; j < i + 1; j++) {",
                            "\t\t\t(*out)[enc_len++] = kBase64Alphabet[a4[j]];",
                            "\t\t}",
                            "",
                            "\t\twhile ((i++ < 3)) {",
                            "\t\t\t(*out)[enc_len++] = '=';",
                            "\t\t}",
                            "\t}",
                            "",
                            "\treturn (enc_len == out->size());",
                            "",
                            "",
                            "/**",
                            " * @brief Dump general info to the log.",
                            " * Data includes:",
                            " * * Amount of free RAM",
                            " */",
                            "void GeneralUtils::dumpInfo() {",
                            "\tsize_t freeHeap = heap_caps_get_free_size(MALLOC_CAP_8BIT);",
                            "\tesp_chip_info_t chipInfo;",
                            "\tesp_chip_info(&chipInfo);",
                            "\tESP_LOGV(LOG_TAG, \"--- dumpInfo ---\");",
                            "\tESP_LOGV(LOG_TAG, \"Free heap: %d\", freeHeap);",
                            "\tESP_LOGV(LOG_TAG, \"Chip Info: Model: %d, cores: %d, revision: %d\", chipInfo.model, chipInfo.cores, chipInfo.revision);",
                            "\tESP_LOGV(LOG_TAG, \"ESP-IDF version: %s\", esp_get_idf_version());",
                            "\tESP_LOGV(LOG_TAG, \"---\");",
                            "",
                            "",
                            "/**",
                            " * @brief Does the string end with a specific character?",
                            " * @param [in] str The string to examine.",
                            " * @param [in] c The character to look form.",
                            " * @return True if the string ends with the given character.",
                            " */",
                            "bool GeneralUtils::endsWith(std::string str, char c) {",
                            "\tif (str.empty()) {",
                            "\t\treturn false;",
                            "\t}",
                            "\tif (str.at(str.length() - 1) == c) {",
                            "\t\treturn true;",
                            "\t}",
                            "\treturn false;",
                            "",
                            "",
                            "static int DecodedLength(const std::string& in) {",
                            "\tint numEq = 0;",
                            "\tint n = (int) in.size();",
                            "",
                            "\tfor (std::string::const_reverse_iterator it = in.rbegin(); *it == '='; ++it) {",
                            "\t\t++numEq;",
                            "\t}",
                            "\treturn ((6 * n) / 8) - numEq;",
                            "",
                            "",
                            "static unsigned char b64_lookup(unsigned char c) {",
                            "\tif(c >='A' && c <='Z') return c - 'A';",
                            "\tif(c >='a' && c <='z') return c - 71;",
                            "\tif(c >='0' && c <='9') return c + 4;",
                            "\tif(c == '+') return 62;",
                            "\tif(c == '/') return 63;",
                            "\treturn 255;",
                            "",
                            "",
                            "/**",
                            " * @brief Decode a chunk of data that is base64 encoded.",
                            " * @param [in] in The string to be decoded.",
                            " * @param [out] out The resulting data.",
                            " */",
                            "bool GeneralUtils::base64Decode(const std::string& in, std::string* out) {",
                            "\tint i = 0, j = 0;",
                            "\tsize_t dec_len = 0;",
                            "\tunsigned char a3[3];",
                            "\tunsigned char a4[4];",
                            "",
                            "\tint input_len = in.size();",
                            "\tstd::string::const_iterator input = in.begin();",
                            "",
                            "\tout->resize(DecodedLength(in));",
                            "",
                            "\twhile (input_len--) {",
                            "\t\tif (*input == '=') {",
                            "\t\t\tbreak;",
                            "\t\t}",
                            "",
                            "\t\ta4[i++] = *(input++);",
                            "\t\tif (i == 4) {",
                            "\t\t\tfor (i = 0; i <4; i++) {",
                            "\t\t\t\ta4[i] = b64_lookup(a4[i]);",
                            "\t\t\t}",
                            "",
                            "\t\t\ta4_to_a3(a3,a4);",
                            "",
                            "\t\t\tfor (i = 0; i < 3; i++) {",
                            "\t\t\t\t(*out)[dec_len++] = a3[i];",
                            "\t\t\t}",
                            "",
                            "\t\t\ti = 0;",
                            "\t\t}",
                            "\t}",
                            "",
                            "\tif (i) {",
                            "\t\tfor (j = i; j < 4; j++) {",
                            "\t\t\ta4[j] = '\\0';",
                            "\t\t}",
                            "",
                            "\t\tfor (j = 0; j < 4; j++) {",
                            "\t\t\ta4[j] = b64_lookup(a4[j]);",
                            "\t\t}",
                            "",
                            "\t\ta4_to_a3(a3,a4);",
                            "",
                            "\t\tfor (j = 0; j < i - 1; j++) {",
                            "\t\t\t(*out)[dec_len++] = a3[j];",
                            "\t\t}",
                            "\t}",
                            "",
                            "\treturn (dec_len == out->size());",
                            "",
                            "/*",
                            "void GeneralUtils::hexDump(uint8_t* pData, uint32_t length) {",
                            "\tuint32_t index=0;",
                            "\tstd::stringstream ascii;",
                            "\tstd::stringstream hex;",
                            "\tchar asciiBuf[80];",
                            "\tchar hexBuf[80];",
                            "\thex.str(\"\");",
                            "\tascii.str(\"\");",
                            "\twhile(index < length) {",
                            "\t\thex << std::setfill('0') << std::setw(2) << std::hex << (int)pData[index] << ' ';",
                            "\t\tif (std::isprint(pData[index])) {",
                            "\t\t\tascii << pData[index];",
                            "\t\t} else {",
                            "\t\t\tascii << '.';",
                            "\t\t}",
                            "\t\tindex++;",
                            "\t\tif (index % 16 == 0) {",
                            "\t\t\tstrcpy(hexBuf, hex.str().c_str());",
                            "\t\t\tstrcpy(asciiBuf, ascii.str().c_str());",
                            "\t\t\tESP_LOGV(tag, \"%s %s\", hexBuf, asciiBuf);",
                            "\t\t\thex.str(\"\");",
                            "\t\t\tascii.str(\"\");",
                            "\t\t}",
                            "\t}",
                            "\tif (index %16 != 0) {",
                            "\t\twhile(index % 16 != 0) {",
                            "\t\t\thex << \"   \";",
                            "\t\t\tindex++;",
                            "\t\t}",
                            "\t\tstrcpy(hexBuf, hex.str().c_str());",
                            "\t\tstrcpy(asciiBuf, ascii.str().c_str());",
                            "\t\tESP_LOGV(tag, \"%s %s\", hexBuf, asciiBuf);",
                            "\t\t//ESP_LOGV(tag, \"%s %s\", hex.str().c_str(), ascii.str().c_str());",
                            "\t}",
                            "\tFreeRTOS::sleep(1000);",
                            "}",
                            "*/",
                            "",
                            "/*",
                            "void GeneralUtils::hexDump(uint8_t* pData, uint32_t length) {",
                            "\tuint32_t index=0;",
                            "\tstatic std::stringstream ascii;",
                            "\tstatic std::stringstream hex;",
                            "\thex.str(\"\");",
                            "\tascii.str(\"\");",
                            "\twhile(index < length) {",
                            "\t\thex << std::setfill('0') << std::setw(2) << std::hex << (int)pData[index] << ' ';",
                            "\t\tif (std::isprint(pData[index])) {",
                            "\t\t\tascii << pData[index];",
                            "\t\t} else {",
                            "\t\t\tascii << '.';",
                            "\t\t}",
                            "\t\tindex++;",
                            "\t\tif (index % 16 == 0) {",
                            "\t\t\tESP_LOGV(tag, \"%s %s\", hex.str().c_str(), ascii.str().c_str());",
                            "\t\t\thex.str(\"\");",
                            "\t\t\tascii.str(\"\");",
                            "\t\t}",
                            "\t}",
                            "\tif (index %16 != 0) {",
                            "\t\twhile(index % 16 != 0) {",
                            "\t\t\thex << \"   \";",
                            "\t\t\tindex++;",
                            "\t\t}",
                            "\t\tESP_LOGV(tag, \"%s %s\", hex.str().c_str(), ascii.str().c_str());",
                            "\t}",
                            "\tFreeRTOS::sleep(1000);",
                            "}",
                            "*/",
                            "",
                            "",
                            "/**",
                            " * @brief Dump a representation of binary data to the console.",
                            " *",
                            " * @param [in] pData Pointer to the start of data to be logged.",
                            " * @param [in] length Length of the data (in bytes) to be logged.",
                            " * @return N/A.",
                            " */",
                            "void GeneralUtils::hexDump(const uint8_t* pData, uint32_t length) {",
                            "\tchar ascii[80];",
                            "\tchar hex[80];",
                            "\tchar tempBuf[80];",
                            "\tuint32_t lineNumber = 0;",
                            "",
                            "\tESP_LOGV(LOG_TAG, \"     00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\");",
                            "\tESP_LOGV(LOG_TAG, \"     -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\");",
                            "\tstrcpy(ascii, \"\");",
                            "\tstrcpy(hex, \"\");",
                            "\tuint32_t index = 0;",
                            "\twhile (index < length) {",
                            "\t\tsprintf(tempBuf, \"%.2x \", pData[index]);",
                            "\t\tstrcat(hex, tempBuf);",
                            "\t\tif (isprint(pData[index])) {",
                            "\t\t\tsprintf(tempBuf, \"%c\", pData[index]);",
                            "\t\t} else {",
                            "\t\t\tsprintf(tempBuf, \".\");",
                            "\t\t}",
                            "\t\tstrcat(ascii, tempBuf);",
                            "\t\tindex++;",
                            "\t\tif (index % 16 == 0) {",
                            "\t\t\tESP_LOGV(LOG_TAG, \"%.4x %s %s\", lineNumber * 16, hex, ascii);",
                            "\t\t\tstrcpy(ascii, \"\");",
                            "\t\t\tstrcpy(hex, \"\");",
                            "\t\t\tlineNumber++;",
                            "\t\t}",
                            "\t}",
                            "\tif (index %16 != 0) {",
                            "\t\twhile (index % 16 != 0) {",
                            "\t\t\tstrcat(hex, \"   \");",
                            "\t\t\tindex++;",
                            "\t\t}",
                            "\t\tESP_LOGV(LOG_TAG, \"%.4x %s %s\", lineNumber * 16, hex, ascii);",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Convert an IP address to string.",
                            " * @param ip The 4 byte IP address.",
                            " * @return A string representation of the IP address.",
                            " */",
                            "std::string GeneralUtils::ipToString(uint8_t *ip) {",
                            "\tstd::stringstream s;",
                            "\ts << (int) ip[0] << '.' << (int) ip[1] << '.' << (int) ip[2] << '.' << (int) ip[3];",
                            "\treturn s.str();",
                            "",
                            "",
                            "/**",
                            " * @brief Split a string into parts based on a delimiter.",
                            " * @param [in] source The source string to split.",
                            " * @param [in] delimiter The delimiter characters.",
                            " * @return A vector of strings that are the split of the input.",
                            " */",
                            "std::vector<std::string> GeneralUtils::split(std::string source, char delimiter) {",
                            "\tstd::vector<std::string> strings;",
                            "\tstd::istringstream iss(source);",
                            "\tstd::string s;",
                            "\twhile (std::getline(iss, s, delimiter)) {",
                            "\t\tstrings.push_back(trim(s));",
                            "\t}",
                            "\treturn strings;",
                            "",
                            "",
                            "/**",
                            " * @brief Convert an ESP error code to a string.",
                            " * @param [in] errCode The errCode to be converted.",
                            " * @return A string representation of the error code.",
                            " */",
                            "const char* GeneralUtils::errorToString(esp_err_t errCode) {",
                            "\tswitch (errCode) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase ESP_OK:",
                            "\t\t\treturn \"ESP_OK\";",
                            "\t\tcase ESP_FAIL:",
                            "\t\t\treturn \"ESP_FAIL\";",
                            "\t\tcase ESP_ERR_NO_MEM:",
                            "\t\t\treturn \"ESP_ERR_NO_MEM\";",
                            "\t\tcase ESP_ERR_INVALID_ARG:",
                            "\t\t\treturn \"ESP_ERR_INVALID_ARG\";",
                            "\t\tcase ESP_ERR_INVALID_SIZE:",
                            "\t\t\treturn \"ESP_ERR_INVALID_SIZE\";",
                            "\t\tcase ESP_ERR_INVALID_STATE:",
                            "\t\t\treturn \"ESP_ERR_INVALID_STATE\";",
                            "\t\tcase ESP_ERR_NOT_FOUND:",
                            "\t\t\treturn \"ESP_ERR_NOT_FOUND\";",
                            "\t\tcase ESP_ERR_NOT_SUPPORTED:",
                            "\t\t\treturn \"ESP_ERR_NOT_SUPPORTED\";",
                            "\t\tcase ESP_ERR_TIMEOUT:",
                            "\t\t\treturn \"ESP_ERR_TIMEOUT\";",
                            "\t\tcase ESP_ERR_NVS_NOT_INITIALIZED:",
                            "\t\t\treturn \"ESP_ERR_NVS_NOT_INITIALIZED\";",
                            "\t\tcase ESP_ERR_NVS_NOT_FOUND:",
                            "\t\t\treturn \"ESP_ERR_NVS_NOT_FOUND\";",
                            "\t\tcase ESP_ERR_NVS_TYPE_MISMATCH:",
                            "\t\t\treturn \"ESP_ERR_NVS_TYPE_MISMATCH\";",
                            "\t\tcase ESP_ERR_NVS_READ_ONLY:",
                            "\t\t\treturn \"ESP_ERR_NVS_READ_ONLY\";",
                            "\t\tcase ESP_ERR_NVS_NOT_ENOUGH_SPACE:",
                            "\t\t\treturn \"ESP_ERR_NVS_NOT_ENOUGH_SPACE\";",
                            "\t\tcase ESP_ERR_NVS_INVALID_NAME:",
                            "\t\t\treturn \"ESP_ERR_NVS_INVALID_NAME\";",
                            "\t\tcase ESP_ERR_NVS_INVALID_HANDLE:",
                            "\t\t\treturn \"ESP_ERR_NVS_INVALID_HANDLE\";",
                            "\t\tcase ESP_ERR_NVS_REMOVE_FAILED:",
                            "\t\t\treturn \"ESP_ERR_NVS_REMOVE_FAILED\";",
                            "\t\tcase ESP_ERR_NVS_KEY_TOO_LONG:",
                            "\t\t\treturn \"ESP_ERR_NVS_KEY_TOO_LONG\";",
                            "\t\tcase ESP_ERR_NVS_PAGE_FULL:",
                            "\t\t\treturn \"ESP_ERR_NVS_PAGE_FULL\";",
                            "\t\tcase ESP_ERR_NVS_INVALID_STATE:",
                            "\t\t\treturn \"ESP_ERR_NVS_INVALID_STATE\";",
                            "\t\tcase ESP_ERR_NVS_INVALID_LENGTH:",
                            "\t\t\treturn \"ESP_ERR_NVS_INVALID_LENGTH\";",
                            "\t\tcase ESP_ERR_WIFI_NOT_INIT:",
                            "\t\t\treturn \"ESP_ERR_WIFI_NOT_INIT\";",
                            "\t\t//case ESP_ERR_WIFI_NOT_START:",
                            "\t\t//\treturn \"ESP_ERR_WIFI_NOT_START\";",
                            "\t\tcase ESP_ERR_WIFI_IF:",
                            "\t\t\treturn \"ESP_ERR_WIFI_IF\";",
                            "\t\tcase ESP_ERR_WIFI_MODE:",
                            "\t\t\treturn \"ESP_ERR_WIFI_MODE\";",
                            "\t\tcase ESP_ERR_WIFI_STATE:",
                            "\t\t\treturn \"ESP_ERR_WIFI_STATE\";",
                            "\t\tcase ESP_ERR_WIFI_CONN:",
                            "\t\t\treturn \"ESP_ERR_WIFI_CONN\";",
                            "\t\tcase ESP_ERR_WIFI_NVS:",
                            "\t\t\treturn \"ESP_ERR_WIFI_NVS\";",
                            "\t\tcase ESP_ERR_WIFI_MAC:",
                            "\t\t\treturn \"ESP_ERR_WIFI_MAC\";",
                            "\t\tcase ESP_ERR_WIFI_SSID:",
                            "\t\t\treturn \"ESP_ERR_WIFI_SSID\";",
                            "\t\tcase ESP_ERR_WIFI_PASSWORD:",
                            "\t\t\treturn \"ESP_ERR_WIFI_PASSWORD\";",
                            "\t\tcase ESP_ERR_WIFI_TIMEOUT:",
                            "\t\t\treturn \"ESP_ERR_WIFI_TIMEOUT\";",
                            "\t\tcase ESP_ERR_WIFI_WAKE_FAIL:",
                            "\t\t\treturn \"ESP_ERR_WIFI_WAKE_FAIL\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\treturn \"Unknown ESP_ERR error\";",
                            "\t\t}",
                            "",
                            "/**",
                            " * @brief Convert a wifi_err_reason_t code to a string.",
                            " * @param [in] errCode The errCode to be converted.",
                            " * @return A string representation of the error code.",
                            " *",
                            " * @note: wifi_err_reason_t values as of April 2018 are: (1-24, 200-204) and are defined in ~/esp-idf/components/esp32/include/esp_wifi_types.h.",
                            " */",
                            "const char* GeneralUtils::wifiErrorToString(uint8_t errCode) {",
                            "\tif (errCode == ESP_OK) return \"ESP_OK (received SYSTEM_EVENT_STA_GOT_IP event)\";",
                            "\tif (errCode == UINT8_MAX) return \"Not Connected (default value)\";",
                            "",
                            "\tswitch ((wifi_err_reason_t) errCode) {",
                            "#if CONFIG_LOG_DEFAULT_LEVEL > 4",
                            "\t\tcase WIFI_REASON_UNSPECIFIED:",
                            "\t\t\treturn \"WIFI_REASON_UNSPECIFIED\";",
                            "\t\tcase WIFI_REASON_AUTH_EXPIRE:",
                            "\t\t\treturn \"WIFI_REASON_AUTH_EXPIRE\";",
                            "\t\tcase WIFI_REASON_AUTH_LEAVE:",
                            "\t\t\treturn \"WIFI_REASON_AUTH_LEAVE\";",
                            "\t\tcase WIFI_REASON_ASSOC_EXPIRE:",
                            "\t\t\treturn \"WIFI_REASON_ASSOC_EXPIRE\";",
                            "\t\tcase WIFI_REASON_ASSOC_TOOMANY:",
                            "\t\t\treturn \"WIFI_REASON_ASSOC_TOOMANY\";",
                            "\t\tcase WIFI_REASON_NOT_AUTHED:",
                            "\t\t\treturn \"WIFI_REASON_NOT_AUTHED\";",
                            "\t\tcase WIFI_REASON_NOT_ASSOCED:",
                            "\t\t\treturn \"WIFI_REASON_NOT_ASSOCED\";",
                            "\t\tcase WIFI_REASON_ASSOC_LEAVE:",
                            "\t\t\treturn \"WIFI_REASON_ASSOC_LEAVE\";",
                            "\t\tcase WIFI_REASON_ASSOC_NOT_AUTHED:",
                            "\t\t\treturn \"WIFI_REASON_ASSOC_NOT_AUTHED\";",
                            "\t\tcase WIFI_REASON_DISASSOC_PWRCAP_BAD:",
                            "\t\t\treturn \"WIFI_REASON_DISASSOC_PWRCAP_BAD\";",
                            "\t\tcase WIFI_REASON_DISASSOC_SUPCHAN_BAD:",
                            "\t\t\treturn \"WIFI_REASON_DISASSOC_SUPCHAN_BAD\";",
                            "\t\tcase WIFI_REASON_IE_INVALID:",
                            "\t\t\treturn \"WIFI_REASON_IE_INVALID\";",
                            "\t\tcase WIFI_REASON_MIC_FAILURE:",
                            "\t\t\treturn \"WIFI_REASON_MIC_FAILURE\";",
                            "\t\tcase WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT:",
                            "\t\t\treturn \"WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT\";",
                            "\t\tcase WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT:",
                            "\t\t\treturn \"WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT\";",
                            "\t\tcase WIFI_REASON_IE_IN_4WAY_DIFFERS:",
                            "\t\t\treturn \"WIFI_REASON_IE_IN_4WAY_DIFFERS\";",
                            "\t\tcase WIFI_REASON_GROUP_CIPHER_INVALID:",
                            "\t\t\treturn \"WIFI_REASON_GROUP_CIPHER_INVALID\";",
                            "\t\tcase WIFI_REASON_PAIRWISE_CIPHER_INVALID:",
                            "\t\t\treturn \"WIFI_REASON_PAIRWISE_CIPHER_INVALID\";",
                            "\t\tcase WIFI_REASON_AKMP_INVALID:",
                            "\t\t\treturn \"WIFI_REASON_AKMP_INVALID\";",
                            "\t\tcase WIFI_REASON_UNSUPP_RSN_IE_VERSION:",
                            "\t\t\treturn \"WIFI_REASON_UNSUPP_RSN_IE_VERSION\";",
                            "\t\tcase WIFI_REASON_INVALID_RSN_IE_CAP:",
                            "\t\t\treturn \"WIFI_REASON_INVALID_RSN_IE_CAP\";",
                            "\t\tcase WIFI_REASON_802_1X_AUTH_FAILED:",
                            "\t\t\treturn \"WIFI_REASON_802_1X_AUTH_FAILED\";",
                            "\t\tcase WIFI_REASON_CIPHER_SUITE_REJECTED:",
                            "\t\t\treturn \"WIFI_REASON_CIPHER_SUITE_REJECTED\";",
                            "\t\tcase WIFI_REASON_BEACON_TIMEOUT:",
                            "\t\t\treturn \"WIFI_REASON_BEACON_TIMEOUT\";",
                            "\t\tcase WIFI_REASON_NO_AP_FOUND:",
                            "\t\t\treturn \"WIFI_REASON_NO_AP_FOUND\";",
                            "\t\tcase WIFI_REASON_AUTH_FAIL:",
                            "\t\t\treturn \"WIFI_REASON_AUTH_FAIL\";",
                            "\t\tcase WIFI_REASON_ASSOC_FAIL:",
                            "\t\t\treturn \"WIFI_REASON_ASSOC_FAIL\";",
                            "\t\tcase WIFI_REASON_HANDSHAKE_TIMEOUT:",
                            "\t\t\treturn \"WIFI_REASON_HANDSHAKE_TIMEOUT\";",
                            "#endif",
                            "\t\tdefault:",
                            "\t\t\treturn \"Unknown ESP_ERR error\";",
                            "\t}",
                            "",
                            "",
                            "/**",
                            " * @brief Convert a string to lower case.",
                            " * @param [in] value The string to convert to lower case.",
                            " * @return A lower case representation of the string.",
                            " */",
                            "std::string GeneralUtils::toLower(std::string& value) {",
                            "\tstd::transform(value.begin(), value.end(), value.begin(), ::tolower);",
                            "\treturn value;",
                            "",
                            "",
                            "/**",
                            " * @brief Remove white space from a string.",
                            " */",
                            "std::string GeneralUtils::trim(const std::string& str) {",
                            "\tsize_t first = str.find_first_not_of(' ');",
                            "\tif (std::string::npos == first) return str;",
                            "\tsize_t last = str.find_last_not_of(' ');",
                            "\treturn str.substr(first, (last - first + 1));"
                        ]
                    }
                ],
                "deleted": []
            },
            "comment_added_diff": {
                "37": "} // base64EncodedLength",
                "42": "} // base64EncodedLength",
                "50": "} // a3_to_a4",
                "57": "} // a4_to_a3",
                "106": "} // base64Encode",
                "123": "} // dumpInfo",
                "140": "} // endsWidth",
                "151": "} // DecodedLength",
                "161": "}; // b64_lookup",
                "218": " } // base64Decode",
                "334": "} // hexDump",
                "346": "} // ipToString",
                "356": "\t// See also: https://stackoverflow.com/questions/5167625/splitting-a-c-stdstring-using-tokens-e-g",
                "364": "} // split",
                "445": "} // errorToString",
                "520": "} // wifiErrorToString",
                "529": "\t// Question: Could this be improved with a signature of:",
                "530": "\t// std::string& GeneralUtils::toLower(std::string& value)",
                "533": "} // toLower",
                "544": "} // trim"
            },
            "comment_deleted_diff": {},
            "comment_modified_diff": {}
        }
    ],
    "GeneralUtils.h": [],
    "HIDKeyboardTypes.h": [],
    "HIDTypes.h": [],
    "camera_pins.h": [],
    "esp_app_trace.h": [],
    "esp_efuse_table.h": [],
    "esp_core_dump.h": [],
    "esp_http_server.h": [],
    "mbcontroller.h": [],
    "idf_performance.h": [],
    "unity.h": [],
    "unity_config.h": [],
    "unity_internals.h": [],
    "unity_test_runner.h": [],
    "esp32.spiram.rom-functions-dram.ld": [],
    "esp32.spiram.rom-functions-iram.ld": [],
    "wifi_iram.ld": [],
    "libefuse.a": [],
    "libespcoredump.a": [],
    "default_16MB.csv": [],
    "default_8MB.csv": [],
    "default_ffat.csv": [],
    "large_spiffs_16MB.csv": [],
    "min_spiffs.csv": [],
    "minimal.csv": [],
    "noota_3g.csv": [],
    "noota_3gffat.csv": [],
    "noota_ffat.csv": [],
    "esp_coexist_adapter.h": [],
    "esp_coexist_internal.h": [],
    "esp_transport_ssl.h": [],
    "libfd.a": [],
    "libfr.a": [],
    "Master.ino": [],
    "RMTReadXJT.ino": [],
    "WiFiUDPClient.ino": [],
    "SerialToSerialBTM.ino": [],
    "bt_remove_paired_devices.ino": [],
    "Uri.h": [],
    "UriBraces.h": [],
    "UriGlob.h": [],
    "UriRegex.h": [],
    "WiFiProv.ino": [],
    "WiFiProv.cpp": [],
    "WiFiProv.h": [],
    "HTTPS_OTA_Update.ino": [],
    "Readme.md": [],
    "HttpsOTAUpdate.cpp": [],
    "HttpsOTAUpdate.h": [],
    "BLE_Beacon_Scanner.ino": [],
    "BLE_Beacon_Scanner.md": [],
    "BLE_EddystoneTLM_Beacon.ino": [],
    "BLE_EddystoneTLM_Beacon.md": [],
    "BLE_EddystoneURL_Beacon.ino": [],
    "BLE_EddystoneURL_Beacon.md": []
}